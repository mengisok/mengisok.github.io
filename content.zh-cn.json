{"pages":[{"title":"关于","text":"你好，我是韩萌。 我正在攻读硕士学位，主修电子学。不过，我对自学更感兴趣，多亏了互联网，我可以做到这一点————我正在学习与计算机科学有关的一切，从硬件到软件。我还喜欢艺术电影和各种让我思考的书籍。 这是一个广阔而不可预知的世界，很多事情都令我惊奇…… 无论如何，我会毫不犹豫地说，我是一个女权主义者，一个怀疑论者，一个自由主义者，并且欢迎所有的异见。 你可以在GitHub, 领英, 豆瓣上找到我，或者给我发邮件。","link":"/zh-cn/about/index.html"},{"title":"Categories","text":"","link":"/zh-cn/categories/index.html"},{"title":"Tags","text":"","link":"/zh-cn/tags/index.html"}],"posts":[{"title":"自适应滤波器","text":"我看了一个条理清晰、简明扼要的youtube视频，Adaptive Filters，这也是我这学期上的一门基础课。我重点关注了学校课程中的关键知识点，并做了一点笔记。 固定系数数字滤波器的局限性 固定系数的数字滤波器 FIR, IIR LP、HP等 局限 噪声频率随时间变化而变化 信号和噪声的重叠带 自适应滤波器 2个主要组成部分 数字滤波器（有可调整的系数） 自适应算法 2个输入信号：$y_k$和$x_k$ $y_k = s_k + n_k$ $s_k$ = 预期信号 $n_k$ = 噪声 $x_k$ = 污染信号，与$n_k$**相关，提供$n_k$的估计值，即$hat{n_k}$ 目标：产生**最佳的$hat{n_k}$ $e_k = hat{s_k} = y_k - hat{n_k} = s_k + n_k - hat{n_k}$ 该定理最小化$e_k$，最大化信噪比 LMS 算法维纳滤波器 输入信号 w(n) 与维纳滤波器 g(n) 进行卷积，并将结果与参考信号 s(n) 进行比较，得到滤波误差 e(n) 判断标准：MMSE (最小均方误差) 最小化 $J = E[e(n)^2] = E[(x(n) - s(n))^2] = E[(w(n) * g(n) - s(n))^2]$ J可用于绘制误差-性能表面 LMS 滤波器收敛于维纳滤波器 维纳-霍普夫解令H的J梯度为零，推导出$H_{opt} = R_{xx}^{-1} R_{xs}$ 其中$R_{xx} = E(X_k X_k^T)$$R_{xs} = E(y_k X_k)$ 需要知道$R_{xx}, R_{xs}$ 矩阵求逆很复杂 对于非稳态，$H_{opt}$ 需要反复计算 LMS 自适应算法版本1：$H(n+1) = H(n) + \\mu (- \\nabla(n))$版本2：$H(n+1) = H(n) + \\frac{1}{2}\\delta (- \\nabla(n))$ 那么$H(n+1) = H(n) + 2\\mu e(n)X(n)$或 $H(n+1) = H(n) + \\delta e(n) X(n)$ 其中$e(n) = y(n) - H^T(n)X(n)$$mu$和$delta$是步长 基于最陡梯度下降算法（沿梯度的反方向更新H(n)） $H(n+1) = H(n) + \\mu (- \\nabla(n))$ 使用瞬时估计，代替平均值（无偏） $J = E[e(n)^2] = e(n)^2$ $nabla(n) = -2\\mu E[e(n)X(n)] = -2\\mu e(n)X(n) $ 步长决定了稳定性和收敛率 如果步长太大，波动太大 如果步长太小，收敛速度太慢 局限性 如果噪声是非稳态的，误差表现面将迅速变化 如果$x(n)$与$y(n)$成正比，信号将被抹杀 H(n)从未达到理论上的最佳状态（有波动） 应用 声学回声消除 从受污染的脑电图EEG中消除眼电，获得正确的脑电图 在分娩过程中消除母体心电图从而获得胎儿心电图","link":"/zh-cn/Adaptive-Filters/"},{"title":"MATLAB 基础（超基础）","text":"概念清除命令 clc 清除屏幕 clear myVar 删除变量myVar clear all 删除所有变量 创建变量 创建一个标量：myScalar = 10 创建一个向量 行向量：myVector = [4 5 6] 列向量：myVectorCol = [7; 8; 9] 创建一个矩阵。myMatrix = [4 5 6; 7 8 9; 1 2 3] myMatrix(1, 2)得到5 myMatrix(2, :)得到所有在第2行的列 myMatrix(3, 2:3)得到第3行、第2列和第3列。 在命令行的末尾使用”; “意味着它将抑制（即不显示）结果 变量类别 double (默认) format long将 double 类改为 long 类 double, long, short, single, logical (boolean)等等 元胞数组一个有不同种类元素的矩阵 myCell = {[1 2 3] [4 5 6 7]; &apos;v1&apos; &apos;v2&apos;} myCell{1, 2}得到[4 5 6 7] 核心语法脚本 “.m “文件 注释: % disp(): 显示一些东西 randi(): 随机整数 要想显示一个矩阵：matrix&apos; 矩阵 创建一些标准矩阵 zeros(m, n) `ones(m, n)’ `randi(m, n)’ 矩阵乘法 标准乘法：M1 * M2 元素与元素的乘法：M1 .* M2 除法是相似的 元素与元素的除法：M1 ./ M2 If 语句1234567if ... ...elseif ... ...else ...end Switch 语句12345678switch ... case ... ... case ... ... otherwise ...end For 循环1234567891011% step = 1for i = 1: 10 ...end% step = 2% for i = 1: 2: 10% n =25;% step = 5;% for i = 0: step: n While 循环123while ... ...end 编程设置路径如果MATLAB找不到你的脚本或函数或其他东西，请确保你已经添加了路径 函数 从 “当前文件夹 “创建一个函数，它是一个.m文件 编辑模式，并编写你的函数 导入数据要导入一个CSV文件： 复制并粘贴到 “当前文件夹” csvread(&apos;sine.csv&apos;) 调试在编辑器左侧的小破折号处设置断点 性能 预先分配一些内存可以加快大型计算的速度 使用 “tik … tok “来计算时间 数据表示绘图123figure% figure(1)plot(x, y) 添加网格：grid on 使窗口与绘图完全吻合：axis tight 为轴设置限制：ylim([-1 1]) 改变颜色：plot(x, y, &apos;m&apos;) % magenta 改变标记: plot(x, y, &apos;o&apos;) % circle, magenta 用不同的线条多次绘制曲线：hold on。 要结束它，使用hold off 添加注释：xlabel(), title(), legend() 使用close all来关闭所有图 图片 使用imread()来导入图像文件 使用image()绘制图像（默认为正方形） 使用imshow()以正确的长宽比绘制图像，轴上没有标签 3D 绘图12345678x = -2*pi:.5:2*pi;[X, Y] = meshgrid(x);Z = sine(X) + cos(Y);figuresurf(X, Y ,Z)colorbar Simulink一个框图工具，可用于建立系统和反馈回路，为FPGA等硬件生成代码","link":"/zh-cn/Basic-MATLAB/"},{"title":"2022年12月","text":"这个月本来是考试月，所以我主要花时间复习了学校的三门主要课程：数字信号处理、数字图像分析和组合数学。 结果考试突然推迟到下学期初，导致我没复习完。 我做了一些笔记（都是中文），还收藏了一些有意思的链接。 复习笔记 Notion或GitHub上的DSP笔记 (有一些MATLAB代码) Google Drive上的DIA笔记 (更新中…) Google Drive上的组合数学笔记 (更新中…) 另一件值得一提的事是，这个月ChatGPT很火！ 我也试用了一下，确实很神奇。以下是我看到的一些关于ChatGPT的有趣或有用的链接。 ChatGPT 官方介绍 awesome-chatgptThere are many trending repos related to ChatGPT recently. 中国大陆可用的ChatGPT 中国区注册OpenAI账号试用ChatGPT指南 在线接受短信的虚拟号码 ChatGPT初体验 ChatGPT中文版VSCode插件 在Jupyter Notebook中手绘草图并变成代码 其它有趣的链接 Telegram指南 oi-wiki.org编程竞赛wiki。 ctf-wiki.org网络安全竞赛wiki。 summerschoolsineurope.eu有关欧洲暑期学校的信息。 fernwanderweg.blogspot.com他用谷歌博客建立了一个博客。看起来不错。 数字逻辑在线学习网站: HDLbit和 解决方案，可以学习Verilog OSS InsightGitHub的实时趋势和统计数据。 FreeCodeCamp学完后可以拿到一些证书？喜欢~ Developer Roadmaps基于角色的程序员成长指南。 Statistics Visualization Learning Site以可视化的方式学习统计。非常清晰易懂! 最后三个是GitHub上拥有大量星星的几个顶级仓库。我发现996.icu竟然排在第三  语言很遗憾，我没有参加雅思考试。还没准备好… 我会去考的!至于学习日语，我不再用多邻国了，因为它有些简单。我找了一些YouTube视频来看，比如出口日語。 博客我把博客主题从Cactus换到了Ascent。Btw，这是我的关于博客主题的收藏夹 。我试图把一个主题改成我想要的样子，但失败了。前端好难！","link":"/zh-cn/Dec-2022/"},{"title":"Git 学习笔记","text":"廖雪峰的Git教程笔记。 简介 Git是用C语言开发的 集中式&amp;分布式版本控制系统 集中式：版本库集中存放在中央服务器；最大的毛病就是必须联网才能工作 分布式：没有“中央服务器”，每个人的电脑上都是一个完整的版本库，不需要联网；安全性要高很多；通常也有一台充当“中央服务器”的电脑，但这个服务器的作用仅仅是用来方便“交换”大家的修改；极其强大的分支管理 创建版本库 版本库：又名仓库，英文名repository，可以简单理解成一个目录，这个目录里面的所有文件都可以被Git管理起来，每个文件的修改、删除，Git都能跟踪，以便任何时刻都可以追踪历史，或者在将来某个时刻可以“还原” 创建版本库 step1：创建一个空目录 step2：初始化，git init 把一个文件放到Git仓库 git add git commit 时光机穿梭 git status查看工作区状态 git diff查看修改内容 版本回退 git reset --hard commit_id版本回退 git reset --hard HEAD^ 在Git中，用HEAD表示当前版本，上一个版本就是HEAD^，上上一个版本就是HEAD^^，往上100个写成HEAD~100 git reset --hard 1094a 版本号（commit id）没必要写全，前几位就可以了，Git会自动去找 git log查看提交历史 显示从最近到最远的提交日志（如果嫌输出信息太多，加上--pretty=oneline参数） git reflog查看命令历史 可以找到版本号 工作区和暂存区 工作区（Working Directory）：在电脑里能看到的目录 版本库（Repository）：工作区有一个隐藏目录.git，这个不算工作区，而是Git的版本库 版本库里重要的东西有： 暂存区：stage（或者叫index） 分支：Git为我们自动创建的第一个分支master 指针：指向master的一个指针叫HEAD 需要提交的文件修改通通放到暂存区，然后一次性提交暂存区的所有修改 管理修改 Git跟踪并管理的是修改，而非文件 每次修改，如果不用git add到暂存区，那就不会加入到commit中 add只添加进了暂存区，commit才是进版本库，暂存区的相同文件都是覆盖的 撤销修改 git restore -- file丢弃修改，让这个文件回到最近一次git commit或git add时的状态 --很重要，没有--，就变成了“切换到另一个分支”的命令 git restore --staged把暂存区的修改撤销掉（unstage），重新放回工作区 注： 原来的git checkout 可以使用 git restore 代替 原来的git reset HEAD 可以使用 git restore –staged 代替 最新版的git提示都已经更换成了restore 总结： 情况1：在工作区做了修改，并未添加到暂存区，想撤销工作区的修改，用 git restore file 情况2：在工作区做了修改，并用git add 添加到了暂存区，未提交；想撤销，分两步，1.先撤销暂存区的修改，用 git restore –staged file, 2.然后参考情况1撤销工作区的修改 情况3：在工作区做了修改，且git add git commit添加并提交了内容，想撤销本次提交，直接用 git reset –hard HEAD^回退版本，即可保证工作区，暂存区，版本库都是上次的内容 删除文件 git rm 如果一个文件已经被提交到版本库，那么你永远不用担心误删，但是要小心，你只能恢复文件到最新版本，你会丢失最近一次提交后你修改的内容 当你直接在文件管理器中把没用的文件删了，或者用rm命令删了，接下来有两种选择： 确实要从版本库中删除该文件，那就用命令git rm删掉，并且git commit 删错了，用git checkout把误删的文件从版本库里恢复到最新版本 远程仓库 本地Git仓库和GitHub仓库之间的传输通过SSH加密 添加远程库 git remote add origin git@server-name:path/repo-name.git 关联一个远程库时必须给远程库指定一个名字，origin是默认习惯命名 关联后，使用命令git push -u origin master第一次推送master分支的所有内容 此后，每次本地提交后，只要有必要，就可以使用命令git push origin master推送最新修改 删除远程库 git remote rm &lt;name&gt; 使用前，建议先用git remote -v查看远程库信息 只是解除了本地和远程的绑定关系，并不是物理上删除了远程库。远程库本身并没有任何改动。要真正删除远程库，需要登录到GitHub，在后台页面找到删除按钮再删除 从远程库克隆 ssh：git clone git@github.com:your name/repo name.git 更快 https：git clone http://github.com/yourname/reponame.git 分支管理创建与合并分支 git checkout -b或git switch -c创建并切换 相当于git branch（创建） + git checkout或git switch（切换） git branch查看当前分支 会列出所有分支，当前分支前面会标一个* git merge合并指定分支到当前分支 git branch -d删除分支 创建、合并和删除分支非常快，所以最好使用分支完成某个任务，合并后再删掉分支，这和直接在master分支上工作效果是一样的，但过程更安全 解决冲突 把Git合并失败的文件手动编辑为我们希望的内容，再提交 分支管理策略 分支策略 master分支应该是非常稳定的，也就是仅用来发布新版本，平时不能在上面干活 dev分支是不稳定的，干活都在dev分支上；到某个时候，比如1.0版本发布时，再把dev分支合并到master上，在master分支发布1.0版本 团队成员都在dev分支上干活，每个人都有自己的分支，时不时地往dev分支上合并就可以了 合并分支时的普通模式：加上--no-ff参数 这样合并后的历史有分支，能看出来曾经做过合并，而fast forward合并就看不出来曾经做过合并 Bug分支 修复bug时，通过创建新的bug分支进行修复，然后合并，最后删除 git stash保存工作现场，然后去修复bug，修复后，有两种方式回到工作现场： git stash apply，stash内容并不删除，需要用git stash drop来删除 git stash pop，恢复的同时把stash内容也删了 git stash list查看stash里的内容，然后用git stash apply stash@{0}恢复到指定的stash（这里是stash@{0}） 在master分支上修复的bug，想要合并到当前dev分支，可以用git cherry-pick &lt;commit&gt;，把bug提交的修改“复制”到当前分支，避免重复劳动 Feature分支 开发一个新feature，最好新建一个分支 如果要丢弃一个没有被合并过的分支，可以通过git branch -D &lt;name&gt;强行删除 多人协作 git push origin &lt;branch-name&gt;推送自己的修改 如果推送失败，则因为远程分支比你的本地更新，需要先用git pull试图合并 如果git pull提示no tracking information，则需要用git branch --set-upstream-to &lt;branch-name&gt; origin/&lt;branch-name&gt;建立起本地分支和远程分支的链接关系 如果合并有冲突，则解决冲突，并在本地提交 没有冲突或者解决掉冲突后，再用git push origin &lt;branch-name&gt;推送 Rebase 把本地未push的分叉提交历史整理成直线 目的：使我们在查看历史提交的变化时更容易，因为分叉的提交需要三方对比 标签管理 tag是一个让人容易记住的有意义的名字，它跟某个commit绑在一起 如果这个commit既出现在master分支，又出现在dev分支，那么在这两个分支上都可以看到这个标签 创建标签 git tag &lt;tagname&gt;新建一个标签 默认为HEAD，也可以指定一个commit id 创建的标签都只存储在本地，不会自动推送到远程 git tag -a &lt;tagname&gt; -m &quot;blablabla...&quot;创建带有说明的标签 git tag查看所有标签 不是按时间顺序列出，而是按字母排序 git show &lt;tagname&gt;查看标签信息 操作标签 推送 git push origin &lt;tagname&gt;推送某个本地标签到远程 git push origin --tags一次性推送全部未推送过的本地标签到远程 删除 git tag -d &lt;tagname&gt;删除某个本地标签 删除一个远程标签：先从本地删除（用上面的命令），然后从远程删除，命令是git push origin :refs/tags/&lt;tagname&gt; 使用GitHub 可以任意Fork开源仓库 Fork后的仓库，你拥有读写权限 推送pull request给官方仓库来贡献代码 使用Gitee 国内的Git托管服务 使用方法和GitHub类似 自定义Git git config --global color.ui **true**让Git显示颜色，看起来更醒目 忽略特殊文件 Github官方.gitignore文件合集 忽略文件的原则： 忽略操作系统自动生成的文件 忽略编译生成的中间文件、可执行文件等 忽略带有个人敏感信息的配置文件 git add -f filename虽然被忽略但强制添加 !filename例外文件 .gitignore online generator 配置别名 git config --global **alias**.st status设定用st表示status --global是全局参数，针对当前用户，即让命令在这台电脑的所有Git仓库下都有用；如果不加，那就只针对当前仓库有用 每个仓库的Git配置文件都放在.git/config文件中 当前用户的Git配置文件放在用户主目录下的一个隐藏文件.gitconfig中 要删除别名，直接把[alias]后面的对应别名的行删掉即可 搭建Git服务器 需要一台运行Linux的机器（推荐Ubuntu或Debian）。暂时用不到就没看，详见这里 使用Sourcetree 免费Git图形界面工具 附录 Git Cheat Sheet Git官网","link":"/zh-cn/Git-Learning-Notes/"},{"title":"Hello World","text":"我成功了！ :)","link":"/zh-cn/Hello-World/"},{"title":"Git & Github 入门","text":"这是我在学习LinkedIn课程Learning Git and Github时做的一些简单笔记。 我发现先在Notion中做笔记，然后导出Markdown，修改，复制粘贴到Blog中，非常方便。 开始12git config --global user.name &quot;name&quot;git config --global user.email &quot;mail&quot; 1git init 暂存区 Staging files12git add filenamegit add . 1git commit -m &quot;message&quot; 1git log Git 环境 Working Staging Commit 文件状态1git status Tracked (after commit) Unmodified Modified Staged Untracked 恢复文件12git restore filenamegit restore . 忽略文件 Sensitive info Personal notes System files 使用 .gitignore 文件 清除缓存1git rm -r --cached . 删除1git rm filename 删除，并转移到暂存区，准备提交 重命名1git mv oldname newname 同样转移到暂存区 显示区别1git diff 1got log --oneline 修正1git commit --amend 12git resetgit reset --hard 重置 Rebasing一台时光机，可以重写历史 1git rebase 分支 Branches1git branch 复制一个分支： 1git switch -c NAME 合并： 1git merge &lt;branch&gt; 删除： 1git branch --delete NAME Git 流程： Fix branch Make changes Merge to master Delete old branch 合并冲突选择其中一个即可 贮藏 Stashing1234git stashgit stash listgit stash applygit stash pop Git clean123git clean -ngit clean -dgit clean -f Github Cloud repository Collaborative dev Projet management 使用github: Set up remote Push Fetch/pull 推送到github远程: 1234git remote add NAME URLgit remote remove NAMEgit rename OLDNAME NEWNAMEgit remote -v Git 推送: 123git push REMOTE BRANCHgit push -u origin maingit push --all Github 选项Issues与人合作 为你自己或其他人写笔记，如待办事项 将待办事项分配给个人，他们可以发表评论 Pull requests更改仓库 批准别人所做的修改 比较不同的分支 Actions管理仓库（高级） 运行测试 自动托管代码 下载其他人的actions来使用 Projects管理仓库 看板 Wiki创建便于人们查看的文件（其实没必要） Security管理安全策略（高级） Insights了解贡献者、仓库动态等（私人） Settings 将此仓库转换为一个模板 Github页面 管理 projects 贡献者 邀请合作者 问题 标签 里程碑 项目 同步1git clone 1git fetch 1git pull pull = fetch + merge","link":"/zh-cn/Intro-to-Git-GitHub/"},{"title":"初识 Linux","text":"LUG @ USTC的Linux 101 - 初识Linux笔记。已经按照教程成功安装用上了 Xubuntu ！赞美！ 计算机性能爆发增长 摩尔定律：集成电路上可容纳的晶体管数目每两年就会翻一倍/计算机的性能每 18 个月提高一倍（Intel CEO David House） 量子物理的限制以及 CPU 功耗和散热的限制使计算机性能的提升开始放缓。多个 CPU 之间的联合协作（基于多核的开发）取代追求单个 CPU 性能的提升，成为了未来发展方向 操作系统 用户与底层硬件交流的桥梁 功能 进程管理：操作系统调度进程，使许多进程可以在几个中央处理器上并发执行 内存管理：操作系统合理分配和回收内存 文件系统：操作系统建立合适的数据结构来存储文件和数据 网络通信：操作系统实现各种必需的网络通信方式（如TCP/IP） 安全机制：操作系统配备安全机制用于保护数据不被未授权的人士获取 用户界面：操作系统通常包含一个图形化的用户界面，方便用户使用计算机 驱动程序：操作系统与驱动程序对接以发挥硬件的功能 Linux 诞生 选择 Linux，很大程度上是一种对极客精神与开源文化的认同。 自由软件意味着其用户拥有自由。（这无关价格。）我们开发了GNU系统，这样用户就有了计算的自由。 具体来说，自由软件的用户拥有四项基本自由：(0)自由运行软件、(1)自由学习和修改软件源代码、(2)自由再发布软件拷贝以及(3)自由发布修改后的软件版本。 软件不同于生活中的事物 — 它不同于椅子、三明治或是汽油 — 软件可以更容易地被复制或修改。恰恰是这一特性，使得软件更为有用。我们由此坚信，软件的这一天然属性应该被用户利用。1 1983 年，Richard Stallman 在 MIT 发起了 GNU 计划；1991年，Linus Torvalds 编写并发布了Linux 内核，成为了后来各类 Linux 发行版的基础 GNU：GNU 是“GNU is Not Unix”的递归缩写，指一套类似 UNIX 但完全自由的操作系统 GNU 通用公共许可证（GNU General Public License，GNU GPL 或 GPL）：把使用该许可的软件的所有权利授予任何使用它的人 这种权利又被称为著作传（Copyleft），相对于通常的著作权（Copyright） 核心GNU操作系统至今没有开发完成。现在实际上用的是 GNU/Linux ，Linux 内核是功能核心，而GNU组件是外设，也是用户操作和使用 Linux 内核的工具 现在智能手机上一个常见的系统是 Android/Linux ，是一个基于 Linux 内核开发的、没有采用 GNU 组件而是用谷歌自行研发的另一套 Android 体系作为工具的操作系统 Linux 发行版 Linux 发行版 = Linux 内核 + 一系列 GNU 工具和库、一些附带的软件、说明文档、一个桌面系统、一个窗口管理器和一个桌面环境 主流的发行版分支 Debian 分支：最著名的是 Ubuntu ，一个主打桌面应用的操作系统，适合普通用户使用。推荐初次接触 Linux 的读者优先采用 Ubuntu 发行版或者它的子发行版（Lubuntu, Xubuntu 等） Red Hat 分支：Fedora ，CentOS（适合在要求高度稳定的服务器上运行） Arch Linux 分支：要求使用者自身愿意去了解操作系统的运作方式，并不采取屏蔽工作原理的方式来降低使用门槛。变种 Manjaro 更注重易用，更适合一般用户 Linux 在身边 智能手机：Google 研发的 Android 操作系统属于 Android/Linux 分支，也叫 Android 原生系统，子发行版很多，如华为 EMUI 操作系统和小米 MIUI 操作系统等 服务器：网站和软件的提供商都需要设立他们自己的计算机来完成计算、存储和通信的功能，这种计算机就被称为服务器。服务器通常不用 Windows 或者 macOS 这种个人计算机操作系统，绝大部分用 Linux 发行版，因为它们界面简洁，功能强大，而且某些发行版也受到专业计算机企业的服务支持（如 RHEL）。Debian 和 Ubuntu Server 很流行 嵌入式设备：Android/Linux 分支下的各类发行版是主流的嵌入式操作系统，如 Google 为数字电视专门推出的 Android TV 操作系统 使用 Linux 推荐使用虚拟机运行安装完毕的 Linux 镜像 步骤 获取虚拟机管理软件，推荐 VMware Workstation Player 获取 Xubuntu 虚拟机镜像（Xubuntu 是 Ubuntu 的一个子发行版，与 Ubuntu 非常类似，但体积更小，性能需求更少，适合各种不同性能的电脑安装使用） 双击打开虚拟机镜像，管理软件会打开并导入该镜像，导入完毕后可直接点击开始按钮启动 拾 ~ 引用来源 [1] GNU 工程的哲学 推荐阅读 为什么开源错失了自由软件的重点","link":"/zh-cn/Intro-to-Linux/"},{"title":"Java 入门","text":"廖雪峰的Java教程-Java快速入门笔记。 简介 创始人：James Gosling Java介于编译型语言和解释型语言之间。它是将代码编译成一种“字节码”，类似于抽象的CPU指令，然后针对不同平台编写虚拟机，不同平台的虚拟机负责加载字节码并执行，实现“一次编写，到处运行” Java三个版本 Java SE：Standard Edition，标准版，包含标准的JVM和标准库，是整个Java平台的核心 Java EE：Enterprise Edition，企业版，在Java SE的基础上加上了大量的API和库，以便方便开发Web应用、数据库、消息服务等；Java EE的的虚拟机和Java SE完全相同；是进一步学习Web应用所必须的 Java ME：Micro Edition，针对嵌入式设备的“瘦身版”，Java SE的标准库无法在Java ME上使用；Java ME的虚拟机也是“瘦身版”；不流行，不建议学习 推荐的Java学习路线 首先要学习Java SE，掌握Java语言本身、Java核心开发技术以及Java标准库的使用； 如果继续学习Java EE，那么Spring框架、数据库开发、分布式架构就是需要学习的； 如果要学习大数据开发，那么Hadoop、Spark、Flink这些大数据平台就是需要学习的，他们都基于Java或Scala开发； 如果想要学习移动开发，那么就深入Android平台，掌握Android App开发。 JDK：Java Development Kit，除了包含JRE，还提供了编译器、调试器等开发工具，用来将Java源码编译成Java字节码 JRE：Java Runtime Environment，是运行Java字节码的虚拟机 JSR规范：Java Specification Request JCP组织：Java Community Process RI：Reference Implementation，参考实现 TCK：Technology Compatibility Kit，兼容性测试套件 基础程序基本结构123public class Hello { // 类名是Hello // ...} // class定义结束 12345public class Hello { public static void main(String[] args) {// 方法名是main// 方法代码... }// 方法定义结束} 类名必须以英文字母（习惯大写）开头；方法名必须以英文字母（习惯小写）开头 在class内部，可以定义若干方法（method） public是访问修饰符，表示该class是公开的。不写public，也能正确编译，但是这个类将无法从命令行执行 Java入口程序规定的方法必须是静态方法，方法名必须为main，括号内的参数必须是String数组 Intelli IDEA代码格式化：Ctrl + Alt + L 变量和数据类型 两种变量类型：基本类型和引用类型 基本类型是CPU可以直接进行运算的类型。包括整型，浮点型，布尔型，字符型 剩下的都是引用类型，类似于C语言的指针，它内部存储一个“地址”，指向某个对象在内存的位置。最常用的是String 基本类型的变量是“持有”某个数值，引用类型的变量是“指向”某个对象 常量在初始化后不可重新赋值 简写变量类型，使用var关键字 运算 整数运算永远是精确的，浮点数运算常常无法精确表示 流程控制输入和输出 输出 System.out.println()，输出并换行 System.out.print()，输出不换行 System.out.printf()，格式化输出 输入（不能在线运行，必须从命令行读取） 1234567import java.util.Scanner;public class Main {publicstaticvoid main(String[] args) { Scanner scanner =new Scanner(System.in);// 创建Scanner对象 String name = scanner.nextLine();// 读取一行输入并获取字符串 int age = scanner.nextInt();// 读取一行输入并获取整数 }} if条件判断 判断浮点数相等用==判断不靠谱，正确的方法是利用差值小于某个临界值来判断 判断引用类型的变量内容是否相等，必须使用equals()方法 case多重选择 总是写上default 从Java12开始，新语法使用-&gt;，如果有多条语句，需要用{}括起来。不要写break语句，因为新语法只会执行匹配的语句，没有穿透效应 在switch表达式内部，用yield返回一个值作为switch语句的返回值 while循环 先判断后循环 可能循环0次 do while循环 先循环后判断 至少循环一次 for循环 可能循环0次 break和continue 在多层嵌套的循环中，都只能跳出自己所在的那一层循环 数组操作遍历、排序、多维数组、命令行参数（略）","link":"/zh-cn/Java%E5%85%A5%E9%97%A8/"},{"title":"LaTeX 简历","text":"从昨天中午到今天中午，我一直在用latex做简历。这对初学者来说非常不友好。幸运的是，我现在做完了，看看我的简历. 我是这样做的： -&gt; 如果你只是偶尔或少量使用latex，一个在线编辑器 Overleaf 可以省去很多麻烦。你可以找模板，然后编辑和编译就可以了。-&gt; 如果你想做更多的事情，请使用以下步骤。 下载 MiKTeX 和 VSCodeMiKTeX你会得到MiKTeX Consle和TeXworks。后者是一个编辑器，但我更喜欢使用VSCode，因为它可以在另一个窗口预览pdf（也因为我已经有VSCode）。另一个选择是Tex Live。它预装了一个完整的软件包，但下载速度太慢，而且经常失败，所以我选择了MiKTeX。 VSCode记得下载插件 latex workshop。 找模板在Overleaf或Github上找一个模板。这是我喜欢的：新卒のためのLaTeX履歴書テンプレートTLC-Resume-2021以及我做的：Resume-CV (在TLC-Resume-2021的基础上修改的) 编辑模板在这一步你可能会遇到很多问题，其中大部分需要你在MiKTeX控制台中下载包，或其他东西，如Perl。只要按照错误信息中所说的安装缺少的项目就可以了。 分享模板 把你的模板放到github上(已经绑定了git和你的github账户并设置了SSH密钥)-&gt; 创建一个新的仓库-&gt; Git bash文件夹，其中包含关于你的模板的全部文件-&gt; 在Git中运行以下代码 git init git add . git commit -m &apos;Description&apos; git remote add origin https://... (copy from github) git push -u origin master 提交到Overleaf我就是在那里找到我的简历的原始模板的! 我想，把模板放在那里可能会帮助到更多的人。","link":"/zh-cn/Latex-CV/"},{"title":"我的第一个领英学习证书！","text":"是的，我得到了它! 我一直梦想着获得在线学习证书，比如Coursera和linkedin。Coursera的免费方案是一个星期，而LinkedIn的是一个月，所以我选择了后者。 (注意，对于中国大陆用户，你必须在你的账户设置中改变你的位置，以获得每月的免费计划。另外，你必须使用Visa的信用卡。） 总之，我得到了我的第一个领英学习证书：Introducation to Web Design and Development 不错的课程简短，不到2个小时，对新手非常友好实用！作者介绍了许多学习前端开发的有用网站 我学到了什么网络开发工作的类型规划和原型设计： UX (用户体验) UI (用户界面) 编程和开发： 前端开发 (Javascript, CSS, HTML; 框架) 后端开发 Javascript、CSS、HTML HTML确定了结构元素 CSS改变了的外观和风格 JS处理交互性，如移动和动画 对Github有了一点了解这超出了我的预期，也正是我所需要的! 看起来Github Pages Service对于小型和简单的网络开发来说是一个很好的（因为免费）开始。我最近会试试的。 无代码这对我来说是一个全新的概念。听起来很有趣，你可以不通过写代码来开发一个网站。但也许代价是，真正的成本————钱？但是它是受限的，尤其是当你了解得越多，就越贪婪 :p 有用的工具原型设计工具： Figma 图形界面设计工具： Illustrator, Photoshop （专业） Affinity, Figma （轻量） Canva （最简单，免费，有模板） 代码编辑器: CodePen （在线，免费） VS Code Atom （免费，高度可个性化定制） Brackets 网络主机： Github Pages Service（最简单，免费） 无代码工具CMSs (内容管理系统)： Joomla! Drupal Wordpress 建立网站的工具： Squarespace, Wix, Weebly （简单） Webflow, Editor X （复杂） 数据库： Google Sheets Airtable 应用： Bubble (web) AppGyver (web, ios, android) Adalo, Glide (ios, android) 最后，这是我的证书，希望今后能得到更多的证书  ~","link":"/zh-cn/My-first-LinkedIn-certificate/"},{"title":"2022年11月","text":"Leetcode目前为止在Leetcode上做了64道题。 完成了《Arrays 101》（剩下一题只有会员才能做）。是对像我这样的初学者来说也非常简单一章！ 得到一个徽章! 说实话，我不太理解这个徽章里的所有数据结构题洛。我只熟悉数组和字符串…… 打算找时间消化一下。 Jupyter Notebook实际使用了一下。写了一个简单的使用Logistic Regression模型对一些数据进行分类的笔记本。 Github Workflow在我的GitHub账户主页上使用了Metrics。它的神奇之处在于可以自动更新! 领英学习证书每个证书下是我对该课程的评分。 ⭐⭐⭐⭐⭐ ⭐⭐ ⭐⭐ ⭐⭐⭐⭐ ⭐⭐⭐ 语言准备IELTS indicator 考试。 坚持学习了42 days的多邻国日语。 我发现，在中国只有两种日语考试，即JLPT和JTEST。JLPT每年只举行两次，而且经常被取消。JTEST的举办频率更高，但它不像JLPT那样被高度认可，所以我很纠结。","link":"/zh-cn/Nov-2022/"},{"title":"面向对象","text":"廖雪峰的Java教程-面向对象基础笔记。 Class &amp; Instance class是对象模板，instance是对象实例 定义class（包含多个字段，field） 1234class Person { public String name; public int age;} 创建instance（指向instance的变量都是引用变量） 1Person ming = new Person(); 访问实例变量用变量.字段 一个Java源文件可以包含多个类的定义，但只能定义一个public类，且public类名必须与文件名一致。如果要定义多个public类，必须拆到多个Java源文件中 方法 动机：为了避免外部代码直接去访问field，我们可以用private修饰field，拒绝外部访问，然后使用method来让外部代码可以间接修改field 在方法内部，我们有机会检查参数对不对；而外部代码没有任何机会把字段设置成不合理的值 一个类通过定义方法，可以给外部代码暴露一些操作的接口，同时保证内部逻辑一致性 调用方法的语法是实例变量.方法名(参数); 定义方法 123456789// 修饰符 方法返回类型 方法名(方法参数列表) {// 若干方法语句;// return 方法返回值;// }// 如果没有返回值，返回类型设置为void，可以省略returnpublic String getName() { return this.name;} private方法：不允许外部调用，只有类的内部可以调用 this变量：在方法内部，可以使用一个隐含的变量this，它始终指向当前实例。通过this.field就可以访问当前实例的字段 如果没有命名冲突，可以省略this；如果局部变量和字段重名，就必须加上this 方法参数：0或任意个，用于接收传递给方法的变量值 可变参数：类型…，相当于数组类型 可变参数可以保证无法传入null 参数绑定 基本类型参数的传递，是调用方值的复制。双方各自的后续修改，互不影响 引用类型参数的传递，调用方的变量和接收方的参数变量指向的是同一个对象。双方任意一方对这个对象的修改，都会影响对方（因为指向同一个对象） 构造方法123456789101112131415161718192021222324public class Main { public static void main(String[] args) { Person p = new Person(&quot;Xiao Ming&quot;, 15); }}class Person { private String name; private int age; // 构造方法 public Person(String name, int age) { this.name = name; this.age = age; } public String getName() { return this.name; } public int getAge() { return this.age; }} 实例在创建时通过new操作符会调用其对应的构造方法，构造方法用于初始化实例 创建实例实际上是通过构造方法来初始化实例的 构造方法的名称就是类名 构造方法的参数没有限制，在方法内部，也可以编写任意语句。但是，和普通方法相比，构造方法没有返回值（也没有void），调用构造方法，必须用new 没有定义构造方法时，编译器会自动创建一个默认的无参数构造方法 没有在构造方法中初始化字段时，引用类型的字段默认是null，数值类型的字段用默认值，int类型默认值是0 ，布尔类型默认值是false 多构造方法 可以定义多个构造方法，编译器根据参数自动判断 可以在一个构造方法内部调用另一个构造方法，便于代码复用 重载123456789101112// String类提供了多个重载方法indexof()public class Main { public static void main(String[] args) { String s = &quot;Test string&quot;; int n1 = s.indexOf(&apos;t&apos;); int n2 = s.indexOf(&quot;st&quot;); int n3 = s.indexOf(&quot;st&quot;, 4); System.out.println(n1); System.out.println(n2); System.out.println(n3); }} 含义：方法重载是指多个方法的方法名相同，但各自的参数不同 作用：功能类似的方法使用同一名字，更容易记住，调用起来更简单 方法重载的返回值类型通常是相同的 继承123456789101112131415161718class Person { private String name; private int age; public String getName() {...} public void setName(String name) {...} public int getAge() {...} public void setAge(int age) {...}}class Student extends Person { // 不要重复name和age字段/方法, // 只需要定义新增score字段/方法: private int score; public int getScore() { … } public void setScore(int score) { … }} 作用：复用代码 使用extends关键字来实现继承 继承树：没有明确写extends的类，编译器会自动加上extends Object 任何类，除了Object，都会继承自某个类 一个类有且仅有一个父类。只有Object特殊，它没有父类 子类无法访问父类的private，可以访问父类的protected 如果父类没有默认的构造方法，子类就必须显式调用super()并给出参数以便让编译器定位到父类的一个合适的构造方法 子类不会继承任何父类的构造方法。子类默认的构造方法是编译器自动生成的，不是继承的 阻止继承1234public sealed class Shape permits Rect, Circle, Triangle { ...}// 上述Shape类只允许指定的3个类(Rect, Circle, Triangle)继承它 从Java15开始，使用sealed修饰class，并通过permits明确写出能够从该class继承的子类名称 sealed目前是预览状态，要启用它，必须使用参数--enable-preview和--source 15 向上转型 Upcasting1Person p = new Student(); 把一个子类型安全地变为更加抽象的父类型 例如，继承树是Student &gt; Person &gt; Object，那么可以把Student类型转型为Person，或者更高层次的Object 向下转型 Downcasting12345Person p = new Student();if (p instanceof Student) { // 只有判断成功才会向下转型: Student s = (Student) p; // 一定会成功} 很可能会失败。为了避免出错，使用instanceof先判断一个实例究竟是不是某种类型 从Java 14开始，判断instanceof后，可以直接转型为指定变量，直接使用，避免再次强制转型 继承 &amp; 组合 继承是is关系，组合是has关系 多态12345678910111213class Person { public void run() { … }}class Student extends Person { @Override public void run() { … }}class Teacher extends Person { @Override public void run() { … }} 含义：针对某个类型的方法调用，其真正执行的方法取决于运行时期实际类型的方法 作用：允许添加更多类型的子类实现功能扩展，却不需要修改基于父类的代码 覆写/覆盖 Override 子类可以覆写父类的方法，覆写在子类中改变了父类方法的行为 加上@Override可以让编译器帮助检查是否进行了正确的覆写 在子类的覆写方法中，如果要调用父类的被覆写的方法，可以通过super来调用 final final修饰的方法可以阻止被覆写 final修饰的class可以阻止被继承 final修饰的field必须在创建对象时初始化，随后不可修改 抽象类123abstract class Person { public abstract void run();} 动机：如果父类的方法本身不需要实现任何功能，仅仅是为了定义方法签名，目的是让子类去覆写它，那么可以把父类的方法声明为抽象方法，本身没有实现任何方法语句 含义：如果一个class定义了方法，但没有具体执行代码，这个方法就是抽象方法，抽象方法用abstract修饰；因为无法执行抽象方法，所以这个类也必须申明为抽象类（abstract class） 抽象类无法实例化 作用：抽象类可以强迫子类实现其定义的抽象方法，否则编译会报错。相当于定义了“规范” 面向抽象编程 上层代码只定义规范 不需要子类就可以实现业务逻辑（正常编译） 具体的业务逻辑由不同的子类实现，调用者并不关心 接口1234interface Person { void run(); String getName();} 动机：如果一个抽象类没有字段，所有方法全部都是抽象方法，就可以把该抽象类改写为接口 接口是比抽象类还要抽象的纯抽象接口，因为它连字段都不能有 使用interface声明一个接口 当一个具体的class去实现一个interface时，需要使用implements关键字；一个类可以实现多个interface 接口也是数据类型，适用于向上转型和向下转型 接口继承12345678interface Hello { void hello();}interface Person extends Hello { void run(); String getName();} 使用extends 继承关系 公共逻辑适合放在abstract class中，具体逻辑放到各个子类，而接口层次代表抽象程度 实例化的对象永远只能是某个具体的子类，但总是通过接口去引用它，因为接口比抽象类更抽象 default方法 接口可以定义default方法 动机：当我们需要给接口新增一个方法时，会涉及到修改全部子类。如果新增的是default方法，那么子类就不必全部修改，只需要在需要覆写的地方去覆写新增方法 default方法和抽象类的普通方法的区别：因为interface没有字段，所以default方法无法访问字段，而抽象类的普通方法可以访问实例字段 静态字段 &amp; 静态方法静态字段 用static修饰的字段称为静态字段 实例字段&amp;静态字段 实例字段在每个实例中都有自己的一个独立“空间”，各个实例的同名字段互不影响 静态字段只有一个共享“空间”，所有实例都会共享该字段 不推荐用实例变量.静态字段去访问静态字段，推荐用类名来访问静态字段 可以把静态字段理解为描述class本身的字段（非实例字段） 静态方法 用static修饰的方法称为静态方法 实例方法&amp;静态方法 调用实例方法必须通过一个实例变量 调用静态方法则不需要实例变量，通过类名就可以调用。静态方法类似其它编程语言的函数 调用静态方法不需要实例，无法访问this，但可以访问静态字段和其他静态方法 静态方法常用于工具类（如Arrays.sort()，Math.random() ）和辅助方法（如Java程序的入口main() 就是静态方法） 接口的静态字段 interface可以有静态字段，并且静态字段必须为final类型 因为interface的字段只能是public static final类型，所以可以去掉这些修饰符，简写 包1234package ming; // 申明包名mingpublic class Person {} 在定义class的时候，需要在第一行声明这个class属于哪个包 一个类总是属于某个包（package），类名（比如Person）只是一个简写，真正的完整类名是包名.类名 只要包名不同，类就不同 包可以是多层结构，用.隔开 包没有继承关系 没有定义包名的class使用的是默认包，非常容易引起名字冲突，不推荐不写包名的做法 包作用域123456789101112131415package hello;public class Person { // 包作用域: void hello() { System.out.println(&quot;Hello!&quot;); }}public class Main { public static void main(String[] args) { Person p = new Person(); p.hello(); // 可以调用，因为Main和Person在同一个包 }} 位于同一个包的类，可以访问包作用域的字段和方法 不用public、protected、private修饰的字段和方法就是包作用域 import1234567891011// Person.javapackage ming;// 导入完整类名:import mr.jun.Arrays;public class Person { public void run() { Arrays arrays = new Arrays(); }} JDK的核心类使用java.lang包，编译器会自动导入 JDK的其它常用类定义在java.util.*，java.math.*，java.text.*，…… 作用域public 定义为public的class、interface可以被其他任何类访问 定义为public的field、method可以被其他类访问，前提是首先有访问class的权限 如果不确定是否需要public，就不声明为public，即尽可能少地暴露对外的字段和方法 一个.java文件只能包含一个public类，但可以包含多个非public类。如果有public类，文件名必须和public类的名字相同 private 定义为private的field、method无法被其他类访问 private访问权限被限定在class的内部，而且与方法声明顺序无关。推荐把private方法放到后面 嵌套类（nested class）拥有访问private的权限 protected 作用于继承关系。定义为protected的字段和方法可以被子类访问，以及子类的子类 pakage 包作用域是指一个类允许访问同一个package的没有public、private修饰的class，以及没有public、protected、private修饰的字段和方法 把方法定义为package权限有助于测试 局部变量 在方法内部定义的变量称为局部变量 局部变量作用域从变量声明处开始到对应的块结束 方法参数也是局部变量 应该尽可能把局部变量的作用域缩小，尽可能延后声明局部变量 final 可以阻止被继承、阻止被子类覆写、阻止被重新赋值 内部类 Nested ClassInner Class123456789101112131415public class Main { public static void main(String[] args) { Outer outer = new Outer(&quot;Nested&quot;); // 实例化一个Outer Outer.Inner inner = outer.new Inner(); // 实例化一个Inner inner.hello(); }}class Outer { ... class Inner { // 定义了一个Inner Class ... }} Inner Class的实例不能单独存在，必须依附于一个Outer Class的实例 要实例化一个Inner，必须首先创建一个Outer的实例，然后，调用Outer实例的new来创建Inner实例 Inner Class可以修改Outer Class的private字段 Outer类被编译为Outer.class，而Inner类被编译为Outer$Inner.class Anonymous Class123Runnable r = new Runnable() { // 实现必要的抽象方法...}; 另一种定义Inner Class的方法。它不需要在Outer Class中明确地定义这个Class 动机：因为在这里我们不关心类名，比直接定义Inner Class可以少写很多代码 匿名类也可以访问Outer Class的private字段和方法 匿名类被编译为Outer$1.class、Outer$2.class、Outer$3.class … 除了接口外，匿名类也可以继承自普通类 Inner Class和Anonymous Class本质上是相同的，都必须依附于Outer Class的实例，即隐含地持有Outer.this实例，并拥有Outer Class的private访问权限 Static Nested Class 不再依附于Outer的实例，而是一个完全独立的类，因此无法引用Outer.this，但可以访问Outer的private静态字段和静态方法 Static Nested Class是独立类，但拥有Outer Class的private访问权限 classpath和jar JVM通过环境变量classpath决定搜索class的路径和顺序 不推荐设置系统环境变量classpath，始终建议通过-cp命令传入 jar包相当于目录，可以包含很多.class文件，方便下载和使用 class版本 高版本的JDK可编译输出低版本兼容的class文件，反之可能报错 运行时使用哪个JDK版本，编译时就尽量使用同一版本编译源码 模块 .class文件是JVM看到的最小可执行文件，而一个大型程序需要编写很多Class，并生成一堆.class文件。jar文件就是class文件的容器，为了方便管理。它并不关心class之间的依赖 从Java 9开始引入了模块（Module），自带“依赖关系”的class容器就是模块，模块以.jmod扩展名标识 只有java.base模块不依赖任何模块，是“根模块” 把一堆class封装为jar仅仅是一个打包的过程，而把一堆class封装为模块则不但需要打包，还需要写入依赖关系，并且可以包含二进制代码（通常是JNI扩展）、支持多版本 模块的作用：声明并管理依赖关系；进一步隔离代码的访问权限","link":"/zh-cn/Object-oriented/"},{"title":"2022年10月","text":"编程到目前为止，我完成了Leetcode上的27道题，都是用Java。上一章的探索Array and String有点难，但现在的Arrays 101就容易多了。为什么我还在做数组？我等不及学新的东西了。 我学了一点一个著名的课程，CS61A，做了HW 01，HW 02，Lab 00，Lab 01，现在在做Lab 02。上半月我学习得比较认真，下半月就懈怠了。希望我能够坚持下去，完成这门课程和CS61B。OK系统非常有趣。 我看了一些Andrew Ng的机器学习视频，从开始到P48“推理：做预测”。我的导师要求我学习机器学习，所以我试图开始学习。我还读了经典教材《机器学习实战》的一些部分。很不错，而且比视频中的代码更多，难度更大。然而，我还是没有很好地理解机器学习。它看起来很容易，但做起来真的很难勞。好消息是，我今天下午终于做了一个python程序…… Matlab看起来很方便，但它对电脑性能要求太高，而且有点不稳定。我在想，数据有什么特点… 语言坚持每天看一部英语视频，尤其是经济学人的文章。我还在“简报”栏目中阅读了一篇名为《王子》的文章。几天前，我开始准备多邻国英语测试。我的男朋友也报名参加了雅思indicator考试。我们都是下周考。希望成功! 我也开始从多邻国和NHK简明日语学习日语了。喜欢这个网站，因为它很简单。我以前不知道日语也有时态。 暂时再见! 现在已经半夜了。","link":"/zh-cn/Oct-2022/"},{"title":"双指针","text":"这个十月，我强迫自己每天做一道LeetCode。虽然中间有几天中断了，但最后还是完成了“探索”里的 Array and String1。 对我来说，最有用的一课是一种叫做双指针的神奇技巧。起初我以为它是嵌套的两个for循环，但后来我发现它实际上更有意义，更有用。所以我想把它记录下来。 含义同时使用两个指针来做迭代。 应用 当你想从两端向中间迭代数组时，你可以使用一个指针从头开始，而另一个指针从尾开始。它们有相同的步长。 123456789101112131415// Reverse Stringclass Solution { public void reverseString(char[] s) { int i = 0; int j = s.length - 1; while (i &lt; j) { char temp = s[i]; s[i] = s[j]; s[j] = temp; i++; j--; } }} 12345678910111213141516171819202122// Two Sum II - Input array is sorted// 给出一个已经按非递减顺序排序的索引到1的整数数组，找出两个数字，使其相加等于一个特定的目标数class Solution { public int[] twoSum(int[] numbers, int target) { int[] res = new int[2]; int start = 0; int end = numbers.length - 1; while (start &lt; end) { if (numbers[start] + numbers[end] == target) { break; } else if (numbers[start] + numbers[end] &lt; target) { start ++; } else { end --; } } res[0] = start + 1; res[1] = end + 1; return res; }} 当你想要一个慢速指针和一个快速指针时，你可以使用一个指针用于迭代，而另一个指针用于标记特殊位置。它们有不同的步长。 123456789101112131415// Remove Element// &quot;i&quot;用于迭代，&quot;k&quot;用于指示要移动的元素class Solution { public int removeElement(int[] nums, int val) { int k = 0; for (int i = 0; i &lt; nums.length; i++) { if (nums[i] != val) { nums[k] = nums[i]; k++; } } return k; }} 这里还介绍了一个重要的概念：原地算法。 原地算法（in-place algorithm，也称“就地算法”）是基本上不需要借助额外的数据结构就能对输入的数据进行变换的算法。不过，分配少量空间给部分辅助变量是被允许的。算法执行过程中，输入的数据往往会被输出结果覆盖。原地算法只能通过替换或交换元素的方式来修改原始的输入。2 123456789101112131415161718// Max Consecutive Ones// &quot;i&quot;用于迭代，&quot;max&quot;用于找最大数class Solution { public int findMaxConsecutiveOnes(int[] nums) { int max = 0; int sum = 0; for (int i = 0; i &lt; nums.length; i++) { sum += nums[i]; if (nums[i] == 0) { sum = 0; } else { max = Math.max(sum, max); } } return max; }} 123456789101112131415// Remove Duplicates from Sorted Array// &quot;i&quot;用于迭代，&quot;j&quot;用于寻找特殊元素class Solution { public int removeDuplicates(int[] nums) { int n = nums.length; int j = 0; for (int i = 1; i &lt; n; i++) { if (nums[j] != nums[i]) { j++; nums[j] = nums[i]; } } return j + 1; }} 1234567891011121314151617181920// Move Zeroes// &quot;i&quot;用于迭代，&quot;k&quot;用于指示非零元素class Solution { public void moveZeroes(int[] nums) { int n = nums.length; int k = 0; for (int i = 0; i &lt; n; i++) { k = i; if (nums[i] == 0) { if (k &lt; n-1) { while (nums[k] == 0 &amp;&amp; k &lt; n-1) {k++; } int temp = nums[i]; nums[i] = nums[k]; nums[k] = temp; } } } }} 我现在的进展：恭喜自己，再接再厉！  参考 [1] LeetCode Explore：Array and String [2] 维基百科：原地算法","link":"/zh-cn/Two-pointer/"}],"tags":[{"name":"DSP","slug":"DSP","link":"/zh-cn/tags/DSP/"},{"name":"MATLAB","slug":"MATLAB","link":"/zh-cn/tags/MATLAB/"},{"name":"Git","slug":"Git","link":"/zh-cn/tags/Git/"},{"name":"GitHub","slug":"GitHub","link":"/zh-cn/tags/GitHub/"},{"name":"Java","slug":"Java","link":"/zh-cn/tags/Java/"},{"name":"Linux","slug":"Linux","link":"/zh-cn/tags/Linux/"},{"name":"LaTex","slug":"LaTex","link":"/zh-cn/tags/LaTex/"},{"name":"前端","slug":"前端","link":"/zh-cn/tags/%E5%89%8D%E7%AB%AF/"},{"name":"数据结构与算法","slug":"数据结构与算法","link":"/zh-cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"categories":[{"name":"LeetCode","slug":"LeetCode","link":"/zh-cn/categories/LeetCode/"},{"name":"学习","slug":"学习","link":"/zh-cn/categories/%E5%AD%A6%E4%B9%A0/"},{"name":"总结","slug":"总结","link":"/zh-cn/categories/%E6%80%BB%E7%BB%93/"},{"name":"工作","slug":"工作","link":"/zh-cn/categories/%E5%B7%A5%E4%BD%9C/"}]}