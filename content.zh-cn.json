{"pages":[{"title":"标签","text":"","link":"/zh-cn/tags/index.html"},{"title":"分类","text":"","link":"/zh-cn/categories/index.html"},{"title":"关于","text":"你好，我是韩萌。 我正在攻读硕士学位，专业是电子信息工程，研究方向是粒子物理实验中的读出电子学。我也在学习与计算机科学有关的、从硬件到软件的一切。 我在博客里记录学习和感悟，也将自我徐徐展开。我觉得博客就像面前的一条数字河流，既可以顺流而行，也可以回溯途径之地。 现在还只是一条小溪。希望它长久流淌。 你可以在GitHub, 领英上找到我，或者给我发邮件。","link":"/zh-cn/about/index.html"},{"title":"链接","text":"CS FreeCodeCamp程序员角色成长指南：Developer Roadmaps编程竞赛 OI Wiki夺旗赛 CTF WikiVerilog 学习网站：HDLbitLinux 101 数学 以可视化的方式学习统计：Statistics Visualization Learning Site 实用 GitHub 实时趋势和统计数据：OSS Insight欧洲暑期学校 语言 出口日語 电子书 Anna’s ArchiveLibrary GenesisZlibraryzhelper search Phd 欧洲phd招聘信息网站分享CERNLHCbATLASJuelichJuelich - Detector SystemsTU Dresden6G-lifeHelmholtz-Institut Mainz 润学 润去新加坡","link":"/zh-cn/links/index.html"}],"posts":[{"title":"自适应滤波器","text":"看了一个条理清晰、简明扼要的关于自适应滤波器的YouTube视频，这也是我这学期上的一门基础课“数字信号处理Ⅱ”的重点内容。 固定系数数字滤波器的局限性 固定系数的数字滤波器 FIR, IIR LP、HP等 局限 噪声频率随时间变化而变化 信号和噪声的重叠带 自适应滤波器 2个主要组成部分 数字滤波器（有可调整的系数） 自适应算法 2个输入信号：$y_k$和$x_k$ $y_k = s_k + n_k$ $s_k$ = 预期信号 $n_k$ = 噪声 $x_k$ = 污染信号，与$n_k$**相关，提供$n_k$的估计值，即$hat{n_k}$ 目标：产生**最佳的$hat{n_k}$ $e_k = hat{s_k} = y_k - hat{n_k} = s_k + n_k - hat{n_k}$ 该定理最小化$e_k$，最大化信噪比 LMS 算法 维纳滤波器 输入信号 w(n) 与维纳滤波器 g(n) 进行卷积，并将结果与参考信号 s(n) 进行比较，得到滤波误差 e(n) 判断标准：MMSE (最小均方误差) 最小化 $J = E[e(n)^2] = E[(x(n) - s(n))^2] = E[(w(n) * g(n) - s(n))^2]$ J可用于绘制误差-性能表面 LMS 滤波器收敛于维纳滤波器 维纳-霍普夫解令H的J梯度为零，推导出$H_{opt} = R_{xx}^{-1} R_{xs}$ 其中$R_{xx} = E(X_k X_k^T)$$R_{xs} = E(y_k X_k)$ 需要知道$R_{xx}, R_{xs}$ 矩阵求逆很复杂 对于非稳态，$H_{opt}$ 需要反复计算 LMS 自适应算法版本1：$H(n+1) = H(n) + \\mu (- \\nabla(n))$版本2：$H(n+1) = H(n) + \\frac{1}{2}\\delta (- \\nabla(n))$ 那么$H(n+1) = H(n) + 2\\mu e(n)X(n)$或 $H(n+1) = H(n) + \\delta e(n) X(n)$ 其中$e(n) = y(n) - H^T(n)X(n)$$\\mu$和$\\delta$是步长 基于最陡梯度下降算法（沿梯度的反方向更新H(n)） $H(n+1) = H(n) + \\mu (- \\nabla(n))$ 使用瞬时估计，代替平均值（无偏） $J = E[e(n)^2] = e(n)^2$ $nabla(n) = -2\\mu E[e(n)X(n)] = -2\\mu e(n)X(n) $ 步长决定了稳定性和收敛率 如果步长太大，波动太大 如果步长太小，收敛速度太慢 局限性 如果噪声是非稳态的，误差表现面将迅速变化 如果$x(n)$与$y(n)$成正比，信号将被抹杀 H(n)从未达到理论上的最佳状态（有波动） 应用 声学回声消除 从受污染的脑电图EEG中消除眼电，获得正确的脑电图 在分娩过程中消除母体心电图从而获得胎儿心电图 附录 YouTube视频 Adaptive Filters 课程主页 数字信号处理 II","link":"/zh-cn/Adaptive-Filters/"},{"title":"粒子物理实验电子学系统的基本构成","text":"粒子物理实验电子学系统主要由四个部分构成：前端读出电子学（Front-End Readout Electronics, FEE），触发判选系统（Trigger System），数据获取系统（Data Acquisition System, DAQ）和慢控制（Slow Control）。这篇笔记主要介绍FEE。 1 前端读出电子学 前端读出电子学对探测器输出的微弱电信号进行必要的预处理（如放大、数字化等），将其转化为能够反映粒子特性的数据，供触发判选系统和DAQ系统使用。 前端读出电子学主要有电荷（能量）测量、时间测量、事例计数三种功能。 1.1 电荷测量电荷测量就是测探测器输出信号的电荷量。粒子通过探测器时是探测器产生电离、激发或光电转换等过程，输出信号的电荷量往往正比于粒子在探测器中消耗掉的能量。 结构：前置放大器+长电缆+主放大器+成形电路+ADC+数据缓存+读出接口 1.2 时间测量时间测量就是测量探测器输出信号的出现时间（指针对某一参考信号t0的时间时隔）。它需要测量两个数据：由定时甑别器电路确定被测信号的出现时刻；由时间－数字变换（TDC）电路将被测信号和参考信号t0之间的时间间隔转换成数字数据。 结构：前置放大器+长电缆+定时甄别器+TDC+数据缓存+读出接口 主流的解决方案是“粗”计数（Coarse Counting） +“细”时间测量（Fine Measurement），即全数字计数器技术 + 时间内插。“粗”计数一般由高性能的Gray码计数器（即数字计数器型TDC）实现，使用的参考时钟频率一般在数百兆赫兹，实现几个ns的时间分辨；“细”时间测量的实现则依靠时间内插技术（Time Interpolation），在一个时钟周期内进行时间内插，达到亚纳秒（100 ps ~ 10ps）的时间分辨。 1.3 事例计数事例计数就是对探测器输出的信号进行必要的放大和甑别，得到“是”或“否”的信息，并进行记录。因为有时我们只需要知道是否有粒子击中相应的位置，并不需要测量信号的电荷或时间（如BES III的µ子探测器）。 结构：前置放大器+长电缆+定时甄别+寄存器/计数器+数据缓存+读出接口 1.4 前置放大器1.4.1 分类 积分型（电荷灵敏前置放大器、电压灵敏前置放大器）：输出信号幅度正比于探测器输出电流信号对时间的积分（即探测器输出的总电荷量） 电流型（电流灵敏前置放大器）：输出信号波形与探测器输出电流信号的波形一致 1.4.2 三种主要的前置放大器 电荷灵敏前置放大器 电路较复杂，性能好，低噪声，最常用。 $V_{output}=-\\frac{Q}{C_{feedback}}$ 电压灵敏前置放大器 电路较简单（实际上就是一个电压放大器），性能较差，噪声比电荷灵敏前置放大器的大。 $\\frac{V_{output}}{V_{input}}=-\\frac{R_{feedback}}{R_{series}}$ 电流灵敏前置放大器 实际上就是一个电流放大器。一般用于获取精确的时间信息、高计数率或高本底情况下的强度测量系统、能谱测量系统等。 1.5 ADC线性放电型ADC，逐次比较型ADC（SAR ADC），流水线型ADC（Pipeline ADC），闪电型ADC（Flash ADC）。 2 触发判选系统 对前端电子学提供的数据进行实时分析，从大量的假事例（本底）数据中挑选出物理上感兴趣的事例，而将假事例（本底）数据舍弃。 构成：触发子系统（特征抽取）、总触发（判定分类）、时钟系统。 3 数据获取系统 筛选保留的物理上感兴趣的事例数据并收集、装配成一个完整的事例数据，记录下来以提供给物理学家进行离线分析。 附录 http://bes.ihep.ac.cn/bes3/internal/workshop/06electronics/anqi.pdf","link":"/zh-cn/Basic-Components-of-Electronics-of-Particle-Physics-Experiments/"},{"title":"吴恩达的机器学习","text":"我看完了吴恩达的机器学习课程! 对初学者来说真的很不错。 概述 有监督的机器学习： 回归和分类 线性回归 逻辑回归 梯度下降 高级学习算法 神经网络 决策树 对机器学习的建议 无监督学习、推荐、强化学习 聚类 异常情况检测 协作式过滤 基于内容的过滤 强化学习 1️⃣ 机器学习  算法有监督学习 将输入x映射到输出y 从被给予的 “正确答案 “中学习 2种主要类型： 回归： 预测一个数 无限多的可能输出 分类法： 预测类别(不一定是数字) 小的有限数量的可能输出，如（0,1） 当两个或更多的输入时：找到边界线 无监督的学习 有监督学习从数据中学习标记的正确答案； 无监督学习在无标签的数据中找到有趣的东西 输入x，但没有输出标签y，它在数据中找到结构 主要类型： 聚类 异常情况检测 降维 强化学习 有监督机器学习模型线性回归(一个变量) 成本函数 梯度下降 学习率 多重线性回归(多个变量) 矢量化 特征缩放（归一化） 可以使梯度下降法更快 特征工程 多项式回归 Logistic回归 → 分类 Sigmoid 函数 决策边界 在逻辑回归中应用梯度下降法 损失和成本 为了使逻辑成本函数是凸函数，使用-log和-log（1-）（损失函数）并求和 比较线性回归和逻辑回归 相同点 学习曲线 矢量化实现 特征缩放 不同点 线性回归：$f=vec{w} \\cdot \\vec{x}+b$ Logistic回归：$f=frac{1} {1+e^{-vec{w}+b$ {1+e^{-vec{w}. \\cdot \\vec{x}. + b}}$ 过拟合 解决过拟合的问题 收集更多的训练实例 选择特征 正则化：减少参数$w_j$的大小 正则化 2️⃣ TensorFlow中的神经网络 Numpy数组和Tensors12345678x = np.array([200.0, 17.0])layer_1 = Dense(units=3, activation=&apos;sigmoid&apos;)a1 = layer_1(x)# print(a1)# -&gt; tf.Tensor([[0.2 0.7 0.3]], shape=（1,3）, dtype=float32a1.numpy()# print(a1)# -&gt; 数组(...) 在TensorFlow中训练一个神经网络1234567891011121314151617import tensorflow as tffrom tensorflow.keras import Sequentialfrom tensorflow.keras.layer import Dense# 第一步：指定模型model = Sequential([Dense(units=25, activation=&apos;relu&apos;)Dense(units=15, activation=&apos;relu&apos;)Dense(units=1, activation=&apos;sigmoid&apos;))]# 第二步：编译模型from tensorfolw.keras.loss import BinaryCrossentropymodel.compile(loss=BinaryCrossentrpy())# 第三步：训练模型model.fit(X, Y, epochs=100) 选择一个激活函数外层 对于二进制分类，使用sigmoid函数 对于回归(+/-)，使用线性函数 对于回归（+），使用ReLU函数 隐藏层 ReLU是最常见的选择 多类分类： Softmax1234567891011121314import tensorflow as tffrom tensorflow.keras import Sequentialfrom tensorflow.keras.layer import Densemodel = Sequential([Dense(units=25, activation=&apos;relu&apos;)Dense(units=15, activation=&apos;relu&apos;)Dense(units=10, activation=&apos;softmax&apos;))]from tensorfolw.keras.loss import SparseCategoricalCrossentropymodel.compile(loss=SparseCategoricalCrossentrpy())model.fit(X, Y, epochs=100) 但是不要使用这个版本! 更精确的实现对于逻辑回归的损失函数 1234567891011121314import tensorflow as tffrom tensorflow.keras import Sequential从tensorflow.keras.layer导入Densemodel = Sequential([Dense(units=25, activation=&apos;relu&apos;)Dense(units=15, activation=&apos;relu&apos;)Dense(units=1, activation=&apos;linear&apos;))]from tensorfolw.keras.loss import BinaryCrossentropymodel.compile(loss=BinaryCrossentrpy(from_logits=True))model.fit(X, Y, epochs=100) 对于softmax 123456789101112131415161718import tensorflow as tffrom tensorflow.keras import Sequentialfrom tensorflow.keras.layer import Densemodel = Sequential([Dense(units=25, activation=&apos;relu&apos;)Dense(units=15, activation=&apos;relu&apos;)Dense(units=10, activation=&apos;linear&apos;))]from tensorfolw.keras.loss import SparseCategoricalCrossentropymodel.compile(loss=SparseCategoricalCrossentrpy(from_logits=True))model.fit(X, Y, epochs=100)# 预测logits = model(X)f_x = tf.nn.softmax(logits) Adam算法Adam：Adaptive Moment estimation，自适应时刻估计 适应性地改变学习率；更快 12345678910111213# 模型model = Sequential([Dense(units=25, activation=&apos;sigmoid&apos;)Dense(units=15, activation=&apos;sigmoid&apos;)密集(单位=10, 激活=&apos;线性&apos;))]# 编译model.compile(optimizer=tf.keras.optimizers.Adam(learning_rate=1e-3)、loss=tf.keras.loss.SparseCategoricalCrossentropy(from_logits=True))# 拟合model.fit(X, Y, epochs=100) 卷积层每个神经元只对前一层输入的部分进行操作 计算速度更快；需要的训练数据更少（不容易出现过拟合现象） 评估一个模型将数据分成三部分： 训练集 交叉验证集（验证/开发/设计集） 测试集 当你对模型做决定时，只使用训练集和开发集，而完全不看测试集。在你决定了最终的模型后，在测试集上评估它 偏倚/方差偏差是训练误差与基线的差距 方差是交叉验证误差和基线的差距 正则化1layer = Dense(units=25, activation=&quot;relu&quot;, kernel_regularizer=L2(0.01)) 转移学习 下载神经网络参数，在大型数据集上进行预训练，数据集的输入类型与你的应用程序相同（例如，图像、音频、文本） 在你自己的数据上微调网络 一个机器学习项目的整个周期 定义项目 定义并收集数据 培训、错误分析和迭代改进 部署、监控和维护系统 混淆矩阵，精度，召回率精确率=真阳性/（预测的阳性）=真阳性/（真阳性+假阳性) 召回率=真阳性/（实际阳性）=真阳性/（真阳性+假阴性) 权衡：高阈值→较高的精度，较低的召回率；低阈值→较低的精度，较高的召回率 F1 score = $\\frac{1}{\\frac{1}{2}(\\frac{1}{P}+\\frac{1}{R})}$ 计算一个平均值，更关注低者（P和R的调和平均值） 决策树模型决策树预测类别的情况 回归树预测数量 树集（更稳健；使用替换抽样）： 随机森林 XGBoost (eXtreme Gradient Boosting)：更有可能挑选以前训练的树**错误分类的例子 1234567891011# 分类from xgboost import XGBClassifiermodel = XGBClassifier()model.fit(X_train, y_train)y_pred = model.pred(X_test)# 回归from xgboost import XGBRegressormodel = XGBRegressor()model.fit(X_train, y_train)y_pred = model.pred(X_test) 决策树与神经网络： 决策树 神经网络 在哪些数据上工作良好 结构化（表格）数据 结构化数据和非结构化（图像、音频、文本）数据 速度 快速 可能较慢 转移学习 不 是 可解释性 也许是 不是 构建一个由多个模型组成的系统 困难 容易 3️⃣ 无监督学习 聚类K-means 第1步：随机初始化K簇中心点； 第2步：将每个点分配给其最近的中心点； 第3步：重新计算中心点，直到它们趋于一致。 如何选择K？ 肘部方法 根据K-means的对后面的目的的性能如何来评估它 异常情况检测第一步：选择n个你认为可能表明异常例子的特征； 第2步：拟合一个高斯分布； 第3步：给定新的例子x，计算p(x)，如果p(x)&lt; epsilon，则为异常 异常检测 监督学习 大量的负面例子（y=0），极少的正面例子（y=1） 大量的正面和负面例子 未来的正面例子：以前没有见过，全新的 未来的正面例子：以前见过，类似的 推荐系统协作式过滤 查找相关项目 自动找到导数 12345678910111213w = tf.Variable(3.0)x = 1.0y = 1.0alpha = 0.01# 自动差分iteration = 30for iter in range(iteration)： with tf.GradientTape() as tape： fwb = w*x costJ = (fwb - y)**2 [dJdw] = tape.gradient(costJ, [w]) w.assign_add(-alpha*dJdw) 也可以使用Adam优化算法 基于内容的过滤 12345678910111213141516171819202122232425user_NN = tf.keras.models.Sequential([ tf.keras.layer.Dense(256, activation=&apos;relu&apos;)、 tf.keras.layer.Dense(128, activation=&apos;relu&apos;)、 tf.keras.layer.Dense(32)])item_NN = tf.keras.models.Sequential([ tf.keras.layer.Dense(256, activation=&apos;relu&apos;)、 tf.keras.layer.Dense(128, activation=&apos;relu&apos;)、 tf.keras.layer.Dense(32)])input_user = tf.keras.layer.Input(shape=(num_user_features))vu = user_NN(input_user)vu = tf.linalg.l2_normalize(vu, axis=1)input_item = tf.keras.layer.Input(shape=（num_item_features）)vm = item_NN(input_item)vm = tf.linalg.l2_normalize(vm, axis=1)output = tf.keras.layer.Dot(axes=1)([vu, vm])model = Model([input_user, input_item], output)cost_fn = tf.keras.loss.MeanSquaredError() 协同过滤 基于内容的过滤 推荐依据是 给予你类似评价的用户的评价 用户和物品的特征，以找到一个好的匹配对象 均值化使算法更快、更好 强化学习奖励机制 “好狗狗”，”坏狗狗” 回报 回报是奖励的总和，由折扣系数加权 它取决于你所采取的行动 策略 策略是函数pi(s)=a，一个从状态到行动的映射 强化学习的目标是找到一个策略pi，以使回报最大化 马尔可夫决策过程（MDP） “马尔科夫 “指的是未来只取决于当前的状态，而不取决于在达到当前状态之前可能发生的任何事情 在MDP中，未来只取决于你现在的位置，而不取决于你是如何得到的 状态价值函数（Q-函数） Q(s, a) = 返回值，如果你： 开始于状态s 采取行动a（一次） 然后在此后的行为是最佳的 状态s的最佳可能回报是maxQ(s, a) 在s状态下，可能的最佳行动是能给出maxQ(s, a)的行动a 贝尔曼方程 Q(s, a) = R(s) + gamma*maxQ(s’, a’) R(s)是你马上就能得到的奖励 gamma*maxQ(s’, a’) 是从下一个状态s’开始的最佳行为的奖励。 DQ算法 1234567891011121314151617Initialize neural network randomly as guess of Q(s,a).Repeat{ Take actions in the lunar lander. Get (s, a, R(s), s’). Store 10000 most recent (s, a, R(s), s’) tuples. Train neural network: Create training set of 10000 examples using x = (s, a) and y = R(s) + gamma * maxQ(s’, a’) Train Q_new such that Q_new (s, a) = y. Set Q = Q_new. } 改进 Epsilon-贪婪策略 例如epsilon = 0.05，这意味着 以0.95的概率，选取使Q(s, a)最大化的行动a，贪婪地”剥削” 以0.05的概率，随机选取一个选项a，”探索” 一开始最好把epsilon设置得很高，然后逐渐降低 批量法 更快 软更新 将 “set Q = Q_new”（即W,B = W_new,B_new）改为 W = 0.01W_new + 0.99WB = 0.01B_new + 0.99B","link":"/zh-cn/Andrew-Ng-Machine-Learning/"},{"title":"MATLAB 基础","text":"为了用MATLAB写计算机作业而火速看了一个领英学习上的入门教程（两三年没用真的忘光了）。 概念 清除命令 clc 清除屏幕 clear myVar 删除变量myVar clear all 删除所有变量 创建变量 创建一个标量：myScalar = 10 创建一个向量 行向量：myVector = [4 5 6] 列向量：myVectorCol = [7; 8; 9] 创建一个矩阵。myMatrix = [4 5 6; 7 8 9; 1 2 3] myMatrix(1, 2)得到5 myMatrix(2, :)得到所有在第2行的列 myMatrix(3, 2:3)得到第3行、第2列和第3列。 在命令行的末尾使用”; “意味着它将抑制（即不显示）结果 变量类别 double (默认) format long将 double 类改为 long 类 double, long, short, single, logical (boolean)等等 元胞数组一个有不同种类元素的矩阵 myCell = {[1 2 3] [4 5 6 7]; &apos;v1&apos; &apos;v2&apos;} myCell{1, 2}得到[4 5 6 7] 核心语法 脚本 “.m “文件 注释: % disp(): 显示一些东西 randi(): 随机整数 要想显示一个矩阵：matrix&apos; 矩阵 创建一些标准矩阵 zeros(m, n) `ones(m, n)’ `randi(m, n)’ 矩阵乘法 标准乘法：M1 * M2 元素与元素的乘法：M1 .* M2 除法是相似的 元素与元素的除法：M1 ./ M2 If 语句1234567if ... ...elseif ... ...else ...end Switch 语句12345678switch ... case ... ... case ... ... otherwise ...end For 循环1234567891011% step = 1for i = 1: 10 ...end% step = 2% for i = 1: 2: 10% n =25;% step = 5;% for i = 0: step: n While 循环123while ... ...end 编程 设置路径如果MATLAB找不到你的脚本或函数或其他东西，请确保你已经添加了路径 函数 从 “当前文件夹 “创建一个函数，它是一个.m文件 编辑模式，并编写你的函数 导入数据要导入一个CSV文件： 复制并粘贴到 “当前文件夹” csvread(&apos;sine.csv&apos;) 调试在编辑器左侧的小破折号处设置断点 性能 预先分配一些内存可以加快大型计算的速度 使用 “tik … tok “来计算时间 数据表示 绘图123figure% figure(1)plot(x, y) 添加网格：grid on 使窗口与绘图完全吻合：axis tight 为轴设置限制：ylim([-1 1]) 改变颜色：plot(x, y, &apos;m&apos;) % magenta 改变标记: plot(x, y, &apos;o&apos;) % circle, magenta 用不同的线条多次绘制曲线：hold on。 要结束它，使用hold off 添加注释：xlabel(), title(), legend() 使用close all来关闭所有图 图片 使用imread()来导入图像文件 使用image()绘制图像（默认为正方形） 使用imshow()以正确的长宽比绘制图像，轴上没有标签 3D 绘图12345678x = -2*pi:.5:2*pi;[X, Y] = meshgrid(x);Z = sine(X) + cos(Y);figuresurf(X, Y ,Z)colorbar Simulink 一个框图工具，可用于建立系统和反馈回路，为FPGA等硬件生成代码 附录 教程 Learning MATLAB","link":"/zh-cn/Basic-MATLAB/"},{"title":"2023年4月","text":"这个月最重要的两件事：养了猫，爱人收到了德国phd offer（因此我也开始关注德国大学的招聘信息）。 Berber到来！ 4月10日晚上听到门外有猫叫，一开门它就进来啦。问了小区群里的邻居们它是不是走丢的猫，没有人认领，于是就决定养下它了。然后在这一个月里恶补了许多养猫知识！原来是这么复杂的事情。我对猫这种生物的理解也变化了，这个亦正亦邪、本能先行的精灵呀…… 爱人收到了offer梦想成真，为他高兴！而我开始焦虑……慢慢留意搜集信息吧。 欧洲phd招聘信息网站分享 研究机构的招聘：CERNLHCbATLASJuelichJuelich - Detector Systems 大学的空缺职位：TU Dresden6G-lifeHelmholtz-Institut Mainz PCB进度在做最后的修改了…这个月应该就会做出来并测试，期待！（不要出错啊！）","link":"/zh-cn/Apr-2023/"},{"title":"用 Allegro PCB Editor 制作封装","text":"以规则形状的 SMD（Surface Mounted Devices，表贴器件）的制作为例。 制作焊盘 查看芯片手册中的封装参数； 打开 Pad Designer 新建焊盘文件（.pad）； 设置焊盘参数： Parameters：设置“Units”（单位）和“Decimal places”（精度）。一般，单位为 Mils 时精度最高为 2，单位为 Millimeter 时精度最高为 4。 Layers：制作表贴焊盘需要勾上“Single layer mode”，并设置三个 Layer： BEGIN_LAYE； SOLDERMASK_TOP（表示这部分在制板时不涂绿油，从而给焊盘开窗，保证焊盘裸露，是实际上允许焊接的区域）； PASTEMASK_TOP（表示焊接时这个区域要涂焊锡，用于机器焊接）的参数。 注： 表贴类不用填“Thermal Relief ”和“Anti Pad” 一般，“PASTEMASK_TOP”的参数和“BEGIN_LAYER”相同，“SOLDERMASK_TOP”比前面两者大 0.1mm 制作封装 放置焊盘 打开 PCB Editor ，”Drawing Type”选择”Package symbol”，新建封装文件（.dra）； 适当修改grids； 添加焊盘文件目录 Setup - User Preferences - Catagories - Paths - Library - 添加上面焊盘所在的目录到 padpath、psmpath、devpath； 添加焊盘引脚 Layout - Pins - 选Connect - 从Padstack中选择焊盘。 画封装封装包括（红色加粗为必须，斜体为强烈推荐）： 至少一个引脚（即焊盘）； 图形边框（即 Package Geometry 类中的 Assembly_Top 子类和 Silkscreen_Top 子类），标明1号管脚； 参考编号（即 Ref Des 类中的中的至少一个子类，通常使用 Silkscreen_Top 子类 ，有时顺便画上 Assembly_Top 子类），放在封装的附近； 安装区（即 Package Geometry 类中的 Place_Bound_Top 子类）; 保存后会得到 .dra文件（绘图文件，可以打开对封装进行编辑）； .psm文件（数据文件，不能直接编辑，但是在.brd 文件中导入网表时要用到）。 注： Assembly_Top 上画装配时的外框； Silkscreen_Top上画丝印图案； Place_Bound_Top上画一个没有电气规则的区域，防止器件重叠； 将 pad、via 和器件封装的各类文件（.dra和.psm）都存放在同一个文件夹中，方便导入网表、调用及修改。 导入 创建电路板 打开 PCB Editor ，”Drawing Type”选择”Board”，新建电路板文件（.brd），设置图纸尺寸和栅格点大小； 画PCB外框：Add - Line，class选Board Geometry，subclass选Outline； 画允许布线的区域Route Keepin：Setup - Areas - Route Keepin，建议距离外框 30~40mil； 画允许摆放器件的区域Package Keepin：Edit - Z-copy - Size: Contract - Offset: 1，一般将Package Keepin比Route Keepin缩进 1mil 的距离； 放置安装孔，令安装孔与Package Keepin的线框相切。 设置层叠结构以4层板为例，从上到下依次为： TOP（顶层走线层）； GND（地层铜平面）； POWER（电源层铜平面）； BOTTOM（底层走线层）。 Setup - Cross-section - 添加中间的层； 设置各层类型（CONDUCTOR用于走线层，DIELECTRIC为介质层，PLANE为铜平面，用于电源层和地层）； 给各层命名； 设置正负片（走线层为正片，即画出来的是要保留的部分；铜平面为负片，即画出来的是要挖掉的部分）。 内电层铺铜在画了Route Keepin的前提下，使用Z-copy进行内电层铺铜。此时的内电层铺铜只是临时性的，为了方便查看后续布线时过孔是否距离过近。和板外框的调整一样，当布局布线确定后，内电层铜平面也要重新调整（即重新铺铜）。 在Options里选GND或POWER（分别为GND层和POWER层铺铜），选中Create dynamic shape（防止短路）； 设置GND层Offset为0，POWER层Offset为40mil（电源层比地层缩进40mil以减少板边缘的对外辐射）； 在Find里选中Shapes； 在Visibility里关掉其余内电层的显示（这样在铺铜时可以清楚地看到铺铜是否成功）。 也可以直接在GND层和POWER层铺动态铜，然后合并和调整铜皮形状。 导入网表File - Import - Logic - Design entry CIS (Capture) - Import directory - Import Cadence 若有文本窗口弹出，根据报错修改后再重新导入；没有窗口弹出说明导入成功。","link":"/zh-cn/Creating-Packages-in-Allegro-PCB-Editor/"},{"title":"2022年12月","text":"这个月本来是考试月，所以我主要花时间复习了学校的三门主要课程：数字信号处理、数字图像分析和组合数学。 结果考试突然推迟到下学期初，导致我没复习完。 我做了一些笔记（都是中文），还收藏了一些有意思的链接。 复习笔记 Notion或GitHub上的DSP笔记 (有一些MATLAB代码) Google Drive上的DIA笔记 (更新中…) Google Drive上的组合数学笔记 (更新中…) 另一件值得一提的事是，这个月ChatGPT很火！ 我也试用了一下，确实很神奇。以下是我看到的一些关于ChatGPT的有趣或有用的链接。 ChatGPT 官方介绍 awesome-chatgptThere are many trending repos related to ChatGPT recently. 中国大陆可用的ChatGPT 中国区注册OpenAI账号试用ChatGPT指南 在线接受短信的虚拟号码 ChatGPT初体验 ChatGPT中文版VSCode插件 在Jupyter Notebook中手绘草图并变成代码 其它有趣的链接 Telegram指南 fernwanderweg.blogspot.com他用谷歌博客建立了一个博客。看起来不错。 最后三个是GitHub上拥有大量星星的几个顶级仓库。我发现996.icu竟然排在第三  语言很遗憾，我没有参加雅思考试。还没准备好… 我会去考的!至于学习日语，我不再用多邻国了，因为它有些简单。我找了一些YouTube视频来看，比如出口日語。 博客我把博客主题从Cactus换到了Ascent。Btw，这是我的关于博客主题的收藏夹 。我试图把一个主题改成我想要的样子，但失败了。前端好难！","link":"/zh-cn/Dec-2022/"},{"title":"STCF MDC FEE 设计","text":"这是我的一篇课程论文，详细介绍了超级陶粲装置主漂移室的前端电子学的设计。 （以下内容和格式经过修改，不拘泥于论文格式，以便阅读） 摘要 超级陶粲装置(Super Tau-Charm Facility，STCF) 是中国计划建设的新一代的正负电子对撞机，是当前正在运行的北京正负电子对撞机(Beijing Electron Positron Collider II, BEPC II)及其配套的北京谱仪(Beijing Spectrometer BES III)项目的延续，专门对τ粲能区进行物理研究。 主漂移室(Main Drift Chamber, MDC) 是STCF探测器的主要子探测器之一，主要用于终态带电粒子径迹、动量的测量和粒子鉴别。探测器输出的微弱的模拟电信号需要配置一套读出电子学(Readout Electronics) 系统加以处理，将其调理放大并转化成数字信号，形成能够反映粒子特性的事例数据，供数据获取系统(Data Acquisition System，DAQ)重建物理事例和记录，提供给物理学家进行离线分析。 本文介绍了STCF MDC前端读出电子学系统原型电路验证板的整体结构，以及其中的模拟子板部分的初步设计。MDC读出电子学方案包含前端电子学(Front End Electronics, FEE)模块和读出(Readout Unit, RU)模块，分别对应模拟子板和数字母板。整个系统为16通道，子板单板上有2个通道，每2个子板和1个母板相连接。子板包含了TIA与ADC驱动器、自标定电路、电源和主控制板四大部分。 目前已经完成了PCB制版、焊接和初步测试，正在进行电子学和探测器的联合测试，为后续进一步的电子学系统设计做准备。 研究背景和意义 粒子物理研究比原子核更深层次的物质构成及相互作用，与宇宙起源及演化密切相关，引领着人类基本时空观的发展，是人类认识世界最前沿的科学。同时，它也衍生了许多新的交叉学科，催生了专用的大型科学装置(如对撞机加速器装置)的建设，发展为多学科交叉前沿研究的大型综合性平台。 基于加速器的粒子物理实验是研究微观物质世界最有效的手段之一。当今基于加速器的粒子物理实验研究可分为高能量前沿和高亮度前沿，两个不同的前沿相辅相成。作为高亮度前沿加速器实验装置的重要代表之一，正负电子对撞机——陶粲工厂运行在陶粲能区(质心能量为2-5GeV)，在过去的40年来一直是粒子物理研究领域关注的重点之一。由中国主持建设的北京正负电子对撞机/北京谱仪(BEPCII/BESIII)实验曾在历史上做出了陶轻子质量测量、R值测量、发现X(1835)等令世人瞩目的物理成果，为中国的高能物理研究奠定了基础。 然而，由于受到地理位置以及部分基础设施条件的约束，BEPCII/BESIII没有进一步大幅度提升性能的空间与潜力。另外，随着探测器的老化以及国际上其他粒子物理实验(如BELLE-II，LHCb等)的竞争，BEPCII/BESIII将于 5—10年完成其历史使命。鉴于以上所述陶粲能区物理的重要性和需求，以及当前国内外在该能区实验研究的现状，中国提出了建设一台新一代的超高亮度正负电子对撞机——超级陶粲装置，以继续保持在该研究领域的领先地位。 STCF整体布局如上图所示。它包括了亮度大于0.5×1035 cm-2s-1，对撞的质心能量覆盖2—7GeV的加速器设施，一台能够适应高亮度环境、满足物理研究需求的多功能磁谱仪以及相关的基础设施。 STCF加速器的核心技术是如何突破峰值对撞亮度。为了实现超高亮度，STCF将采用广泛运用的扁平对称正负电子束和双环结构。STCF探测谱仪是由多种粒子探测器组合而成的大型综合粒子探测装置，用来对正负电子对撞后产生的末态粒子(质子、π、K、电子、缪子和光子等)进行探测和种类鉴别。 如上图所示，探测谱仪由内到外包括内径迹探测器(Inner Tracker, ITK)、外径迹探测器(MDC)、粒子鉴别器(Particle Identification, PID)、电磁量能器(ElectroMagnetic Calorimeter, EMC)、超导磁铁(Superconducting magnet)和缪子探测器(Muon Detector, MUD) 。 其中，外径探测器是包围着内径迹探测器的一个大型圆柱形的精密漂移室，它承担了带电粒子径迹和动量测量的主要功能，因此又叫主漂移室(MDC) 。MDC同时也测量带电粒子的电离能量损失，用于鉴别低动量带电粒子。MDC内充满了气体，并沿轴向布置了大量的细金属丝，形成了大量漂移单元。通过测量带电粒子在单元内产生的电离电子的漂移时间，可以获得对应的漂移距离，结合阳极丝的位置就可以得到带电粒子径迹的位置。STCF MDC共有48个丝层，单丝位置分辨为120µm。 如上图所示，粒子物理实验中的电子学系统的基本构成为前端读出电子学、触发判选系统、数据获取系统和慢控制系统（可以看粒子物理实验电子学系统的基本构成）。为了对STCF MDC的输出信号进行采集和处理，需要设计与其配套的电子学系统。 前端读出电子学的功能是将探测器输出的微弱电信号放大，数字化后将其转化为能够反映粒子特性的数据，供数据获取系统重建物理事例和记录。前端读出电子学将探测器输出的信号经过初步处理后，可以向触发判选系统提供探测器的哪些部分被粒子击中，以及粒子在探测器中能量沉积等信息，作为触发判选的原始条件。前端读出电子学还需要对数据进行必要的预处理，如：数据压缩、数据归一化等。 触发判选系统的功能是对前端电子学提供的数据进行实时分析，从大量的假事例数据中挑选出物理上感兴趣的事例，而将假事例数据舍弃。 数据获取系统的功能是将读出电子学系统数字化的数据收集并装配成一个完整的事例数据，记录在海量存储器中。 系统整体结构 MDC读出电子学方案在STCF MDC初步的概念设计中，MDC包含11520个单元，信号的读出电子学通道总数也是11520个。读出电子系统设置在端盖中，端盖由15毫米厚的铝板制成，用于机械支撑。束流模拟的结果表明，MDC的第一层（最内层）受到最高的背景计数率（大约为200至400kHz）的影响，这会使信号事件的带电轨迹测量受到严重的干扰。GARFIELD模拟的结果表明，由于电子按粒子轨道到导线的距离的不确定性分布，每个单元中的信号持续200到500ns。因此，读出电子学系统必须有一个快速的整形时间，并且MDC的端盖中必须有足够的背景屏蔽。MDC读出电子学系统需要高精度的时间(大约0.5ns RMS)和电荷测量，输入信号的振幅可达1.8pC。 STCF MDC读出电子学系统结构见上图，由FEE模块和RU模块组成。MDC的读出电子系统需要与系统时钟信号同步，该信号由RU接收，然后扇出到FEE。FEE的输出由RU收集，RU进一步汇总这些数据并通过光纤将信号传送到DAQ。RU还接收全局触发信号，并将其扇向FEE，以进行触发匹配，从而读出有效数据。 FEE的电路结构见上图。FEE负责模拟信号的处理、A/D转换以及时间信息和电荷信息的测量。来自探测器MDC的信号首先被跨阻放大器(Trans-Impedance Amplifier, TIA) 放大，以确保时间测量的快速响应，并提供电荷测量。然后，TIA的输出信号被分成两路：一路连接到电荷测量电路，另一路连接到时间测量电路。 对于时间测量，考虑到信号的特征形状，鉴别器(Discriminator, Disc) 的阈值被设置为低电平。为了达到较高的时间精度，位于鉴别器之前的一个放大器(Amplifier) 被用来提高信号的回转率。为了过滤掉噪声越过低阈值的情况，经过整形后需要使用另一个高阈值鉴别器。然后，时间-数字转换器(Time-to-Digital Converter, TDC) 用于将低阈值鉴别器的前沿时间数字化。 电荷测量电路使用一个整形电路(Shaper) 来提高信噪比，其输出波形被模拟-数字转换器(Analog-to-Digital Converter, ADC) 数字化并被发送到FPGA进行电荷计算。整形电路的输出信号被送入一个具有高阈值的鉴别器。该鉴别器的输出被用作启动电荷计算过程的标志信号（HIT flag），并作为一个“有效”条件用于低阈值鉴别器输出的时间测量。为了抑制堆积(Data Packaging) 的影响，数字化后的信号波形上的基线恢复和数字处理将被应用于电路设计中。 验证板结构 上图是在LTspice软件中进行的电路建模和仿真。为了进一步确保上述基本方案的原理正确性和应用可行性，以及得到一个初步的实际测试结果，需要设计验证板。 在硬件电路结构上，将验证板设计成上图所示的灵活的子母板形式，即模拟子板和数字母板的组合。模拟子板接收和调理来自MDC的模拟信号，并通过差分LEMO接插件将信号输入数字母板。数字母板对信号进行模拟-数字转换，并在FPGA中进行数字信号的处理和计算，最后通过接插件将需要的数据结果输出到PC端。使用高速ADC实现32通道的信号读出较为困难，因此单个验证板系统的通道数定为16。单个子板上有2个通道，单个母板可以连接2块子板，故单个验证板系统包含8个子板和4个母板。 子板主要包含TIA以及ADC驱动。由于ADC的采样率大概在500MHz 至1GHz之间，因此考虑采用型号为GM4680-1000的双通道、14位、采样率为1GHz的ADC芯片。母板中，FPGA芯片的选型需要优先满足ADC的数据接收要求。即需要保证高速收发器接口的正常工作。FPGA部分也可以先由开发板代替。 系统时钟由本地晶振或者时钟接口提供。由FPGA产生ADC驱动器的时钟，经过时钟驱动发送至各ADC以保证所有ADC同步工作。MDC电子学的时钟同步需要通过时钟接口完成。 MDC信号输入接口由探测器MDC的输出决定。数据触发接口由DAQ与触发系统共同决定。 自标定电路用于后续测试或者电子学功能自检。 模拟子板的设计 使用Cadence进行电子学系统的设计。首先在OrCAD Capture CIS中设计电路原理图，然后在Allegro PCB Editor中设计印刷电路板(Printed Circuit Board, PCB)。 原理图设计 上面是子板的原理图，共4页，依次为TIA与ADC驱动、电源、主控和标定部分的电路。 TIA与ADC驱动部分 来自探测器MDC的模拟信号通过LEMO接插件输入子板，然后经过隔直电容和匹配电阻进入前置放大器。前置放大器是指置于信号源与放大器之间的电路或电子设备，是专为接受来自信号源的微弱信号而设计的。处理电荷（电流）信息的前置放大器称为电荷灵敏放大器。 前置放大器采用OPA855芯片。它是一款具有双极输入的宽频带低噪声运算放大器，适用于宽带跨阻和电压放大。如果将该运算放大器配置为TIA，则它的8GHz增益带宽积(Gain-BandWidth Product, GBWP)能够以高达几十千欧姆的跨阻增益实现高闭环带宽。仿真测试结果显示，当OPA855的增益为20kΩ，探测器等效对地电容为50pF时，OPA855的-3dB带宽为80MHz。OPA855的反向端连接反馈电阻，正向端通过0Ω的电阻接地，或者也可以通过数字-模拟转换器(Digital-Analog Converter, DAC)进行基线配置。根据MDC信号丝的阻抗值，适当调整匹配电阻，当达到阻抗匹配时，电路的噪声最小。电源端附近配置旁路电容以滤除高频噪声，减少耦合干扰。 信号经过OPA855的调理和放大后，输入CR-RC无源滤波网络，以方便后续的调试。经过滤波网络处理的信号依次经过电容隔直和电阻匹配后输入到ADC驱动器中。ADC驱动器一般放在靠近ADC的地方。电源端附近同样需要配置旁路电容。 ADC驱动器采用LTC6419芯片。它是一款双通道、极高速且低失真的差分放大器，可以将输入的单端信号转换为差分信号，以驱动后面连接的ADC，并且将前置放大器和ADC隔离开来，起到缓冲的作用。差分ADC驱动器是数据采集系统中不可或缺的信号调理元件。本设计中，LTC6419的差分放大增益配置为2。 电源部分 外部电源通过电源插座进入电路板，经过一系列电容滤波和电感隔离的处理后输入低压差稳压器(Low-Dropout Regulator, LDO)元件。配置LDO得到整个电路板所需的电源电压。LDO是线性直流稳压器的一种，用于提供稳定的直流电压电源。相比于一般线性直流稳压器，LDO能在更小输出输入电压差的情况下工作。本设计中的LDO元件采用LT1764，它具有快速的瞬态响应和极低的输出电压噪声等优点。 主控部分 主控制部分的功能是全局控制电路，连接子板和母板之间的各个模块。它主要包含一个作为子母板接口的接插件，输出信号的LEMO接插件，以及多个用于后续调试和测试的选择电阻。本设计的子母板接口采用Samtec公司的TFM-115-01-L-D-DS型号的接插件，它总共有30个管脚可用。对于上升沿为1 ns的信号，它的相邻管脚之间的串扰小于1%；单端阻抗为48.2-50.8Ω，差分阻抗为92.2-102.8Ω；带宽可达8 GHz；可通过1A @ 70℃的电流信号。 子母板间接插件的管脚定义为：DIFF_1_SAM_N、DIFF_1_SAM_P和DIFF_2_SAM_N、DIFF_2_SAM_P分别为两路通道ADC驱动器的输出管脚；DAC_CH_1、DAC_CH_2、DAC_CH_3、和DAC_CH_4为数字验证母板上DAC的输出管脚；FPGA_1、FPGA_2、FPGA_3和FPGA_4为自标定电路的控制信号，连接至母板上的FPGA芯片；MASTER_POWER为+5.5 V的电源输入管脚；其它管脚都需要接地，以降低噪声、减少电磁辐射，起到保护信号和电源管脚里的信号的作用。 标定部分 通过控制模拟开关的断开与导通，使电容C19、C20分别通过电阻R38、R41和R40、R42进行充电和放电，并经过电阻R36和R39输入至TIA中，作为标定信号。标定信号的电荷量由标定参考电压以及电容C19、C20决定，信号特征由电容C19、C20和电阻R38、R41、R40、R42决定。自标定电路中的模拟开关元件选用TMUX6211PWR，它是一款四通道的互补金属氧化物半导体(ComplementaryMetal-Oxide-Semiconductor, CMOS)精密开关，通过SELx引脚上适当的输入逻辑来控制输出。TMUX6211PWR的导通电阻为2Ω，导通后的最大电流为200 mA。电源端附近依然需要配置旁路电容。 PCB设计由于子板的元件数量较少、电路结构较简单，所以采用四层PCB板结构。顶层和底层为信号层，方便灵活布局和走线；中间两层由上至下依次为地层和电源层。电源层与地线层在中间可以起到隔离两个信号层，减少它们之间的相互干扰的作用。 在Allegro PCB Editor中设计完成的PCB如上图所示。图中仅显示信号层，红色为顶层，蓝色为底层，两个信号层都铺上了接地的铜皮，以提高电路屏蔽性能。矩形PCB的大小为2500mil * 2800mil (约63.5mm * 71.1mm)。 结论本文针对STCF MDC探测器读出电子学的应用需求，设计了模拟子板部分的原理图和PCB，并且已经完成制板、焊接和初步测试，正在进行与探测器的联合测试。在本工作的基础上，需要结合探测器的最新需求，进行更完善的设计，并开展与后端数字化系统的联合测试。 参考文献中国超级陶粲装置 STCF Conceptual Design Report: Volume 1–Physics","link":"/zh-cn/Design-of-STCF-MDC-FEE/"},{"title":"用OrCAD Capture CIS画原理图","text":"开始给一个项目画PCB了。首先学习使用OrCAD Capture CIS画原理图。下面是一些基本的概念和操作。 工程 新建工程 修改原理图偏好 修改原理图说明 元件库 新建元件库 修改元件库存储位置 元件 在元件库中新建元件 放置元件 修改元件属性 修改Footprint 查看整个元件 批量修改管脚属性 Snap to grid 复合封装元件 Homogeneous 组成元件的各模块是相同功能的 各模块以“？”后的A、B等来区分 画完“ U?A”后切换到下一部分“ U?B”，已自动画好，只剩管脚号留空了 切换到上一部分的快捷键为“Ctrl+B”，切换到下一部分的快捷键为“Ctrl+N” 对于一个元件，若只用一张图表示出来，那么元件不能有两个管脚的管脚号和管脚名都相同。但如果将元件分成很多部分来画，那么各个部分之间的管脚的管脚号和管脚名可以相同，且管脚号和管脚名都相同的管脚是相连的 Heterogenous 组成元件的各模块是不同功能的 画完“ U?A”后切换到下一部分“ U?B”，为空白 如果在一个原理图中放置了两个及以上的复合封装元件，为防止使用“Annotate”进行索引编号时报错，应给元件添加一个新属性（名字不能是”group“），各部分就会根据新属性的值是否相同分为不同的组，这样就可以判断哪些部分是在同一个芯片中 在原理图中添加元件 旋转元件 不在库中的元件： 电源，地 Cadence自带元件库 Cadence - SPB_16.6 - tools - capture - library 一般常用的电容、电阻、电感、变压器等在Discrete.olb Design Cache 引脚的连接 3种连接：wire，net alias，总线 wire 快捷键W 原理图中的线默认横平竖直，如果要画任意角度，按Shift键同时点击线的起点和终点 两根线相交时，若交点为一根线的端点，则表示两根线是有电气连接的，且电气连接不可取消；若交点不是端点，则默认无电气连接 给交点添加电气连接 Place junction 同一个页面内的互连 Place net alias 页面之间的互连 Place off-page connector 悬空引脚 Place no connect 不要将两元件的管脚直接相连（可以将两个元件管脚直接连上后，再拉开，两管脚之间就会出现一条连线） 总线连接 总线命名 BaseName[0:all] BaseName和[之间不能有空格 32位总线ED，为ED[0:31] BaseName不能以数字作为结尾 方括号内的冒号“:”可以换成减号“-”或两点“..” 总线入口命名 BaseName0 BaseName1 BaseName2 … 总线和信号线的连接必须要借助总线入口，通过net alias方式，命名保持一致 快捷键F4快速布线 浏览、搜索 浏览元件 重新编号所有元件 Tools - Annotate - Packaging - Action: Reset part references to “?”, Incremental reference update 浏览Nets 浏览Off-Page Connector 浏览DRC Markers 若有错误且被修正了，需将DRC Markers同步更新 也可以选中单个原理图进行浏览 搜索 元件的替换和更新 二者区别 替换可以改变原理图和元件库的连接关系，即用别的元件库的元件替换原元件库的元件，而更新不能 如果新元件的封装形式与原元件不同，例如原元件的封装形式为“ Homogeneous”，而新元件的封装形式为“Heterogeneous”，那么要让新元件的封装形式替换原元件的封装形式，只能使用替换，并且“Action”必须选择“Replace schematic part properties”： Cleanup Cache 清除已经不存在的元件副本 操作原理图中的对象 同时选中多个对象 移动对象 直接拖动，该对象与其它对象的连接关系保持不变 按住Alt拖动，该对象与其它对象的连接关系会断开 断开后，能否再次通过接触而连接 Options - Preferences - Miscellaneous - Wire Drag: Allow component move with connectivity changes 旋转对象 R 复制、粘贴、删除 选中对象，按住Ctrl键拖动，拖出来对象即为复制出来的对象 镜像翻转对象 H V 添加footprint属性 在原理图中修改单个元件封装信息 在元件库中修改单个元件封装信息，更新到原理图 - 打开某元件的编辑页面 - Options - Package Properties - PCB Footprint - OK，最后Replace（不要Update） 批量修改元件封装信息 批量修改修改一个原理图页面中的所有元件的封装信息 检查元件封装信息是否遗漏 生成网表netlist 生成前检查原理图的逻辑功能、电气连接，对整个工程重新索引编号，DRC检查 后处理 生成元件清单 打印原理图","link":"/zh-cn/Drawing-Schematics-in-OrCAD-Capture-CIS/"},{"title":"电子学基础","text":"最近画PCB时感觉很多电子学知识都不太熟悉，于是通过搜索维基百科做了一个基础知识的整理。 电子学历史 真空管时期真空管（Vacuum tube）可分为二极管、三极管、四极管、五极管和复合管等。 1904年，John Ambrose Fleming发明了二极管（Diode）。1906年，Lee De Forest发明了三极管（Triode）。 这时的电子学主要是“无线电技术”。 晶体管及集成电路时期1948年，贝尔实验室的John Bardeen、Walter Houser Brattain和William Shockley发明了晶体管（Transistor）。 1958年，Jack Killby发明了集成电路（Integrated Circuit, IC ）。 ⭐️二极管（Diode） 早期是真空二极管，后来发展出半导体二极管。 结构一个半导体性能的结晶片通过PN结连接到两个终端。 PN结将一块半导体晶体（如硅晶体）的一侧掺入少量磷，使自由电子浓度较高，带负电，为N型半导体；另一侧掺入少量硼，使空穴浓度较高，带正电，为P型半导体。中间的接触面形成一个过渡层，成为PN结（P-N junction）。 特性 二极管仅允许电流单方向传导，即顺向流通、逆向阻断。 二极管的电流-电压特性曲线是非线性的。 ⭐️三极管 三极管可以指真空三极管（Triode），也可以指双极性晶体管（BJT）。 真空三极管具有放大功能，是第一个电子放大器。20世纪70年代起被晶体管取代。 ⭐️晶体管（Transistor） 结构晶体管由三部分掺杂程度不同的半导体制成，两种不同掺杂物之间的边界形成PN结，故有NPN型和PNP型。它有三个对外端点（称之为极）。 特性当晶体管工作于线性区时，就成为“放大器”。常用于模拟电路。 当晶体管要么完全关闭要么完全导通时，就称为“开关”。常用于数字电路。 分类晶体管主要分两类：双极性结型晶体管（Bipolar Junction Transistor, BJT ）（俗称三极管）和场效应管（Field Effect Transistor, FET）（也叫单极性晶体管）。 BJT工作时，电子和空穴两种载流子都在流动；FET工作时，只有单一种类的载流子在流动。 BJTBJT的三个极为射极（Emitter）、基极（Base）和集极（Collector）。 射极到基极的微小电流，会使得射极到集极之间的阻抗改变，从而改变流经的电流。即基极-发射极电流控制集电极-发射极电流（也可以看成电压控制）。 在放大区内，可以近似认为：前者为恒定值，后者为前者的若干倍，晶体管起电流放大作用。 NPN型 箭头（表示发射极电流方向）指向外侧，即从基极指向发射极。 现在使用的BJT大部分是NPN型。 根据发射结（基极-发射极）和集电结（基极-集电极）的偏置情况定义工作区： 正向放大区/放大区（集电极-发射极电流与基极-发射极电流近似成线性关系）：发射结正向偏置，集电结反向偏置; 反向放大区（几乎不用）：发射极反向偏置，集电结正向偏置； 饱和区（可在数字逻辑中表示高电平）：两个PN结均正向偏置； 截止区（可在数字逻辑中表示低电平）：两个PN结均反向偏置； 突崩溃：集电结反向偏置电流过大，PN结被击穿。 PNP型箭头指向内侧，即从发射极指向基极。 PNP型的工作区的电压描述与NPN型相反。 三种放大器结构 共射极 基极作为输入端，集极作为输出端，射极为共用端（即接地，或接电源）。类似FET的共源极。 通常用于功率放大器、射频电路、低噪音放大器。 共基极 即基极接地（或接电源）。类似FET的共闸极。 通常用于电流缓冲器、电压放大器。不常用于低频电路，常用于高频电路。 共集极 即集电极接地（或接电源）。类似FET的共漏极。 通常用于电压缓冲器、负反馈放大器。 FET实用的器件是结型场效应晶体管（Junction gate Field- Effect Transistor，JFET）和金属氧化物半导体场效应晶体管（Metal-Oxide-Semiconductor FET, MOSFET）。二者原理相同，但前者使用PN结，后者使用肖特基结（金属与半导体之间的结）。 FET的三个极是栅极（Gate）、漏极（Drain）、源极（Source）（对应BJT的B、C、E）。除JFET外，所有FET都有第四个极，被称为体（body）、基（base）、块体（bulk）或衬底（substrate）。这个第四极可以将FET调制至运行。 JFETJFET分为N沟道（N-channel）和P沟道（P-channel）两种。 结构和原理 一个N沟道JFET是被P型半导体环绕的N型半导体。Source与Drain之间为N通道，它与Gate的P区形成PN结。Gate起控制作用。 Up为夹断电压。夹断后，相当于一个恒流源（I_DSS）。 符号 箭头表示沟道和栅极形成的PN结的极性（从P指向N），也是正向偏压下的电流方向。 MOSFETMOSFET分为NMOSFET和PMOSFET。还可以分为增强型和耗尽型。 MOSFET在概念上属于绝缘闸极场效电晶体（Insulated-Gate Field Effect Transistor, IGFET）。IGFET多指MOSFET。 结构和原理 MOSFET除了Source、Drain和Gate外，还有Body。 MOSFET的核心是位于中央的MOS电容，左右两侧是Source和Drain。 MOS电容的结构是“金属（常用多晶硅取代）-氧化物（SiO2）-半导体”，其中氧化物相当于电容器中的介电质。 工作区 根据在MOSFET三个极施加的偏置电压的不同，有三种工作模式。以增强型NMOS为例： 当 |VGS| &lt; |Vth| 时，处于截止区，不导通。|VGS| 为Gate到 Source的偏压差，|Vth| 为材料的临界电压； 当 VGS &gt; Vth 且 VGD &gt; Vth 时，处于线性区，相当于一个压控电阻，电流-电压有线性关系； 当 VGS &gt; Vth 且 VGD &lt; Vth 时，处于饱和区。 符号 将虚线改成实线就是耗尽型MOSFET。 ⭐️逻辑电路 BJT逻辑电路有TTL（Transistor-Transistor Logic，晶体管-晶体管逻辑）和ECL（Emitter Coupled Logic，发射极耦合逻辑），MOSFET的逻辑电路是CMOS（Complementary Metal- Oxide- Semiconductor，互补式金属氧化物半导体）。 TTL TTL是由晶体管、二极管和电阻构成的数字集成电路。最常见的是74系列。 TTL速度快，CMOS速度慢，但省电，成本比TTL低。后来CMOS的发展超越了TTL。目前TTL主要应用于教育或是较简单的数字电路。 CMOS CMOS由一对NMOS和PMOS构成。 CMOS只有在切换启动与关闭时才消耗能量。 ECL ECL的速度很快。摆幅小，抗干扰能力弱。 图中第一部分为开关，实现“或/或非”功能；第二部分为参考电压源，实现温度补偿功能；第三部分为射极跟随器，实现输出及隔离功能。","link":"/zh-cn/Fundamentals-of-Electronics/"},{"title":"2023年2月","text":"开学啦。 赶在考试前整理完了笔记，依然连滚带爬地出了考场。目前只出了DSP一门成绩，78，剩下两门感觉考得更烂不知道还会烂到哪里…… 本月发现 類 流浪豆瓣被豆瓣无端挖坟删帖+禁言一周后，怒搜了一番替代APP。下面是几种方案： 标记书影音：NeoDB 使用方法见这个帖子 。结合豆伴，可以将豆瓣书影音数据全部迁移过来，而且NeoDB上可以标记那些被禁的条目。 标记电影：Letterboxed 标记书籍：Goodreads 这篇blog“豆瓣逃离计划”讲了如何迁移数据到Notion 我没有尝试，不过看起来详细可行。 复习数字图像分析时发现两个不错的网页： 传统CV算法-边缘检测-教材合辑 很全面的介绍。 SUSAN算子 条目作者竟是我的授课老师 (ﾟoﾟ;; 翻LUG群聊天记录发现Linux C编程一站式学习。 也是复习时查资料发现一个清华老师做的物联网教程，感觉很厉害的样子先存起来吧qwq 推特冲浪发现一个blogger的关于RisingWave的周报，看不懂但喜欢周报。 日语课上，老师推荐了日本文化中心网站。 本月进展 有在留意和收集实习信息（但并没有投简历）。 有继续在看Linux 101和吴恩达机器学习（其它还在搁置）。 有健几次身。 开始画板子了！好难！不过不讨厌。像周星驰从跑龙套开始一样从PCB民工开始吧！ 书与影  始于极限：女性主义往复书简激情推荐给了不少人。 我的阴阳两界帮我度过了漫长到有点难熬的寒假时光。一本能让人在生活之余享受而不是倍加折磨的小说是很难得的。 本月看的11部电影中，最推荐的三部电影： 巴黎夜旅人侯麦影迷狂喜！ 童年往事沉痛而真切。 晒后假日如不少人所说的，“后劲十足”。 最后，一张Chantal Akerman的帅气截图：","link":"/zh-cn/Feb-2023/"},{"title":"Hello World","text":"我成功了！ :)","link":"/zh-cn/Hello-World/"},{"title":"在Linux中安装软件","text":"在 Linux 中安装软件有5种方法。 安装 使用应用商店安装适用于自带应用商店的发行版，如 Ubuntu、Manjaro 等 在 Xubuntu 中应用商店叫“软件”，试了一下并不好用，加载很慢 使用包管理系统安装软件包管理器是一系列工具的集合，他自动化地完成软件的安装、更新、配置和移除功能 在 Linux 中，许多软件均可以通过一行命令完成其安装，优雅而快速 与应用商店相比，使用包管理器安装需要预先知道所需软件在软件仓库中的对应包名 本教程以管理 Debian (.deb) 软件包的 dpkg以及它的前端 apt（用于 Debian 系的发行版）为例 apt 的全称是 Advance Package Tool apt 安装前，使用 apt search 搜索内容 查看对应的包名是否在软件仓库中 确定了软件包的包名后，通过 apt install 包名 进行安装 输入 Y 后回车确定进行安装 权限问题 提示“Permission denied”、“are you root?” 修正方法：在命令前面添加 sudo，即使用 sudo apt install firefox 在用户输入密码的过程中，为了安全，终端不进行密码的回显 官方软件源 apt 的软件源列表在 /etc/apt/sources.list 下 第三方软件源 官方软件源中没有的软件，可以添加第三方软件源然后安装软件 将第三方软件源添加到 /etc/apt/sources.list 中之后，就可以获取到第三方提供的软件列表，再通过 apt install package-name 安装需要的第三方软件 例如，通过添加 Docker 软件源安装 Docker 1 使用包管理器手动安装软件包除了从官方软件源和第三方软件源安装软件外，还可以直接下载安装软件供应商打包好的 deb 、rpm 等二进制包，使用命令安装 尽量使用 apt 来安装 deb ，避免直接使用 dpkg -i 安装 deb，因为直接通过 dpkg 安装 deb 并不会安装需要的依赖，只会报告出相应的依赖缺失了，需用下面的命令手动修复： 1$ sudo apt -f install 例如，安装 VSCode 2 我尝试了一下但失败了…… 首先，我的 Linux 发行版太旧了，无法使用 apt 安装，于是用了 dpkg -i ，出了一些错其次，我的存储空间似乎不足，无法完整装上 VSCode最后我又犯了一个错误，把 Linux 关机了，再开机时没有图形界面，只有左上角一个光标在一直闪动 这些问题我搜索了一下，都没有顺利解决。无奈之下只好删除了原先的虚拟机，添加新的虚拟机 宿主机win10与虚拟机ubuntu之间的文件传输 通过ssh连接服务器的方式传输文件 3。我用了 MobaXterm，成功了 断开连接时突然跳出几只小企鹅 ^_^ 安装预编译的可执行文件软件提供商还可能提供预编译好的二进制文件，可以直接运行 例如，安装预编译的 LLVM 4 使用源代码编译安装 5更新 在计算机本地，系统会维护一个包列表，里面包含了软件信息以及软件包的依赖关系 更新软件列表 使用 apt update 获取新的软件版本、软件依赖关系 更新软件 在获取到了新的软件列表后，使用 apt upgrade 进行软件更新 附录 教程 Linux 101 - 第三章：软件安装与文件操作 [1] Linux 101 - 第三方软件源 [2] Visual Studio Code on Linux [3] 宿主机win10与虚拟机ubuntu之间的文件传输方法 [4] Linux 101 - 安装预编译可执行文件 [5] Linux 101 - 使用源代码安装","link":"/zh-cn/Installing-software-in-Linux/"},{"title":"Git 学习笔记","text":"完整地过了一遍廖雪峰的教程。我学Git的初衷是想熟练用上GitHub, 现在发现Git才是那个深奥的核心 简介 Git是用C语言开发的 集中式&amp;分布式版本控制系统 集中式：版本库集中存放在中央服务器；最大的毛病就是必须联网才能工作 分布式：没有“中央服务器”，每个人的电脑上都是一个完整的版本库，不需要联网；安全性要高很多；通常也有一台充当“中央服务器”的电脑，但这个服务器的作用仅仅是用来方便“交换”大家的修改；极其强大的分支管理 创建版本库 版本库：又名仓库，英文名repository，可以简单理解成一个目录，这个目录里面的所有文件都可以被Git管理起来，每个文件的修改、删除，Git都能跟踪，以便任何时刻都可以追踪历史，或者在将来某个时刻可以“还原” 创建版本库 step1：创建一个空目录 step2：初始化，git init 把一个文件放到Git仓库 git add git commit 时光机穿梭 git status查看工作区状态 git diff查看修改内容 版本回退 git reset --hard commit_id版本回退 git reset --hard HEAD^ 在Git中，用HEAD表示当前版本，上一个版本就是HEAD^，上上一个版本就是HEAD^^，往上100个写成HEAD~100 git reset --hard 1094a 版本号（commit id）没必要写全，前几位就可以了，Git会自动去找 git log查看提交历史 显示从最近到最远的提交日志（如果嫌输出信息太多，加上--pretty=oneline参数） git reflog查看命令历史 可以找到版本号 工作区和暂存区 工作区（Working Directory）：在电脑里能看到的目录 版本库（Repository）：工作区有一个隐藏目录.git，这个不算工作区，而是Git的版本库 版本库里重要的东西有： 暂存区：stage（或者叫index） 分支：Git为我们自动创建的第一个分支master 指针：指向master的一个指针叫HEAD 需要提交的文件修改通通放到暂存区，然后一次性提交暂存区的所有修改 管理修改 Git跟踪并管理的是修改，而非文件 每次修改，如果不用git add到暂存区，那就不会加入到commit中 add只添加进了暂存区，commit才是进版本库，暂存区的相同文件都是覆盖的 撤销修改 git restore -- file丢弃修改，让这个文件回到最近一次git commit或git add时的状态 --很重要，没有--，就变成了“切换到另一个分支”的命令 git restore --staged把暂存区的修改撤销掉（unstage），重新放回工作区 注： 原来的git checkout 可以使用 git restore 代替 原来的git reset HEAD 可以使用 git restore –staged 代替 最新版的git提示都已经更换成了restore 总结： 情况1：在工作区做了修改，并未添加到暂存区，想撤销工作区的修改，用 git restore file 情况2：在工作区做了修改，并用git add 添加到了暂存区，未提交；想撤销，分两步，1.先撤销暂存区的修改，用 git restore –staged file, 2.然后参考情况1撤销工作区的修改 情况3：在工作区做了修改，且git add git commit添加并提交了内容，想撤销本次提交，直接用 git reset –hard HEAD^回退版本，即可保证工作区，暂存区，版本库都是上次的内容 删除文件 git rm 如果一个文件已经被提交到版本库，那么你永远不用担心误删，但是要小心，你只能恢复文件到最新版本，你会丢失最近一次提交后你修改的内容 当你直接在文件管理器中把没用的文件删了，或者用rm命令删了，接下来有两种选择： 确实要从版本库中删除该文件，那就用命令git rm删掉，并且git commit 删错了，用git checkout把误删的文件从版本库里恢复到最新版本 远程仓库 本地Git仓库和GitHub仓库之间的传输通过SSH加密 添加远程库 git remote add origin git@server-name:path/repo-name.git 关联一个远程库时必须给远程库指定一个名字，origin是默认习惯命名 关联后，使用命令git push -u origin master第一次推送master分支的所有内容 此后，每次本地提交后，只要有必要，就可以使用命令git push origin master推送最新修改 删除远程库 git remote rm &lt;name&gt; 使用前，建议先用git remote -v查看远程库信息 只是解除了本地和远程的绑定关系，并不是物理上删除了远程库。远程库本身并没有任何改动。要真正删除远程库，需要登录到GitHub，在后台页面找到删除按钮再删除 从远程库克隆 ssh：git clone git@github.com:your name/repo name.git 更快 https：git clone http://github.com/yourname/reponame.git 分支管理 创建与合并分支 git checkout -b或git switch -c创建并切换 相当于git branch（创建） + git checkout或git switch（切换） git branch查看当前分支 会列出所有分支，当前分支前面会标一个* git merge合并指定分支到当前分支 git branch -d删除分支 创建、合并和删除分支非常快，所以最好使用分支完成某个任务，合并后再删掉分支，这和直接在master分支上工作效果是一样的，但过程更安全 解决冲突 把Git合并失败的文件手动编辑为我们希望的内容，再提交 分支管理策略 分支策略 master分支应该是非常稳定的，也就是仅用来发布新版本，平时不能在上面干活 dev分支是不稳定的，干活都在dev分支上；到某个时候，比如1.0版本发布时，再把dev分支合并到master上，在master分支发布1.0版本 团队成员都在dev分支上干活，每个人都有自己的分支，时不时地往dev分支上合并就可以了 合并分支时的普通模式：加上--no-ff参数 这样合并后的历史有分支，能看出来曾经做过合并，而fast forward合并就看不出来曾经做过合并 Bug分支 修复bug时，通过创建新的bug分支进行修复，然后合并，最后删除 git stash保存工作现场，然后去修复bug，修复后，有两种方式回到工作现场： git stash apply，stash内容并不删除，需要用git stash drop来删除 git stash pop，恢复的同时把stash内容也删了 git stash list查看stash里的内容，然后用git stash apply stash@{0}恢复到指定的stash（这里是stash@{0}） 在master分支上修复的bug，想要合并到当前dev分支，可以用git cherry-pick &lt;commit&gt;，把bug提交的修改“复制”到当前分支，避免重复劳动 Feature分支 开发一个新feature，最好新建一个分支 如果要丢弃一个没有被合并过的分支，可以通过git branch -D &lt;name&gt;强行删除 多人协作 git push origin &lt;branch-name&gt;推送自己的修改 如果推送失败，则因为远程分支比你的本地更新，需要先用git pull试图合并 如果git pull提示no tracking information，则需要用git branch --set-upstream-to &lt;branch-name&gt; origin/&lt;branch-name&gt;建立起本地分支和远程分支的链接关系 如果合并有冲突，则解决冲突，并在本地提交 没有冲突或者解决掉冲突后，再用git push origin &lt;branch-name&gt;推送 Rebase 把本地未push的分叉提交历史整理成直线 目的：使我们在查看历史提交的变化时更容易，因为分叉的提交需要三方对比 标签管理 tag是一个让人容易记住的有意义的名字，它跟某个commit绑在一起 如果这个commit既出现在master分支，又出现在dev分支，那么在这两个分支上都可以看到这个标签 创建标签 git tag &lt;tagname&gt;新建一个标签 默认为HEAD，也可以指定一个commit id 创建的标签都只存储在本地，不会自动推送到远程 git tag -a &lt;tagname&gt; -m &quot;blablabla...&quot;创建带有说明的标签 git tag查看所有标签 不是按时间顺序列出，而是按字母排序 git show &lt;tagname&gt;查看标签信息 操作标签 推送 git push origin &lt;tagname&gt;推送某个本地标签到远程 git push origin --tags一次性推送全部未推送过的本地标签到远程 删除 git tag -d &lt;tagname&gt;删除某个本地标签 删除一个远程标签：先从本地删除（用上面的命令），然后从远程删除，命令是git push origin :refs/tags/&lt;tagname&gt; 使用GitHub 可以任意Fork开源仓库 Fork后的仓库，你拥有读写权限 推送pull request给官方仓库来贡献代码 使用Gitee 国内的Git托管服务 使用方法和GitHub类似 自定义Git git config --global color.ui **true**让Git显示颜色，看起来更醒目 忽略特殊文件 Github官方.gitignore文件合集 忽略文件的原则： 忽略操作系统自动生成的文件 忽略编译生成的中间文件、可执行文件等 忽略带有个人敏感信息的配置文件 git add -f filename虽然被忽略但强制添加 !filename例外文件 .gitignore online generator 配置别名 git config --global **alias**.st status设定用st表示status --global是全局参数，针对当前用户，即让命令在这台电脑的所有Git仓库下都有用；如果不加，那就只针对当前仓库有用 每个仓库的Git配置文件都放在.git/config文件中 当前用户的Git配置文件放在用户主目录下的一个隐藏文件.gitconfig中 要删除别名，直接把[alias]后面的对应别名的行删掉即可 搭建Git服务器 需要一台运行Linux的机器（推荐Ubuntu或Debian）。暂时用不到就没看，详见这里 使用Sourcetree 免费Git图形界面工具 附录 教程 廖雪峰的Git教程 链接 Git Cheat SheetGit官网","link":"/zh-cn/Git-Learning-Notes/"},{"title":"Git & Github 入门","text":"这是我在学习LinkedIn课程Learning Git and Github时做的一些简单笔记。我发现先在Notion中做笔记，然后导出Markdown，修改，复制粘贴到Blog中，非常方便。 开始12git config --global user.name &quot;name&quot;git config --global user.email &quot;mail&quot; 1git init 暂存区 Staging files12git add filenamegit add . 1git commit -m &quot;message&quot; 1git log Git 环境 Working Staging Commit 文件状态1git status Tracked (after commit) Unmodified Modified Staged Untracked 恢复文件12git restore filenamegit restore . 忽略文件 Sensitive info Personal notes System files 使用 .gitignore 文件 清除缓存1git rm -r --cached . 删除1git rm filename 删除，并转移到暂存区，准备提交 重命名1git mv oldname newname 同样转移到暂存区 显示区别1git diff 1got log --oneline 修正1git commit --amend 12git resetgit reset --hard 重置 Rebasing一台时光机，可以重写历史 1git rebase 分支 Branches1git branch 复制一个分支： 1git switch -c NAME 合并： 1git merge &lt;branch&gt; 删除： 1git branch --delete NAME Git 流程： Fix branch Make changes Merge to master Delete old branch 合并冲突选择其中一个即可 贮藏 Stashing1234git stashgit stash listgit stash applygit stash pop Git clean123git clean -ngit clean -dgit clean -f Github Cloud repository Collaborative dev Projet management 使用github: Set up remote Push Fetch/pull 推送到github远程: 1234git remote add NAME URLgit remote remove NAMEgit rename OLDNAME NEWNAMEgit remote -v Git 推送: 123git push REMOTE BRANCHgit push -u origin maingit push --all Github 选项Issues与人合作 为你自己或其他人写笔记，如待办事项 将待办事项分配给个人，他们可以发表评论 Pull requests更改仓库 批准别人所做的修改 比较不同的分支 Actions管理仓库（高级） 运行测试 自动托管代码 下载其他人的actions来使用 Projects管理仓库 看板 Wiki创建便于人们查看的文件（其实没必要） Security管理安全策略（高级） Insights了解贡献者、仓库动态等（私人） Settings 将此仓库转换为一个模板 Github页面 管理 projects 贡献者 邀请合作者 问题 标签 里程碑 项目 同步1git clone 1git fetch 1git pull pull = fetch + merge","link":"/zh-cn/Intro-to-Git-GitHub/"},{"title":"初识 Linux","text":"按照教程成功安装用上了 Xubuntu ！赞美！ 计算机性能爆发增长 摩尔定律：集成电路上可容纳的晶体管数目每两年就会翻一倍/计算机的性能每 18 个月提高一倍（Intel CEO David House） 量子物理的限制以及 CPU 功耗和散热的限制使计算机性能的提升开始放缓。多个 CPU 之间的联合协作（基于多核的开发）取代追求单个 CPU 性能的提升，成为了未来发展方向 操作系统 用户与底层硬件交流的桥梁 功能 进程管理：操作系统调度进程，使许多进程可以在几个中央处理器上并发执行 内存管理：操作系统合理分配和回收内存 文件系统：操作系统建立合适的数据结构来存储文件和数据 网络通信：操作系统实现各种必需的网络通信方式（如TCP/IP） 安全机制：操作系统配备安全机制用于保护数据不被未授权的人士获取 用户界面：操作系统通常包含一个图形化的用户界面，方便用户使用计算机 驱动程序：操作系统与驱动程序对接以发挥硬件的功能 Linux 诞生 选择 Linux，很大程度上是一种对极客精神与开源文化的认同。 自由软件意味着其用户拥有自由。（这无关价格。）我们开发了GNU系统，这样用户就有了计算的自由。 具体来说，自由软件的用户拥有四项基本自由：(0)自由运行软件、(1)自由学习和修改软件源代码、(2)自由再发布软件拷贝以及(3)自由发布修改后的软件版本。 软件不同于生活中的事物 — 它不同于椅子、三明治或是汽油 — 软件可以更容易地被复制或修改。恰恰是这一特性，使得软件更为有用。我们由此坚信，软件的这一天然属性应该被用户利用。1 1983 年，Richard Stallman 在 MIT 发起了 GNU 计划；1991年，Linus Torvalds 编写并发布了Linux 内核，成为了后来各类 Linux 发行版的基础 GNU：GNU 是“GNU is Not Unix”的递归缩写，指一套类似 UNIX 但完全自由的操作系统 GNU 通用公共许可证（GNU General Public License，GNU GPL 或 GPL）：把使用该许可的软件的所有权利授予任何使用它的人 这种权利又被称为著作传（Copyleft），相对于通常的著作权（Copyright） 核心GNU操作系统至今没有开发完成。现在实际上用的是 GNU/Linux ，Linux 内核是功能核心，而GNU组件是外设，也是用户操作和使用 Linux 内核的工具 现在智能手机上一个常见的系统是 Android/Linux ，是一个基于 Linux 内核开发的、没有采用 GNU 组件而是用谷歌自行研发的另一套 Android 体系作为工具的操作系统 Linux 发行版 Linux 发行版 = Linux 内核 + 一系列 GNU 工具和库、一些附带的软件、说明文档、一个桌面系统、一个窗口管理器和一个桌面环境 主流的发行版分支 Debian 分支：最著名的是 Ubuntu ，一个主打桌面应用的操作系统，适合普通用户使用。推荐初次接触 Linux 的读者优先采用 Ubuntu 发行版或者它的子发行版（Lubuntu, Xubuntu 等） Red Hat 分支：Fedora ，CentOS（适合在要求高度稳定的服务器上运行） Arch Linux 分支：要求使用者自身愿意去了解操作系统的运作方式，并不采取屏蔽工作原理的方式来降低使用门槛。变种 Manjaro 更注重易用，更适合一般用户 Linux 在身边 智能手机：Google 研发的 Android 操作系统属于 Android/Linux 分支，也叫 Android 原生系统，子发行版很多，如华为 EMUI 操作系统和小米 MIUI 操作系统等 服务器：网站和软件的提供商都需要设立他们自己的计算机来完成计算、存储和通信的功能，这种计算机就被称为服务器。服务器通常不用 Windows 或者 macOS 这种个人计算机操作系统，绝大部分用 Linux 发行版，因为它们界面简洁，功能强大，而且某些发行版也受到专业计算机企业的服务支持（如 RHEL）。Debian 和 Ubuntu Server 很流行 嵌入式设备：Android/Linux 分支下的各类发行版是主流的嵌入式操作系统，如 Google 为数字电视专门推出的 Android TV 操作系统 使用 Linux 推荐使用虚拟机运行安装完毕的 Linux 镜像 步骤 获取虚拟机管理软件，推荐 VMware Workstation Player 获取 Xubuntu 虚拟机镜像（Xubuntu 是 Ubuntu 的一个子发行版，与 Ubuntu 非常类似，但体积更小，性能需求更少，适合各种不同性能的电脑安装使用） 双击打开虚拟机镜像，管理软件会打开并导入该镜像，导入完毕后可直接点击开始按钮启动 拾 ~ 附录 教程 LUG @ USTC的Linux 101 - 第一章：初识Linux 引用 [1] GNU 工程的哲学 推荐阅读 为什么开源错失了自由软件的重点","link":"/zh-cn/Intro-to-Linux/"},{"title":"Java 入门","text":"关于Java的诞生背景、发展历史和版本说明部分让我收获较大。 简介 创始人：James Gosling Java介于编译型语言和解释型语言之间。它是将代码编译成一种“字节码”，类似于抽象的CPU指令，然后针对不同平台编写虚拟机，不同平台的虚拟机负责加载字节码并执行，实现“一次编写，到处运行” Java三个版本 Java SE：Standard Edition，标准版，包含标准的JVM和标准库，是整个Java平台的核心 Java EE：Enterprise Edition，企业版，在Java SE的基础上加上了大量的API和库，以便方便开发Web应用、数据库、消息服务等；Java EE的的虚拟机和Java SE完全相同；是进一步学习Web应用所必须的 Java ME：Micro Edition，针对嵌入式设备的“瘦身版”，Java SE的标准库无法在Java ME上使用；Java ME的虚拟机也是“瘦身版”；不流行，不建议学习 推荐的Java学习路线 首先要学习Java SE，掌握Java语言本身、Java核心开发技术以及Java标准库的使用； 如果继续学习Java EE，那么Spring框架、数据库开发、分布式架构就是需要学习的； 如果要学习大数据开发，那么Hadoop、Spark、Flink这些大数据平台就是需要学习的，他们都基于Java或Scala开发； 如果想要学习移动开发，那么就深入Android平台，掌握Android App开发。 JDK：Java Development Kit，除了包含JRE，还提供了编译器、调试器等开发工具，用来将Java源码编译成Java字节码 JRE：Java Runtime Environment，是运行Java字节码的虚拟机 JSR规范：Java Specification Request JCP组织：Java Community Process RI：Reference Implementation，参考实现 TCK：Technology Compatibility Kit，兼容性测试套件 基础 程序基本结构123public class Hello { // 类名是Hello // ...} // class定义结束 12345public class Hello { public static void main(String[] args) {// 方法名是main// 方法代码... }// 方法定义结束} 类名必须以英文字母（习惯大写）开头；方法名必须以英文字母（习惯小写）开头 在class内部，可以定义若干方法（method） public是访问修饰符，表示该class是公开的。不写public，也能正确编译，但是这个类将无法从命令行执行 Java入口程序规定的方法必须是静态方法，方法名必须为main，括号内的参数必须是String数组 Intelli IDEA代码格式化：Ctrl + Alt + L 变量和数据类型 两种变量类型：基本类型和引用类型 基本类型是CPU可以直接进行运算的类型。包括整型，浮点型，布尔型，字符型 剩下的都是引用类型，类似于C语言的指针，它内部存储一个“地址”，指向某个对象在内存的位置。最常用的是String 基本类型的变量是“持有”某个数值，引用类型的变量是“指向”某个对象 常量在初始化后不可重新赋值 简写变量类型，使用var关键字 运算 整数运算永远是精确的，浮点数运算常常无法精确表示 流程控制 输入和输出 输出 System.out.println()，输出并换行 System.out.print()，输出不换行 System.out.printf()，格式化输出 输入（不能在线运行，必须从命令行读取） 1234567import java.util.Scanner;public class Main {publicstaticvoid main(String[] args) { Scanner scanner =new Scanner(System.in);// 创建Scanner对象 String name = scanner.nextLine();// 读取一行输入并获取字符串 int age = scanner.nextInt();// 读取一行输入并获取整数 }} if条件判断 判断浮点数相等用==判断不靠谱，正确的方法是利用差值小于某个临界值来判断 判断引用类型的变量内容是否相等，必须使用equals()方法 case多重选择 总是写上default 从Java12开始，新语法使用-&gt;，如果有多条语句，需要用{}括起来。不要写break语句，因为新语法只会执行匹配的语句，没有穿透效应 在switch表达式内部，用yield返回一个值作为switch语句的返回值 while循环 先判断后循环 可能循环0次 do while循环 先循环后判断 至少循环一次 for循环 可能循环0次 break和continue 在多层嵌套的循环中，都只能跳出自己所在的那一层循环 数组操作 遍历、排序、多维数组、命令行参数（略） 附录 教程 廖雪峰的Java教程-Java快速入门","link":"/zh-cn/Intro-to-Java/"},{"title":"LaTeX 简历","text":"从昨天中午到今天中午，我一直在用latex做简历。这对初学者来说非常不友好。幸运的是，我现在做完了，看看我的简历. 我是这样做的： -&gt; 如果你只是偶尔或少量使用latex，一个在线编辑器 Overleaf 可以省去很多麻烦。你可以找模板，然后编辑和编译就可以了。-&gt; 如果你想做更多的事情，请使用以下步骤。 下载 MiKTeX 和 VSCodeMiKTeX你会得到MiKTeX Consle和TeXworks。后者是一个编辑器，但我更喜欢使用VSCode，因为它可以在另一个窗口预览pdf（也因为我已经有VSCode）。另一个选择是Tex Live。它预装了一个完整的软件包，但下载速度太慢，而且经常失败，所以我选择了MiKTeX。 VSCode记得下载插件 latex workshop。 找模板在Overleaf或Github上找一个模板。这是我喜欢的：新卒のためのLaTeX履歴書テンプレートTLC-Resume-2021以及我做的：Resume-CV (在TLC-Resume-2021的基础上修改的) 编辑模板在这一步你可能会遇到很多问题，其中大部分需要你在MiKTeX控制台中下载包，或其他东西，如Perl。只要按照错误信息中所说的安装缺少的项目就可以了。 分享模板 把你的模板放到github上(已经绑定了git和你的github账户并设置了SSH密钥)-&gt; 创建一个新的仓库-&gt; Git bash文件夹，其中包含关于你的模板的全部文件-&gt; 在Git中运行以下代码 git init git add . git commit -m &apos;Description&apos; git remote add origin https://... (copy from github) git push -u origin master 提交到Overleaf我就是在那里找到我的简历的原始模板的! 我想，把模板放在那里可能会帮助到更多的人。","link":"/zh-cn/Latex-CV/"},{"title":"2023年3月","text":"打喷为主学习为辅的一个月。 出成绩啦漫长的等待结束，上学期的课程全部合格了（虽然不高），心满意足。数字图像分析给分还不错。所幸这学期的专业课只有一门闭卷考试。专业课也都更贴切实验室的项目了。 画PCBPCB图还在反复修改。我按照自己的理解画好后发给师兄，师兄看完会改改再发回给我，并且给出详细的修改指导。太厉害了，每修改一次我都会感叹自己多么无知和欠缺经验……但同时也在不断地学到很多新东西！ 听报告听了STCF主题的报告（终于理解了一点STCF的物理背景），CGG新加坡部门招聘的宣讲会（并和校友一起吃了晚饭，结束后险些直接面试），大众安徽的宣讲会（德语神仙在线打架），伽马光子对撞机的报告，两位师兄的博士开题，已毕业并在自动驾驶行业工作的师兄的经验分享会…… 关于新加坡，搜到这个：润去新加坡。 考试报名报名了5月底的软考（程序员）和七月初的JLPT（N4）！尽量每天学一课出口日语，听一遍音频，写练习题。今天学完第12课了。 入坑 Splatoon 3游戏到手一周多就玩了80+小时的水平。我不忏悔，我爱喷喷无罪，大家都来喷！ 斯普拉遁资料站Inkipedia捏脸","link":"/zh-cn/Mar-2023/"},{"title":"2023年1月","text":"新年第一个月，仍在龟速整理复习笔记，摸鱼怠惰。不过也学到了一些新东西。 又换了blog主题为了增加中英文语言选项而换了Minos主题，一番捣鼓后终于成功了！并且出于自己的审美而稍做了外观修改。然后发现在手机端点击更换语言时下拉菜单被导航栏遮挡，想了各种解决办法，最后通过更改排版实现了完整显示，于是整理成了一个仓库，方便中国用户直接使用。 后来又发现一个问题：在config中开启阅读文章时的导航栏后，英文版正常显示小标题，中文却乱码了。这个遗留问题尚未解决所以暂且改成：英文版开启导航栏，中文版关闭。 用上了Linux发现了一个很好的教程：Linux 101，是中科大Linux社团写的。成功用上Linux并激情发邮件入社围观群内大佬！目前学完了前三章。 关于机器学习重拾吴恩达，丢下freecodecamp藍。freecodecamp讲的很实用，直接敲代码演示，但语速太快了，吴恩达则反过来。不着急的话还是先看吴恩达了解原理吧。目前看到“P92 16.3 整合”。 复习DIA时搜到了一篇很清晰地讲解了BP算法的文章。原文在这里。 在一亩三分地看到一个机器学习八股文的帖子。 开始画PCB了准确说只是刚开始画原理图，磨叽到现在还没有画完。以前只用过Altium Designer，现在需要用Cadence。饶有兴趣地查了一番二者的区别，看来Altium Designer易于上手、性能有限，Cadence更难也更强大。 看到一篇不错的blog：Cadence使用及画板技巧相关。 没有学语言但是给下学期选了日语课！好耶，选到就是学到ヽ(ﾟ▽ﾟ)ノ","link":"/zh-cn/Jan-2023/"},{"title":"2023年5月-8月","text":"好久没写blog了……克服惰性真难啊。 STCF MDC FEE子板初步完成5月底PCB设计图最终修改完成，投板、焊接，7月底测试了PCB基本功能正常。很有成就感！本来导师说8月初可能需要出差去兰州，用实际的探测器信号测试，但因为放暑假所以不了了之了。可惜。关于STCF还需要单独写一篇blog。 新的项目：White Rabbit多端口节点研制这是我最近参与的第二个项目，和另一位研一同学合作。预计今年底要设计好PCB。White rabbit真是太难了……同样下次单独写一篇讨论吧。目前还是一头雾水的状态。 一些考试成绩期末考试成绩差不多都出来了，还行吧……软考居然过了。JLPT果然没过，笑死。不懂日语！ （很敷衍地总结了三个月，但写了就好~）","link":"/zh-cn/May-Aug-2023/"},{"title":"2022年11月","text":"Leetcode目前为止在Leetcode上做了64道题。 完成了Arrays 101（剩下一题只有会员才能做）。是对像我这样的初学者来说也非常简单一章！ 得到一个徽章! 说实话，我不太理解这个徽章里的所有数据结构题洛。我只熟悉数组和字符串…… 打算找时间消化一下。 Jupyter Notebook实际使用了一下。写了一个简单的使用Logistic Regression模型对一些数据进行分类的笔记本。 Github Workflow在我的GitHub账户主页上使用了Metrics。它的神奇之处在于可以自动更新! 领英学习证书每个证书下是我对该课程的评分。 ⭐⭐⭐⭐⭐ ⭐⭐ ⭐⭐ ⭐⭐⭐⭐ ⭐⭐⭐ 语言准备IELTS indicator 考试。 坚持学习了42 days的多邻国日语。 我发现，在中国只有两种日语考试，即JLPT和JTEST。JLPT每年只举行两次，而且经常被取消。JTEST的举办频率更高，但它不像JLPT那样被高度认可，所以我很纠结。","link":"/zh-cn/Nov-2022/"},{"title":"我的第一个领英学习证书！","text":"是的，我得到了! 我一直想要获得在线学习证书，比如Coursera和LinkedIn。Coursera的免费方案是一个星期，而LinkedIn的是一个月，所以我选择了后者。 (注意，对于中国大陆用户，你必须在账户设置中改变你的位置为非中国大陆地区，以获得每月的免费计划。另外，你必须使用Visa的信用卡。） 不错的课程 简短，不到2个小时，对新手非常友好实用！作者介绍了许多学习前端开发的有用网站 我学到了什么 网络开发工作的类型规划和原型设计： UX (用户体验) UI (用户界面) 编程和开发： 前端开发 (Javascript, CSS, HTML; 框架) 后端开发 Javascript、CSS、HTML HTML确定了结构元素 CSS改变了的外观和风格 JS处理交互性，如移动和动画 对Github有了一点了解这超出了我的预期，也正是我所需要的! 看起来Github Pages Service对于小型和简单的网络开发来说是一个很好的（因为免费）开始。我最近会试试的。 无代码这对我来说是一个全新的概念。听起来很有趣，你可以不通过写代码来开发一个网站。但也许代价是，真正的成本————钱？但是它是受限的，尤其是当你了解得越多，就越贪婪 :p 有用的工具 原型设计工具： Figma 图形界面设计工具： Illustrator, Photoshop （专业） Affinity, Figma （轻量） Canva （最简单，免费，有模板） 代码编辑器: CodePen （在线，免费） VS Code Atom （免费，高度可个性化定制） Brackets 网络主机： Github Pages Service（最简单，免费） 无代码工具 CMSs (内容管理系统)： Joomla! Drupal Wordpress 建立网站的工具： Squarespace, Wix, Weebly （简单） Webflow, Editor X （复杂） 数据库： Google Sheets Airtable 应用： Bubble (web) AppGyver (web, ios, android) Adalo, Glide (ios, android) 最后，这是我的证书，希望今后能得到更多的证书  ~ 附录 领英学习课程 Introducation to Web Design and Development","link":"/zh-cn/My-first-LinkedIn-certificate/"},{"title":"在Linux中操作文件","text":"Linux 通过命令行操作文件，包括查看、编辑、复制、移动、删除、创建、搜索、匹配、压缩、解压缩文件。学会查看使用文档也很重要。 查看 cat 12$ # 输出 FILE 文件的全部内容$ cat [OPTION] FILE cat 是 concatenate（连接）的缩写。cat 工具实际的功能是连接多个文件，然后输出。只有一个文件的时候，cat 就会直接输出这个文件，所以 cat 最常见的用途就是输出单个文件。 less 12$ # 在可交互的窗口内输出 FILE 文件的内容$ less FILE cat 会一次性打印全部内容到终端中并退出，而 less 一次只显示一页，且支持向前/后滚动、搜索等功能。如果要在一个大文件中查找一部分内容，less 通常要比 cat 方便得多。 和 less 相似的指令：more, most。 编辑 Nano 是在很多机器上自带的命令行文本编辑器，比 vim 和 emacs 对新手更加友好。 1$ nano FILE # 使用 nano 编辑 FILE 文件 复制 123456789$ # 将 SOURCE 文件拷贝到 DEST 文件，拷贝得到的文件即为 DEST$ cp [OPTION] SOURCE DEST$ # 将 SOURCE 文件拷贝到 DIRECTORY 目录下，SOURCE 可以为不止一个文件$ cp [OPTION] SOURCE... DIRECTORY$ # e.g.$ cp file1 file3 # 将 file1 复制一份到同目录，命名为 file3$ cp file1 file2 ./file/ # 将 file1、file2 文件复制到同目录下的 file 目录中$ cp -r file ./test/ # 将 file 文件夹及其所有子文件复制到同目录下的 test 文件夹中 硬链接和软链接 硬链接与源文件有着相同的 inode，都指向磁盘中的同一个位置。删除其中一个，并不影响另一个。 软链接与源文件的 inode 不同。软链接保存了源文件的路径，在访问软链接的时候，访问的路径被替换为源文件的路径，因此访问软链接也等同于访问源文件。但是如果删除了源文件，软链接所保存的路径也就无效了，软链接因此也是无效的1。 移动 12345$ # 将 SOURCE 文件移动到 DEST 文件$ mv [OPTION] SOURCE DEST$ # 将 SOURCE 文件移动到 DIRECTORY 目录下，SOURCE 可以为多个文件$ mv [OPTION] SOURCE... DIRECTORY 类似于 Windows 下的剪切。 删除 123456789$ # 删除 FILE 文件，FILE 可以为多个文件。$ # 如果需要删除目录，需要通过 -r 选项递归删除目录$ rm [OPTION] FILE...$ # e.g.$ rm file1 # 删除 file1 文件$ rm -r test/ # 删除 test 目录及其下的所有文件$ rm -rf test1/ test2/ file1.txt # 删除 test1/、test2/、file1.txt 这些文件、目录。其中，这些文件或者目录可能不存在、写保护或者没有权限读写 创建 创建目录 123456$ # 创建一个目录，名为 DIR_NAME$ mkdir [OPTION] DIR_NAME...$ # e.g.$ mkdir test1 test2 # 创建两个目录，名字分别为 test1、test2$ mkdir -p test1/test2/test3/ # 创建路径 test1/test2/test3/ 创建文件 12$ # 创建一个文件，名为 FILE_NAME$ touch FILE_NAME... stat 命令可以显示文件的属性信息。 touch 实际上的功能是修改文件的访问时间（access time, atime）和修改时间（modification time, mtime），可以当作是摸（touch）了一下文件，使得它的访问与修改时间发生了变化。当文件不存在时，touch 会创建新文件。 搜索 1234567$ # 在 PATH（路径）中根据 EXPRESSION（表达式）搜索文件$ find [OPTION] PATH [EXPRESSION]$ # e.g.$ find . -name &apos;report.pdf&apos; # 在当前目录搜索名为 report.pdf 的文件$ find / -size +1G # 全盘搜索大于 1G 的文件$ find ~/ -name &apos;node_modules&apos; -type d # 在用户目录搜索所有名为 node_modules 的文件夹 模式匹配 bash 的匹配模式被称为glob。 123$ # e.g.$ rm *.tar.gz # 删除所有以 tar.gz 结尾的压缩文件$ mv -r *.[ch] /path # 将当前及子目录下所有以 .c 或 .h 结尾的代码移动到 /path 使用通配符前一定要确认输入无误，否则可能出现严重的后果（如 rm -rf * 会删掉当前目录的所有文件）。 压缩与解压缩 使用 tar 操作存档、压缩文件 1234567$ # 命令格式如下，请参考下面的使用样例了解使用方法$ tar [OPTIONS] FILE...$ # e.g.$ tar -c -f target.tar file1 file2 file3 # 将file1、file2、file3 打包为 target.tar$ tar -x -f target.tar -C test/ # 将 target.tar 中的文件提取到 test 目录中$ tar -cz -f target.tar.gz file1 file2 file3 # 将 file1、file2、file3 打包，并使用 gzip 算法压缩，得到压缩文件 target.tar.gz 和大部分 Linux 命令一样，tar 命令可以组合参数。例如，以下命令等价： 123$ tar -c -z -v -f target.tar test/$ tar -czvf target.tar test/$ tar -f target.tar -czv test/ 后缀名并不能决定文件类型，但可以帮助人们辨认这个文件的可能文件类型，从而选择合适的打开方法。 软件的使用文档 man 命令 123$ # 调出 tar 命令和 ls 命令的文档$ man tar$ man ls 会显示软件的每一个参数的含义、退出值含义、作者等内容，大而全。但一般较少带有使用样例，需要根据自身需要拼接软件参数，不利于快速上手。 tldr 软件 通过几个简单的例子让用户可以快速了解软件的使用方法。 1$ tldr COMMAND 注意，如果出现报错： 1mkdir:无法创建目录&quot;/home/lzy/.tldr&quot;：文件已存在 解决办法是： 1234$ sudo apt-get update$ sudo apt-get install tldr$ mkdir -p ~/.tldr/tldr$ sudo git clone https://github.com/tldr-pages/tldr.git ~/.tldr/tldr 附录 Linux 101 - chap 03: 软件安装与文件操作 [1] 阮一峰的网络日志 - 理解inode","link":"/zh-cn/Operating-Files-in-Linux/"},{"title":"2022年10月","text":"编程到目前为止，我完成了Leetcode上的27道题，都是用Java。上一章的探索Array and String有点难，但现在的Arrays 101就容易多了。为什么我还在做数组？我等不及学新的东西了。 我学了一点一个著名的课程，CS61A，做了HW 01，HW 02，Lab 00，Lab 01，现在在做Lab 02。上半月我学习得比较认真，下半月就懈怠了。希望我能够坚持下去，完成这门课程和CS61B。OK系统非常有趣。 我看了一些Andrew Ng的机器学习视频，从开始到P48“推理：做预测”。我的导师要求我学习机器学习，所以我试图开始学习。我还读了经典教材《机器学习实战》的一些部分。很不错，而且比视频中的代码更多，难度更大。然而，我还是没有很好地理解机器学习。它看起来很容易，但做起来真的很难勞。好消息是，我今天下午终于做了一个python程序…… Matlab看起来很方便，但它对电脑性能要求太高，而且有点不稳定。我在想，数据有什么特点… 语言坚持每天看一部英语视频，尤其是经济学人的文章。我还在“简报”栏目中阅读了一篇名为《王子》的文章。几天前，我开始准备多邻国英语测试。我的男朋友也报名参加了雅思indicator考试。我们都是下周考。希望成功! 我也开始从多邻国和NHK简明日语学习日语了。喜欢这个网站，因为它很简单。我以前不知道日语也有时态。 暂时再见! 现在已经半夜了。","link":"/zh-cn/Oct-2022/"},{"title":"面向对象","text":"面向对象的三个基本特征是：封装、继承、多态。 Class &amp; Instance class是对象模板，instance是对象实例 定义class（包含多个字段，field） 1234class Person { public String name; public int age;} 创建instance（指向instance的变量都是引用变量） 1Person ming = new Person(); 访问实例变量用变量.字段 一个Java源文件可以包含多个类的定义，但只能定义一个public类，且public类名必须与文件名一致。如果要定义多个public类，必须拆到多个Java源文件中 方法 动机：为了避免外部代码直接去访问field，我们可以用private修饰field，拒绝外部访问，然后使用method来让外部代码可以间接修改field 在方法内部，我们有机会检查参数对不对；而外部代码没有任何机会把字段设置成不合理的值 一个类通过定义方法，可以给外部代码暴露一些操作的接口，同时保证内部逻辑一致性 调用方法的语法是实例变量.方法名(参数); 定义方法 123456789// 修饰符 方法返回类型 方法名(方法参数列表) {// 若干方法语句;// return 方法返回值;// }// 如果没有返回值，返回类型设置为void，可以省略returnpublic String getName() { return this.name;} private方法：不允许外部调用，只有类的内部可以调用 this变量：在方法内部，可以使用一个隐含的变量this，它始终指向当前实例。通过this.field就可以访问当前实例的字段 如果没有命名冲突，可以省略this；如果局部变量和字段重名，就必须加上this 方法参数：0或任意个，用于接收传递给方法的变量值 可变参数：类型…，相当于数组类型 可变参数可以保证无法传入null 参数绑定 基本类型参数的传递，是调用方值的复制。双方各自的后续修改，互不影响 引用类型参数的传递，调用方的变量和接收方的参数变量指向的是同一个对象。双方任意一方对这个对象的修改，都会影响对方（因为指向同一个对象） 构造方法 123456789101112131415161718192021222324public class Main { public static void main(String[] args) { Person p = new Person(&quot;Xiao Ming&quot;, 15); }}class Person { private String name; private int age; // 构造方法 public Person(String name, int age) { this.name = name; this.age = age; } public String getName() { return this.name; } public int getAge() { return this.age; }} 实例在创建时通过new操作符会调用其对应的构造方法，构造方法用于初始化实例 创建实例实际上是通过构造方法来初始化实例的 构造方法的名称就是类名 构造方法的参数没有限制，在方法内部，也可以编写任意语句。但是，和普通方法相比，构造方法没有返回值（也没有void），调用构造方法，必须用new 没有定义构造方法时，编译器会自动创建一个默认的无参数构造方法 没有在构造方法中初始化字段时，引用类型的字段默认是null，数值类型的字段用默认值，int类型默认值是0 ，布尔类型默认值是false 多构造方法 可以定义多个构造方法，编译器根据参数自动判断 可以在一个构造方法内部调用另一个构造方法，便于代码复用 重载 123456789101112// String类提供了多个重载方法indexof()public class Main { public static void main(String[] args) { String s = &quot;Test string&quot;; int n1 = s.indexOf(&apos;t&apos;); int n2 = s.indexOf(&quot;st&quot;); int n3 = s.indexOf(&quot;st&quot;, 4); System.out.println(n1); System.out.println(n2); System.out.println(n3); }} 含义：方法重载是指多个方法的方法名相同，但各自的参数不同 作用：功能类似的方法使用同一名字，更容易记住，调用起来更简单 方法重载的返回值类型通常是相同的 继承 123456789101112131415161718class Person { private String name; private int age; public String getName() {...} public void setName(String name) {...} public int getAge() {...} public void setAge(int age) {...}}class Student extends Person { // 不要重复name和age字段/方法, // 只需要定义新增score字段/方法: private int score; public int getScore() { … } public void setScore(int score) { … }} 作用：复用代码 使用extends关键字来实现继承 继承树：没有明确写extends的类，编译器会自动加上extends Object 任何类，除了Object，都会继承自某个类 一个类有且仅有一个父类。只有Object特殊，它没有父类 子类无法访问父类的private，可以访问父类的protected 如果父类没有默认的构造方法，子类就必须显式调用super()并给出参数以便让编译器定位到父类的一个合适的构造方法 子类不会继承任何父类的构造方法。子类默认的构造方法是编译器自动生成的，不是继承的 阻止继承1234public sealed class Shape permits Rect, Circle, Triangle { ...}// 上述Shape类只允许指定的3个类(Rect, Circle, Triangle)继承它 从Java15开始，使用sealed修饰class，并通过permits明确写出能够从该class继承的子类名称 sealed目前是预览状态，要启用它，必须使用参数--enable-preview和--source 15 向上转型 Upcasting1Person p = new Student(); 把一个子类型安全地变为更加抽象的父类型 例如，继承树是Student &gt; Person &gt; Object，那么可以把Student类型转型为Person，或者更高层次的Object 向下转型 Downcasting12345Person p = new Student();if (p instanceof Student) { // 只有判断成功才会向下转型: Student s = (Student) p; // 一定会成功} 很可能会失败。为了避免出错，使用instanceof先判断一个实例究竟是不是某种类型 从Java 14开始，判断instanceof后，可以直接转型为指定变量，直接使用，避免再次强制转型 继承 &amp; 组合 继承是is关系，组合是has关系 多态 12345678910111213class Person { public void run() { … }}class Student extends Person { @Override public void run() { … }}class Teacher extends Person { @Override public void run() { … }} 含义：针对某个类型的方法调用，其真正执行的方法取决于运行时期实际类型的方法 作用：允许添加更多类型的子类实现功能扩展，却不需要修改基于父类的代码 覆写 Override 子类可以覆写父类的方法，覆写在子类中改变了父类方法的行为 加上@Override可以让编译器帮助检查是否进行了正确的覆写 在子类的覆写方法中，如果要调用父类的被覆写的方法，可以通过super来调用 final final修饰的方法可以阻止被覆写 final修饰的class可以阻止被继承 final修饰的field必须在创建对象时初始化，随后不可修改 抽象类 123abstract class Person { public abstract void run();} 动机：如果父类的方法本身不需要实现任何功能，仅仅是为了定义方法签名，目的是让子类去覆写它，那么可以把父类的方法声明为抽象方法，本身没有实现任何方法语句 含义：如果一个class定义了方法，但没有具体执行代码，这个方法就是抽象方法，抽象方法用abstract修饰；因为无法执行抽象方法，所以这个类也必须申明为抽象类（abstract class） 抽象类无法实例化 作用：抽象类可以强迫子类实现其定义的抽象方法，否则编译会报错。相当于定义了“规范” 面向抽象编程 上层代码只定义规范 不需要子类就可以实现业务逻辑（正常编译） 具体的业务逻辑由不同的子类实现，调用者并不关心 接口 1234interface Person { void run(); String getName();} 动机：如果一个抽象类没有字段，所有方法全部都是抽象方法，就可以把该抽象类改写为接口 接口是比抽象类还要抽象的纯抽象接口，因为它连字段都不能有 使用interface声明一个接口 当一个具体的class去实现一个interface时，需要使用implements关键字；一个类可以实现多个interface 接口也是数据类型，适用于向上转型和向下转型 接口继承12345678interface Hello { void hello();}interface Person extends Hello { void run(); String getName();} 使用extends 继承关系 公共逻辑适合放在abstract class中，具体逻辑放到各个子类，而接口层次代表抽象程度 实例化的对象永远只能是某个具体的子类，但总是通过接口去引用它，因为接口比抽象类更抽象 default方法 接口可以定义default方法 动机：当我们需要给接口新增一个方法时，会涉及到修改全部子类。如果新增的是default方法，那么子类就不必全部修改，只需要在需要覆写的地方去覆写新增方法 default方法和抽象类的普通方法的区别：因为interface没有字段，所以default方法无法访问字段，而抽象类的普通方法可以访问实例字段 静态字段 &amp; 静态方法 静态字段 用static修饰的字段称为静态字段 实例字段&amp;静态字段 实例字段在每个实例中都有自己的一个独立“空间”，各个实例的同名字段互不影响 静态字段只有一个共享“空间”，所有实例都会共享该字段 不推荐用实例变量.静态字段去访问静态字段，推荐用类名来访问静态字段 可以把静态字段理解为描述class本身的字段（非实例字段） 静态方法 用static修饰的方法称为静态方法 实例方法&amp;静态方法 调用实例方法必须通过一个实例变量 调用静态方法则不需要实例变量，通过类名就可以调用。静态方法类似其它编程语言的函数 调用静态方法不需要实例，无法访问this，但可以访问静态字段和其他静态方法 静态方法常用于工具类（如Arrays.sort()，Math.random() ）和辅助方法（如Java程序的入口main() 就是静态方法） 接口的静态字段 interface可以有静态字段，并且静态字段必须为final类型 因为interface的字段只能是public static final类型，所以可以去掉这些修饰符，简写 包 1234package ming; // 申明包名mingpublic class Person {} 在定义class的时候，需要在第一行声明这个class属于哪个包 一个类总是属于某个包（package），类名（比如Person）只是一个简写，真正的完整类名是包名.类名 只要包名不同，类就不同 包可以是多层结构，用.隔开 包没有继承关系 没有定义包名的class使用的是默认包，非常容易引起名字冲突，不推荐不写包名的做法 包作用域123456789101112131415package hello;public class Person { // 包作用域: void hello() { System.out.println(&quot;Hello!&quot;); }}public class Main { public static void main(String[] args) { Person p = new Person(); p.hello(); // 可以调用，因为Main和Person在同一个包 }} 位于同一个包的类，可以访问包作用域的字段和方法 不用public、protected、private修饰的字段和方法就是包作用域 import1234567891011// Person.javapackage ming;// 导入完整类名:import mr.jun.Arrays;public class Person { public void run() { Arrays arrays = new Arrays(); }} JDK的核心类使用java.lang包，编译器会自动导入 JDK的其它常用类定义在java.util.*，java.math.*，java.text.*，…… 作用域 public 定义为public的class、interface可以被其他任何类访问 定义为public的field、method可以被其他类访问，前提是首先有访问class的权限 如果不确定是否需要public，就不声明为public，即尽可能少地暴露对外的字段和方法 一个.java文件只能包含一个public类，但可以包含多个非public类。如果有public类，文件名必须和public类的名字相同 private 定义为private的field、method无法被其他类访问 private访问权限被限定在class的内部，而且与方法声明顺序无关。推荐把private方法放到后面 嵌套类（nested class）拥有访问private的权限 protected 作用于继承关系。定义为protected的字段和方法可以被子类访问，以及子类的子类 pakage 包作用域是指一个类允许访问同一个package的没有public、private修饰的class，以及没有public、protected、private修饰的字段和方法 把方法定义为package权限有助于测试 局部变量 在方法内部定义的变量称为局部变量 局部变量作用域从变量声明处开始到对应的块结束 方法参数也是局部变量 应该尽可能把局部变量的作用域缩小，尽可能延后声明局部变量 final 可以阻止被继承、阻止被子类覆写、阻止被重新赋值 内部类 Nested Class Inner Class123456789101112131415public class Main { public static void main(String[] args) { Outer outer = new Outer(&quot;Nested&quot;); // 实例化一个Outer Outer.Inner inner = outer.new Inner(); // 实例化一个Inner inner.hello(); }}class Outer { ... class Inner { // 定义了一个Inner Class ... }} Inner Class的实例不能单独存在，必须依附于一个Outer Class的实例 要实例化一个Inner，必须首先创建一个Outer的实例，然后，调用Outer实例的new来创建Inner实例 Inner Class可以修改Outer Class的private字段 Outer类被编译为Outer.class，而Inner类被编译为Outer$Inner.class Anonymous Class123Runnable r = new Runnable() { // 实现必要的抽象方法...}; 另一种定义Inner Class的方法。它不需要在Outer Class中明确地定义这个Class 动机：因为在这里我们不关心类名，比直接定义Inner Class可以少写很多代码 匿名类也可以访问Outer Class的private字段和方法 匿名类被编译为Outer$1.class、Outer$2.class、Outer$3.class … 除了接口外，匿名类也可以继承自普通类 Inner Class和Anonymous Class本质上是相同的，都必须依附于Outer Class的实例，即隐含地持有Outer.this实例，并拥有Outer Class的private访问权限 Static Nested Class 不再依附于Outer的实例，而是一个完全独立的类，因此无法引用Outer.this，但可以访问Outer的private静态字段和静态方法 Static Nested Class是独立类，但拥有Outer Class的private访问权限 classpath和jar JVM通过环境变量classpath决定搜索class的路径和顺序 不推荐设置系统环境变量classpath，始终建议通过-cp命令传入 jar包相当于目录，可以包含很多.class文件，方便下载和使用 class版本 高版本的JDK可编译输出低版本兼容的class文件，反之可能报错 运行时使用哪个JDK版本，编译时就尽量使用同一版本编译源码 模块 .class文件是JVM看到的最小可执行文件，而一个大型程序需要编写很多Class，并生成一堆.class文件。jar文件就是class文件的容器，为了方便管理。它并不关心class之间的依赖 从Java 9开始引入了模块（Module），自带“依赖关系”的class容器就是模块，模块以.jmod扩展名标识 只有java.base模块不依赖任何模块，是“根模块” 把一堆class封装为jar仅仅是一个打包的过程，而把一堆class封装为模块则不但需要打包，还需要写入依赖关系，并且可以包含二进制代码（通常是JNI扩展）、支持多版本 模块的作用：声明并管理依赖关系；进一步隔离代码的访问权限 附录 教程 廖雪峰的Java教程-面向对象基础","link":"/zh-cn/Object-oriented/"},{"title":"进程","text":"进程就是正在运行的程序。 当你启动一个程序，操作系统会先从硬盘中读取程序文件，然后将程序内容加载入内存中，最后 CPU 执行程序。这就是进程。 进程的基本概念 查看进程htop ps (process status) ps 仅显示本终端中运行的相关进程。 ps aux 显示所有进程。 进程标识符 PID (process identifier)PID是一个数字，是进程的唯一标识。 挂起、继续或终止进程时可以使用 PID 作为索引。 进程优先级NI (nice) 取值范围-20～19，通常当前运行的程序NI值为0。NI越高，优先级越低。 指定优先级： 12$ nice -n 10 vim # 以 10 为 nice 值运行 vim$ renice -n 10 -p 12345 # 设置 PID 为 12345 的进程的 nice 值为 10 调低 nice 值需要?sudo。 PRI (priority) 通常PRI = nice + 20。若PRI值是 RT，或者是负数，表明对应的进程有更高的实时性要求（例如内核进程、音频相关进程等）。 进程状态粗略分： 运行态（running） 就绪态（ready） 阻塞态（blocked） 详细分： 状态 缩写表示 说明 Running R 正在运行/可以立刻运行 Sleeping S 可以被中断的睡眠 Disk Sleep D 不可被中断的睡眠 Traced / Stopped T 被跟踪/被挂起的进程 Zombie Z 僵尸进程 进程控制 信号信号是 Unix 系列系统中进程之间相互通信的一种机制。 发送信号的 Linux 命令叫作?kill。 使用?man 7 signal?查看信号列表。 前后台切换默认在 shell 中运行的命令都在前台运行。如果需要在后台运行，需要在命令最后加上?&amp;。 如果需要将前台程序切换到后台，则需要按下 Ctrl + Z 发送 SIGTSTP 使进程挂起，控制权还给 shell。 1$ bg %2 # 将2号进程放入后台 终止进程标准的终止进程信号是 SIGTERM，意味着一个进程的自然死亡。 在 htop 中发送信号 按 K 键，在左侧提示栏中选择需要的信号，按回车发送。 kill 12$ kill -l # 显示所有信号名称$ kill -9 PID # 9代表SIGKILL，立即结束进程PID 若不加任何参数，只有 PID，kill 将自动使用 15 (SIGTERM) 作为信号参数。 类kill命令 1$ apropos kill # 显示各种其他的类kill命令 脱离终端nohup 终端一旦被关闭，会向其中每个进程发送 SIGHUP (Signal hangup)，而 SIGHUP 的默认动作是退出程序运行。在需要屏蔽 SIGHUP 的程序前添加 nohup，则运行时的输出将被重定向到 nohup.out（也可以自定义）。 tmuxtmux 是一个分屏的、运行在命令行的模拟终端。它可以将多个交互进程集成在在一个窗口上，并且不因断开连接或者暂时登出而消失，而是保存在后台，下一次登录时可以立即还原。 tmux 分为三部分： 会话 (session)：用于区分不同的工作； 窗口 (window)：会话中以显示屏为单位的不同的页； 面板 (pane)：窗口上被白线分割的不同区域。 安装和打开tmux： 12$ sudo apt install tmux$ tmux 快捷键（先 Ctrl + B） 功能 % 左右分屏 “ 上下分屏 ↑ ↓ ← → 焦点切换为上、下、左、右侧 pane，正在交互的 pane 被绿色框选中。 d (detach) 从 tmux 中脱离，回到命令行界面 z (zoom) 将 pane 暂时全屏，再按一次恢复原状 c 新建窗口 , 为窗口命名 s 列出所有 session 如果掉线，再次登录时使用?tmux attach [-t 窗口名称] 重新连接窗口，不加?-t 则默认连接最后一次打开的窗口。 定制tmux 服务 守护进程只有启动时脱离会话才能避免因为终端的关闭而消失。这类一直默默工作于后台的进程被称为守护进程?(daemon)。 服务管理绝大多数 Linux 发行版的 init 方案是 systemd，其管理系统服务的命令是?systemctl 。 使用 systemctl status?命令查看系统中正在运行的服务的情况。使用 systemctl list-units 查看所有 systemd 管理的服务的情况。 使用 tldr 查看服务的启动、终止、重载配置等命令。 自定义服务编写 .service 配置文件并运行。 例行性任务指实现周期性的定时任务。在 Linux 中主要有 at 和 crontab 。 at at负责单次计划任务。 安装： 1$ sudo apt install at 使用 tldr 查看使用方法。 crontab crontab负责周期性的任务。 与 at 不同的是，crontab 大多通过配置文件实现。 查看 crontab 的用法： 1$ crontab --help 配置格式：每一行前半段为时间，后半段为 shell 执行命令。 123456# 分 时 日 月 星期 | 命令# 示例* * * * * echo &quot;hello&quot; &gt;&gt; ~/count# 每分钟输出 hello 到家目录下 count 文件0,15,30,45 0-6 * JAN SUN command# 每年一月份的每个星期日半夜 0 点到早晨 6 点每 15 分钟随便做点什么 crontab.guru网站可以将配置文件中的时间字段翻译为通俗易懂的表示。 附录 参考教程 Linux 101 - chap 04: 进程、前后台、服务与例行性任务 推荐阅读 进程和线程 - 廖雪峰的官方网站 进程、线程基础知识 - 小林coding 进程的概念 &amp; 组成 &amp; 特征","link":"/zh-cn/Process/"},{"title":"2023年9月","text":"最近明显感觉到变忙了。所以这就是研二吗？ 不用再上课，但是参与的项目增加到了三个：STCF读出电子学，White rabbit设备，以及水透镜的触发电子学——我的毕业课题。 最近主要在做WR项目的工作。这个项目预计今年年底结束。只有我们两个人干活，又都是初学者，所以还是蛮紧张困难的。首先了解WR的原理就非常费劲（至今没有完全理解），其次虽然实验室有以前师兄师姐做过相似的课题，但是参考归参考，亲自使用和设计还是有很大难度。一开始的计划是另一个同学画多节点模块的原理图和PCB，我写FPGA代码。然而直到他画完了，我还处于努力理解WRPC使用手册的阶段……现在他接手FPGA代码部分，我在他的基础上修改设计，正在画第二块板，即普通节点模块。 STCF的前端放大板下周由师兄带去兰州的近代物理所，和探测器联合测试。 水透镜的触发电子学是我刚刚确定下来的毕业设计题目。目前对它几乎一无所知！","link":"/zh-cn/Sep-2023/"},{"title":"命令行","text":"黑客帝国特效好酷。 什么是命令行（shell） 命令行是 Linux 中的一类程序，它接受通过键盘输入的命令，然后把命令交给系统执行，并将命令的输出返回给用户几乎所有的 Linux 发行版都提供了一个叫 Bash 的 shell 程序，是传统 shell 的“增强版” 注意： Windows 系统中路径以反斜杠 \\分隔；类 UNIX 系统中路径以正斜杠 /分隔；类 UNIX 系统也不采用 Windows 下的盘符机制，而是采用统一的根目录 绝对路径 &amp; 相对路径： 123/bin/ls # 绝对路径./file.txt # 相对路径，当前目录下的 file.txt 文件../file.txt # 相对路径，上一级目录（父目录）下的 file.txt 文件 $ 和 # 命令开头的 $代表此命令使用普通用户权限运行 #代表执行命令需要使用 root 权限（最高权限），一般等价于 $ sudo 该命令 命令末尾的 #代表此符号与其后的内容都是注释 123456$ 某条命令命令的输出# 需要使用 root 权限执行的命令$ # 注释 为什么要用命令行 效率 熟悉了命令行之后再加上有自动补全的 shell 程序，使用命令行可以节省大量时间 1$ mv ../source/file.txt ../dest/ # 将file.txt 从 ../source/ 文件夹拖拽到 ../dest/ 文件夹中 自动化脚本 自动执行重复的任务 节省资源 绝大部分服务器为了节省资源都不使用图形界面 高级的系统维护工作 一些高级的系统没有图形界面，维护任务只能通过命令行完成；或者需要手工编写复杂的配置文件 看上去很酷！ 《黑客帝国》特效： 打开终端模拟器 安装cmatrix 1$ sudo apt install cmatrix 使用 cmatrix命令查看特效效果 按下 q键或者 Ctrl + C 组合键退出 简单的 shell 命令 ls: 列出（list）目录的内容 cd: 更改目录（change directory） pwd: 查看当前所在的目录（print working directory） 附录 教程 Linux 101 - 第二章：个性化配置与建站体验","link":"/zh-cn/Shell/"},{"title":"用户、文件","text":"这是一篇对Linux中的“用户”和“文件”的简介。 服务器的管理员可以为不同的使用者创建用户，分配不同的权限，保障系统的正常运行；也可以为网络服务创建用户，通过权限限制来减小服务被攻击时对系统安全的破坏。 现代操作系统一般区分使用者的“用户”与“系统用户”，并划分权限，以保证系统的完整性不会因为用户的误操作或恶意程序而遭到破坏。 Linux 中的用户 在 /etc/passwd 里可以看到各种用户信息。 根用户根用户 /root 用户在 Linux 操作系统中拥有最高的权限，可以对系统做任何操作（包括删除所有系统文件这种极端危险的操作）。root 用户的数据存储在 /root 下。 谨慎使用 root 权限执行命令（如 sudo ），不要执行以下命令： rm -rf / mkfs.ext4 /dev/sda dd if=/dev/urandom of=/dev/sda :(){ :|: &amp; };: 系统用户系统用户由系统或相关程序创建，用于执行服务等系统任务，如 nobody , www-data 等。不要随意删除这些用户。 普通用户普通用户位于 /home/username/ ，username 是用户名。普通用户可以登录系统，对自己的家目录下的文件进行操作；不可以直接修改系统配置，也不可以为系统环境安装或卸载软件。 切换用户 sudosudo 用于以另一个用户的身份执行指定的命令。 123$ sudo + 命令 # 以 root 用户执行命令$ sudo !! # 以 root 用户执行上一条命令$ sudo -u 用户名 命令 # 以 root 之外的其它用户执行命令 susu 用于直接切换用户。 注意，如 Ubuntu 等 Linux 发行版默认禁止了 root 用户的密码登录，所以不能直接使用su ，要通过 sudo 提高权限。 12$ sudo su # 切换到 root $ su 用户名 # 切换到其它用户 用户组 用户组是用户的集合。用户组可以为一批用户设置权限。 用户组也有编号GID (Group ID)。 12345678$ group # 查看自己所属的用户组$ passwd username # 修改用户username的密码$ passwd # 修改自己的密码$ sudo adduser username # 添加用户username$ sudo adduser --group groupname # 添加用户组groupname$ sudo adduser username groupname # 将用户username添加到用户组groupname中 文件权限 1234$ ls -l # 查看当前目录中文件的详细信息## eg. -rwxrw-r-- 1 ustc ustc 40 Feb 3 22:37 a_file## a_file 为普通文件(-)；所属用户权限为rwx，所属用户组权限为rw-，其他人的权限为r--；文件所属用户和用户组均为ustc## r代表读取Read，w代表写入Write，x代表执行Execute，-代表没有对应的权限 执行权限对于文件来说，执行权限意味着它可以被操作系统作为程序代码执行。如果某个程序文件没有执行权限，你仍然可以查看这个程序文件本身，修改它的内容，但是无法执行它。 对于目录来说，执行权限意味着你可以访问这个目录下的文件的内容。可以把目录视为一个“文件”，它包含了目录中下一层的文件列表，“读取”对应读取文件列表的权限，“写入”对应修改文件列表（添加、删除、重命名文件）的权限，“执行”对应实际去访问列表中文件、以及使用 cd 切换当前目录到此目录的权限。 1234$ chmod # change file mode bits 修改权限$ chmod +x program # 给文件program添加执行权限(x)$ chown # change file owner 修改文件所有者 文件系统层次结构 UNIX 系列整个系统的文件都从 /（根目录）开始，像一棵树一样；其它分区以挂载 (mount) 的形式”挂“在这棵树上。 文件系统层次结构标准 (FHS, Filesystem Hierarchy Standard) 定义了 Linux 发行版的标准目录结构，可以查看Filesystem Hierarchy Standard。也可以使用 man hier 和 man file-hierarchy 查看系统中关于文件系统层次结构的文档。 附录 Linux 101 - chap 05: 用户与用户组、文件权限、文件系统层次结构","link":"/zh-cn/Users-Files/"},{"title":"双指针","text":"这个十月，我强迫自己每天做一道LeetCode。虽然中间有几天中断了，但最后还是完成了我的第一个“探索”单元。 对我来说，最有用的一课是一种叫做双指针的神奇技巧。起初我以为它是嵌套的两个for循环，但后来我发现它实际上更有意义，更有用。所以我想把它记录下来。 含义 同时使用两个指针来做迭代。 应用 当你想从两端向中间迭代数组时，你可以使用一个指针从头开始，而另一个指针从尾开始。它们有相同的步长。 123456789101112131415// Reverse Stringclass Solution { public void reverseString(char[] s) { int i = 0; int j = s.length - 1; while (i &lt; j) { char temp = s[i]; s[i] = s[j]; s[j] = temp; i++; j--; } }} 12345678910111213141516171819202122// Two Sum II - Input array is sorted// 给出一个已经按非递减顺序排序的索引到1的整数数组，找出两个数字，使其相加等于一个特定的目标数class Solution { public int[] twoSum(int[] numbers, int target) { int[] res = new int[2]; int start = 0; int end = numbers.length - 1; while (start &lt; end) { if (numbers[start] + numbers[end] == target) { break; } else if (numbers[start] + numbers[end] &lt; target) { start ++; } else { end --; } } res[0] = start + 1; res[1] = end + 1; return res; }} 当你想要一个慢速指针和一个快速指针时，你可以使用一个指针用于迭代，而另一个指针用于标记特殊位置。它们有不同的步长。 123456789101112131415// Remove Element// &quot;i&quot;用于迭代，&quot;k&quot;用于指示要移动的元素class Solution { public int removeElement(int[] nums, int val) { int k = 0; for (int i = 0; i &lt; nums.length; i++) { if (nums[i] != val) { nums[k] = nums[i]; k++; } } return k; }} 这里还介绍了一个重要的概念：原地算法。 原地算法（in-place algorithm，也称“就地算法”）是基本上不需要借助额外的数据结构就能对输入的数据进行变换的算法。不过，分配少量空间给部分辅助变量是被允许的。算法执行过程中，输入的数据往往会被输出结果覆盖。原地算法只能通过替换或交换元素的方式来修改原始的输入。1 123456789101112131415161718// Max Consecutive Ones// &quot;i&quot;用于迭代，&quot;max&quot;用于找最大数class Solution { public int findMaxConsecutiveOnes(int[] nums) { int max = 0; int sum = 0; for (int i = 0; i &lt; nums.length; i++) { sum += nums[i]; if (nums[i] == 0) { sum = 0; } else { max = Math.max(sum, max); } } return max; }} 123456789101112131415// Remove Duplicates from Sorted Array// &quot;i&quot;用于迭代，&quot;j&quot;用于寻找特殊元素class Solution { public int removeDuplicates(int[] nums) { int n = nums.length; int j = 0; for (int i = 1; i &lt; n; i++) { if (nums[j] != nums[i]) { j++; nums[j] = nums[i]; } } return j + 1; }} 1234567891011121314151617181920// Move Zeroes// &quot;i&quot;用于迭代，&quot;k&quot;用于指示非零元素class Solution { public void moveZeroes(int[] nums) { int n = nums.length; int k = 0; for (int i = 0; i &lt; n; i++) { k = i; if (nums[i] == 0) { if (k &lt; n-1) { while (nums[k] == 0 &amp;&amp; k &lt; n-1) {k++; } int temp = nums[i]; nums[i] = nums[k]; nums[k] = temp; } } } }} 我现在的进展：恭喜自己，再接再厉！  附录 题库 LeetCode Explore：Array and String 引用 [1] 维基百科：原地算法","link":"/zh-cn/Two-pointer/"}],"tags":[{"name":"MATLAB","slug":"MATLAB","link":"/zh-cn/tags/MATLAB/"},{"name":"Git","slug":"Git","link":"/zh-cn/tags/Git/"},{"name":"Linux","slug":"Linux","link":"/zh-cn/tags/Linux/"},{"name":"GitHub","slug":"GitHub","link":"/zh-cn/tags/GitHub/"},{"name":"Java","slug":"Java","link":"/zh-cn/tags/Java/"},{"name":"LaTeX","slug":"LaTeX","link":"/zh-cn/tags/LaTeX/"},{"name":"LeetCode","slug":"LeetCode","link":"/zh-cn/tags/LeetCode/"},{"name":"数字信号处理","slug":"数字信号处理","link":"/zh-cn/tags/%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/"},{"name":"物理电子学","slug":"物理电子学","link":"/zh-cn/tags/%E7%89%A9%E7%90%86%E7%94%B5%E5%AD%90%E5%AD%A6/"},{"name":"读出电子学","slug":"读出电子学","link":"/zh-cn/tags/%E8%AF%BB%E5%87%BA%E7%94%B5%E5%AD%90%E5%AD%A6/"},{"name":"机器学习","slug":"机器学习","link":"/zh-cn/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"name":"Cadence PCB设计","slug":"Cadence-PCB设计","link":"/zh-cn/tags/Cadence-PCB%E8%AE%BE%E8%AE%A1/"},{"name":"STCF项目","slug":"STCF项目","link":"/zh-cn/tags/STCF%E9%A1%B9%E7%9B%AE/"},{"name":"Cadence原理图设计","slug":"Cadence原理图设计","link":"/zh-cn/tags/Cadence%E5%8E%9F%E7%90%86%E5%9B%BE%E8%AE%BE%E8%AE%A1/"},{"name":"模拟电子技术","slug":"模拟电子技术","link":"/zh-cn/tags/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/"},{"name":"网页设计","slug":"网页设计","link":"/zh-cn/tags/%E7%BD%91%E9%A1%B5%E8%AE%BE%E8%AE%A1/"},{"name":"数据结构与算法","slug":"数据结构与算法","link":"/zh-cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"categories":[{"name":"学习","slug":"学习","link":"/zh-cn/categories/%E5%AD%A6%E4%B9%A0/"},{"name":"总结","slug":"总结","link":"/zh-cn/categories/%E6%80%BB%E7%BB%93/"},{"name":"实验室工作","slug":"实验室工作","link":"/zh-cn/categories/%E5%AE%9E%E9%AA%8C%E5%AE%A4%E5%B7%A5%E4%BD%9C/"},{"name":"计算机科学","slug":"学习/计算机科学","link":"/zh-cn/categories/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/"},{"name":"电子学","slug":"学习/电子学","link":"/zh-cn/categories/%E5%AD%A6%E4%B9%A0/%E7%94%B5%E5%AD%90%E5%AD%A6/"},{"name":"工作","slug":"工作","link":"/zh-cn/categories/%E5%B7%A5%E4%BD%9C/"},{"name":"AI","slug":"学习/AI","link":"/zh-cn/categories/%E5%AD%A6%E4%B9%A0/AI/"},{"name":"月度总结","slug":"总结/月度总结","link":"/zh-cn/categories/%E6%80%BB%E7%BB%93/%E6%9C%88%E5%BA%A6%E6%80%BB%E7%BB%93/"}]}