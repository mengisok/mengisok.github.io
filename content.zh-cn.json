{"pages":[{"title":"关于","text":"你好，我是韩萌。 我正在攻读硕士学位，专业是电子信息工程。我对自学更感兴趣，感谢互联网——我正在学习与计算机科学有关的、从硬件到软件的一切。我也喜欢艺术电影和各种帮助我思考的书籍。 这是一个广阔而不可预知的世界，很多事物都令我惊奇……我想知道，世界为何真实？在触碰自己的未知区域时，声称崇拜自由、拥抱革命的我，思维又在怎样变化？ 因此，我在博客里记录学习和感悟，也将自我徐徐展开。我觉得博客好像面前的一条数字河流，既可以顺流而行，也可以回溯途径之地。 现在还只是一条小溪。但是，希望它长久流淌。 你可以在GitHub, 领英上找到我，或者给我发邮件。","link":"/zh-cn/about/index.html"},{"title":"分类","text":"","link":"/zh-cn/categories/index.html"},{"title":"标签","text":"","link":"/zh-cn/tags/index.html"},{"title":"链接","text":"CS FreeCodeCamp程序员角色成长指南：Developer Roadmaps编程竞赛 OI Wiki夺旗赛 CTF WikiVerilog 学习网站：HDLbitLinux 101 数学 以可视化的方式学习统计：Statistics Visualization Learning Site 实用 GitHub 实时趋势和统计数据：OSS Insight欧洲暑期学校 语言 出口日語 电子书 Anna’s ArchiveLibrary GenesisZlibraryzhelper search","link":"/zh-cn/links/index.html"}],"posts":[{"title":"自适应滤波器","text":"看了一个条理清晰、简明扼要的关于自适应滤波器的YouTube视频，这也是我这学期上的一门基础课“数字信号处理Ⅱ”的重点内容。 固定系数数字滤波器的局限性 固定系数的数字滤波器 FIR, IIR LP、HP等 局限 噪声频率随时间变化而变化 信号和噪声的重叠带 自适应滤波器 2个主要组成部分 数字滤波器（有可调整的系数） 自适应算法 2个输入信号：$y_k$和$x_k$ $y_k = s_k + n_k$ $s_k$ = 预期信号 $n_k$ = 噪声 $x_k$ = 污染信号，与$n_k$**相关，提供$n_k$的估计值，即$hat{n_k}$ 目标：产生**最佳的$hat{n_k}$ $e_k = hat{s_k} = y_k - hat{n_k} = s_k + n_k - hat{n_k}$ 该定理最小化$e_k$，最大化信噪比 LMS 算法 维纳滤波器 输入信号 w(n) 与维纳滤波器 g(n) 进行卷积，并将结果与参考信号 s(n) 进行比较，得到滤波误差 e(n) 判断标准：MMSE (最小均方误差) 最小化 $J = E[e(n)^2] = E[(x(n) - s(n))^2] = E[(w(n) * g(n) - s(n))^2]$ J可用于绘制误差-性能表面 LMS 滤波器收敛于维纳滤波器 维纳-霍普夫解令H的J梯度为零，推导出$H_{opt} = R_{xx}^{-1} R_{xs}$ 其中$R_{xx} = E(X_k X_k^T)$$R_{xs} = E(y_k X_k)$ 需要知道$R_{xx}, R_{xs}$ 矩阵求逆很复杂 对于非稳态，$H_{opt}$ 需要反复计算 LMS 自适应算法版本1：$H(n+1) = H(n) + \\mu (- \\nabla(n))$版本2：$H(n+1) = H(n) + \\frac{1}{2}\\delta (- \\nabla(n))$ 那么$H(n+1) = H(n) + 2\\mu e(n)X(n)$或 $H(n+1) = H(n) + \\delta e(n) X(n)$ 其中$e(n) = y(n) - H^T(n)X(n)$$\\mu$和$\\delta$是步长 基于最陡梯度下降算法（沿梯度的反方向更新H(n)） $H(n+1) = H(n) + \\mu (- \\nabla(n))$ 使用瞬时估计，代替平均值（无偏） $J = E[e(n)^2] = e(n)^2$ $nabla(n) = -2\\mu E[e(n)X(n)] = -2\\mu e(n)X(n) $ 步长决定了稳定性和收敛率 如果步长太大，波动太大 如果步长太小，收敛速度太慢 局限性 如果噪声是非稳态的，误差表现面将迅速变化 如果$x(n)$与$y(n)$成正比，信号将被抹杀 H(n)从未达到理论上的最佳状态（有波动） 应用 声学回声消除 从受污染的脑电图EEG中消除眼电，获得正确的脑电图 在分娩过程中消除母体心电图从而获得胎儿心电图 附录 YouTube视频 Adaptive Filters 课程主页 数字信号处理 II","link":"/zh-cn/Adaptive-Filters/"},{"title":"用OrCAD Capture CIS画原理图","text":"开始给一个项目画PCB了。首先学习使用OrCAD Capture CIS画原理图。下面是一些基本的概念和操作。 工程 新建工程 修改原理图偏好 修改原理图说明 元件库 新建元件库 修改元件库存储位置 元件 在元件库中新建元件 放置元件 修改元件属性 修改Footprint 查看整个元件 批量修改管脚属性 Snap to grid 复合封装元件 Homogeneous 组成元件的各模块是相同功能的 各模块以“？”后的A、B等来区分 画完“ U?A”后切换到下一部分“ U?B”，已自动画好，只剩管脚号留空了 切换到上一部分的快捷键为“Ctrl+B”，切换到下一部分的快捷键为“Ctrl+N” 对于一个元件，若只用一张图表示出来，那么元件不能有两个管脚的管脚号和管脚名都相同。但如果将元件分成很多部分来画，那么各个部分之间的管脚的管脚号和管脚名可以相同，且管脚号和管脚名都相同的管脚是相连的 Heterogenous 组成元件的各模块是不同功能的 画完“ U?A”后切换到下一部分“ U?B”，为空白 如果在一个原理图中放置了两个及以上的复合封装元件，为防止使用“Annotate”进行索引编号时报错，应给元件添加一个新属性（名字不能是”group“），各部分就会根据新属性的值是否相同分为不同的组，这样就可以判断哪些部分是在同一个芯片中 在原理图中添加元件 旋转元件 不在库中的元件： 电源，地 Cadence自带元件库 Cadence - SPB_16.6 - tools - capture - library 一般常用的电容、电阻、电感、变压器等在Discrete.olb Design Cache 引脚的连接 3种连接：wire，net alias，总线 wire 快捷键W 原理图中的线默认横平竖直，如果要画任意角度，按Shift键同时点击线的起点和终点 两根线相交时，若交点为一根线的端点，则表示两根线是有电气连接的，且电气连接不可取消；若交点不是端点，则默认无电气连接 给交点添加电气连接 Place junction 同一个页面内的互连 Place net alias 页面之间的互连 Place off-page connector 悬空引脚 Place no connect 不要将两元件的管脚直接相连（可以将两个元件管脚直接连上后，再拉开，两管脚之间就会出现一条连线） 总线连接 总线命名 BaseName[0:all] BaseName和[之间不能有空格 32位总线ED，为ED[0:31] BaseName不能以数字作为结尾 方括号内的冒号“:”可以换成减号“-”或两点“..” 总线入口命名 BaseName0 BaseName1 BaseName2 … 总线和信号线的连接必须要借助总线入口，通过net alias方式，命名保持一致 快捷键F4快速布线 浏览、搜索 浏览元件 重新编号所有元件 Tools - Annotate - Packaging - Action: Reset part references to “?”, Incremental reference update 浏览Nets 浏览Off-Page Connector 浏览DRC Markers 若有错误且被修正了，需将DRC Markers同步更新 也可以选中单个原理图进行浏览 搜索 元件的替换和更新 二者区别 替换可以改变原理图和元件库的连接关系，即用别的元件库的元件替换原元件库的元件，而更新不能 如果新元件的封装形式与原元件不同，例如原元件的封装形式为“ Homogeneous”，而新元件的封装形式为“Heterogeneous”，那么要让新元件的封装形式替换原元件的封装形式，只能使用替换，并且“Action”必须选择“Replace schematic part properties”： Cleanup Cache 清除已经不存在的元件副本 操作原理图中的对象 同时选中多个对象 移动对象 直接拖动，该对象与其它对象的连接关系保持不变 按住Alt拖动，该对象与其它对象的连接关系会断开 断开后，能否再次通过接触而连接 Options - Preferences - Miscellaneous - Wire Drag: Allow component move with connectivity changes 旋转对象 R 复制、粘贴、删除 选中对象，按住Ctrl键拖动，拖出来对象即为复制出来的对象 镜像翻转对象 H V 添加footprint属性 在原理图中修改单个元件封装信息 在元件库中修改单个元件封装信息，更新到原理图 - 打开某元件的编辑页面 - Options - Package Properties - PCB Footprint - OK，最后Replace（不要Update） 批量修改元件封装信息 批量修改修改一个原理图页面中的所有元件的封装信息 检查元件封装信息是否遗漏 生成网表netlist 生成前检查原理图的逻辑功能、电气连接，对整个工程重新索引编号，DRC检查 后处理 生成元件清单 打印原理图","link":"/zh-cn/Drawing-Schematics-in-OrCAD-Capture-CIS/"},{"title":"2022年12月","text":"这个月本来是考试月，所以我主要花时间复习了学校的三门主要课程：数字信号处理、数字图像分析和组合数学。 结果考试突然推迟到下学期初，导致我没复习完。 我做了一些笔记（都是中文），还收藏了一些有意思的链接。 复习笔记 Notion或GitHub上的DSP笔记 (有一些MATLAB代码) Google Drive上的DIA笔记 (更新中…) Google Drive上的组合数学笔记 (更新中…) 另一件值得一提的事是，这个月ChatGPT很火！ 我也试用了一下，确实很神奇。以下是我看到的一些关于ChatGPT的有趣或有用的链接。 ChatGPT 官方介绍 awesome-chatgptThere are many trending repos related to ChatGPT recently. 中国大陆可用的ChatGPT 中国区注册OpenAI账号试用ChatGPT指南 在线接受短信的虚拟号码 ChatGPT初体验 ChatGPT中文版VSCode插件 在Jupyter Notebook中手绘草图并变成代码 其它有趣的链接 Telegram指南 fernwanderweg.blogspot.com他用谷歌博客建立了一个博客。看起来不错。 最后三个是GitHub上拥有大量星星的几个顶级仓库。我发现996.icu竟然排在第三  语言很遗憾，我没有参加雅思考试。还没准备好… 我会去考的!至于学习日语，我不再用多邻国了，因为它有些简单。我找了一些YouTube视频来看，比如出口日語。 博客我把博客主题从Cactus换到了Ascent。Btw，这是我的关于博客主题的收藏夹 。我试图把一个主题改成我想要的样子，但失败了。前端好难！","link":"/zh-cn/Dec-2022/"},{"title":"2023年2月","text":"开学啦。 赶在考试前整理完了笔记，依然连滚带爬地出了考场。目前只出了DSP一门成绩，78，剩下两门感觉考得更烂不知道还会烂到哪里…… 本月发现 類 流浪豆瓣被豆瓣无端挖坟删帖+禁言一周后，怒搜了一番替代APP。下面是几种方案： 标记书影音：NeoDB 使用方法见这个帖子 。结合豆伴，可以将豆瓣书影音数据全部迁移过来，而且NeoDB上可以标记那些被禁的条目。 标记电影：Letterboxed 标记书籍：Goodreads 这篇blog“豆瓣逃离计划”讲了如何迁移数据到Notion 我没有尝试，不过看起来详细可行。 复习数字图像分析时发现两个不错的网页： 传统CV算法-边缘检测-教材合辑 很全面的介绍。 SUSAN算子 条目作者竟是我的授课老师 (ﾟoﾟ;; 翻LUG群聊天记录发现Linux C编程一站式学习。 也是复习时查资料发现一个清华老师做的物联网教程，感觉很厉害的样子先存起来吧qwq 推特冲浪发现一个blogger的关于RisingWave的周报，看不懂但喜欢周报。 日语课上，老师推荐了日本文化中心网站。 本月进展 有在留意和收集实习信息（但并没有投简历）。 有继续在看Linux 101和吴恩达机器学习（其它还在搁置）。 有健几次身。 开始画板子了！好难！不过不讨厌。像周星驰从跑龙套开始一样从PCB民工开始吧！ 书与影  始于极限：女性主义往复书简激情推荐给了不少人。 我的阴阳两界帮我度过了漫长到有点难熬的寒假时光。一本能让人在生活之余享受而不是倍加折磨的小说是很难得的。 本月看的11部电影中，最推荐的三部电影： 巴黎夜旅人侯麦影迷狂喜！ 童年往事沉痛而真切。 晒后假日如不少人所说的，“后劲十足”。 最后，一张Chantal Akerman的帅气截图：","link":"/zh-cn/Feb-2023/"},{"title":"Git 学习笔记","text":"完整地过了一遍廖雪峰的教程。我学Git的初衷是想熟练用上GitHub, 现在发现Git才是那个深奥的核心 简介 Git是用C语言开发的 集中式&amp;分布式版本控制系统 集中式：版本库集中存放在中央服务器；最大的毛病就是必须联网才能工作 分布式：没有“中央服务器”，每个人的电脑上都是一个完整的版本库，不需要联网；安全性要高很多；通常也有一台充当“中央服务器”的电脑，但这个服务器的作用仅仅是用来方便“交换”大家的修改；极其强大的分支管理 创建版本库 版本库：又名仓库，英文名repository，可以简单理解成一个目录，这个目录里面的所有文件都可以被Git管理起来，每个文件的修改、删除，Git都能跟踪，以便任何时刻都可以追踪历史，或者在将来某个时刻可以“还原” 创建版本库 step1：创建一个空目录 step2：初始化，git init 把一个文件放到Git仓库 git add git commit 时光机穿梭 git status查看工作区状态 git diff查看修改内容 版本回退 git reset --hard commit_id版本回退 git reset --hard HEAD^ 在Git中，用HEAD表示当前版本，上一个版本就是HEAD^，上上一个版本就是HEAD^^，往上100个写成HEAD~100 git reset --hard 1094a 版本号（commit id）没必要写全，前几位就可以了，Git会自动去找 git log查看提交历史 显示从最近到最远的提交日志（如果嫌输出信息太多，加上--pretty=oneline参数） git reflog查看命令历史 可以找到版本号 工作区和暂存区 工作区（Working Directory）：在电脑里能看到的目录 版本库（Repository）：工作区有一个隐藏目录.git，这个不算工作区，而是Git的版本库 版本库里重要的东西有： 暂存区：stage（或者叫index） 分支：Git为我们自动创建的第一个分支master 指针：指向master的一个指针叫HEAD 需要提交的文件修改通通放到暂存区，然后一次性提交暂存区的所有修改 管理修改 Git跟踪并管理的是修改，而非文件 每次修改，如果不用git add到暂存区，那就不会加入到commit中 add只添加进了暂存区，commit才是进版本库，暂存区的相同文件都是覆盖的 撤销修改 git restore -- file丢弃修改，让这个文件回到最近一次git commit或git add时的状态 --很重要，没有--，就变成了“切换到另一个分支”的命令 git restore --staged把暂存区的修改撤销掉（unstage），重新放回工作区 注： 原来的git checkout 可以使用 git restore 代替 原来的git reset HEAD 可以使用 git restore –staged 代替 最新版的git提示都已经更换成了restore 总结： 情况1：在工作区做了修改，并未添加到暂存区，想撤销工作区的修改，用 git restore file 情况2：在工作区做了修改，并用git add 添加到了暂存区，未提交；想撤销，分两步，1.先撤销暂存区的修改，用 git restore –staged file, 2.然后参考情况1撤销工作区的修改 情况3：在工作区做了修改，且git add git commit添加并提交了内容，想撤销本次提交，直接用 git reset –hard HEAD^回退版本，即可保证工作区，暂存区，版本库都是上次的内容 删除文件 git rm 如果一个文件已经被提交到版本库，那么你永远不用担心误删，但是要小心，你只能恢复文件到最新版本，你会丢失最近一次提交后你修改的内容 当你直接在文件管理器中把没用的文件删了，或者用rm命令删了，接下来有两种选择： 确实要从版本库中删除该文件，那就用命令git rm删掉，并且git commit 删错了，用git checkout把误删的文件从版本库里恢复到最新版本 远程仓库 本地Git仓库和GitHub仓库之间的传输通过SSH加密 添加远程库 git remote add origin git@server-name:path/repo-name.git 关联一个远程库时必须给远程库指定一个名字，origin是默认习惯命名 关联后，使用命令git push -u origin master第一次推送master分支的所有内容 此后，每次本地提交后，只要有必要，就可以使用命令git push origin master推送最新修改 删除远程库 git remote rm &lt;name&gt; 使用前，建议先用git remote -v查看远程库信息 只是解除了本地和远程的绑定关系，并不是物理上删除了远程库。远程库本身并没有任何改动。要真正删除远程库，需要登录到GitHub，在后台页面找到删除按钮再删除 从远程库克隆 ssh：git clone git@github.com:your name/repo name.git 更快 https：git clone http://github.com/yourname/reponame.git 分支管理 创建与合并分支 git checkout -b或git switch -c创建并切换 相当于git branch（创建） + git checkout或git switch（切换） git branch查看当前分支 会列出所有分支，当前分支前面会标一个* git merge合并指定分支到当前分支 git branch -d删除分支 创建、合并和删除分支非常快，所以最好使用分支完成某个任务，合并后再删掉分支，这和直接在master分支上工作效果是一样的，但过程更安全 解决冲突 把Git合并失败的文件手动编辑为我们希望的内容，再提交 分支管理策略 分支策略 master分支应该是非常稳定的，也就是仅用来发布新版本，平时不能在上面干活 dev分支是不稳定的，干活都在dev分支上；到某个时候，比如1.0版本发布时，再把dev分支合并到master上，在master分支发布1.0版本 团队成员都在dev分支上干活，每个人都有自己的分支，时不时地往dev分支上合并就可以了 合并分支时的普通模式：加上--no-ff参数 这样合并后的历史有分支，能看出来曾经做过合并，而fast forward合并就看不出来曾经做过合并 Bug分支 修复bug时，通过创建新的bug分支进行修复，然后合并，最后删除 git stash保存工作现场，然后去修复bug，修复后，有两种方式回到工作现场： git stash apply，stash内容并不删除，需要用git stash drop来删除 git stash pop，恢复的同时把stash内容也删了 git stash list查看stash里的内容，然后用git stash apply stash@{0}恢复到指定的stash（这里是stash@{0}） 在master分支上修复的bug，想要合并到当前dev分支，可以用git cherry-pick &lt;commit&gt;，把bug提交的修改“复制”到当前分支，避免重复劳动 Feature分支 开发一个新feature，最好新建一个分支 如果要丢弃一个没有被合并过的分支，可以通过git branch -D &lt;name&gt;强行删除 多人协作 git push origin &lt;branch-name&gt;推送自己的修改 如果推送失败，则因为远程分支比你的本地更新，需要先用git pull试图合并 如果git pull提示no tracking information，则需要用git branch --set-upstream-to &lt;branch-name&gt; origin/&lt;branch-name&gt;建立起本地分支和远程分支的链接关系 如果合并有冲突，则解决冲突，并在本地提交 没有冲突或者解决掉冲突后，再用git push origin &lt;branch-name&gt;推送 Rebase 把本地未push的分叉提交历史整理成直线 目的：使我们在查看历史提交的变化时更容易，因为分叉的提交需要三方对比 标签管理 tag是一个让人容易记住的有意义的名字，它跟某个commit绑在一起 如果这个commit既出现在master分支，又出现在dev分支，那么在这两个分支上都可以看到这个标签 创建标签 git tag &lt;tagname&gt;新建一个标签 默认为HEAD，也可以指定一个commit id 创建的标签都只存储在本地，不会自动推送到远程 git tag -a &lt;tagname&gt; -m &quot;blablabla...&quot;创建带有说明的标签 git tag查看所有标签 不是按时间顺序列出，而是按字母排序 git show &lt;tagname&gt;查看标签信息 操作标签 推送 git push origin &lt;tagname&gt;推送某个本地标签到远程 git push origin --tags一次性推送全部未推送过的本地标签到远程 删除 git tag -d &lt;tagname&gt;删除某个本地标签 删除一个远程标签：先从本地删除（用上面的命令），然后从远程删除，命令是git push origin :refs/tags/&lt;tagname&gt; 使用GitHub 可以任意Fork开源仓库 Fork后的仓库，你拥有读写权限 推送pull request给官方仓库来贡献代码 使用Gitee 国内的Git托管服务 使用方法和GitHub类似 自定义Git git config --global color.ui **true**让Git显示颜色，看起来更醒目 忽略特殊文件 Github官方.gitignore文件合集 忽略文件的原则： 忽略操作系统自动生成的文件 忽略编译生成的中间文件、可执行文件等 忽略带有个人敏感信息的配置文件 git add -f filename虽然被忽略但强制添加 !filename例外文件 .gitignore online generator 配置别名 git config --global **alias**.st status设定用st表示status --global是全局参数，针对当前用户，即让命令在这台电脑的所有Git仓库下都有用；如果不加，那就只针对当前仓库有用 每个仓库的Git配置文件都放在.git/config文件中 当前用户的Git配置文件放在用户主目录下的一个隐藏文件.gitconfig中 要删除别名，直接把[alias]后面的对应别名的行删掉即可 搭建Git服务器 需要一台运行Linux的机器（推荐Ubuntu或Debian）。暂时用不到就没看，详见这里 使用Sourcetree 免费Git图形界面工具 附录 教程 廖雪峰的Git教程 链接 Git Cheat SheetGit官网","link":"/zh-cn/Git-Learning-Notes/"},{"title":"Hello World","text":"我成功了！ :)","link":"/zh-cn/Hello-World/"},{"title":"MATLAB 基础（超基础）","text":"为了用MATLAB写计算机作业而火速看了一个领英学习上的入门教程（两三年没用真的忘光了）。 概念 清除命令 clc 清除屏幕 clear myVar 删除变量myVar clear all 删除所有变量 创建变量 创建一个标量：myScalar = 10 创建一个向量 行向量：myVector = [4 5 6] 列向量：myVectorCol = [7; 8; 9] 创建一个矩阵。myMatrix = [4 5 6; 7 8 9; 1 2 3] myMatrix(1, 2)得到5 myMatrix(2, :)得到所有在第2行的列 myMatrix(3, 2:3)得到第3行、第2列和第3列。 在命令行的末尾使用”; “意味着它将抑制（即不显示）结果 变量类别 double (默认) format long将 double 类改为 long 类 double, long, short, single, logical (boolean)等等 元胞数组一个有不同种类元素的矩阵 myCell = {[1 2 3] [4 5 6 7]; &apos;v1&apos; &apos;v2&apos;} myCell{1, 2}得到[4 5 6 7] 核心语法 脚本 “.m “文件 注释: % disp(): 显示一些东西 randi(): 随机整数 要想显示一个矩阵：matrix&apos; 矩阵 创建一些标准矩阵 zeros(m, n) `ones(m, n)’ `randi(m, n)’ 矩阵乘法 标准乘法：M1 * M2 元素与元素的乘法：M1 .* M2 除法是相似的 元素与元素的除法：M1 ./ M2 If 语句1234567if ... ...elseif ... ...else ...end Switch 语句12345678switch ... case ... ... case ... ... otherwise ...end For 循环1234567891011% step = 1for i = 1: 10 ...end% step = 2% for i = 1: 2: 10% n =25;% step = 5;% for i = 0: step: n While 循环123while ... ...end 编程 设置路径如果MATLAB找不到你的脚本或函数或其他东西，请确保你已经添加了路径 函数 从 “当前文件夹 “创建一个函数，它是一个.m文件 编辑模式，并编写你的函数 导入数据要导入一个CSV文件： 复制并粘贴到 “当前文件夹” csvread(&apos;sine.csv&apos;) 调试在编辑器左侧的小破折号处设置断点 性能 预先分配一些内存可以加快大型计算的速度 使用 “tik … tok “来计算时间 数据表示 绘图123figure% figure(1)plot(x, y) 添加网格：grid on 使窗口与绘图完全吻合：axis tight 为轴设置限制：ylim([-1 1]) 改变颜色：plot(x, y, &apos;m&apos;) % magenta 改变标记: plot(x, y, &apos;o&apos;) % circle, magenta 用不同的线条多次绘制曲线：hold on。 要结束它，使用hold off 添加注释：xlabel(), title(), legend() 使用close all来关闭所有图 图片 使用imread()来导入图像文件 使用image()绘制图像（默认为正方形） 使用imshow()以正确的长宽比绘制图像，轴上没有标签 3D 绘图12345678x = -2*pi:.5:2*pi;[X, Y] = meshgrid(x);Z = sine(X) + cos(Y);figuresurf(X, Y ,Z)colorbar Simulink 一个框图工具，可用于建立系统和反馈回路，为FPGA等硬件生成代码 附录 教程 Learning MATLAB","link":"/zh-cn/Basic-MATLAB/"},{"title":"Git & Github 入门","text":"这是我在学习LinkedIn课程Learning Git and Github时做的一些简单笔记。我发现先在Notion中做笔记，然后导出Markdown，修改，复制粘贴到Blog中，非常方便。 开始12git config --global user.name &quot;name&quot;git config --global user.email &quot;mail&quot; 1git init 暂存区 Staging files12git add filenamegit add . 1git commit -m &quot;message&quot; 1git log Git 环境 Working Staging Commit 文件状态1git status Tracked (after commit) Unmodified Modified Staged Untracked 恢复文件12git restore filenamegit restore . 忽略文件 Sensitive info Personal notes System files 使用 .gitignore 文件 清除缓存1git rm -r --cached . 删除1git rm filename 删除，并转移到暂存区，准备提交 重命名1git mv oldname newname 同样转移到暂存区 显示区别1git diff 1got log --oneline 修正1git commit --amend 12git resetgit reset --hard 重置 Rebasing一台时光机，可以重写历史 1git rebase 分支 Branches1git branch 复制一个分支： 1git switch -c NAME 合并： 1git merge &lt;branch&gt; 删除： 1git branch --delete NAME Git 流程： Fix branch Make changes Merge to master Delete old branch 合并冲突选择其中一个即可 贮藏 Stashing1234git stashgit stash listgit stash applygit stash pop Git clean123git clean -ngit clean -dgit clean -f Github Cloud repository Collaborative dev Projet management 使用github: Set up remote Push Fetch/pull 推送到github远程: 1234git remote add NAME URLgit remote remove NAMEgit rename OLDNAME NEWNAMEgit remote -v Git 推送: 123git push REMOTE BRANCHgit push -u origin maingit push --all Github 选项Issues与人合作 为你自己或其他人写笔记，如待办事项 将待办事项分配给个人，他们可以发表评论 Pull requests更改仓库 批准别人所做的修改 比较不同的分支 Actions管理仓库（高级） 运行测试 自动托管代码 下载其他人的actions来使用 Projects管理仓库 看板 Wiki创建便于人们查看的文件（其实没必要） Security管理安全策略（高级） Insights了解贡献者、仓库动态等（私人） Settings 将此仓库转换为一个模板 Github页面 管理 projects 贡献者 邀请合作者 问题 标签 里程碑 项目 同步1git clone 1git fetch 1git pull pull = fetch + merge","link":"/zh-cn/Intro-to-Git-GitHub/"},{"title":"Linux 中的软件安装","text":"在 Linux 中安装软件有5种方法。 安装 使用应用商店安装适用于自带应用商店的发行版，如 Ubuntu、Manjaro 等 在 Xubuntu 中应用商店叫“软件”，试了一下并不好用，加载很慢 使用包管理系统安装软件包管理器是一系列工具的集合，他自动化地完成软件的安装、更新、配置和移除功能 在 Linux 中，许多软件均可以通过一行命令完成其安装，优雅而快速 与应用商店相比，使用包管理器安装需要预先知道所需软件在软件仓库中的对应包名 本教程以管理 Debian (.deb) 软件包的 dpkg以及它的前端 apt（用于 Debian 系的发行版）为例 apt 的全称是 Advance Package Tool apt 安装前，使用 apt search 搜索内容 查看对应的包名是否在软件仓库中 确定了软件包的包名后，通过 apt install 包名 进行安装 输入 Y 后回车确定进行安装 权限问题 提示“Permission denied”、“are you root?” 修正方法：在命令前面添加 sudo，即使用 sudo apt install firefox 在用户输入密码的过程中，为了安全，终端不进行密码的回显 官方软件源 apt 的软件源列表在 /etc/apt/sources.list 下 第三方软件源 官方软件源中没有的软件，可以添加第三方软件源然后安装软件 将第三方软件源添加到 /etc/apt/sources.list 中之后，就可以获取到第三方提供的软件列表，再通过 apt install package-name 安装需要的第三方软件 例如，通过添加 Docker 软件源安装 Docker 1 使用包管理器手动安装软件包除了从官方软件源和第三方软件源安装软件外，还可以直接下载安装软件供应商打包好的 deb 、rpm 等二进制包，使用命令安装 尽量使用 apt 来安装 deb ，避免直接使用 dpkg -i 安装 deb，因为直接通过 dpkg 安装 deb 并不会安装需要的依赖，只会报告出相应的依赖缺失了，需用下面的命令手动修复： 1$ sudo apt -f install 例如，安装 VSCode 2 我尝试了一下但失败了…… 首先，我的 Linux 发行版太旧了，无法使用 apt 安装，于是用了 dpkg -i ，出了一些错其次，我的存储空间似乎不足，无法完整装上 VSCode最后我又犯了一个错误，把 Linux 关机了，再开机时没有图形界面，只有左上角一个光标在一直闪动 这些问题我搜索了一下，都没有顺利解决。无奈之下只好删除了原先的虚拟机，添加新的虚拟机 宿主机win10与虚拟机ubuntu之间的文件传输 通过ssh连接服务器的方式传输文件 3。我用了 MobaXterm，成功了 断开连接时突然跳出几只小企鹅 ^_^ 安装预编译的可执行文件软件提供商还可能提供预编译好的二进制文件，可以直接运行 例如，安装预编译的 LLVM 4 使用源代码编译安装 5更新 在计算机本地，系统会维护一个包列表，里面包含了软件信息以及软件包的依赖关系 更新软件列表 使用 apt update 获取新的软件版本、软件依赖关系 更新软件 在获取到了新的软件列表后，使用 apt upgrade 进行软件更新 附录 教程 Linux 101 - 第三章：软件安装与文件操作 [1] Linux 101 - 第三方软件源 [2] Visual Studio Code on Linux [3] 宿主机win10与虚拟机ubuntu之间的文件传输方法 [4] Linux 101 - 安装预编译可执行文件 [5] Linux 101 - 使用源代码安装","link":"/zh-cn/Installing-software-in-Linux/"},{"title":"Java 入门","text":"关于Java的诞生背景、发展历史和版本说明部分让我收获较大。 简介 创始人：James Gosling Java介于编译型语言和解释型语言之间。它是将代码编译成一种“字节码”，类似于抽象的CPU指令，然后针对不同平台编写虚拟机，不同平台的虚拟机负责加载字节码并执行，实现“一次编写，到处运行” Java三个版本 Java SE：Standard Edition，标准版，包含标准的JVM和标准库，是整个Java平台的核心 Java EE：Enterprise Edition，企业版，在Java SE的基础上加上了大量的API和库，以便方便开发Web应用、数据库、消息服务等；Java EE的的虚拟机和Java SE完全相同；是进一步学习Web应用所必须的 Java ME：Micro Edition，针对嵌入式设备的“瘦身版”，Java SE的标准库无法在Java ME上使用；Java ME的虚拟机也是“瘦身版”；不流行，不建议学习 推荐的Java学习路线 首先要学习Java SE，掌握Java语言本身、Java核心开发技术以及Java标准库的使用； 如果继续学习Java EE，那么Spring框架、数据库开发、分布式架构就是需要学习的； 如果要学习大数据开发，那么Hadoop、Spark、Flink这些大数据平台就是需要学习的，他们都基于Java或Scala开发； 如果想要学习移动开发，那么就深入Android平台，掌握Android App开发。 JDK：Java Development Kit，除了包含JRE，还提供了编译器、调试器等开发工具，用来将Java源码编译成Java字节码 JRE：Java Runtime Environment，是运行Java字节码的虚拟机 JSR规范：Java Specification Request JCP组织：Java Community Process RI：Reference Implementation，参考实现 TCK：Technology Compatibility Kit，兼容性测试套件 基础 程序基本结构123public class Hello { // 类名是Hello // ...} // class定义结束 12345public class Hello { public static void main(String[] args) {// 方法名是main// 方法代码... }// 方法定义结束} 类名必须以英文字母（习惯大写）开头；方法名必须以英文字母（习惯小写）开头 在class内部，可以定义若干方法（method） public是访问修饰符，表示该class是公开的。不写public，也能正确编译，但是这个类将无法从命令行执行 Java入口程序规定的方法必须是静态方法，方法名必须为main，括号内的参数必须是String数组 Intelli IDEA代码格式化：Ctrl + Alt + L 变量和数据类型 两种变量类型：基本类型和引用类型 基本类型是CPU可以直接进行运算的类型。包括整型，浮点型，布尔型，字符型 剩下的都是引用类型，类似于C语言的指针，它内部存储一个“地址”，指向某个对象在内存的位置。最常用的是String 基本类型的变量是“持有”某个数值，引用类型的变量是“指向”某个对象 常量在初始化后不可重新赋值 简写变量类型，使用var关键字 运算 整数运算永远是精确的，浮点数运算常常无法精确表示 流程控制 输入和输出 输出 System.out.println()，输出并换行 System.out.print()，输出不换行 System.out.printf()，格式化输出 输入（不能在线运行，必须从命令行读取） 1234567import java.util.Scanner;public class Main {publicstaticvoid main(String[] args) { Scanner scanner =new Scanner(System.in);// 创建Scanner对象 String name = scanner.nextLine();// 读取一行输入并获取字符串 int age = scanner.nextInt();// 读取一行输入并获取整数 }} if条件判断 判断浮点数相等用==判断不靠谱，正确的方法是利用差值小于某个临界值来判断 判断引用类型的变量内容是否相等，必须使用equals()方法 case多重选择 总是写上default 从Java12开始，新语法使用-&gt;，如果有多条语句，需要用{}括起来。不要写break语句，因为新语法只会执行匹配的语句，没有穿透效应 在switch表达式内部，用yield返回一个值作为switch语句的返回值 while循环 先判断后循环 可能循环0次 do while循环 先循环后判断 至少循环一次 for循环 可能循环0次 break和continue 在多层嵌套的循环中，都只能跳出自己所在的那一层循环 数组操作 遍历、排序、多维数组、命令行参数（略） 附录 教程 廖雪峰的Java教程-Java快速入门","link":"/zh-cn/Intro-to-Java/"},{"title":"初识 Linux","text":"按照教程成功安装用上了 Xubuntu ！赞美！ 计算机性能爆发增长 摩尔定律：集成电路上可容纳的晶体管数目每两年就会翻一倍/计算机的性能每 18 个月提高一倍（Intel CEO David House） 量子物理的限制以及 CPU 功耗和散热的限制使计算机性能的提升开始放缓。多个 CPU 之间的联合协作（基于多核的开发）取代追求单个 CPU 性能的提升，成为了未来发展方向 操作系统 用户与底层硬件交流的桥梁 功能 进程管理：操作系统调度进程，使许多进程可以在几个中央处理器上并发执行 内存管理：操作系统合理分配和回收内存 文件系统：操作系统建立合适的数据结构来存储文件和数据 网络通信：操作系统实现各种必需的网络通信方式（如TCP/IP） 安全机制：操作系统配备安全机制用于保护数据不被未授权的人士获取 用户界面：操作系统通常包含一个图形化的用户界面，方便用户使用计算机 驱动程序：操作系统与驱动程序对接以发挥硬件的功能 Linux 诞生 选择 Linux，很大程度上是一种对极客精神与开源文化的认同。 自由软件意味着其用户拥有自由。（这无关价格。）我们开发了GNU系统，这样用户就有了计算的自由。 具体来说，自由软件的用户拥有四项基本自由：(0)自由运行软件、(1)自由学习和修改软件源代码、(2)自由再发布软件拷贝以及(3)自由发布修改后的软件版本。 软件不同于生活中的事物 — 它不同于椅子、三明治或是汽油 — 软件可以更容易地被复制或修改。恰恰是这一特性，使得软件更为有用。我们由此坚信，软件的这一天然属性应该被用户利用。1 1983 年，Richard Stallman 在 MIT 发起了 GNU 计划；1991年，Linus Torvalds 编写并发布了Linux 内核，成为了后来各类 Linux 发行版的基础 GNU：GNU 是“GNU is Not Unix”的递归缩写，指一套类似 UNIX 但完全自由的操作系统 GNU 通用公共许可证（GNU General Public License，GNU GPL 或 GPL）：把使用该许可的软件的所有权利授予任何使用它的人 这种权利又被称为著作传（Copyleft），相对于通常的著作权（Copyright） 核心GNU操作系统至今没有开发完成。现在实际上用的是 GNU/Linux ，Linux 内核是功能核心，而GNU组件是外设，也是用户操作和使用 Linux 内核的工具 现在智能手机上一个常见的系统是 Android/Linux ，是一个基于 Linux 内核开发的、没有采用 GNU 组件而是用谷歌自行研发的另一套 Android 体系作为工具的操作系统 Linux 发行版 Linux 发行版 = Linux 内核 + 一系列 GNU 工具和库、一些附带的软件、说明文档、一个桌面系统、一个窗口管理器和一个桌面环境 主流的发行版分支 Debian 分支：最著名的是 Ubuntu ，一个主打桌面应用的操作系统，适合普通用户使用。推荐初次接触 Linux 的读者优先采用 Ubuntu 发行版或者它的子发行版（Lubuntu, Xubuntu 等） Red Hat 分支：Fedora ，CentOS（适合在要求高度稳定的服务器上运行） Arch Linux 分支：要求使用者自身愿意去了解操作系统的运作方式，并不采取屏蔽工作原理的方式来降低使用门槛。变种 Manjaro 更注重易用，更适合一般用户 Linux 在身边 智能手机：Google 研发的 Android 操作系统属于 Android/Linux 分支，也叫 Android 原生系统，子发行版很多，如华为 EMUI 操作系统和小米 MIUI 操作系统等 服务器：网站和软件的提供商都需要设立他们自己的计算机来完成计算、存储和通信的功能，这种计算机就被称为服务器。服务器通常不用 Windows 或者 macOS 这种个人计算机操作系统，绝大部分用 Linux 发行版，因为它们界面简洁，功能强大，而且某些发行版也受到专业计算机企业的服务支持（如 RHEL）。Debian 和 Ubuntu Server 很流行 嵌入式设备：Android/Linux 分支下的各类发行版是主流的嵌入式操作系统，如 Google 为数字电视专门推出的 Android TV 操作系统 使用 Linux 推荐使用虚拟机运行安装完毕的 Linux 镜像 步骤 获取虚拟机管理软件，推荐 VMware Workstation Player 获取 Xubuntu 虚拟机镜像（Xubuntu 是 Ubuntu 的一个子发行版，与 Ubuntu 非常类似，但体积更小，性能需求更少，适合各种不同性能的电脑安装使用） 双击打开虚拟机镜像，管理软件会打开并导入该镜像，导入完毕后可直接点击开始按钮启动 拾 ~ 附录 教程 LUG @ USTC的Linux 101 - 第一章：初识Linux 引用 [1] GNU 工程的哲学 推荐阅读 为什么开源错失了自由软件的重点","link":"/zh-cn/Intro-to-Linux/"},{"title":"2023年1月","text":"新年第一个月，仍在龟速整理复习笔记，摸鱼怠惰。不过也学到了一些新东西。 又换了blog主题为了增加中英文语言选项而换了Minos主题，一番捣鼓后终于成功了！并且出于自己的审美而稍做了外观修改。然后发现在手机端点击更换语言时下拉菜单被导航栏遮挡，想了各种解决办法，最后通过更改排版实现了完整显示，于是整理成了一个仓库，方便中国用户直接使用。 后来又发现一个问题：在config中开启阅读文章时的导航栏后，英文版正常显示小标题，中文却乱码了。这个遗留问题尚未解决所以暂且改成：英文版开启导航栏，中文版关闭。 用上了Linux发现了一个很好的教程：Linux 101，是中科大Linux社团写的。成功用上Linux并激情发邮件入社围观群内大佬！目前学完了前三章。 关于机器学习重拾吴恩达，丢下freecodecamp藍。freecodecamp讲的很实用，直接敲代码演示，但语速太快了，吴恩达则反过来。不着急的话还是先看吴恩达了解原理吧。目前看到“P92 16.3 整合”。 复习DIA时搜到了一篇很清晰地讲解了BP算法的文章。原文在这里。 在一亩三分地看到一个机器学习八股文的帖子。 开始画PCB了准确说只是刚开始画原理图，磨叽到现在还没有画完。以前只用过Altium Designer，现在需要用Cadence。饶有兴趣地查了一番二者的区别，看来Altium Designer易于上手、性能有限，Cadence更难也更强大。 看到一篇不错的blog：Cadence使用及画板技巧相关。 没有学语言但是给下学期选了日语课！好耶，选到就是学到ヽ(✿ﾟ▽ﾟ)ノ","link":"/zh-cn/Jan-2023/"},{"title":"LaTeX 简历","text":"从昨天中午到今天中午，我一直在用latex做简历。这对初学者来说非常不友好。幸运的是，我现在做完了，看看我的简历. 我是这样做的： -&gt; 如果你只是偶尔或少量使用latex，一个在线编辑器 Overleaf 可以省去很多麻烦。你可以找模板，然后编辑和编译就可以了。-&gt; 如果你想做更多的事情，请使用以下步骤。 下载 MiKTeX 和 VSCodeMiKTeX你会得到MiKTeX Consle和TeXworks。后者是一个编辑器，但我更喜欢使用VSCode，因为它可以在另一个窗口预览pdf（也因为我已经有VSCode）。另一个选择是Tex Live。它预装了一个完整的软件包，但下载速度太慢，而且经常失败，所以我选择了MiKTeX。 VSCode记得下载插件 latex workshop。 找模板在Overleaf或Github上找一个模板。这是我喜欢的：新卒のためのLaTeX履歴書テンプレートTLC-Resume-2021以及我做的：Resume-CV (在TLC-Resume-2021的基础上修改的) 编辑模板在这一步你可能会遇到很多问题，其中大部分需要你在MiKTeX控制台中下载包，或其他东西，如Perl。只要按照错误信息中所说的安装缺少的项目就可以了。 分享模板 把你的模板放到github上(已经绑定了git和你的github账户并设置了SSH密钥)-&gt; 创建一个新的仓库-&gt; Git bash文件夹，其中包含关于你的模板的全部文件-&gt; 在Git中运行以下代码 git init git add . git commit -m &apos;Description&apos; git remote add origin https://... (copy from github) git push -u origin master 提交到Overleaf我就是在那里找到我的简历的原始模板的! 我想，把模板放在那里可能会帮助到更多的人。","link":"/zh-cn/Latex-CV/"},{"title":"我的第一个领英学习证书！","text":"是的，我得到了! 我一直想要获得在线学习证书，比如Coursera和LinkedIn。Coursera的免费方案是一个星期，而LinkedIn的是一个月，所以我选择了后者。 (注意，对于中国大陆用户，你必须在账户设置中改变你的位置为非中国大陆地区，以获得每月的免费计划。另外，你必须使用Visa的信用卡。） 不错的课程 简短，不到2个小时，对新手非常友好实用！作者介绍了许多学习前端开发的有用网站 我学到了什么 网络开发工作的类型规划和原型设计： UX (用户体验) UI (用户界面) 编程和开发： 前端开发 (Javascript, CSS, HTML; 框架) 后端开发 Javascript、CSS、HTML HTML确定了结构元素 CSS改变了的外观和风格 JS处理交互性，如移动和动画 对Github有了一点了解这超出了我的预期，也正是我所需要的! 看起来Github Pages Service对于小型和简单的网络开发来说是一个很好的（因为免费）开始。我最近会试试的。 无代码这对我来说是一个全新的概念。听起来很有趣，你可以不通过写代码来开发一个网站。但也许代价是，真正的成本————钱？但是它是受限的，尤其是当你了解得越多，就越贪婪 :p 有用的工具 原型设计工具： Figma 图形界面设计工具： Illustrator, Photoshop （专业） Affinity, Figma （轻量） Canva （最简单，免费，有模板） 代码编辑器: CodePen （在线，免费） VS Code Atom （免费，高度可个性化定制） Brackets 网络主机： Github Pages Service（最简单，免费） 无代码工具 CMSs (内容管理系统)： Joomla! Drupal Wordpress 建立网站的工具： Squarespace, Wix, Weebly （简单） Webflow, Editor X （复杂） 数据库： Google Sheets Airtable 应用： Bubble (web) AppGyver (web, ios, android) Adalo, Glide (ios, android) 最后，这是我的证书，希望今后能得到更多的证书  ~ 附录 领英学习课程 Introducation to Web Design and Development","link":"/zh-cn/My-first-LinkedIn-certificate/"},{"title":"2022年11月","text":"Leetcode目前为止在Leetcode上做了64道题。 完成了Arrays 101（剩下一题只有会员才能做）。是对像我这样的初学者来说也非常简单一章！ 得到一个徽章! 说实话，我不太理解这个徽章里的所有数据结构题洛。我只熟悉数组和字符串…… 打算找时间消化一下。 Jupyter Notebook实际使用了一下。写了一个简单的使用Logistic Regression模型对一些数据进行分类的笔记本。 Github Workflow在我的GitHub账户主页上使用了Metrics。它的神奇之处在于可以自动更新! 领英学习证书每个证书下是我对该课程的评分。 ⭐⭐⭐⭐⭐ ⭐⭐ ⭐⭐ ⭐⭐⭐⭐ ⭐⭐⭐ 语言准备IELTS indicator 考试。 坚持学习了42 days的多邻国日语。 我发现，在中国只有两种日语考试，即JLPT和JTEST。JLPT每年只举行两次，而且经常被取消。JTEST的举办频率更高，但它不像JLPT那样被高度认可，所以我很纠结。","link":"/zh-cn/Nov-2022/"},{"title":"面向对象","text":"面向对象的三个基本特征是：封装、继承、多态。 Class &amp; Instance class是对象模板，instance是对象实例 定义class（包含多个字段，field） 1234class Person { public String name; public int age;} 创建instance（指向instance的变量都是引用变量） 1Person ming = new Person(); 访问实例变量用变量.字段 一个Java源文件可以包含多个类的定义，但只能定义一个public类，且public类名必须与文件名一致。如果要定义多个public类，必须拆到多个Java源文件中 方法 动机：为了避免外部代码直接去访问field，我们可以用private修饰field，拒绝外部访问，然后使用method来让外部代码可以间接修改field 在方法内部，我们有机会检查参数对不对；而外部代码没有任何机会把字段设置成不合理的值 一个类通过定义方法，可以给外部代码暴露一些操作的接口，同时保证内部逻辑一致性 调用方法的语法是实例变量.方法名(参数); 定义方法 123456789// 修饰符 方法返回类型 方法名(方法参数列表) {// 若干方法语句;// return 方法返回值;// }// 如果没有返回值，返回类型设置为void，可以省略returnpublic String getName() { return this.name;} private方法：不允许外部调用，只有类的内部可以调用 this变量：在方法内部，可以使用一个隐含的变量this，它始终指向当前实例。通过this.field就可以访问当前实例的字段 如果没有命名冲突，可以省略this；如果局部变量和字段重名，就必须加上this 方法参数：0或任意个，用于接收传递给方法的变量值 可变参数：类型…，相当于数组类型 可变参数可以保证无法传入null 参数绑定 基本类型参数的传递，是调用方值的复制。双方各自的后续修改，互不影响 引用类型参数的传递，调用方的变量和接收方的参数变量指向的是同一个对象。双方任意一方对这个对象的修改，都会影响对方（因为指向同一个对象） 构造方法 123456789101112131415161718192021222324public class Main { public static void main(String[] args) { Person p = new Person(&quot;Xiao Ming&quot;, 15); }}class Person { private String name; private int age; // 构造方法 public Person(String name, int age) { this.name = name; this.age = age; } public String getName() { return this.name; } public int getAge() { return this.age; }} 实例在创建时通过new操作符会调用其对应的构造方法，构造方法用于初始化实例 创建实例实际上是通过构造方法来初始化实例的 构造方法的名称就是类名 构造方法的参数没有限制，在方法内部，也可以编写任意语句。但是，和普通方法相比，构造方法没有返回值（也没有void），调用构造方法，必须用new 没有定义构造方法时，编译器会自动创建一个默认的无参数构造方法 没有在构造方法中初始化字段时，引用类型的字段默认是null，数值类型的字段用默认值，int类型默认值是0 ，布尔类型默认值是false 多构造方法 可以定义多个构造方法，编译器根据参数自动判断 可以在一个构造方法内部调用另一个构造方法，便于代码复用 重载 123456789101112// String类提供了多个重载方法indexof()public class Main { public static void main(String[] args) { String s = &quot;Test string&quot;; int n1 = s.indexOf(&apos;t&apos;); int n2 = s.indexOf(&quot;st&quot;); int n3 = s.indexOf(&quot;st&quot;, 4); System.out.println(n1); System.out.println(n2); System.out.println(n3); }} 含义：方法重载是指多个方法的方法名相同，但各自的参数不同 作用：功能类似的方法使用同一名字，更容易记住，调用起来更简单 方法重载的返回值类型通常是相同的 继承 123456789101112131415161718class Person { private String name; private int age; public String getName() {...} public void setName(String name) {...} public int getAge() {...} public void setAge(int age) {...}}class Student extends Person { // 不要重复name和age字段/方法, // 只需要定义新增score字段/方法: private int score; public int getScore() { … } public void setScore(int score) { … }} 作用：复用代码 使用extends关键字来实现继承 继承树：没有明确写extends的类，编译器会自动加上extends Object 任何类，除了Object，都会继承自某个类 一个类有且仅有一个父类。只有Object特殊，它没有父类 子类无法访问父类的private，可以访问父类的protected 如果父类没有默认的构造方法，子类就必须显式调用super()并给出参数以便让编译器定位到父类的一个合适的构造方法 子类不会继承任何父类的构造方法。子类默认的构造方法是编译器自动生成的，不是继承的 阻止继承1234public sealed class Shape permits Rect, Circle, Triangle { ...}// 上述Shape类只允许指定的3个类(Rect, Circle, Triangle)继承它 从Java15开始，使用sealed修饰class，并通过permits明确写出能够从该class继承的子类名称 sealed目前是预览状态，要启用它，必须使用参数--enable-preview和--source 15 向上转型 Upcasting1Person p = new Student(); 把一个子类型安全地变为更加抽象的父类型 例如，继承树是Student &gt; Person &gt; Object，那么可以把Student类型转型为Person，或者更高层次的Object 向下转型 Downcasting12345Person p = new Student();if (p instanceof Student) { // 只有判断成功才会向下转型: Student s = (Student) p; // 一定会成功} 很可能会失败。为了避免出错，使用instanceof先判断一个实例究竟是不是某种类型 从Java 14开始，判断instanceof后，可以直接转型为指定变量，直接使用，避免再次强制转型 继承 &amp; 组合 继承是is关系，组合是has关系 多态 12345678910111213class Person { public void run() { … }}class Student extends Person { @Override public void run() { … }}class Teacher extends Person { @Override public void run() { … }} 含义：针对某个类型的方法调用，其真正执行的方法取决于运行时期实际类型的方法 作用：允许添加更多类型的子类实现功能扩展，却不需要修改基于父类的代码 覆写 Override 子类可以覆写父类的方法，覆写在子类中改变了父类方法的行为 加上@Override可以让编译器帮助检查是否进行了正确的覆写 在子类的覆写方法中，如果要调用父类的被覆写的方法，可以通过super来调用 final final修饰的方法可以阻止被覆写 final修饰的class可以阻止被继承 final修饰的field必须在创建对象时初始化，随后不可修改 抽象类 123abstract class Person { public abstract void run();} 动机：如果父类的方法本身不需要实现任何功能，仅仅是为了定义方法签名，目的是让子类去覆写它，那么可以把父类的方法声明为抽象方法，本身没有实现任何方法语句 含义：如果一个class定义了方法，但没有具体执行代码，这个方法就是抽象方法，抽象方法用abstract修饰；因为无法执行抽象方法，所以这个类也必须申明为抽象类（abstract class） 抽象类无法实例化 作用：抽象类可以强迫子类实现其定义的抽象方法，否则编译会报错。相当于定义了“规范” 面向抽象编程 上层代码只定义规范 不需要子类就可以实现业务逻辑（正常编译） 具体的业务逻辑由不同的子类实现，调用者并不关心 接口 1234interface Person { void run(); String getName();} 动机：如果一个抽象类没有字段，所有方法全部都是抽象方法，就可以把该抽象类改写为接口 接口是比抽象类还要抽象的纯抽象接口，因为它连字段都不能有 使用interface声明一个接口 当一个具体的class去实现一个interface时，需要使用implements关键字；一个类可以实现多个interface 接口也是数据类型，适用于向上转型和向下转型 接口继承12345678interface Hello { void hello();}interface Person extends Hello { void run(); String getName();} 使用extends 继承关系 公共逻辑适合放在abstract class中，具体逻辑放到各个子类，而接口层次代表抽象程度 实例化的对象永远只能是某个具体的子类，但总是通过接口去引用它，因为接口比抽象类更抽象 default方法 接口可以定义default方法 动机：当我们需要给接口新增一个方法时，会涉及到修改全部子类。如果新增的是default方法，那么子类就不必全部修改，只需要在需要覆写的地方去覆写新增方法 default方法和抽象类的普通方法的区别：因为interface没有字段，所以default方法无法访问字段，而抽象类的普通方法可以访问实例字段 静态字段 &amp; 静态方法 静态字段 用static修饰的字段称为静态字段 实例字段&amp;静态字段 实例字段在每个实例中都有自己的一个独立“空间”，各个实例的同名字段互不影响 静态字段只有一个共享“空间”，所有实例都会共享该字段 不推荐用实例变量.静态字段去访问静态字段，推荐用类名来访问静态字段 可以把静态字段理解为描述class本身的字段（非实例字段） 静态方法 用static修饰的方法称为静态方法 实例方法&amp;静态方法 调用实例方法必须通过一个实例变量 调用静态方法则不需要实例变量，通过类名就可以调用。静态方法类似其它编程语言的函数 调用静态方法不需要实例，无法访问this，但可以访问静态字段和其他静态方法 静态方法常用于工具类（如Arrays.sort()，Math.random() ）和辅助方法（如Java程序的入口main() 就是静态方法） 接口的静态字段 interface可以有静态字段，并且静态字段必须为final类型 因为interface的字段只能是public static final类型，所以可以去掉这些修饰符，简写 包 1234package ming; // 申明包名mingpublic class Person {} 在定义class的时候，需要在第一行声明这个class属于哪个包 一个类总是属于某个包（package），类名（比如Person）只是一个简写，真正的完整类名是包名.类名 只要包名不同，类就不同 包可以是多层结构，用.隔开 包没有继承关系 没有定义包名的class使用的是默认包，非常容易引起名字冲突，不推荐不写包名的做法 包作用域123456789101112131415package hello;public class Person { // 包作用域: void hello() { System.out.println(&quot;Hello!&quot;); }}public class Main { public static void main(String[] args) { Person p = new Person(); p.hello(); // 可以调用，因为Main和Person在同一个包 }} 位于同一个包的类，可以访问包作用域的字段和方法 不用public、protected、private修饰的字段和方法就是包作用域 import1234567891011// Person.javapackage ming;// 导入完整类名:import mr.jun.Arrays;public class Person { public void run() { Arrays arrays = new Arrays(); }} JDK的核心类使用java.lang包，编译器会自动导入 JDK的其它常用类定义在java.util.*，java.math.*，java.text.*，…… 作用域 public 定义为public的class、interface可以被其他任何类访问 定义为public的field、method可以被其他类访问，前提是首先有访问class的权限 如果不确定是否需要public，就不声明为public，即尽可能少地暴露对外的字段和方法 一个.java文件只能包含一个public类，但可以包含多个非public类。如果有public类，文件名必须和public类的名字相同 private 定义为private的field、method无法被其他类访问 private访问权限被限定在class的内部，而且与方法声明顺序无关。推荐把private方法放到后面 嵌套类（nested class）拥有访问private的权限 protected 作用于继承关系。定义为protected的字段和方法可以被子类访问，以及子类的子类 pakage 包作用域是指一个类允许访问同一个package的没有public、private修饰的class，以及没有public、protected、private修饰的字段和方法 把方法定义为package权限有助于测试 局部变量 在方法内部定义的变量称为局部变量 局部变量作用域从变量声明处开始到对应的块结束 方法参数也是局部变量 应该尽可能把局部变量的作用域缩小，尽可能延后声明局部变量 final 可以阻止被继承、阻止被子类覆写、阻止被重新赋值 内部类 Nested Class Inner Class123456789101112131415public class Main { public static void main(String[] args) { Outer outer = new Outer(&quot;Nested&quot;); // 实例化一个Outer Outer.Inner inner = outer.new Inner(); // 实例化一个Inner inner.hello(); }}class Outer { ... class Inner { // 定义了一个Inner Class ... }} Inner Class的实例不能单独存在，必须依附于一个Outer Class的实例 要实例化一个Inner，必须首先创建一个Outer的实例，然后，调用Outer实例的new来创建Inner实例 Inner Class可以修改Outer Class的private字段 Outer类被编译为Outer.class，而Inner类被编译为Outer$Inner.class Anonymous Class123Runnable r = new Runnable() { // 实现必要的抽象方法...}; 另一种定义Inner Class的方法。它不需要在Outer Class中明确地定义这个Class 动机：因为在这里我们不关心类名，比直接定义Inner Class可以少写很多代码 匿名类也可以访问Outer Class的private字段和方法 匿名类被编译为Outer$1.class、Outer$2.class、Outer$3.class … 除了接口外，匿名类也可以继承自普通类 Inner Class和Anonymous Class本质上是相同的，都必须依附于Outer Class的实例，即隐含地持有Outer.this实例，并拥有Outer Class的private访问权限 Static Nested Class 不再依附于Outer的实例，而是一个完全独立的类，因此无法引用Outer.this，但可以访问Outer的private静态字段和静态方法 Static Nested Class是独立类，但拥有Outer Class的private访问权限 classpath和jar JVM通过环境变量classpath决定搜索class的路径和顺序 不推荐设置系统环境变量classpath，始终建议通过-cp命令传入 jar包相当于目录，可以包含很多.class文件，方便下载和使用 class版本 高版本的JDK可编译输出低版本兼容的class文件，反之可能报错 运行时使用哪个JDK版本，编译时就尽量使用同一版本编译源码 模块 .class文件是JVM看到的最小可执行文件，而一个大型程序需要编写很多Class，并生成一堆.class文件。jar文件就是class文件的容器，为了方便管理。它并不关心class之间的依赖 从Java 9开始引入了模块（Module），自带“依赖关系”的class容器就是模块，模块以.jmod扩展名标识 只有java.base模块不依赖任何模块，是“根模块” 把一堆class封装为jar仅仅是一个打包的过程，而把一堆class封装为模块则不但需要打包，还需要写入依赖关系，并且可以包含二进制代码（通常是JNI扩展）、支持多版本 模块的作用：声明并管理依赖关系；进一步隔离代码的访问权限 附录 教程 廖雪峰的Java教程-面向对象基础","link":"/zh-cn/Object-oriented/"},{"title":"2022年10月","text":"编程到目前为止，我完成了Leetcode上的27道题，都是用Java。上一章的探索Array and String有点难，但现在的Arrays 101就容易多了。为什么我还在做数组？我等不及学新的东西了。 我学了一点一个著名的课程，CS61A，做了HW 01，HW 02，Lab 00，Lab 01，现在在做Lab 02。上半月我学习得比较认真，下半月就懈怠了。希望我能够坚持下去，完成这门课程和CS61B。OK系统非常有趣。 我看了一些Andrew Ng的机器学习视频，从开始到P48“推理：做预测”。我的导师要求我学习机器学习，所以我试图开始学习。我还读了经典教材《机器学习实战》的一些部分。很不错，而且比视频中的代码更多，难度更大。然而，我还是没有很好地理解机器学习。它看起来很容易，但做起来真的很难勞。好消息是，我今天下午终于做了一个python程序…… Matlab看起来很方便，但它对电脑性能要求太高，而且有点不稳定。我在想，数据有什么特点… 语言坚持每天看一部英语视频，尤其是经济学人的文章。我还在“简报”栏目中阅读了一篇名为《王子》的文章。几天前，我开始准备多邻国英语测试。我的男朋友也报名参加了雅思indicator考试。我们都是下周考。希望成功! 我也开始从多邻国和NHK简明日语学习日语了。喜欢这个网站，因为它很简单。我以前不知道日语也有时态。 暂时再见! 现在已经半夜了。","link":"/zh-cn/Oct-2022/"},{"title":"Linux 中的文件操作","text":"Linux 通过命令行操作文件，包括查看、编辑、复制、移动、删除、创建、搜索、匹配、压缩、解压缩文件。学会查看使用文档也很重要。 查看 cat 12$ # 输出 FILE 文件的全部内容$ cat [OPTION] FILE cat 是 concatenate（连接）的缩写。cat 工具实际的功能是连接多个文件，然后输出。只有一个文件的时候，cat 就会直接输出这个文件，所以 cat 最常见的用途就是输出单个文件。 less 12$ # 在可交互的窗口内输出 FILE 文件的内容$ less FILE cat 会一次性打印全部内容到终端中并退出，而 less 一次只显示一页，且支持向前/后滚动、搜索等功能。如果要在一个大文件中查找一部分内容，less 通常要比 cat 方便得多。 和 less 相似的指令：more, most。 编辑 Nano 是在很多机器上自带的命令行文本编辑器，比 vim 和 emacs 对新手更加友好。 1$ nano FILE # 使用 nano 编辑 FILE 文件 复制 123456789$ # 将 SOURCE 文件拷贝到 DEST 文件，拷贝得到的文件即为 DEST$ cp [OPTION] SOURCE DEST$ # 将 SOURCE 文件拷贝到 DIRECTORY 目录下，SOURCE 可以为不止一个文件$ cp [OPTION] SOURCE... DIRECTORY$ # e.g.$ cp file1 file3 # 将 file1 复制一份到同目录，命名为 file3$ cp file1 file2 ./file/ # 将 file1、file2 文件复制到同目录下的 file 目录中$ cp -r file ./test/ # 将 file 文件夹及其所有子文件复制到同目录下的 test 文件夹中 硬链接和软链接 硬链接与源文件有着相同的 inode，都指向磁盘中的同一个位置。删除其中一个，并不影响另一个。 软链接与源文件的 inode 不同。软链接保存了源文件的路径，在访问软链接的时候，访问的路径被替换为源文件的路径，因此访问软链接也等同于访问源文件。但是如果删除了源文件，软链接所保存的路径也就无效了，软链接因此也是无效的1。 移动 12345$ # 将 SOURCE 文件移动到 DEST 文件$ mv [OPTION] SOURCE DEST$ # 将 SOURCE 文件移动到 DIRECTORY 目录下，SOURCE 可以为多个文件$ mv [OPTION] SOURCE... DIRECTORY 类似于 Windows 下的剪切。 删除 123456789$ # 删除 FILE 文件，FILE 可以为多个文件。$ # 如果需要删除目录，需要通过 -r 选项递归删除目录$ rm [OPTION] FILE...$ # e.g.$ rm file1 # 删除 file1 文件$ rm -r test/ # 删除 test 目录及其下的所有文件$ rm -rf test1/ test2/ file1.txt # 删除 test1/、test2/、file1.txt 这些文件、目录。其中，这些文件或者目录可能不存在、写保护或者没有权限读写 创建 创建目录 123456$ # 创建一个目录，名为 DIR_NAME$ mkdir [OPTION] DIR_NAME...$ # e.g.$ mkdir test1 test2 # 创建两个目录，名字分别为 test1、test2$ mkdir -p test1/test2/test3/ # 创建路径 test1/test2/test3/ 创建文件 12$ # 创建一个文件，名为 FILE_NAME$ touch FILE_NAME... stat 命令可以显示文件的属性信息。 touch 实际上的功能是修改文件的访问时间（access time, atime）和修改时间（modification time, mtime），可以当作是摸（touch）了一下文件，使得它的访问与修改时间发生了变化。当文件不存在时，touch 会创建新文件。 搜索 1234567$ # 在 PATH（路径）中根据 EXPRESSION（表达式）搜索文件$ find [OPTION] PATH [EXPRESSION]$ # e.g.$ find . -name &apos;report.pdf&apos; # 在当前目录搜索名为 report.pdf 的文件$ find / -size +1G # 全盘搜索大于 1G 的文件$ find ~/ -name &apos;node_modules&apos; -type d # 在用户目录搜索所有名为 node_modules 的文件夹 模式匹配 bash 的匹配模式被称为glob。 123$ # e.g.$ rm *.tar.gz # 删除所有以 tar.gz 结尾的压缩文件$ mv -r *.[ch] /path # 将当前及子目录下所有以 .c 或 .h 结尾的代码移动到 /path 使用通配符前一定要确认输入无误，否则可能出现严重的后果（如 rm -rf * 会删掉当前目录的所有文件）。 压缩与解压缩 使用 tar 操作存档、压缩文件 1234567$ # 命令格式如下，请参考下面的使用样例了解使用方法$ tar [OPTIONS] FILE...$ # e.g.$ tar -c -f target.tar file1 file2 file3 # 将file1、file2、file3 打包为 target.tar$ tar -x -f target.tar -C test/ # 将 target.tar 中的文件提取到 test 目录中$ tar -cz -f target.tar.gz file1 file2 file3 # 将 file1、file2、file3 打包，并使用 gzip 算法压缩，得到压缩文件 target.tar.gz 和大部分 Linux 命令一样，tar 命令可以组合参数。例如，以下命令等价： 123$ tar -c -z -v -f target.tar test/$ tar -czvf target.tar test/$ tar -f target.tar -czv test/ 后缀名并不能决定文件类型，但可以帮助人们辨认这个文件的可能文件类型，从而选择合适的打开方法。 软件的使用文档 man 命令 123$ # 调出 tar 命令和 ls 命令的文档$ man tar$ man ls 会显示软件的每一个参数的含义、退出值含义、作者等内容，大而全。但一般较少带有使用样例，需要根据自身需要拼接软件参数，不利于快速上手。 tldr 软件 通过几个简单的例子让用户可以快速了解软件的使用方法。 1$ tldr COMMAND 注意，如果出现报错： 1mkdir:无法创建目录&quot;/home/lzy/.tldr&quot;：文件已存在 解决办法是： 1234$ sudo apt-get update$ sudo apt-get install tldr$ mkdir -p ~/.tldr/tldr$ sudo git clone https://github.com/tldr-pages/tldr.git ~/.tldr/tldr 附录 Linux 101 - chap 03: 软件安装与文件操作 [1] 阮一峰的网络日志 - 理解inode","link":"/zh-cn/Operating-Files-in-Linux/"},{"title":"命令行","text":"黑客帝国特效好酷。 什么是命令行（shell） 命令行是 Linux 中的一类程序，它接受通过键盘输入的命令，然后把命令交给系统执行，并将命令的输出返回给用户几乎所有的 Linux 发行版都提供了一个叫 Bash 的 shell 程序，是传统 shell 的“增强版” 注意： Windows 系统中路径以反斜杠 \\分隔；类 UNIX 系统中路径以正斜杠 /分隔；类 UNIX 系统也不采用 Windows 下的盘符机制，而是采用统一的根目录 绝对路径 &amp; 相对路径： 123/bin/ls # 绝对路径./file.txt # 相对路径，当前目录下的 file.txt 文件../file.txt # 相对路径，上一级目录（父目录）下的 file.txt 文件 $ 和 # 命令开头的 $代表此命令使用普通用户权限运行 #代表执行命令需要使用 root 权限（最高权限），一般等价于 $ sudo 该命令 命令末尾的 #代表此符号与其后的内容都是注释 123456$ 某条命令命令的输出# 需要使用 root 权限执行的命令$ # 注释 为什么要用命令行 效率 熟悉了命令行之后再加上有自动补全的 shell 程序，使用命令行可以节省大量时间 1$ mv ../source/file.txt ../dest/ # 将file.txt 从 ../source/ 文件夹拖拽到 ../dest/ 文件夹中 自动化脚本 自动执行重复的任务 节省资源 绝大部分服务器为了节省资源都不使用图形界面 高级的系统维护工作 一些高级的系统没有图形界面，维护任务只能通过命令行完成；或者需要手工编写复杂的配置文件 看上去很酷！ 《黑客帝国》特效： 打开终端模拟器 安装cmatrix 1$ sudo apt install cmatrix 使用 cmatrix命令查看特效效果 按下 q键或者 Ctrl + C 组合键退出 简单的 shell 命令 ls: 列出（list）目录的内容 cd: 更改目录（change directory） pwd: 查看当前所在的目录（print working directory） 附录 教程 Linux 101 - 第二章：个性化配置与建站体验","link":"/zh-cn/Shell/"},{"title":"双指针","text":"这个十月，我强迫自己每天做一道LeetCode。虽然中间有几天中断了，但最后还是完成了我的第一个“探索”单元。 对我来说，最有用的一课是一种叫做双指针的神奇技巧。起初我以为它是嵌套的两个for循环，但后来我发现它实际上更有意义，更有用。所以我想把它记录下来。 含义 同时使用两个指针来做迭代。 应用 当你想从两端向中间迭代数组时，你可以使用一个指针从头开始，而另一个指针从尾开始。它们有相同的步长。 123456789101112131415// Reverse Stringclass Solution { public void reverseString(char[] s) { int i = 0; int j = s.length - 1; while (i &lt; j) { char temp = s[i]; s[i] = s[j]; s[j] = temp; i++; j--; } }} 12345678910111213141516171819202122// Two Sum II - Input array is sorted// 给出一个已经按非递减顺序排序的索引到1的整数数组，找出两个数字，使其相加等于一个特定的目标数class Solution { public int[] twoSum(int[] numbers, int target) { int[] res = new int[2]; int start = 0; int end = numbers.length - 1; while (start &lt; end) { if (numbers[start] + numbers[end] == target) { break; } else if (numbers[start] + numbers[end] &lt; target) { start ++; } else { end --; } } res[0] = start + 1; res[1] = end + 1; return res; }} 当你想要一个慢速指针和一个快速指针时，你可以使用一个指针用于迭代，而另一个指针用于标记特殊位置。它们有不同的步长。 123456789101112131415// Remove Element// &quot;i&quot;用于迭代，&quot;k&quot;用于指示要移动的元素class Solution { public int removeElement(int[] nums, int val) { int k = 0; for (int i = 0; i &lt; nums.length; i++) { if (nums[i] != val) { nums[k] = nums[i]; k++; } } return k; }} 这里还介绍了一个重要的概念：原地算法。 原地算法（in-place algorithm，也称“就地算法”）是基本上不需要借助额外的数据结构就能对输入的数据进行变换的算法。不过，分配少量空间给部分辅助变量是被允许的。算法执行过程中，输入的数据往往会被输出结果覆盖。原地算法只能通过替换或交换元素的方式来修改原始的输入。1 123456789101112131415161718// Max Consecutive Ones// &quot;i&quot;用于迭代，&quot;max&quot;用于找最大数class Solution { public int findMaxConsecutiveOnes(int[] nums) { int max = 0; int sum = 0; for (int i = 0; i &lt; nums.length; i++) { sum += nums[i]; if (nums[i] == 0) { sum = 0; } else { max = Math.max(sum, max); } } return max; }} 123456789101112131415// Remove Duplicates from Sorted Array// &quot;i&quot;用于迭代，&quot;j&quot;用于寻找特殊元素class Solution { public int removeDuplicates(int[] nums) { int n = nums.length; int j = 0; for (int i = 1; i &lt; n; i++) { if (nums[j] != nums[i]) { j++; nums[j] = nums[i]; } } return j + 1; }} 1234567891011121314151617181920// Move Zeroes// &quot;i&quot;用于迭代，&quot;k&quot;用于指示非零元素class Solution { public void moveZeroes(int[] nums) { int n = nums.length; int k = 0; for (int i = 0; i &lt; n; i++) { k = i; if (nums[i] == 0) { if (k &lt; n-1) { while (nums[k] == 0 &amp;&amp; k &lt; n-1) {k++; } int temp = nums[i]; nums[i] = nums[k]; nums[k] = temp; } } } }} 我现在的进展：恭喜自己，再接再厉！  附录 题库 LeetCode Explore：Array and String 引用 [1] 维基百科：原地算法","link":"/zh-cn/Two-pointer/"}],"tags":[{"name":"DSP","slug":"DSP","link":"/zh-cn/tags/DSP/"},{"name":"MATLAB","slug":"MATLAB","link":"/zh-cn/tags/MATLAB/"},{"name":"Cadence","slug":"Cadence","link":"/zh-cn/tags/Cadence/"},{"name":"Git","slug":"Git","link":"/zh-cn/tags/Git/"},{"name":"Linux","slug":"Linux","link":"/zh-cn/tags/Linux/"},{"name":"GitHub","slug":"GitHub","link":"/zh-cn/tags/GitHub/"},{"name":"Java","slug":"Java","link":"/zh-cn/tags/Java/"},{"name":"LaTeX","slug":"LaTeX","link":"/zh-cn/tags/LaTeX/"},{"name":"前端","slug":"前端","link":"/zh-cn/tags/%E5%89%8D%E7%AB%AF/"},{"name":"数据结构与算法","slug":"数据结构与算法","link":"/zh-cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"categories":[{"name":"LeetCode","slug":"LeetCode","link":"/zh-cn/categories/LeetCode/"},{"name":"学习","slug":"学习","link":"/zh-cn/categories/%E5%AD%A6%E4%B9%A0/"},{"name":"总结","slug":"总结","link":"/zh-cn/categories/%E6%80%BB%E7%BB%93/"},{"name":"工作","slug":"工作","link":"/zh-cn/categories/%E5%B7%A5%E4%BD%9C/"}]}