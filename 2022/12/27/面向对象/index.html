<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>面向对象 | Meng&#39;s Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/css/highlight.css">

  
  <meta name="description" content="class是对象模板，instance是对象实例 定义class（包含多个字段，field）  1234class Person {    public String name;    public int age;}  创建instance（指向instance的变量都是引用变量）  1Person ming &#x3D; **new** Person();  访问实例变量用变量.字段 一个Java源文">
<meta property="og:type" content="article">
<meta property="og:title" content="面向对象">
<meta property="og:url" content="http://example.com/2022/12/27/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/index.html">
<meta property="og:site_name" content="Meng&#39;s Blog">
<meta property="og:description" content="class是对象模板，instance是对象实例 定义class（包含多个字段，field）  1234class Person {    public String name;    public int age;}  创建instance（指向instance的变量都是引用变量）  1Person ming &#x3D; **new** Person();  访问实例变量用变量.字段 一个Java源文">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2022-12-27T08:46:31.000Z">
<meta property="article:modified_time" content="2022-12-27T08:49:02.924Z">
<meta property="article:author" content="Han Meng">
<meta property="article:tag" content="Java">
<meta name="twitter:card" content="summary"><meta name="generator" content="Hexo 6.3.0">
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
</head>

<body>
  <div id="wrapper">
    <header id="header">
  <h1 id="title">
    <a href="/">Meng&#39;s Blog</a>
  </h1>
  <nav>
    
    
      
      <a class="nav-link" href="/">Home</a>
    
      
        <span class="nav-spacer">×</span>
      
      <a class="nav-link" href="/about/">About</a>
    
      
        <span class="nav-spacer">×</span>
      
      <a class="nav-link" href="/archives">Archives</a>
    
    
  </nav>
</header>

    <div id="content">
      <article id="post-面向对象" class="article article-type-post" itemprop="blogPost" itemscope>
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h2 class="article-title" itemprop="headline name">
      面向对象
    </h2>
  


        <div class="article-meta">
          <time class="article-date" datetime="2022-12-27T08:46:31.000Z" itemprop="datePublished">December 27, 2022, 4:46 PM</time>

          
            × <span class="article-word-count">4k words</span>
            
            × <span class="article-time-to-read">14 minutes</span>
            
          
        </div>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
      
        <ul>
<li>class是对象模板，instance是对象实例</li>
<li>定义class（包含多个字段，<code>field</code>）</li>
</ul>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> {</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> age;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>创建instance（指向<code>instance</code>的变量都是引用变量）</li>
</ul>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Person</span> <span class="variable">ming</span> <span class="operator">=</span> **<span class="keyword">new</span>** Person();</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>访问实例变量用<code>变量.字段</code></li>
<li>一个Java源文件可以包含多个类的定义，但只能定义一个public类，且public类名必须与文件名一致。如果要定义多个public类，必须拆到多个Java源文件中</li>
</ul>
<span id="more"></span>
<h2 id="方法">方法</h2>
<ul>
<li>动机：为了避免外部代码直接去访问<code>field</code>，我们可以用<code>private</code>修饰<code>field</code>，拒绝外部访问，然后使用<code>method</code>来让外部代码可以间接修改<code>field</code>
<ul>
<li>在方法内部，我们有机会检查参数对不对；而外部代码没有任何机会把字段设置成不合理的值</li>
<li>一个类通过定义方法，可以给外部代码暴露一些操作的接口，同时保证内部逻辑一致性</li>
<li>调用方法的语法是<code>实例变量.方法名(参数);</code></li>
</ul>
</li>
<li>定义方法</li>
</ul>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 修饰符 方法返回类型 方法名(方法参数列表) {</span></span><br><span class="line"><span class="comment">//     若干方法语句;</span></span><br><span class="line"><span class="comment">// return 方法返回值;</span></span><br><span class="line"><span class="comment">// }</span></span><br><span class="line"><span class="comment">// 如果没有返回值，返回类型设置为void，可以省略return</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> {</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.name;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>private方法：不允许外部调用，只有类的内部可以调用</li>
<li>this变量：在方法内部，可以使用一个隐含的变量<code>this</code>，它始终指向当前实例。通过<code>this.field</code>就可以访问当前实例的字段
<ul>
<li>如果没有命名冲突，可以省略<code>this</code>；如果局部变量和字段重名，就必须加上<code>this</code></li>
</ul>
</li>
<li>方法参数：0或任意个，用于接收传递给方法的变量值</li>
<li>可变参数：<code>类型…</code>，相当于数组类型
<ul>
<li>可变参数可以保证无法传入<code>null</code></li>
</ul>
</li>
<li>参数绑定
<ul>
<li>基本类型参数的传递，是调用方值的复制。双方各自的后续修改，互不影响</li>
<li>引用类型参数的传递，调用方的变量和接收方的参数变量指向的是同一个对象。双方任意一方对这个对象的修改，都会影响对方（因为指向同一个对象）</li>
</ul>
</li>
</ul>
<h2 id="构造方法">构造方法</h2>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">"Xiao Ming"</span>, <span class="number">15</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> {</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name, <span class="type">int</span> age)</span> {</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.name;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.age;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>实例在创建时通过<code>new</code>操作符会调用其对应的构造方法，构造方法用于初始化实例
<ul>
<li>创建实例实际上是通过构造方法来初始化实例的</li>
<li>构造方法的名称就是类名</li>
<li>构造方法的参数没有限制，在方法内部，也可以编写任意语句。但是，和普通方法相比，构造方法没有返回值（也没有<code>void</code>），调用构造方法，必须用<code>new</code></li>
<li>没有定义构造方法时，编译器会自动创建一个默认的无参数构造方法</li>
<li>没有在构造方法中初始化字段时，引用类型的字段默认是<code>null</code>，数值类型的字段用默认值，<code>int</code>类型默认值是<code>0</code><br>
，布尔类型默认值是<code>false</code></li>
</ul>
</li>
</ul>
<h3 id="多构造方法">多构造方法</h3>
<ul>
<li>可以定义多个构造方法，编译器根据参数自动判断</li>
<li>可以在一个构造方法内部调用另一个构造方法，便于代码复用</li>
</ul>
<h2 id="方法重载">方法重载</h2>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// String类提供了多个重载方法indexof()</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">"Test string"</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n1</span> <span class="operator">=</span> s.indexOf(<span class="string">'t'</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">n2</span> <span class="operator">=</span> s.indexOf(<span class="string">"st"</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">n3</span> <span class="operator">=</span> s.indexOf(<span class="string">"st"</span>, <span class="number">4</span>);</span><br><span class="line">        System.out.println(n1);</span><br><span class="line">        System.out.println(n2);</span><br><span class="line">        System.out.println(n3);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>含义：方法重载是指多个方法的方法名相同，但各自的参数不同</li>
<li>作用：功能类似的方法使用同一名字，更容易记住，调用起来更简单</li>
<li>方法重载的返回值类型通常是相同的</li>
</ul>
<h2 id="继承">继承</h2>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> {</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> {...}</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> {...}</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> {...}</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> {...}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">extends</span> <span class="title class_">Person</span> {</span><br><span class="line">    <span class="comment">// 不要重复name和age字段/方法,</span></span><br><span class="line">    <span class="comment">// 只需要定义新增score字段/方法:</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> score;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getScore</span><span class="params">()</span> { … }</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setScore</span><span class="params">(<span class="type">int</span> score)</span> { … }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>作用：复用代码</li>
<li>使用<code>extends</code>关键字来实现继承</li>
<li>继承树：没有明确写<code>extends</code>的类，编译器会自动加上<code>extends Object</code>
<ul>
<li>任何类，除了<code>Object</code>，都会继承自某个类</li>
<li>一个类有且仅有一个父类。只有<code>Object</code>特殊，它没有父类</li>
</ul>
</li>
<li>子类无法访问父类的<code>private</code>，可以访问父类的<code>protected</code></li>
<li>如果父类没有默认的构造方法，子类就必须显式调用<code>super()</code>并给出参数以便让编译器定位到父类的一个合适的构造方法
<ul>
<li>子类<strong>不会继承</strong>任何父类的构造方法。子类默认的构造方法是编译器自动生成的，不是继承的</li>
</ul>
</li>
</ul>
<h3 id="阻止继承">阻止继承</h3>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title class_">Shape</span> permits Rect, Circle, Triangle {</span><br><span class="line">    ...</span><br><span class="line">}</span><br><span class="line"><span class="comment">// 上述Shape类只允许指定的3个类(Rect, Circle, Triangle)继承它</span></span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>从Java15开始，使用<code>sealed</code>修饰class，并通过<code>permits</code>明确写出能够从该class继承的子类名称
<ul>
<li><code>sealed</code>目前是预览状态，要启用它，必须使用参数<code>--enable-preview</code>和<code>--source 15</code></li>
</ul>
</li>
</ul>
<h3 id="向上转型（upcasting）">向上转型（upcasting）</h3>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>把一个子类型安全地变为更加抽象的父类型
<ul>
<li>例如，继承树是<code>Student &gt; Person &gt; Object</code>，那么可以把<code>Student</code>类型转型为<code>Person</code>，或者更高层次的<code>Object</code></li>
</ul>
</li>
</ul>
<h3 id="向下转型（downcasting）">向下转型（downcasting）</h3>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line"><span class="keyword">if</span> (p <span class="keyword">instanceof</span> Student) {</span><br><span class="line">    <span class="comment">// 只有判断成功才会向下转型:</span></span><br><span class="line">    <span class="type">Student</span> <span class="variable">s</span> <span class="operator">=</span> (Student) p; <span class="comment">// 一定会成功</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>很可能会失败。为了避免出错，使用<code>instanceof</code>先判断一个实例究竟是不是某种类型</li>
<li>从Java 14开始，判断<code>instanceof</code>后，可以直接转型为指定变量，直接使用，避免再次强制转型</li>
</ul>
<h3 id="继承-组合">继承&amp;组合</h3>
<ul>
<li>继承是is关系，组合是has关系</li>
</ul>
<h2 id="多态">多态</h2>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> { … }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">extends</span> <span class="title class_">Person</span> {</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> { … }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Teacher</span> <span class="keyword">extends</span> <span class="title class_">Person</span> {</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> { … }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>含义：针对某个类型的方法调用，其真正执行的方法取决于运行时期实际类型的方法</li>
<li>作用：允许添加更多类型的子类实现功能扩展，却不需要修改基于父类的代码</li>
</ul>
<h3 id="Override">Override</h3>
<ul>
<li>子类可以覆写父类的方法（Override），覆写在子类中改变了父类方法的行为
<ul>
<li>加上<code>@Override</code>可以让编译器帮助检查是否进行了正确的覆写</li>
</ul>
</li>
<li>在子类的覆写方法中，如果要调用父类的被覆写的方法，可以通过<code>super</code>来调用</li>
<li><code>final</code>
<ul>
<li><code>final</code>修饰的方法可以阻止被覆写</li>
<li><code>final</code>修饰的class可以阻止被继承</li>
<li><code>final</code>修饰的field必须在创建对象时初始化，随后不可修改</li>
</ul>
</li>
</ul>
<h2 id="抽象类">抽象类</h2>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Person</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>动机：如果父类的方法本身不需要实现任何功能，仅仅是为了定义方法签名，目的是让子类去覆写它，那么可以把父类的方法声明为抽象方法，本身没有实现任何方法语句</li>
<li>含义：如果一个<code>class</code>定义了方法，但没有具体执行代码，这个方法就是抽象方法，抽象方法用<code>abstract</code>修饰；因为无法执行抽象方法，所以这个类也必须申明为抽象类（abstract class）
<ul>
<li>抽象类无法实例化</li>
</ul>
</li>
<li>作用：抽象类可以强迫子类实现其定义的抽象方法，否则编译会报错。相当于定义了“规范”</li>
</ul>
<h3 id="面向抽象编程">面向抽象编程</h3>
<ul>
<li>上层代码只定义规范</li>
<li>不需要子类就可以实现业务逻辑（正常编译）</li>
<li>具体的业务逻辑由不同的子类实现，调用者并不关心</li>
</ul>
<h2 id="接口">接口</h2>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Person</span> {</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>;</span><br><span class="line">    String <span class="title function_">getName</span><span class="params">()</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>动机：如果一个抽象类没有字段，所有方法全部都是抽象方法，就可以把该抽象类改写为接口
<ul>
<li>接口是比抽象类还要抽象的纯抽象接口，因为它连字段都不能有</li>
</ul>
</li>
<li>使用<code>interface</code>声明一个接口</li>
<li>当一个具体的<code>class</code>去实现一个<code>interface</code>时，需要使用<code>implements</code>关键字；一个类可以实现多个<code>interface</code></li>
<li>接口也是数据类型，适用于向上转型和向下转型</li>
</ul>
<h3 id="接口继承">接口继承</h3>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Hello</span> {</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">hello</span><span class="params">()</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Person</span> <span class="keyword">extends</span> <span class="title class_">Hello</span> {</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>;</span><br><span class="line">    String <span class="title function_">getName</span><span class="params">()</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>使用<code>extends</code></li>
<li>继承关系
<ul>
<li>公共逻辑适合放在<code>abstract class</code>中，具体逻辑放到各个子类，而接口层次代表抽象程度</li>
<li>实例化的对象永远只能是某个具体的子类，但总是通过接口去引用它，因为接口比抽象类更抽象</li>
</ul>
</li>
</ul>
<h3 id="default方法">default方法</h3>
<ul>
<li>接口可以定义<code>default</code>方法</li>
<li>动机：当我们需要给接口新增一个方法时，会涉及到修改全部子类。如果新增的是<code>default</code>方法，那么子类就不必全部修改，只需要在需要覆写的地方去覆写新增方法</li>
<li><code>default</code>方法和抽象类的普通方法的区别：因为<code>interface</code>没有字段，所以<code>default</code>方法无法访问字段，而抽象类的普通方法可以访问实例字段</li>
</ul>
<h2 id="静态字段-静态方法">静态字段&amp;静态方法</h2>
<h3 id="静态字段">静态字段</h3>
<ul>
<li>用<code>static</code>修饰的字段称为静态字段</li>
<li>实例字段&amp;静态字段
<ul>
<li>实例字段在每个实例中都有自己的一个独立“空间”，各个实例的同名字段互不影响</li>
<li>静态字段只有一个共享“空间”，所有实例都会共享该字段</li>
</ul>
</li>
<li>不推荐用<code>实例变量.静态字段</code>去访问静态字段，推荐用类名来访问静态字段
<ul>
<li>可以把静态字段理解为描述<code>class</code>本身的字段（非实例字段）</li>
</ul>
</li>
</ul>
<h3 id="静态方法">静态方法</h3>
<ul>
<li>用<code>static</code>修饰的方法称为静态方法</li>
<li>实例方法&amp;静态方法
<ul>
<li>调用实例方法必须通过一个实例变量</li>
<li>调用静态方法则不需要实例变量，通过类名就可以调用。静态方法类似其它编程语言的函数</li>
</ul>
</li>
<li>调用静态方法不需要实例，无法访问<code>this</code>，但可以访问静态字段和其他静态方法</li>
<li>静态方法常用于工具类（如<code>Arrays.sort()</code>，<code>Math.random()</code> ）和辅助方法（如Java程序的入口<code>main()</code> 就是静态方法）</li>
</ul>
<h3 id="接口的静态字段">接口的静态字段</h3>
<ul>
<li><code>interface</code>可以有静态字段，并且静态字段必须为<code>final</code>类型</li>
<li>因为<code>interface</code>的字段只能是<code>public static final</code>类型，所以可以去掉这些修饰符，简写</li>
</ul>
<h2 id="包">包</h2>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> ming; <span class="comment">// 申明包名ming</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> {</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>在定义<code>class</code>的时候，需要在第一行声明这个<code>class</code>属于哪个包</li>
<li>一个类总是属于某个包（<code>package</code>），类名（比如<code>Person</code>）只是一个简写，真正的完整类名是<code>包名.类名</code>
<ul>
<li>只要包名不同，类就不同</li>
<li>包可以是多层结构，用<code>.</code>隔开</li>
<li>包没有继承关系</li>
<li>没有定义包名的<code>class</code>使用的是默认包，非常容易引起名字冲突，不推荐不写包名的做法</li>
</ul>
</li>
</ul>
<h3 id="包作用域">包作用域</h3>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> hello;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> {</span><br><span class="line">    <span class="comment">// 包作用域:</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">hello</span><span class="params">()</span> {</span><br><span class="line">        System.out.println(<span class="string">"Hello!"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">        p.hello(); <span class="comment">// 可以调用，因为Main和Person在同一个包</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>位于同一个包的类，可以访问包作用域的字段和方法</li>
<li>不用<code>public</code>、<code>protected</code>、<code>private</code>修饰的字段和方法就是包作用域</li>
</ul>
<h3 id="import">import</h3>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Person.java</span></span><br><span class="line"><span class="keyword">package</span> ming;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 导入完整类名:</span></span><br><span class="line"><span class="keyword">import</span> mr.jun.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> {</span><br><span class="line">        <span class="type">Arrays</span> <span class="variable">arrays</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Arrays</span>();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>JDK的核心类使用<code>java.lang</code>包，编译器会自动导入</li>
<li>JDK的其它常用类定义在<code>java.util.*</code>，<code>java.math.*</code>，<code>java.text.*</code>，……</li>
</ul>
<h2 id="作用域">作用域</h2>
<h3 id="public">public</h3>
<ul>
<li>定义为<code>public</code>的<code>class</code>、<code>interface</code>可以被其他任何类访问</li>
<li>定义为<code>public</code>的<code>field</code>、<code>method</code>可以被其他类访问，前提是首先有访问<code>class</code>的权限</li>
<li>如果不确定是否需要<code>public</code>，就不声明为<code>public</code>，即尽可能少地暴露对外的字段和方法</li>
<li>一个<code>.java</code>文件只能包含一个<code>public</code>类，但可以包含多个非<code>public</code>类。如果有<code>public</code>类，文件名必须和<code>public</code>类的名字相同</li>
</ul>
<h3 id="private">private</h3>
<ul>
<li>定义为<code>private</code>的<code>field</code>、<code>method</code>无法被其他类访问</li>
<li><code>private</code>访问权限被限定在<code>class</code>的内部，而且与方法声明顺序<strong>无关</strong>。推荐把<code>private</code>方法放到后面</li>
<li>嵌套类（<code>nested class</code>）拥有访问<code>private</code>的权限</li>
</ul>
<h3 id="protected">protected</h3>
<ul>
<li>作用于继承关系。定义为<code>protected</code>的字段和方法可以被子类访问，以及子类的子类</li>
</ul>
<h3 id="pakage">pakage</h3>
<ul>
<li>包作用域是指一个类允许访问同一个<code>package</code>的没有<code>public</code>、<code>private</code>修饰的<code>class</code>，以及没有<code>public</code>、<code>protected</code>、<code>private</code>修饰的字段和方法</li>
<li>把方法定义为<code>package</code>权限有助于测试</li>
</ul>
<h3 id="局部变量">局部变量</h3>
<ul>
<li>在方法内部定义的变量称为局部变量</li>
<li>局部变量作用域从变量声明处开始到对应的块结束</li>
<li>方法参数也是局部变量</li>
<li>应该尽可能把局部变量的作用域缩小，尽可能延后声明局部变量</li>
</ul>
<h3 id="final">final</h3>
<ul>
<li>可以阻止被继承、阻止被子类覆写、阻止被重新赋值</li>
</ul>
<h2 id="内部类（Nested-Class）">内部类（Nested Class）</h2>
<h3 id="Inner-Class">Inner Class</h3>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">Outer</span> <span class="variable">outer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outer</span>(<span class="string">"Nested"</span>); <span class="comment">// 实例化一个Outer</span></span><br><span class="line">        Outer.<span class="type">Inner</span> <span class="variable">inner</span> <span class="operator">=</span> outer.<span class="keyword">new</span> <span class="title class_">Inner</span>(); <span class="comment">// 实例化一个Inner</span></span><br><span class="line">        inner.hello();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Outer</span> {</span><br><span class="line">		...</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Inner</span> {</span><br><span class="line">        <span class="comment">// 定义了一个Inner Class</span></span><br><span class="line">				...</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>Inner Class的实例不能单独存在，必须依附于一个Outer Class的实例
<ul>
<li>要实例化一个<code>Inner</code>，必须首先创建一个<code>Outer</code>的实例，然后，调用<code>Outer</code>实例的<code>new</code>来创建<code>Inner</code>实例</li>
</ul>
</li>
<li>Inner Class可以修改Outer Class的<code>private</code>字段</li>
<li><code>Outer</code>类被编译为<code>Outer.class</code>，而<code>Inner</code>类被编译为<code>Outer$Inner.class</code></li>
</ul>
<h3 id="Anonymous-Class">Anonymous Class</h3>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Runnable</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Runnable</span>() {</span><br><span class="line">    <span class="comment">// 实现必要的抽象方法...</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>另一种定义Inner Class的方法。它不需要在Outer Class中明确地定义这个Class
<ul>
<li>动机：因为在这里我们不关心类名，比直接定义Inner Class可以少写很多代码</li>
</ul>
</li>
<li>匿名类也可以访问Outer Class的<code>private</code>字段和方法</li>
<li>匿名类被编译为<code>Outer$1.class</code>、<code>Outer$2.class</code>、<code>Outer$3.class</code> …</li>
<li>除了接口外，匿名类也可以继承自普通类</li>
<li>Inner Class和Anonymous Class本质上是相同的，都必须依附于Outer Class的实例，即隐含地持有<code>Outer.this</code>实例，并拥有Outer Class的<code>private</code>访问权限</li>
</ul>
<h3 id="Static-Nested-Class">Static Nested Class</h3>
<ul>
<li>不再依附于<code>Outer</code>的实例，而是一个完全独立的类，因此无法引用<code>Outer.this</code>，但可以访问<code>Outer</code>的<code>private</code>静态字段和静态方法</li>
<li>Static Nested Class是独立类，但拥有Outer Class的<code>private</code>访问权限</li>
</ul>
<h2 id="classpath和jar">classpath和jar</h2>
<ul>
<li>JVM通过环境变量<code>classpath</code>决定搜索<code>class</code>的路径和顺序</li>
<li>不推荐设置系统环境变量<code>classpath</code>，始终建议通过<code>-cp</code>命令传入</li>
<li>jar包相当于目录，可以包含很多<code>.class</code>文件，方便下载和使用</li>
</ul>
<p>（没懂，以后需要时回顾）</p>
<h2 id="class版本">class版本</h2>
<ul>
<li>高版本的JDK可编译输出低版本兼容的class文件，反之可能报错</li>
<li>运行时使用哪个JDK版本，编译时就尽量使用同一版本编译源码</li>
</ul>
<p>（没懂，以后需要时回顾）</p>
<h2 id="模块">模块</h2>
<ul>
<li><code>.class</code>文件是JVM看到的最小可执行文件，而一个大型程序需要编写很多Class，并生成一堆<code>.class</code>文件。<code>jar</code>文件就是<code>class</code>文件的容器，为了方便管理。它并不关心<code>class</code>之间的依赖</li>
<li>从Java 9开始引入了模块（Module），自带“依赖关系”的class容器就是模块，模块以<code>.jmod</code>扩展名标识</li>
<li>只有<code>java.base</code>模块不依赖任何模块，是“根模块”</li>
<li>把一堆class封装为jar仅仅是一个打包的过程，而把一堆class封装为模块则不但需要打包，还需要写入依赖关系，并且可以包含二进制代码（通常是JNI扩展）、支持多版本</li>
<li>模块的作用：声明并管理依赖关系；进一步隔离代码的访问权限</li>
</ul>
<p>（没懂，以后需要时回顾）</p>

      
    </div>
    
    
    <div class="article-category">
      
        <b>Categories:</b>
        <a class="article-category-link" href="/categories/Learning/">Learning</a>, <a class="article-category-link" href="/categories/Learning/Software-Development/">Software Development</a>
      
      
        <br/>
      
      
        <b>Tags:</b>
        <a class="article-tag-none-link" href="/tags/Java/" rel="tag">Java</a>
      
    </div>
    
    
  </div>
</article>

  
<nav id="article-nav" class="article-nav">
  
    <span id="article-nav-newer" class="article-nav-link-wrap newer"></span>
  
  
    <a href="/2022/12/26/Java%E5%85%A5%E9%97%A8/" id="article-nav-older" class="article-nav-link-wrap older">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">
        
          Java入门
        
      </div>
    </a>
  
</nav>




  <script>
  var idcomments_acct = '9d8919a5b096256f25ee7d613644a9f9';
  var idcomments_post_id;
  var idcomments_post_url;
  </script>
  <span id="IDCommentsPostTitle" style="display:none"></span>
  <script type='text/javascript' src='https://www.intensedebate.com/js/genericCommentWrapperV2.js'></script>



    </div>
  </div>
  
  
<link rel="stylesheet" href="/css/comments.css">









<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/assets/hijiki.model.json"},"display":{"superSample":2,"width":150,"height":300,"position":"right","hOffset":0,"vOffset":-20},"mobile":{"show":true,"scale":0.5},"react":{"opacityDefault":0.7,"opacityOnHover":0.2},"log":false});</script></body>
</html>
