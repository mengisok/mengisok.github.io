{"pages":[{"title":"Categories","text":"","link":"/categories/index.html"},{"title":"Notes","text":"Course Notes Digital Signal Processing 数字信号处理 Combinatorial Mathematics 组合数学 Digital Image Analysis 数字图像分析","link":"/Notes/index.html"},{"title":"Codes","text":" I’m on a code journal…","link":"/codes/index.html"},{"title":"About","text":"Hello, I’m Meng. I’m currently studying for my master’s degree, majoring in Electronics. I’m more interested in self-study and thanks to the Internet I can do it. I’m learning everything related to software development and hope to get more involved in open source projects in the future. Find me on GitHub, LinkedIn or send me an e-mail.","link":"/about/index.html"},{"title":"Schedule","text":"Test.","link":"/schedule/index.html"},{"title":"Tags","text":"","link":"/tags/index.html"},{"title":"Sitemap","text":"Test.","link":"/sitemap/index.html"},{"title":"Troubleshooting","text":"Failed to connect to github.com port 443","link":"/troubleshooting/index.html"},{"title":"","text":"PDF.js for NexT Introduce This is a plugin that allows to preview PDF files in the blog pages. If the browser supports embedded PDFs natively, NexT will create a &lt;embed&gt; tag and include the PDF file on your website. Otherwise it will create a &lt;iframe&gt; tag and uses PDF.js by @mozilla to render the pdf file. Follow the guide below to install dependencies. Installation Step 1 → Go to Hexo dir Change dir to Hexo directory. There must be source, themes and other directories: 1234$ cd hexo-site$ ls_config.next.yml db.json package-lock.json scaffolds themes_config.yml node_modules package.json source Step 2 → Get module Install module to source/lib directory: 1$ git clone https://github.com/next-theme/theme-next-pdf source/lib/pdf Step 3 → Set it up Enable module in NexT _config.next.yml file: 12345678# PDF tag# NexT will try to load pdf files natively, if failed, pdf.js will be used.# So, you have to install the dependency of pdf.js if you want to use pdf tag and make it available to all browsers.# See: https://github.com/next-theme/theme-next-pdfpdf: enable: true # Default height height: 500px Find and edit skip_render settings in Hexo _config.yml file: 12skip_render: - lib/**/* Usage In order to embed PDF files in the article, you just need to create an pdf tag with the URL of your local PDF file, e.g. 1{% pdf /path/to/your/file.pdf %} Notice: Do not use cross-origin PDF files, it might be blocked by the CORS policy. Enjoy it! Update 12$ cd hexo-site/source/lib/pdf$ git pull","link":"/lib/pdf/README.html"},{"title":"","text":"/* Copyright 2014 Mozilla Foundation * * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ #PDFBug, #PDFBug input, #PDFBug button, #PDFBug select { font: message-box; } #PDFBug { background-color: rgba(255, 255, 255, 1); border: 1px solid rgba(102, 102, 102, 1); position: fixed; top: 32px; right: 0; bottom: 0; font-size: 10px; padding: 0; width: 300px; } #PDFBug .controls { background: rgba(238, 238, 238, 1); border-bottom: 1px solid rgba(102, 102, 102, 1); padding: 3px; } #PDFBug .panels { bottom: 0; left: 0; overflow: auto; position: absolute; right: 0; top: 27px; } #PDFBug .panels &gt; div { padding: 5px; } #PDFBug button.active { font-weight: bold; } .debuggerShowText, .debuggerHideText:hover { background-color: rgba(255, 255, 0, 1); } #PDFBug .stats { font-family: courier; font-size: 10px; white-space: pre; } #PDFBug .stats .title { font-weight: bold; } #PDFBug table { font-size: 10px; white-space: pre; } #PDFBug table.showText { border-collapse: collapse; text-align: center; } #PDFBug table.showText, #PDFBug table.showText tr, #PDFBug table.showText td { border: 1px solid black; padding: 1px; } #PDFBug table.showText td.advance { color: grey; } #viewer.textLayer-visible .textLayer { opacity: 1; } #viewer.textLayer-visible .canvasWrapper { background-color: rgba(128, 255, 128, 1); } #viewer.textLayer-visible .canvasWrapper canvas { mix-blend-mode: screen; } #viewer.textLayer-visible .textLayer span { background-color: rgba(255, 255, 0, 0.1); color: rgba(0, 0, 0, 1); border: solid 1px rgba(255, 0, 0, 0.5); box-sizing: border-box; } #viewer.textLayer-visible .textLayer span[aria-owns] { background-color: rgba(255, 0, 0, 0.3); } #viewer.textLayer-hover .textLayer span:hover { background-color: rgba(255, 255, 255, 1); color: rgba(0, 0, 0, 1); } #viewer.textLayer-shadow .textLayer span { background-color: rgba(255, 255, 255, 0.6); color: rgba(0, 0, 0, 1); }","link":"/lib/pdf/web/debugger.css"},{"title":"","text":"/* Copyright 2012 Mozilla Foundation * * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ let opMap; const FontInspector = (function FontInspectorClosure() { let fonts; let active = false; const fontAttribute = &quot;data-font-name&quot;; function removeSelection() { const divs = document.querySelectorAll(`span[${fontAttribute}]`); for (const div of divs) { div.className = &quot;&quot;; } } function resetSelection() { const divs = document.querySelectorAll(`span[${fontAttribute}]`); for (const div of divs) { div.className = &quot;debuggerHideText&quot;; } } function selectFont(fontName, show) { const divs = document.querySelectorAll( `span[${fontAttribute}=${fontName}]` ); for (const div of divs) { div.className = show ? &quot;debuggerShowText&quot; : &quot;debuggerHideText&quot;; } } function textLayerClick(e) { if ( !e.target.dataset.fontName || e.target.tagName.toUpperCase() !== &quot;SPAN&quot; ) { return; } const fontName = e.target.dataset.fontName; const selects = document.getElementsByTagName(&quot;input&quot;); for (const select of selects) { if (select.dataset.fontName !== fontName) { continue; } select.checked = !select.checked; selectFont(fontName, select.checked); select.scrollIntoView(); } } return { // Properties/functions needed by PDFBug. id: &quot;FontInspector&quot;, name: &quot;Font Inspector&quot;, panel: null, manager: null, init(pdfjsLib) { const panel = this.panel; const tmp = document.createElement(&quot;button&quot;); tmp.addEventListener(&quot;click&quot;, resetSelection); tmp.textContent = &quot;Refresh&quot;; panel.append(tmp); fonts = document.createElement(&quot;div&quot;); panel.append(fonts); }, cleanup() { fonts.textContent = &quot;&quot;; }, enabled: false, get active() { return active; }, set active(value) { active = value; if (active) { document.body.addEventListener(&quot;click&quot;, textLayerClick, true); resetSelection(); } else { document.body.removeEventListener(&quot;click&quot;, textLayerClick, true); removeSelection(); } }, // FontInspector specific functions. fontAdded(fontObj, url) { function properties(obj, list) { const moreInfo = document.createElement(&quot;table&quot;); for (const entry of list) { const tr = document.createElement(&quot;tr&quot;); const td1 = document.createElement(&quot;td&quot;); td1.textContent = entry; tr.append(td1); const td2 = document.createElement(&quot;td&quot;); td2.textContent = obj[entry].toString(); tr.append(td2); moreInfo.append(tr); } return moreInfo; } const moreInfo = properties(fontObj, [&quot;name&quot;, &quot;type&quot;]); const fontName = fontObj.loadedName; const font = document.createElement(&quot;div&quot;); const name = document.createElement(&quot;span&quot;); name.textContent = fontName; const download = document.createElement(&quot;a&quot;); if (url) { url = /url\\([&apos;&quot;]?([^)&quot;&apos;]+)/.exec(url); download.href = url[1]; } else if (fontObj.data) { download.href = URL.createObjectURL( new Blob([fontObj.data], { type: fontObj.mimetype }) ); } download.textContent = &quot;Download&quot;; const logIt = document.createElement(&quot;a&quot;); logIt.href = &quot;&quot;; logIt.textContent = &quot;Log&quot;; logIt.addEventListener(&quot;click&quot;, function (event) { event.preventDefault(); console.log(fontObj); }); const select = document.createElement(&quot;input&quot;); select.setAttribute(&quot;type&quot;, &quot;checkbox&quot;); select.dataset.fontName = fontName; select.addEventListener(&quot;click&quot;, function () { selectFont(fontName, select.checked); }); font.append(select, name, &quot; &quot;, download, &quot; &quot;, logIt, moreInfo); fonts.append(font); // Somewhat of a hack, should probably add a hook for when the text layer // is done rendering. setTimeout(() =&gt; { if (this.active) { resetSelection(); } }, 2000); }, }; })(); // Manages all the page steppers. const StepperManager = (function StepperManagerClosure() { let steppers = []; let stepperDiv = null; let stepperControls = null; let stepperChooser = null; let breakPoints = Object.create(null); return { // Properties/functions needed by PDFBug. id: &quot;Stepper&quot;, name: &quot;Stepper&quot;, panel: null, manager: null, init(pdfjsLib) { const self = this; stepperControls = document.createElement(&quot;div&quot;); stepperChooser = document.createElement(&quot;select&quot;); stepperChooser.addEventListener(&quot;change&quot;, function (event) { self.selectStepper(this.value); }); stepperControls.append(stepperChooser); stepperDiv = document.createElement(&quot;div&quot;); this.panel.append(stepperControls, stepperDiv); if (sessionStorage.getItem(&quot;pdfjsBreakPoints&quot;)) { breakPoints = JSON.parse(sessionStorage.getItem(&quot;pdfjsBreakPoints&quot;)); } opMap = Object.create(null); for (const key in pdfjsLib.OPS) { opMap[pdfjsLib.OPS[key]] = key; } }, cleanup() { stepperChooser.textContent = &quot;&quot;; stepperDiv.textContent = &quot;&quot;; steppers = []; }, enabled: false, active: false, // Stepper specific functions. create(pageIndex) { const debug = document.createElement(&quot;div&quot;); debug.id = &quot;stepper&quot; + pageIndex; debug.hidden = true; debug.className = &quot;stepper&quot;; stepperDiv.append(debug); const b = document.createElement(&quot;option&quot;); b.textContent = &quot;Page &quot; + (pageIndex + 1); b.value = pageIndex; stepperChooser.append(b); const initBreakPoints = breakPoints[pageIndex] || []; const stepper = new Stepper(debug, pageIndex, initBreakPoints); steppers.push(stepper); if (steppers.length === 1) { this.selectStepper(pageIndex, false); } return stepper; }, selectStepper(pageIndex, selectPanel) { pageIndex |= 0; if (selectPanel) { this.manager.selectPanel(this); } for (const stepper of steppers) { stepper.panel.hidden = stepper.pageIndex !== pageIndex; } for (const option of stepperChooser.options) { option.selected = (option.value | 0) === pageIndex; } }, saveBreakPoints(pageIndex, bps) { breakPoints[pageIndex] = bps; sessionStorage.setItem(&quot;pdfjsBreakPoints&quot;, JSON.stringify(breakPoints)); }, }; })(); // The stepper for each page&apos;s operatorList. const Stepper = (function StepperClosure() { // Shorter way to create element and optionally set textContent. function c(tag, textContent) { const d = document.createElement(tag); if (textContent) { d.textContent = textContent; } return d; } function simplifyArgs(args) { if (typeof args === &quot;string&quot;) { const MAX_STRING_LENGTH = 75; return args.length &lt;= MAX_STRING_LENGTH ? args : args.substring(0, MAX_STRING_LENGTH) + &quot;...&quot;; } if (typeof args !== &quot;object&quot; || args === null) { return args; } if (&quot;length&quot; in args) { // array const MAX_ITEMS = 10, simpleArgs = []; let i, ii; for (i = 0, ii = Math.min(MAX_ITEMS, args.length); i &lt; ii; i++) { simpleArgs.push(simplifyArgs(args[i])); } if (i &lt; args.length) { simpleArgs.push(&quot;...&quot;); } return simpleArgs; } const simpleObj = {}; for (const key in args) { simpleObj[key] = simplifyArgs(args[key]); } return simpleObj; } // eslint-disable-next-line no-shadow class Stepper { constructor(panel, pageIndex, initialBreakPoints) { this.panel = panel; this.breakPoint = 0; this.nextBreakPoint = null; this.pageIndex = pageIndex; this.breakPoints = initialBreakPoints; this.currentIdx = -1; this.operatorListIdx = 0; this.indentLevel = 0; } init(operatorList) { const panel = this.panel; const content = c(&quot;div&quot;, &quot;c=continue, s=step&quot;); const table = c(&quot;table&quot;); content.append(table); table.cellSpacing = 0; const headerRow = c(&quot;tr&quot;); table.append(headerRow); headerRow.append( c(&quot;th&quot;, &quot;Break&quot;), c(&quot;th&quot;, &quot;Idx&quot;), c(&quot;th&quot;, &quot;fn&quot;), c(&quot;th&quot;, &quot;args&quot;) ); panel.append(content); this.table = table; this.updateOperatorList(operatorList); } updateOperatorList(operatorList) { const self = this; function cboxOnClick() { const x = +this.dataset.idx; if (this.checked) { self.breakPoints.push(x); } else { self.breakPoints.splice(self.breakPoints.indexOf(x), 1); } StepperManager.saveBreakPoints(self.pageIndex, self.breakPoints); } const MAX_OPERATORS_COUNT = 15000; if (this.operatorListIdx &gt; MAX_OPERATORS_COUNT) { return; } const chunk = document.createDocumentFragment(); const operatorsToDisplay = Math.min( MAX_OPERATORS_COUNT, operatorList.fnArray.length ); for (let i = this.operatorListIdx; i &lt; operatorsToDisplay; i++) { const line = c(&quot;tr&quot;); line.className = &quot;line&quot;; line.dataset.idx = i; chunk.append(line); const checked = this.breakPoints.includes(i); const args = operatorList.argsArray[i] || []; const breakCell = c(&quot;td&quot;); const cbox = c(&quot;input&quot;); cbox.type = &quot;checkbox&quot;; cbox.className = &quot;points&quot;; cbox.checked = checked; cbox.dataset.idx = i; cbox.onclick = cboxOnClick; breakCell.append(cbox); line.append(breakCell, c(&quot;td&quot;, i.toString())); const fn = opMap[operatorList.fnArray[i]]; let decArgs = args; if (fn === &quot;showText&quot;) { const glyphs = args[0]; const charCodeRow = c(&quot;tr&quot;); const fontCharRow = c(&quot;tr&quot;); const unicodeRow = c(&quot;tr&quot;); for (const glyph of glyphs) { if (typeof glyph === &quot;object&quot; &amp;&amp; glyph !== null) { charCodeRow.append(c(&quot;td&quot;, glyph.originalCharCode)); fontCharRow.append(c(&quot;td&quot;, glyph.fontChar)); unicodeRow.append(c(&quot;td&quot;, glyph.unicode)); } else { // null or number const advanceEl = c(&quot;td&quot;, glyph); advanceEl.classList.add(&quot;advance&quot;); charCodeRow.append(advanceEl); fontCharRow.append(c(&quot;td&quot;)); unicodeRow.append(c(&quot;td&quot;)); } } decArgs = c(&quot;td&quot;); const table = c(&quot;table&quot;); table.classList.add(&quot;showText&quot;); decArgs.append(table); table.append(charCodeRow, fontCharRow, unicodeRow); } else if (fn === &quot;restore&quot;) { this.indentLevel--; } line.append(c(&quot;td&quot;, &quot; &quot;.repeat(this.indentLevel * 2) + fn)); if (fn === &quot;save&quot;) { this.indentLevel++; } if (decArgs instanceof HTMLElement) { line.append(decArgs); } else { line.append(c(&quot;td&quot;, JSON.stringify(simplifyArgs(decArgs)))); } } if (operatorsToDisplay &lt; operatorList.fnArray.length) { const lastCell = c(&quot;td&quot;, &quot;...&quot;); lastCell.colspan = 4; chunk.append(lastCell); } this.operatorListIdx = operatorList.fnArray.length; this.table.append(chunk); } getNextBreakPoint() { this.breakPoints.sort(function (a, b) { return a - b; }); for (const breakPoint of this.breakPoints) { if (breakPoint &gt; this.currentIdx) { return breakPoint; } } return null; } breakIt(idx, callback) { StepperManager.selectStepper(this.pageIndex, true); this.currentIdx = idx; const listener = evt =&gt; { switch (evt.keyCode) { case 83: // step document.removeEventListener(&quot;keydown&quot;, listener); this.nextBreakPoint = this.currentIdx + 1; this.goTo(-1); callback(); break; case 67: // continue document.removeEventListener(&quot;keydown&quot;, listener); this.nextBreakPoint = this.getNextBreakPoint(); this.goTo(-1); callback(); break; } }; document.addEventListener(&quot;keydown&quot;, listener); this.goTo(idx); } goTo(idx) { const allRows = this.panel.getElementsByClassName(&quot;line&quot;); for (const row of allRows) { if ((row.dataset.idx | 0) === idx) { row.style.backgroundColor = &quot;rgb(251,250,207)&quot;; row.scrollIntoView(); } else { row.style.backgroundColor = null; } } } } return Stepper; })(); const Stats = (function Stats() { let stats = []; function clear(node) { node.textContent = &quot;&quot;; // Remove any `node` contents from the DOM. } function getStatIndex(pageNumber) { for (const [i, stat] of stats.entries()) { if (stat.pageNumber === pageNumber) { return i; } } return false; } return { // Properties/functions needed by PDFBug. id: &quot;Stats&quot;, name: &quot;Stats&quot;, panel: null, manager: null, init(pdfjsLib) {}, enabled: false, active: false, // Stats specific functions. add(pageNumber, stat) { if (!stat) { return; } const statsIndex = getStatIndex(pageNumber); if (statsIndex !== false) { stats[statsIndex].div.remove(); stats.splice(statsIndex, 1); } const wrapper = document.createElement(&quot;div&quot;); wrapper.className = &quot;stats&quot;; const title = document.createElement(&quot;div&quot;); title.className = &quot;title&quot;; title.textContent = &quot;Page: &quot; + pageNumber; const statsDiv = document.createElement(&quot;div&quot;); statsDiv.textContent = stat.toString(); wrapper.append(title, statsDiv); stats.push({ pageNumber, div: wrapper }); stats.sort(function (a, b) { return a.pageNumber - b.pageNumber; }); clear(this.panel); for (const entry of stats) { this.panel.append(entry.div); } }, cleanup() { stats = []; clear(this.panel); }, }; })(); // Manages all the debugging tools. const PDFBug = (function PDFBugClosure() { const panelWidth = 300; const buttons = []; let activePanel = null; return { tools: [FontInspector, StepperManager, Stats], enable(ids) { const all = ids.length === 1 &amp;&amp; ids[0] === &quot;all&quot;; const tools = this.tools; for (const tool of tools) { if (all || ids.includes(tool.id)) { tool.enabled = true; } } if (!all) { // Sort the tools by the order they are enabled. tools.sort(function (a, b) { let indexA = ids.indexOf(a.id); indexA = indexA &lt; 0 ? tools.length : indexA; let indexB = ids.indexOf(b.id); indexB = indexB &lt; 0 ? tools.length : indexB; return indexA - indexB; }); } }, init(pdfjsLib, container, ids) { this.loadCSS(); this.enable(ids); /* * Basic Layout: * PDFBug * Controls * Panels * Panel * Panel * ... */ const ui = document.createElement(&quot;div&quot;); ui.id = &quot;PDFBug&quot;; const controls = document.createElement(&quot;div&quot;); controls.setAttribute(&quot;class&quot;, &quot;controls&quot;); ui.append(controls); const panels = document.createElement(&quot;div&quot;); panels.setAttribute(&quot;class&quot;, &quot;panels&quot;); ui.append(panels); container.append(ui); container.style.right = panelWidth + &quot;px&quot;; // Initialize all the debugging tools. for (const tool of this.tools) { const panel = document.createElement(&quot;div&quot;); const panelButton = document.createElement(&quot;button&quot;); panelButton.textContent = tool.name; panelButton.addEventListener(&quot;click&quot;, event =&gt; { event.preventDefault(); this.selectPanel(tool); }); controls.append(panelButton); panels.append(panel); tool.panel = panel; tool.manager = this; if (tool.enabled) { tool.init(pdfjsLib); } else { panel.textContent = `${tool.name} is disabled. To enable add &quot;${tool.id}&quot; to ` + &quot;the pdfBug parameter and refresh (separate multiple by commas).&quot;; } buttons.push(panelButton); } this.selectPanel(0); }, loadCSS() { const { url } = import.meta; const link = document.createElement(&quot;link&quot;); link.rel = &quot;stylesheet&quot;; link.href = url.replace(/.js$/, &quot;.css&quot;); document.head.append(link); }, cleanup() { for (const tool of this.tools) { if (tool.enabled) { tool.cleanup(); } } }, selectPanel(index) { if (typeof index !== &quot;number&quot;) { index = this.tools.indexOf(index); } if (index === activePanel) { return; } activePanel = index; for (const [j, tool] of this.tools.entries()) { const isActive = j === index; buttons[j].classList.toggle(&quot;active&quot;, isActive); tool.active = isActive; tool.panel.hidden = !isActive; } }, }; })(); globalThis.FontInspector = FontInspector; globalThis.StepperManager = StepperManager; globalThis.Stats = Stats; export { PDFBug };","link":"/lib/pdf/web/debugger.js"},{"title":"","text":"/* Copyright 2014 Mozilla Foundation * * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ .textLayer { position: absolute; text-align: initial; left: 0; top: 0; right: 0; bottom: 0; overflow: hidden; opacity: 0.25; line-height: 1; -webkit-text-size-adjust: none; -moz-text-size-adjust: none; text-size-adjust: none; forced-color-adjust: none; } .textLayer span, .textLayer br { color: transparent; position: absolute; white-space: pre; cursor: text; transform-origin: 0% 0%; } /* Only necessary in Google Chrome, see issue 14205, and most unfortunately * the problem doesn&apos;t show up in &quot;text&quot; reference tests. */ .textLayer span.markedContent { top: 0; height: 0; } .textLayer .highlight { margin: -1px; padding: 1px; background-color: rgba(180, 0, 170, 1); border-radius: 4px; } .textLayer .highlight.appended { position: initial; } .textLayer .highlight.begin { border-radius: 4px 0 0 4px; } .textLayer .highlight.end { border-radius: 0 4px 4px 0; } .textLayer .highlight.middle { border-radius: 0; } .textLayer .highlight.selected { background-color: rgba(0, 100, 0, 1); } .textLayer ::-moz-selection { background: blue; background: AccentColor; } .textLayer ::selection { background: blue; background: AccentColor; } /* Avoids https://github.com/mozilla/pdf.js/issues/13840 in Chrome */ .textLayer br::-moz-selection { background: transparent; } .textLayer br::selection { background: transparent; } .textLayer .endOfContent { display: block; position: absolute; left: 0; top: 100%; right: 0; bottom: 0; z-index: -1; cursor: default; -webkit-user-select: none; -moz-user-select: none; user-select: none; } .textLayer .endOfContent.active { top: 0; } :root { --annotation-unfocused-field-background: url(&quot;data:image/svg+xml;charset=UTF-8,&quot;); --input-focus-border-color: Highlight; --input-focus-outline: 1px solid Canvas; --input-unfocused-border-color: transparent; --input-disabled-border-color: transparent; --input-hover-border-color: black; } @media (forced-colors: active) { :root { --input-focus-border-color: CanvasText; --input-unfocused-border-color: ActiveText; --input-disabled-border-color: GrayText; --input-hover-border-color: Highlight; } .annotationLayer .textWidgetAnnotation input:required, .annotationLayer .textWidgetAnnotation textarea:required, .annotationLayer .choiceWidgetAnnotation select:required, .annotationLayer .buttonWidgetAnnotation.checkBox input:required, .annotationLayer .buttonWidgetAnnotation.radioButton input:required { outline: 1.5px solid selectedItem; } } .annotationLayer { position: absolute; top: 0; left: 0; pointer-events: none; transform-origin: 0 0; } .annotationLayer section { position: absolute; text-align: initial; pointer-events: auto; box-sizing: border-box; transform-origin: 0 0; } .annotationLayer .linkAnnotation &gt; a, .annotationLayer .buttonWidgetAnnotation.pushButton &gt; a { position: absolute; font-size: 1em; top: 0; left: 0; width: 100%; height: 100%; } .annotationLayer .buttonWidgetAnnotation.pushButton &gt; canvas { width: 100%; height: 100%; } .annotationLayer .linkAnnotation &gt; a:hover, .annotationLayer .buttonWidgetAnnotation.pushButton &gt; a:hover { opacity: 0.2; background: rgba(255, 255, 0, 1); box-shadow: 0 2px 10px rgba(255, 255, 0, 1); } .annotationLayer .textAnnotation img { position: absolute; cursor: pointer; width: 100%; height: 100%; } .annotationLayer .textWidgetAnnotation input, .annotationLayer .textWidgetAnnotation textarea, .annotationLayer .choiceWidgetAnnotation select, .annotationLayer .buttonWidgetAnnotation.checkBox input, .annotationLayer .buttonWidgetAnnotation.radioButton input { background-image: var(--annotation-unfocused-field-background); border: 2px solid var(--input-unfocused-border-color); box-sizing: border-box; font: calc(9px * var(--scale-factor)) sans-serif; height: 100%; margin: 0; vertical-align: top; width: 100%; } .annotationLayer .textWidgetAnnotation input:required, .annotationLayer .textWidgetAnnotation textarea:required, .annotationLayer .choiceWidgetAnnotation select:required, .annotationLayer .buttonWidgetAnnotation.checkBox input:required, .annotationLayer .buttonWidgetAnnotation.radioButton input:required { outline: 1.5px solid red; } .annotationLayer .choiceWidgetAnnotation select option { padding: 0; } .annotationLayer .buttonWidgetAnnotation.radioButton input { border-radius: 50%; } .annotationLayer .textWidgetAnnotation textarea { resize: none; } .annotationLayer .textWidgetAnnotation input[disabled], .annotationLayer .textWidgetAnnotation textarea[disabled], .annotationLayer .choiceWidgetAnnotation select[disabled], .annotationLayer .buttonWidgetAnnotation.checkBox input[disabled], .annotationLayer .buttonWidgetAnnotation.radioButton input[disabled] { background: none; border: 2px solid var(--input-disabled-border-color); cursor: not-allowed; } .annotationLayer .textWidgetAnnotation input:hover, .annotationLayer .textWidgetAnnotation textarea:hover, .annotationLayer .choiceWidgetAnnotation select:hover, .annotationLayer .buttonWidgetAnnotation.checkBox input:hover, .annotationLayer .buttonWidgetAnnotation.radioButton input:hover { border: 2px solid var(--input-hover-border-color); } .annotationLayer .textWidgetAnnotation input:hover, .annotationLayer .textWidgetAnnotation textarea:hover, .annotationLayer .choiceWidgetAnnotation select:hover, .annotationLayer .buttonWidgetAnnotation.checkBox input:hover { border-radius: 2px; } .annotationLayer .textWidgetAnnotation input:focus, .annotationLayer .textWidgetAnnotation textarea:focus, .annotationLayer .choiceWidgetAnnotation select:focus { background: none; border: 2px solid var(--input-focus-border-color); border-radius: 2px; outline: var(--input-focus-outline); } .annotationLayer .buttonWidgetAnnotation.checkBox :focus, .annotationLayer .buttonWidgetAnnotation.radioButton :focus { background-image: none; background-color: transparent; } .annotationLayer .buttonWidgetAnnotation.checkBox :focus { border: 2px solid var(--input-focus-border-color); border-radius: 2px; outline: var(--input-focus-outline); } .annotationLayer .buttonWidgetAnnotation.radioButton :focus { border: 2px solid var(--input-focus-border-color); outline: var(--input-focus-outline); } .annotationLayer .buttonWidgetAnnotation.checkBox input:checked:before, .annotationLayer .buttonWidgetAnnotation.checkBox input:checked:after, .annotationLayer .buttonWidgetAnnotation.radioButton input:checked:before { background-color: CanvasText; content: &quot;&quot;; display: block; position: absolute; } .annotationLayer .buttonWidgetAnnotation.checkBox input:checked:before, .annotationLayer .buttonWidgetAnnotation.checkBox input:checked:after { height: 80%; left: 45%; width: 1px; } .annotationLayer .buttonWidgetAnnotation.checkBox input:checked:before { transform: rotate(45deg); } .annotationLayer .buttonWidgetAnnotation.checkBox input:checked:after { transform: rotate(-45deg); } .annotationLayer .buttonWidgetAnnotation.radioButton input:checked:before { border-radius: 50%; height: 50%; left: 30%; top: 20%; width: 50%; } .annotationLayer .textWidgetAnnotation input.comb { font-family: monospace; padding-left: 2px; padding-right: 0; } .annotationLayer .textWidgetAnnotation input.comb:focus { /* * Letter spacing is placed on the right side of each character. Hence, the * letter spacing of the last character may be placed outside the visible * area, causing horizontal scrolling. We avoid this by extending the width * when the element has focus and revert this when it loses focus. */ width: 103%; } .annotationLayer .buttonWidgetAnnotation.checkBox input, .annotationLayer .buttonWidgetAnnotation.radioButton input { -webkit-appearance: none; -moz-appearance: none; appearance: none; } .annotationLayer .popupTriggerArea { height: 100%; width: 100%; } .annotationLayer .popupWrapper { position: absolute; font-size: calc(9px * var(--scale-factor)); width: 100%; min-width: calc(180px * var(--scale-factor)); pointer-events: none; } .annotationLayer .popup { position: absolute; max-width: calc(180px * var(--scale-factor)); background-color: rgba(255, 255, 153, 1); box-shadow: 0 calc(2px * var(--scale-factor)) calc(5px * var(--scale-factor)) rgba(136, 136, 136, 1); border-radius: calc(2px * var(--scale-factor)); padding: calc(6px * var(--scale-factor)); margin-left: calc(5px * var(--scale-factor)); cursor: pointer; font: message-box; white-space: normal; word-wrap: break-word; pointer-events: auto; } .annotationLayer .popup &gt; * { font-size: calc(9px * var(--scale-factor)); } .annotationLayer .popup h1 { display: inline-block; } .annotationLayer .popupDate { display: inline-block; margin-left: calc(5px * var(--scale-factor)); } .annotationLayer .popupContent { border-top: 1px solid rgba(51, 51, 51, 1); margin-top: calc(2px * var(--scale-factor)); padding-top: calc(2px * var(--scale-factor)); } .annotationLayer .richText &gt; * { white-space: pre-wrap; font-size: calc(9px * var(--scale-factor)); } .annotationLayer .highlightAnnotation, .annotationLayer .underlineAnnotation, .annotationLayer .squigglyAnnotation, .annotationLayer .strikeoutAnnotation, .annotationLayer .freeTextAnnotation, .annotationLayer .lineAnnotation svg line, .annotationLayer .squareAnnotation svg rect, .annotationLayer .circleAnnotation svg ellipse, .annotationLayer .polylineAnnotation svg polyline, .annotationLayer .polygonAnnotation svg polygon, .annotationLayer .caretAnnotation, .annotationLayer .inkAnnotation svg polyline, .annotationLayer .stampAnnotation, .annotationLayer .fileAttachmentAnnotation { cursor: pointer; } .annotationLayer section svg { position: absolute; width: 100%; height: 100%; } .annotationLayer .annotationTextContent { position: absolute; width: 100%; height: 100%; opacity: 0; color: transparent; -webkit-user-select: none; -moz-user-select: none; user-select: none; pointer-events: none; } .annotationLayer .annotationTextContent span { width: 100%; display: inline-block; } :root { --xfa-unfocused-field-background: url(&quot;data:image/svg+xml;charset=UTF-8,&quot;); --xfa-focus-outline: auto; } @media (forced-colors: active) { :root { --xfa-focus-outline: 2px solid CanvasText; } .xfaLayer *:required { outline: 1.5px solid selectedItem; } } .xfaLayer { background-color: transparent; } .xfaLayer .highlight { margin: -1px; padding: 1px; background-color: rgba(239, 203, 237, 1); border-radius: 4px; } .xfaLayer .highlight.appended { position: initial; } .xfaLayer .highlight.begin { border-radius: 4px 0 0 4px; } .xfaLayer .highlight.end { border-radius: 0 4px 4px 0; } .xfaLayer .highlight.middle { border-radius: 0; } .xfaLayer .highlight.selected { background-color: rgba(203, 223, 203, 1); } .xfaPage { overflow: hidden; position: relative; } .xfaContentarea { position: absolute; } .xfaPrintOnly { display: none; } .xfaLayer { position: absolute; text-align: initial; top: 0; left: 0; transform-origin: 0 0; line-height: 1.2; } .xfaLayer * { color: inherit; font: inherit; font-style: inherit; font-weight: inherit; font-kerning: inherit; letter-spacing: -0.01px; text-align: inherit; text-decoration: inherit; box-sizing: border-box; background-color: transparent; padding: 0; margin: 0; pointer-events: auto; line-height: inherit; } .xfaLayer *:required { outline: 1.5px solid red; } .xfaLayer div { pointer-events: none; } .xfaLayer svg { pointer-events: none; } .xfaLayer svg * { pointer-events: none; } .xfaLayer a { color: blue; } .xfaRich li { margin-left: 3em; } .xfaFont { color: black; font-weight: normal; font-kerning: none; font-size: 10px; font-style: normal; letter-spacing: 0; text-decoration: none; vertical-align: 0; } .xfaCaption { overflow: hidden; flex: 0 0 auto; } .xfaCaptionForCheckButton { overflow: hidden; flex: 1 1 auto; } .xfaLabel { height: 100%; width: 100%; } .xfaLeft { display: flex; flex-direction: row; align-items: center; } .xfaRight { display: flex; flex-direction: row-reverse; align-items: center; } .xfaLeft &gt; .xfaCaption, .xfaLeft &gt; .xfaCaptionForCheckButton, .xfaRight &gt; .xfaCaption, .xfaRight &gt; .xfaCaptionForCheckButton { max-height: 100%; } .xfaTop { display: flex; flex-direction: column; align-items: flex-start; } .xfaBottom { display: flex; flex-direction: column-reverse; align-items: flex-start; } .xfaTop &gt; .xfaCaption, .xfaTop &gt; .xfaCaptionForCheckButton, .xfaBottom &gt; .xfaCaption, .xfaBottom &gt; .xfaCaptionForCheckButton { width: 100%; } .xfaBorder { background-color: transparent; position: absolute; pointer-events: none; } .xfaWrapped { width: 100%; height: 100%; } .xfaTextfield:focus, .xfaSelect:focus { background-image: none; background-color: transparent; outline: var(--xfa-focus-outline); outline-offset: -1px; } .xfaCheckbox:focus, .xfaRadio:focus { outline: var(--xfa-focus-outline); } .xfaTextfield, .xfaSelect { height: 100%; width: 100%; flex: 1 1 auto; border: none; resize: none; background-image: var(--xfa-unfocused-field-background); } .xfaSelect { padding-left: 2px; padding-right: 2px; padding-inline: 2px; } .xfaTop &gt; .xfaTextfield, .xfaTop &gt; .xfaSelect, .xfaBottom &gt; .xfaTextfield, .xfaBottom &gt; .xfaSelect { flex: 0 1 auto; } .xfaButton { cursor: pointer; width: 100%; height: 100%; border: none; text-align: center; } .xfaLink { width: 100%; height: 100%; position: absolute; top: 0; left: 0; } .xfaCheckbox, .xfaRadio { width: 100%; height: 100%; flex: 0 0 auto; border: none; } .xfaRich { white-space: pre-wrap; width: 100%; height: 100%; } .xfaImage { -o-object-position: left top; object-position: left top; -o-object-fit: contain; object-fit: contain; width: 100%; height: 100%; } .xfaLrTb, .xfaRlTb, .xfaTb { display: flex; flex-direction: column; align-items: stretch; } .xfaLr { display: flex; flex-direction: row; align-items: stretch; } .xfaRl { display: flex; flex-direction: row-reverse; align-items: stretch; } .xfaTb &gt; div { justify-content: left; } .xfaPosition { position: relative; } .xfaArea { position: relative; } .xfaValignMiddle { display: flex; align-items: center; } .xfaTable { display: flex; flex-direction: column; align-items: stretch; } .xfaTable .xfaRow { display: flex; flex-direction: row; align-items: stretch; } .xfaTable .xfaRlRow { display: flex; flex-direction: row-reverse; align-items: stretch; flex: 1; } .xfaTable .xfaRlRow &gt; div { flex: 1; } .xfaNonInteractive input, .xfaNonInteractive textarea, .xfaDisabled input, .xfaDisabled textarea, .xfaReadOnly input, .xfaReadOnly textarea { background: initial; } @media print { .xfaTextfield, .xfaSelect { background: transparent; } .xfaSelect { -webkit-appearance: none; -moz-appearance: none; appearance: none; text-indent: 1px; text-overflow: &quot;&quot;; } } :root { --focus-outline: solid 2px blue; --hover-outline: dashed 2px blue; --freetext-line-height: 1.35; --freetext-padding: 2px; --editorInk-editing-cursor: url(images/cursor-editorInk.svg) 0 16; --editorFreeText-editing-cursor: url(images/toolbarButton-editorFreeText.svg) 8 16; } @media (forced-colors: active) { :root { --focus-outline: solid 3px ButtonText; --hover-outline: dashed 3px ButtonText; } } [data-editor-rotation=&quot;90&quot;] { transform: rotate(90deg); } [data-editor-rotation=&quot;180&quot;] { transform: rotate(180deg); } [data-editor-rotation=&quot;270&quot;] { transform: rotate(270deg); } .annotationEditorLayer { background: transparent; position: absolute; top: 0; left: 0; font-size: calc(100px * var(--scale-factor)); transform-origin: 0 0; cursor: auto; z-index: 20000; } .annotationEditorLayer.freeTextEditing { cursor: var(--editorFreeText-editing-cursor), text; } .annotationEditorLayer.inkEditing { cursor: var(--editorInk-editing-cursor), pointer; } .annotationEditorLayer .selectedEditor { outline: var(--focus-outline); resize: none; } .annotationEditorLayer .freeTextEditor { position: absolute; background: transparent; border-radius: 3px; padding: calc(var(--freetext-padding) * var(--scale-factor)); resize: none; width: auto; height: auto; z-index: 1; transform-origin: 0 0; touch-action: none; cursor: auto; } .annotationEditorLayer .freeTextEditor .internal { background: transparent; border: none; top: 0; left: 0; overflow: visible; white-space: nowrap; resize: none; font: 10px sans-serif; line-height: var(--freetext-line-height); } .annotationEditorLayer .freeTextEditor .overlay { position: absolute; display: none; background: transparent; top: 0; left: 0; width: 100%; height: 100%; } .annotationEditorLayer .freeTextEditor .overlay.enabled { display: block; } .annotationEditorLayer .freeTextEditor .internal:empty::before { content: attr(default-content); color: gray; } .annotationEditorLayer .freeTextEditor .internal:focus { outline: none; } .annotationEditorLayer .inkEditor.disabled { resize: none; } .annotationEditorLayer .inkEditor.disabled.selectedEditor { resize: horizontal; } .annotationEditorLayer .freeTextEditor:hover:not(.selectedEditor), .annotationEditorLayer .inkEditor:hover:not(.selectedEditor) { outline: var(--hover-outline); } .annotationEditorLayer .inkEditor { position: absolute; background: transparent; border-radius: 3px; overflow: auto; width: 100%; height: 100%; z-index: 1; transform-origin: 0 0; cursor: auto; } .annotationEditorLayer .inkEditor.editing { resize: none; cursor: inherit; } .annotationEditorLayer .inkEditor .inkEditorCanvas { position: absolute; top: 0; left: 0; width: 100%; height: 100%; touch-action: none; } :root { --viewer-container-height: 0; --pdfViewer-padding-bottom: 0; --page-margin: 1px auto -8px; --page-border: 9px solid transparent; --page-border-image: url(images/shadow.png) 9 9 repeat; --spreadHorizontalWrapped-margin-LR: -3.5px; --scale-factor: 1; } @media screen and (forced-colors: active) { :root { --pdfViewer-padding-bottom: 9px; --page-margin: 8px auto -1px; --page-border: 1px solid CanvasText; --page-border-image: none; --spreadHorizontalWrapped-margin-LR: 3.5px; } } [data-main-rotation=&quot;90&quot;] { transform: rotate(90deg) translateY(-100%); } [data-main-rotation=&quot;180&quot;] { transform: rotate(180deg) translate(-100%, -100%); } [data-main-rotation=&quot;270&quot;] { transform: rotate(270deg) translateX(-100%); } .pdfViewer { padding-bottom: var(--pdfViewer-padding-bottom); } .pdfViewer .canvasWrapper { overflow: hidden; } .pdfViewer .page { direction: ltr; width: 816px; height: 1056px; margin: var(--page-margin); position: relative; overflow: visible; border: var(--page-border); -o-border-image: var(--page-border-image); border-image: var(--page-border-image); background-clip: content-box; background-color: rgba(255, 255, 255, 1); } .pdfViewer .dummyPage { position: relative; width: 0; height: var(--viewer-container-height); } .pdfViewer.removePageBorders .page { margin: 0 auto 10px; border: none; } .pdfViewer.singlePageView { display: inline-block; } .pdfViewer.singlePageView .page { margin: 0; border: none; } .pdfViewer.scrollHorizontal, .pdfViewer.scrollWrapped, .spread { margin-left: 3.5px; margin-right: 3.5px; text-align: center; } .pdfViewer.scrollHorizontal, .spread { white-space: nowrap; } .pdfViewer.removePageBorders, .pdfViewer.scrollHorizontal .spread, .pdfViewer.scrollWrapped .spread { margin-left: 0; margin-right: 0; } .spread .page, .spread .dummyPage, .pdfViewer.scrollHorizontal .page, .pdfViewer.scrollWrapped .page, .pdfViewer.scrollHorizontal .spread, .pdfViewer.scrollWrapped .spread { display: inline-block; vertical-align: middle; } .spread .page, .pdfViewer.scrollHorizontal .page, .pdfViewer.scrollWrapped .page { margin-left: var(--spreadHorizontalWrapped-margin-LR); margin-right: var(--spreadHorizontalWrapped-margin-LR); } .pdfViewer.removePageBorders .spread .page, .pdfViewer.removePageBorders.scrollHorizontal .page, .pdfViewer.removePageBorders.scrollWrapped .page { margin-left: 5px; margin-right: 5px; } .pdfViewer .page canvas { margin: 0; display: block; } .pdfViewer .page canvas[hidden] { display: none; } .pdfViewer .page .loadingIcon { position: absolute; display: block; left: 0; top: 0; right: 0; bottom: 0; background: url(&quot;images/loading-icon.gif&quot;) center no-repeat; } .pdfViewer .page .loadingIcon.notVisible { background: none; } .pdfViewer.enablePermissions .textLayer span { -webkit-user-select: none !important; -moz-user-select: none !important; user-select: none !important; cursor: not-allowed; } .pdfPresentationMode .pdfViewer { padding-bottom: 0; } .pdfPresentationMode .spread { margin: 0; } .pdfPresentationMode .pdfViewer .page { margin: 0 auto; border: 2px solid transparent; } :root { --dir-factor: 1; --sidebar-width: 200px; --sidebar-transition-duration: 200ms; --sidebar-transition-timing-function: ease; --scale-select-width: 140px; --toolbar-icon-opacity: 0.7; --doorhanger-icon-opacity: 0.9; --main-color: rgba(12, 12, 13, 1); --body-bg-color: rgba(237, 237, 240, 1); --progressBar-percent: 0%; --progressBar-end-offset: 0; --progressBar-color: rgba(10, 132, 255, 1); --progressBar-indeterminate-bg-color: rgba(221, 221, 222, 1); --progressBar-indeterminate-blend-color: rgba(116, 177, 239, 1); --scrollbar-color: auto; --scrollbar-bg-color: auto; --toolbar-icon-bg-color: rgba(0, 0, 0, 1); --toolbar-icon-hover-bg-color: rgba(0, 0, 0, 1); --sidebar-narrow-bg-color: rgba(237, 237, 240, 0.9); --sidebar-toolbar-bg-color: rgba(245, 246, 247, 1); --toolbar-bg-color: rgba(249, 249, 250, 1); --toolbar-border-color: rgba(204, 204, 204, 1); --toolbar-box-shadow: 0 1px 0 var(--toolbar-border-color); --toolbar-border-bottom: none; --toolbarSidebar-box-shadow: inset calc(-1px * var(--dir-factor)) 0 0 rgba(0, 0, 0, 0.25), 0 1px 0 rgba(0, 0, 0, 0.15), 0 0 1px rgba(0, 0, 0, 0.1); --toolbarSidebar-border-bottom: none; --button-hover-color: rgba(221, 222, 223, 1); --toggled-btn-color: rgba(0, 0, 0, 1); --toggled-btn-bg-color: rgba(0, 0, 0, 0.3); --toggled-hover-active-btn-color: rgba(0, 0, 0, 0.4); --dropdown-btn-bg-color: rgba(215, 215, 219, 1); --dropdown-btn-border: none; --separator-color: rgba(0, 0, 0, 0.3); --field-color: rgba(6, 6, 6, 1); --field-bg-color: rgba(255, 255, 255, 1); --field-border-color: rgba(187, 187, 188, 1); --treeitem-color: rgba(0, 0, 0, 0.8); --treeitem-hover-color: rgba(0, 0, 0, 0.9); --treeitem-selected-color: rgba(0, 0, 0, 0.9); --treeitem-selected-bg-color: rgba(0, 0, 0, 0.25); --sidebaritem-bg-color: rgba(0, 0, 0, 0.15); --doorhanger-bg-color: rgba(255, 255, 255, 1); --doorhanger-border-color: rgba(12, 12, 13, 0.2); --doorhanger-hover-color: rgba(12, 12, 13, 1); --doorhanger-hover-bg-color: rgba(237, 237, 237, 1); --doorhanger-separator-color: rgba(222, 222, 222, 1); --dialog-button-border: none; --dialog-button-bg-color: rgba(12, 12, 13, 0.1); --dialog-button-hover-bg-color: rgba(12, 12, 13, 0.3); --loading-icon: url(images/loading.svg); --treeitem-expanded-icon: url(images/treeitem-expanded.svg); --treeitem-collapsed-icon: url(images/treeitem-collapsed.svg); --toolbarButton-editorFreeText-icon: url(images/toolbarButton-editorFreeText.svg); --toolbarButton-editorInk-icon: url(images/toolbarButton-editorInk.svg); --toolbarButton-menuArrow-icon: url(images/toolbarButton-menuArrow.svg); --toolbarButton-sidebarToggle-icon: url(images/toolbarButton-sidebarToggle.svg); --toolbarButton-secondaryToolbarToggle-icon: url(images/toolbarButton-secondaryToolbarToggle.svg); --toolbarButton-pageUp-icon: url(images/toolbarButton-pageUp.svg); --toolbarButton-pageDown-icon: url(images/toolbarButton-pageDown.svg); --toolbarButton-zoomOut-icon: url(images/toolbarButton-zoomOut.svg); --toolbarButton-zoomIn-icon: url(images/toolbarButton-zoomIn.svg); --toolbarButton-presentationMode-icon: url(images/toolbarButton-presentationMode.svg); --toolbarButton-print-icon: url(images/toolbarButton-print.svg); --toolbarButton-openFile-icon: url(images/toolbarButton-openFile.svg); --toolbarButton-download-icon: url(images/toolbarButton-download.svg); --toolbarButton-bookmark-icon: url(images/toolbarButton-bookmark.svg); --toolbarButton-viewThumbnail-icon: url(images/toolbarButton-viewThumbnail.svg); --toolbarButton-viewOutline-icon: url(images/toolbarButton-viewOutline.svg); --toolbarButton-viewAttachments-icon: url(images/toolbarButton-viewAttachments.svg); --toolbarButton-viewLayers-icon: url(images/toolbarButton-viewLayers.svg); --toolbarButton-currentOutlineItem-icon: url(images/toolbarButton-currentOutlineItem.svg); --toolbarButton-search-icon: url(images/toolbarButton-search.svg); --findbarButton-previous-icon: url(images/findbarButton-previous.svg); --findbarButton-next-icon: url(images/findbarButton-next.svg); --secondaryToolbarButton-firstPage-icon: url(images/secondaryToolbarButton-firstPage.svg); --secondaryToolbarButton-lastPage-icon: url(images/secondaryToolbarButton-lastPage.svg); --secondaryToolbarButton-rotateCcw-icon: url(images/secondaryToolbarButton-rotateCcw.svg); --secondaryToolbarButton-rotateCw-icon: url(images/secondaryToolbarButton-rotateCw.svg); --secondaryToolbarButton-selectTool-icon: url(images/secondaryToolbarButton-selectTool.svg); --secondaryToolbarButton-handTool-icon: url(images/secondaryToolbarButton-handTool.svg); --secondaryToolbarButton-scrollPage-icon: url(images/secondaryToolbarButton-scrollPage.svg); --secondaryToolbarButton-scrollVertical-icon: url(images/secondaryToolbarButton-scrollVertical.svg); --secondaryToolbarButton-scrollHorizontal-icon: url(images/secondaryToolbarButton-scrollHorizontal.svg); --secondaryToolbarButton-scrollWrapped-icon: url(images/secondaryToolbarButton-scrollWrapped.svg); --secondaryToolbarButton-spreadNone-icon: url(images/secondaryToolbarButton-spreadNone.svg); --secondaryToolbarButton-spreadOdd-icon: url(images/secondaryToolbarButton-spreadOdd.svg); --secondaryToolbarButton-spreadEven-icon: url(images/secondaryToolbarButton-spreadEven.svg); --secondaryToolbarButton-documentProperties-icon: url(images/secondaryToolbarButton-documentProperties.svg); } [dir=&quot;rtl&quot;]:root { --dir-factor: -1; } @media (prefers-color-scheme: dark) { :root { --main-color: rgba(249, 249, 250, 1); --body-bg-color: rgba(42, 42, 46, 1); --progressBar-color: rgba(0, 96, 223, 1); --progressBar-indeterminate-bg-color: rgba(40, 40, 43, 1); --progressBar-indeterminate-blend-color: rgba(20, 68, 133, 1); --scrollbar-color: rgba(121, 121, 123, 1); --scrollbar-bg-color: rgba(35, 35, 39, 1); --toolbar-icon-bg-color: rgba(255, 255, 255, 1); --toolbar-icon-hover-bg-color: rgba(255, 255, 255, 1); --sidebar-narrow-bg-color: rgba(42, 42, 46, 0.9); --sidebar-toolbar-bg-color: rgba(50, 50, 52, 1); --toolbar-bg-color: rgba(56, 56, 61, 1); --toolbar-border-color: rgba(12, 12, 13, 1); --button-hover-color: rgba(102, 102, 103, 1); --toggled-btn-color: rgba(255, 255, 255, 1); --toggled-btn-bg-color: rgba(0, 0, 0, 0.3); --toggled-hover-active-btn-color: rgba(0, 0, 0, 0.4); --dropdown-btn-bg-color: rgba(74, 74, 79, 1); --separator-color: rgba(0, 0, 0, 0.3); --field-color: rgba(250, 250, 250, 1); --field-bg-color: rgba(64, 64, 68, 1); --field-border-color: rgba(115, 115, 115, 1); --treeitem-color: rgba(255, 255, 255, 0.8); --treeitem-hover-color: rgba(255, 255, 255, 0.9); --treeitem-selected-color: rgba(255, 255, 255, 0.9); --treeitem-selected-bg-color: rgba(255, 255, 255, 0.25); --sidebaritem-bg-color: rgba(255, 255, 255, 0.15); --doorhanger-bg-color: rgba(74, 74, 79, 1); --doorhanger-border-color: rgba(39, 39, 43, 1); --doorhanger-hover-color: rgba(249, 249, 250, 1); --doorhanger-hover-bg-color: rgba(93, 94, 98, 1); --doorhanger-separator-color: rgba(92, 92, 97, 1); --dialog-button-bg-color: rgba(92, 92, 97, 1); --dialog-button-hover-bg-color: rgba(115, 115, 115, 1); /* This image is used in elements, which unfortunately means that * the `mask-image` approach used with all of the other images doesn&apos;t work * here; hence why we still have two versions of this particular image. */ --loading-icon: url(images/loading-dark.svg); } } @media screen and (forced-colors: active) { :root { --button-hover-color: Highlight; --doorhanger-hover-bg-color: Highlight; --toolbar-icon-opacity: 1; --toolbar-icon-bg-color: ButtonText; --toolbar-icon-hover-bg-color: ButtonFace; --toolbar-border-color: CanvasText; --toolbar-border-bottom: 1px solid var(--toolbar-border-color); --toolbar-box-shadow: none; --toggled-btn-color: HighlightText; --toggled-btn-bg-color: LinkText; --doorhanger-hover-color: ButtonFace; --doorhanger-border-color-whcm: 1px solid ButtonText; --doorhanger-triangle-opacity-whcm: 0; --dialog-button-border: 1px solid Highlight; --dialog-button-hover-bg-color: Highlight; --dialog-button-hover-color: ButtonFace; --dropdown-btn-border: 1px solid ButtonText; --field-border-color: ButtonText; --main-color: CanvasText; --separator-color: GrayText; --doorhanger-separator-color: GrayText; --toolbarSidebar-box-shadow: none; --toolbarSidebar-border-bottom: 1px solid var(--toolbar-border-color); } } * { padding: 0; margin: 0; } html, body { height: 100%; width: 100%; } body { background-color: var(--body-bg-color); scrollbar-color: var(--scrollbar-color) var(--scrollbar-bg-color); } .hidden, [hidden] { display: none !important; } #viewerContainer.pdfPresentationMode:-webkit-full-screen { top: 0; background-color: rgba(0, 0, 0, 1); width: 100%; height: 100%; overflow: hidden; cursor: none; -webkit-user-select: none; user-select: none; } #viewerContainer.pdfPresentationMode:fullscreen { top: 0; background-color: rgba(0, 0, 0, 1); width: 100%; height: 100%; overflow: hidden; cursor: none; -webkit-user-select: none; -moz-user-select: none; user-select: none; } .pdfPresentationMode:-webkit-full-screen a:not(.internalLink) { display: none; } .pdfPresentationMode:fullscreen a:not(.internalLink) { display: none; } .pdfPresentationMode:-webkit-full-screen .textLayer span { cursor: none; } .pdfPresentationMode:fullscreen .textLayer span { cursor: none; } .pdfPresentationMode.pdfPresentationModeControls &gt; *, .pdfPresentationMode.pdfPresentationModeControls .textLayer span { cursor: default; } #outerContainer { width: 100%; height: 100%; position: relative; } [dir=&quot;ltr&quot;] #sidebarContainer { left: calc(-1 * var(--sidebar-width)); } [dir=&quot;rtl&quot;] #sidebarContainer { right: calc(-1 * var(--sidebar-width)); } [dir=&quot;ltr&quot;] #sidebarContainer { border-right: var(--doorhanger-border-color-whcm); } [dir=&quot;rtl&quot;] #sidebarContainer { border-left: var(--doorhanger-border-color-whcm); } [dir=&quot;ltr&quot;] #sidebarContainer { transition-property: left; } [dir=&quot;rtl&quot;] #sidebarContainer { transition-property: right; } #sidebarContainer { position: absolute; top: 32px; bottom: 0; inset-inline-start: calc(-1 * var(--sidebar-width)); width: var(--sidebar-width); visibility: hidden; z-index: 100; font: message-box; border-top: 1px solid rgba(51, 51, 51, 1); -webkit-border-end: var(--doorhanger-border-color-whcm); border-inline-end: var(--doorhanger-border-color-whcm); transition-property: inset-inline-start; transition-duration: var(--sidebar-transition-duration); transition-timing-function: var(--sidebar-transition-timing-function); } #outerContainer.sidebarMoving #sidebarContainer, #outerContainer.sidebarOpen #sidebarContainer { visibility: visible; } [dir=&quot;ltr&quot;] #outerContainer.sidebarOpen #sidebarContainer { left: 0; } [dir=&quot;rtl&quot;] #outerContainer.sidebarOpen #sidebarContainer { right: 0; } #outerContainer.sidebarOpen #sidebarContainer { inset-inline-start: 0; } #mainContainer { position: absolute; top: 0; right: 0; bottom: 0; left: 0; min-width: 350px; } [dir=&quot;ltr&quot;] #sidebarContent { left: 0; } [dir=&quot;rtl&quot;] #sidebarContent { right: 0; } #sidebarContent { top: 32px; bottom: 0; inset-inline-start: 0; overflow: auto; position: absolute; width: 100%; background-color: rgba(0, 0, 0, 0.1); box-shadow: inset calc(-1px * var(--dir-factor)) 0 0 rgba(0, 0, 0, 0.25); } #viewerContainer { overflow: auto; position: absolute; top: 32px; right: 0; bottom: 0; left: 0; outline: none; } #viewerContainer:not(.pdfPresentationMode) { transition-duration: var(--sidebar-transition-duration); transition-timing-function: var(--sidebar-transition-timing-function); } [dir=&quot;ltr&quot;] #outerContainer.sidebarOpen #viewerContainer:not(.pdfPresentationMode) { left: var(--sidebar-width); } [dir=&quot;rtl&quot;] #outerContainer.sidebarOpen #viewerContainer:not(.pdfPresentationMode) { right: var(--sidebar-width); } [dir=&quot;ltr&quot;] #outerContainer.sidebarOpen #viewerContainer:not(.pdfPresentationMode) { transition-property: left; } [dir=&quot;rtl&quot;] #outerContainer.sidebarOpen #viewerContainer:not(.pdfPresentationMode) { transition-property: right; } #outerContainer.sidebarOpen #viewerContainer:not(.pdfPresentationMode) { inset-inline-start: var(--sidebar-width); transition-property: inset-inline-start; } .toolbar { position: relative; left: 0; right: 0; z-index: 9999; cursor: default; font: message-box; } .toolbar input, .toolbar button, .toolbar select, .secondaryToolbar input, .secondaryToolbar button, .secondaryToolbar select, .editorParamsToolbar input, .editorParamsToolbar button, .editorParamsToolbar select, .findbar input, .findbar button, .findbar select, #sidebarContainer input, #sidebarContainer button, #sidebarContainer select { outline: none; font: message-box; } #toolbarContainer { width: 100%; } #toolbarSidebar { width: 100%; height: 32px; background-color: var(--sidebar-toolbar-bg-color); box-shadow: var(--toolbarSidebar-box-shadow); border-bottom: var(--toolbarSidebar-border-bottom); } [dir=&quot;ltr&quot;] #sidebarResizer { right: -6px; } [dir=&quot;rtl&quot;] #sidebarResizer { left: -6px; } #sidebarResizer { position: absolute; top: 0; bottom: 0; inset-inline-end: -6px; width: 6px; z-index: 200; cursor: ew-resize; } #toolbarContainer, .findbar, .secondaryToolbar, .editorParamsToolbar { position: relative; height: 32px; background-color: var(--toolbar-bg-color); box-shadow: var(--toolbar-box-shadow); border-bottom: var(--toolbar-border-bottom); } #toolbarViewer { height: 32px; } [dir=&quot;ltr&quot;] #loadingBar { left: 0; right: var(--progressBar-end-offset); } [dir=&quot;rtl&quot;] #loadingBar { right: 0; left: var(--progressBar-end-offset); } [dir=&quot;ltr&quot;] #loadingBar { transition-property: left; } [dir=&quot;rtl&quot;] #loadingBar { transition-property: right; } #loadingBar { position: absolute; inset-inline: 0 var(--progressBar-end-offset); height: 4px; background-color: var(--body-bg-color); border-bottom: 1px solid var(--toolbar-border-color); transition-property: inset-inline-start; transition-duration: var(--sidebar-transition-duration); transition-timing-function: var(--sidebar-transition-timing-function); } [dir=&quot;ltr&quot;] #outerContainer.sidebarOpen #loadingBar { left: var(--sidebar-width); } [dir=&quot;rtl&quot;] #outerContainer.sidebarOpen #loadingBar { right: var(--sidebar-width); } #outerContainer.sidebarOpen #loadingBar { inset-inline-start: var(--sidebar-width); } #loadingBar .progress { position: absolute; top: 0; left: 0; width: 100%; transform: scaleX(var(--progressBar-percent)); transform-origin: 0 0; height: 100%; background-color: var(--progressBar-color); overflow: hidden; transition: transform 200ms; } @keyframes progressIndeterminate { 0% { transform: translateX(-142px); } 100% { transform: translateX(0); } } #loadingBar.indeterminate .progress { transform: none; background-color: var(--progressBar-indeterminate-bg-color); transition: none; } #loadingBar.indeterminate .progress .glimmer { position: absolute; top: 0; left: 0; height: 100%; width: calc(100% + 150px); background: repeating-linear-gradient( 135deg, var(--progressBar-indeterminate-blend-color) 0, var(--progressBar-indeterminate-bg-color) 5px, var(--progressBar-indeterminate-bg-color) 45px, var(--progressBar-color) 55px, var(--progressBar-color) 95px, var(--progressBar-indeterminate-blend-color) 100px ); animation: progressIndeterminate 1s linear infinite; } #outerContainer.sidebarResizing #sidebarContainer, #outerContainer.sidebarResizing #viewerContainer, #outerContainer.sidebarResizing #loadingBar { /* Improve responsiveness and avoid visual glitches when the sidebar is resized. */ transition-duration: 0s; } .findbar, .secondaryToolbar, .editorParamsToolbar { top: 32px; position: absolute; z-index: 30000; height: auto; padding: 0 4px; margin: 4px 2px; font: message-box; font-size: 12px; line-height: 14px; text-align: left; cursor: default; } [dir=&quot;ltr&quot;] .findbar { left: 64px; } [dir=&quot;rtl&quot;] .findbar { right: 64px; } .findbar { inset-inline-start: 64px; min-width: 300px; background-color: var(--toolbar-bg-color); } .findbar &gt; div { height: 32px; } [dir=&quot;ltr&quot;] .findbar &gt; div#findbarInputContainer { margin-right: 4px; } [dir=&quot;rtl&quot;] .findbar &gt; div#findbarInputContainer { margin-left: 4px; } .findbar &gt; div#findbarInputContainer { -webkit-margin-end: 4px; margin-inline-end: 4px; } .findbar.wrapContainers &gt; div, .findbar.wrapContainers &gt; div#findbarMessageContainer &gt; * { clear: both; } .findbar.wrapContainers &gt; div#findbarMessageContainer { height: auto; } .findbar input[type=&quot;checkbox&quot;] { pointer-events: none; } .findbar label { -webkit-user-select: none; -moz-user-select: none; user-select: none; } .findbar label:hover, .findbar input:focus-visible + label { color: var(--toggled-btn-color); background-color: var(--button-hover-color); } .findbar .toolbarField[type=&quot;checkbox&quot;]:checked + .toolbarLabel { background-color: var(--toggled-btn-bg-color) !important; color: var(--toggled-btn-color); } #findInput { width: 200px; } #findInput::-moz-placeholder { font-style: normal; } #findInput::placeholder { font-style: normal; } #findInput[data-status=&quot;pending&quot;] { background-image: var(--loading-icon); background-repeat: no-repeat; background-position: calc(50% + 48% * var(--dir-factor)); } #findInput[data-status=&quot;notFound&quot;] { background-color: rgba(255, 102, 102, 1); } [dir=&quot;ltr&quot;] .secondaryToolbar,[dir=&quot;ltr&quot;] .editorParamsToolbar { right: 4px; } [dir=&quot;rtl&quot;] .secondaryToolbar,[dir=&quot;rtl&quot;] .editorParamsToolbar { left: 4px; } .secondaryToolbar, .editorParamsToolbar { padding: 6px 0 10px; inset-inline-end: 4px; height: auto; background-color: var(--doorhanger-bg-color); } .editorParamsToolbarContainer { width: 220px; margin-bottom: -4px; } .editorParamsToolbarContainer &gt; .editorParamsSetter { min-height: 26px; display: flex; align-items: center; justify-content: space-between; padding-left: 10px; padding-right: 10px; padding-inline: 10px; } [dir=&quot;ltr&quot;] .editorParamsToolbarContainer .editorParamsLabel { padding-right: 10px; } [dir=&quot;rtl&quot;] .editorParamsToolbarContainer .editorParamsLabel { padding-left: 10px; } .editorParamsToolbarContainer .editorParamsLabel { -webkit-padding-end: 10px; padding-inline-end: 10px; flex: none; color: var(--main-color); } .editorParamsToolbarContainer .editorParamsColor { width: 32px; height: 32px; flex: none; } .editorParamsToolbarContainer .editorParamsSlider { background-color: transparent; width: 90px; flex: 0 1 0; } .editorParamsToolbarContainer .editorParamsSlider::-moz-range-progress { background-color: black; } .editorParamsToolbarContainer .editorParamsSlider::-webkit-slider-runnable-track, .editorParamsToolbarContainer .editorParamsSlider::-moz-range-track { background-color: black; } .editorParamsToolbarContainer .editorParamsSlider::-webkit-slider-thumb, .editorParamsToolbarContainer .editorParamsSlider::-moz-range-thumb { background-color: white; } #secondaryToolbarButtonContainer { max-width: 220px; min-height: 26px; max-height: calc(var(--viewer-container-height) - 40px); overflow-y: auto; margin-bottom: -4px; } [dir=&quot;ltr&quot;] #editorInkParamsToolbar { right: 40px; } [dir=&quot;rtl&quot;] #editorInkParamsToolbar { left: 40px; } #editorInkParamsToolbar { inset-inline-end: 40px; background-color: var(--toolbar-bg-color); } [dir=&quot;ltr&quot;] #editorFreeTextParamsToolbar { right: 68px; } [dir=&quot;rtl&quot;] #editorFreeTextParamsToolbar { left: 68px; } #editorFreeTextParamsToolbar { inset-inline-end: 68px; background-color: var(--toolbar-bg-color); } .doorHanger, .doorHangerRight { border-radius: 2px; box-shadow: 0 1px 5px var(--doorhanger-border-color), 0 0 0 1px var(--doorhanger-border-color); border: var(--doorhanger-border-color-whcm); } .doorHanger:after, .doorHanger:before, .doorHangerRight:after, .doorHangerRight:before { bottom: 100%; border: 8px solid rgba(0, 0, 0, 0); content: &quot; &quot;; height: 0; width: 0; position: absolute; pointer-events: none; opacity: var(--doorhanger-triangle-opacity-whcm); } [dir=&quot;ltr&quot;] .doorHanger:after { left: 10px; } [dir=&quot;rtl&quot;] .doorHanger:after { right: 10px; } [dir=&quot;ltr&quot;] .doorHanger:after { margin-left: -8px; } [dir=&quot;rtl&quot;] .doorHanger:after { margin-right: -8px; } .doorHanger:after { inset-inline-start: 10px; -webkit-margin-start: -8px; margin-inline-start: -8px; border-bottom-color: var(--toolbar-bg-color); } [dir=&quot;ltr&quot;] .doorHangerRight:after { right: 10px; } [dir=&quot;rtl&quot;] .doorHangerRight:after { left: 10px; } [dir=&quot;ltr&quot;] .doorHangerRight:after { margin-right: -8px; } [dir=&quot;rtl&quot;] .doorHangerRight:after { margin-left: -8px; } .doorHangerRight:after { inset-inline-end: 10px; -webkit-margin-end: -8px; margin-inline-end: -8px; border-bottom-color: var(--doorhanger-bg-color); } .doorHanger:before, .doorHangerRight:before { border-bottom-color: var(--doorhanger-border-color); border-width: 9px; } [dir=&quot;ltr&quot;] .doorHanger:before { left: 10px; } [dir=&quot;rtl&quot;] .doorHanger:before { right: 10px; } [dir=&quot;ltr&quot;] .doorHanger:before { margin-left: -9px; } [dir=&quot;rtl&quot;] .doorHanger:before { margin-right: -9px; } .doorHanger:before { inset-inline-start: 10px; -webkit-margin-start: -9px; margin-inline-start: -9px; } [dir=&quot;ltr&quot;] .doorHangerRight:before { right: 10px; } [dir=&quot;rtl&quot;] .doorHangerRight:before { left: 10px; } [dir=&quot;ltr&quot;] .doorHangerRight:before { margin-right: -9px; } [dir=&quot;rtl&quot;] .doorHangerRight:before { margin-left: -9px; } .doorHangerRight:before { inset-inline-end: 10px; -webkit-margin-end: -9px; margin-inline-end: -9px; } #findResultsCount { background-color: rgba(217, 217, 217, 1); color: rgba(82, 82, 82, 1); text-align: center; padding: 4px 5px; margin: 5px; } #findMsg { color: rgba(251, 0, 0, 1); } #findResultsCount:empty, #findMsg:empty { display: none; } #toolbarViewerMiddle { position: absolute; left: 50%; transform: translateX(-50%); } [dir=&quot;ltr&quot;] #toolbarViewerLeft,[dir=&quot;ltr&quot;] #toolbarSidebarLeft { float: left; } [dir=&quot;rtl&quot;] #toolbarViewerLeft,[dir=&quot;rtl&quot;] #toolbarSidebarLeft { float: right; } #toolbarViewerLeft, #toolbarSidebarLeft { float: inline-start; } [dir=&quot;ltr&quot;] #toolbarViewerRight,[dir=&quot;ltr&quot;] #toolbarSidebarRight { float: right; } [dir=&quot;rtl&quot;] #toolbarViewerRight,[dir=&quot;rtl&quot;] #toolbarSidebarRight { float: left; } #toolbarViewerRight, #toolbarSidebarRight { float: inline-end; } [dir=&quot;ltr&quot;] #toolbarViewerLeft &gt; *,[dir=&quot;ltr&quot;] #toolbarViewerMiddle &gt; *,[dir=&quot;ltr&quot;] #toolbarViewerRight &gt; *,[dir=&quot;ltr&quot;] #toolbarSidebarLeft *,[dir=&quot;ltr&quot;] #toolbarSidebarRight *,[dir=&quot;ltr&quot;] .findbar * { float: left; } [dir=&quot;rtl&quot;] #toolbarViewerLeft &gt; *,[dir=&quot;rtl&quot;] #toolbarViewerMiddle &gt; *,[dir=&quot;rtl&quot;] #toolbarViewerRight &gt; *,[dir=&quot;rtl&quot;] #toolbarSidebarLeft *,[dir=&quot;rtl&quot;] #toolbarSidebarRight *,[dir=&quot;rtl&quot;] .findbar * { float: right; } #toolbarViewerLeft &gt; *, #toolbarViewerMiddle &gt; *, #toolbarViewerRight &gt; *, #toolbarSidebarLeft *, #toolbarSidebarRight *, .findbar * { position: relative; float: inline-start; } [dir=&quot;ltr&quot;] #toolbarViewerLeft { padding-left: 1px; } [dir=&quot;rtl&quot;] #toolbarViewerLeft { padding-right: 1px; } #toolbarViewerLeft { -webkit-padding-start: 1px; padding-inline-start: 1px; } [dir=&quot;ltr&quot;] #toolbarViewerRight { padding-right: 1px; } [dir=&quot;rtl&quot;] #toolbarViewerRight { padding-left: 1px; } #toolbarViewerRight { -webkit-padding-end: 1px; padding-inline-end: 1px; } [dir=&quot;ltr&quot;] #toolbarSidebarRight { padding-right: 2px; } [dir=&quot;rtl&quot;] #toolbarSidebarRight { padding-left: 2px; } #toolbarSidebarRight { -webkit-padding-end: 2px; padding-inline-end: 2px; } .splitToolbarButton { margin: 2px; display: inline-block; } [dir=&quot;ltr&quot;] .splitToolbarButton &gt; .toolbarButton { float: left; } [dir=&quot;rtl&quot;] .splitToolbarButton &gt; .toolbarButton { float: right; } .splitToolbarButton &gt; .toolbarButton { float: inline-start; } .toolbarButton, .secondaryToolbarButton, .dialogButton { border: none; background: none; width: 28px; height: 28px; outline: none; } .dialogButton:hover, .dialogButton:focus-visible { background-color: var(--dialog-button-hover-bg-color); } .dialogButton:hover &gt; span, .dialogButton:focus-visible &gt; span { color: var(--dialog-button-hover-color); } .toolbarButton &gt; span { display: inline-block; width: 0; height: 0; overflow: hidden; } .toolbarButton[disabled], .secondaryToolbarButton[disabled], .dialogButton[disabled] { opacity: 0.5; } .splitToolbarButton &gt; .toolbarButton:hover, .splitToolbarButton &gt; .toolbarButton:focus-visible, .dropdownToolbarButton:hover { background-color: var(--button-hover-color); } .splitToolbarButton &gt; .toolbarButton { position: relative; margin: 0; } [dir=&quot;ltr&quot;] #toolbarSidebar .splitToolbarButton &gt; .toolbarButton { margin-right: 2px; } [dir=&quot;rtl&quot;] #toolbarSidebar .splitToolbarButton &gt; .toolbarButton { margin-left: 2px; } #toolbarSidebar .splitToolbarButton &gt; .toolbarButton { -webkit-margin-end: 2px; margin-inline-end: 2px; } [dir=&quot;ltr&quot;] .splitToolbarButtonSeparator { float: left; } [dir=&quot;rtl&quot;] .splitToolbarButtonSeparator { float: right; } .splitToolbarButtonSeparator { float: inline-start; margin: 4px 0; width: 1px; height: 20px; background-color: var(--separator-color); } .toolbarButton, .dropdownToolbarButton, .secondaryToolbarButton, .dialogButton { min-width: 16px; margin: 2px 1px; padding: 2px 6px 0; border: none; border-radius: 2px; color: var(--main-color); font-size: 12px; line-height: 14px; -webkit-user-select: none; -moz-user-select: none; user-select: none; cursor: default; box-sizing: border-box; } .toolbarButton:hover, .toolbarButton:focus-visible { background-color: var(--button-hover-color); } .secondaryToolbarButton:hover, .secondaryToolbarButton:focus-visible { background-color: var(--doorhanger-hover-bg-color); color: var(--doorhanger-hover-color); } .toolbarButton.toggled, .splitToolbarButton.toggled &gt; .toolbarButton.toggled, .secondaryToolbarButton.toggled { background-color: var(--toggled-btn-bg-color); color: var(--toggled-btn-color); } .toolbarButton.toggled::before, .secondaryToolbarButton.toggled::before { background-color: var(--toggled-btn-color); } .toolbarButton.toggled:hover:active, .splitToolbarButton.toggled &gt; .toolbarButton.toggled:hover:active, .secondaryToolbarButton.toggled:hover:active { background-color: var(--toggled-hover-active-btn-color); } .dropdownToolbarButton { width: var(--scale-select-width); padding: 0; background-color: var(--dropdown-btn-bg-color); border: var(--dropdown-btn-border); } [dir=&quot;ltr&quot;] .dropdownToolbarButton::after { right: 6px; } [dir=&quot;rtl&quot;] .dropdownToolbarButton::after { left: 6px; } .dropdownToolbarButton::after { top: 6px; inset-inline-end: 6px; pointer-events: none; -webkit-mask-image: var(--toolbarButton-menuArrow-icon); mask-image: var(--toolbarButton-menuArrow-icon); } [dir=&quot;ltr&quot;] .dropdownToolbarButton &gt; select { padding-left: 6px; } [dir=&quot;rtl&quot;] .dropdownToolbarButton &gt; select { padding-right: 6px; } .dropdownToolbarButton &gt; select { -webkit-appearance: none; -moz-appearance: none; appearance: none; width: inherit; height: 28px; font-size: 12px; color: var(--main-color); margin: 0; padding: 1px 0 2px; -webkit-padding-start: 6px; padding-inline-start: 6px; border: none; background-color: var(--dropdown-btn-bg-color); } .dropdownToolbarButton &gt; select:hover, .dropdownToolbarButton &gt; select:focus-visible { background-color: var(--button-hover-color); color: var(--toggled-btn-color); } .dropdownToolbarButton &gt; select &gt; option { background: var(--doorhanger-bg-color); color: var(--main-color); } .toolbarButtonSpacer { width: 30px; display: inline-block; height: 1px; } .toolbarButton::before, .secondaryToolbarButton::before, .dropdownToolbarButton::after, .treeItemToggler::before { /* All matching images have a size of 16x16 * All relevant containers have a size of 28x28 */ position: absolute; display: inline-block; width: 16px; height: 16px; content: &quot;&quot;; background-color: var(--toolbar-icon-bg-color); -webkit-mask-size: cover; mask-size: cover; } .dropdownToolbarButton:hover::after, .dropdownToolbarButton:focus-visible::after, .dropdownToolbarButton:active::after { background-color: var(--toolbar-icon-hover-bg-color); } .toolbarButton::before { opacity: var(--toolbar-icon-opacity); top: 6px; left: 6px; } .toolbarButton:hover::before, .toolbarButton:focus-visible::before, .secondaryToolbarButton:hover::before, .secondaryToolbarButton:focus-visible::before { background-color: var(--toolbar-icon-hover-bg-color); } [dir=&quot;ltr&quot;] .secondaryToolbarButton::before { left: 12px; } [dir=&quot;rtl&quot;] .secondaryToolbarButton::before { right: 12px; } .secondaryToolbarButton::before { opacity: var(--doorhanger-icon-opacity); top: 5px; inset-inline-start: 12px; } #sidebarToggle::before { -webkit-mask-image: var(--toolbarButton-sidebarToggle-icon); mask-image: var(--toolbarButton-sidebarToggle-icon); transform: scaleX(var(--dir-factor)); } #secondaryToolbarToggle::before { -webkit-mask-image: var(--toolbarButton-secondaryToolbarToggle-icon); mask-image: var(--toolbarButton-secondaryToolbarToggle-icon); transform: scaleX(var(--dir-factor)); } #findPrevious::before { -webkit-mask-image: var(--findbarButton-previous-icon); mask-image: var(--findbarButton-previous-icon); } #findNext::before { -webkit-mask-image: var(--findbarButton-next-icon); mask-image: var(--findbarButton-next-icon); } #previous::before { -webkit-mask-image: var(--toolbarButton-pageUp-icon); mask-image: var(--toolbarButton-pageUp-icon); } #next::before { -webkit-mask-image: var(--toolbarButton-pageDown-icon); mask-image: var(--toolbarButton-pageDown-icon); } #zoomOut::before { -webkit-mask-image: var(--toolbarButton-zoomOut-icon); mask-image: var(--toolbarButton-zoomOut-icon); } #zoomIn::before { -webkit-mask-image: var(--toolbarButton-zoomIn-icon); mask-image: var(--toolbarButton-zoomIn-icon); } #presentationMode::before { -webkit-mask-image: var(--toolbarButton-presentationMode-icon); mask-image: var(--toolbarButton-presentationMode-icon); } #editorFreeText::before { -webkit-mask-image: var(--toolbarButton-editorFreeText-icon); mask-image: var(--toolbarButton-editorFreeText-icon); } #editorInk::before { -webkit-mask-image: var(--toolbarButton-editorInk-icon); mask-image: var(--toolbarButton-editorInk-icon); } #print::before, #secondaryPrint::before { -webkit-mask-image: var(--toolbarButton-print-icon); mask-image: var(--toolbarButton-print-icon); } #openFile::before, #secondaryOpenFile::before { -webkit-mask-image: var(--toolbarButton-openFile-icon); mask-image: var(--toolbarButton-openFile-icon); } #download::before, #secondaryDownload::before { -webkit-mask-image: var(--toolbarButton-download-icon); mask-image: var(--toolbarButton-download-icon); } a.secondaryToolbarButton { padding-top: 6px; text-decoration: none; } a.toolbarButton[href=&quot;#&quot;], a.secondaryToolbarButton[href=&quot;#&quot;] { opacity: 0.5; pointer-events: none; } #viewBookmark::before { -webkit-mask-image: var(--toolbarButton-bookmark-icon); mask-image: var(--toolbarButton-bookmark-icon); } #viewThumbnail::before { -webkit-mask-image: var(--toolbarButton-viewThumbnail-icon); mask-image: var(--toolbarButton-viewThumbnail-icon); } #viewOutline::before { -webkit-mask-image: var(--toolbarButton-viewOutline-icon); mask-image: var(--toolbarButton-viewOutline-icon); transform: scaleX(var(--dir-factor)); } #viewAttachments::before { -webkit-mask-image: var(--toolbarButton-viewAttachments-icon); mask-image: var(--toolbarButton-viewAttachments-icon); } #viewLayers::before { -webkit-mask-image: var(--toolbarButton-viewLayers-icon); mask-image: var(--toolbarButton-viewLayers-icon); } #currentOutlineItem::before { -webkit-mask-image: var(--toolbarButton-currentOutlineItem-icon); mask-image: var(--toolbarButton-currentOutlineItem-icon); transform: scaleX(var(--dir-factor)); } #viewFind::before { -webkit-mask-image: var(--toolbarButton-search-icon); mask-image: var(--toolbarButton-search-icon); } [dir=&quot;ltr&quot;] .pdfSidebarNotification::after { right: 2px; } [dir=&quot;rtl&quot;] .pdfSidebarNotification::after { left: 2px; } .pdfSidebarNotification::after { position: absolute; display: inline-block; top: 2px; inset-inline-end: 2px; /* Create a filled circle, with a diameter of 9 pixels, using only CSS: */ content: &quot;&quot;; background-color: rgba(112, 219, 85, 1); height: 9px; width: 9px; border-radius: 50%; } [dir=&quot;ltr&quot;] .secondaryToolbarButton { padding-left: 36px; } [dir=&quot;rtl&quot;] .secondaryToolbarButton { padding-right: 36px; } [dir=&quot;ltr&quot;] .secondaryToolbarButton { text-align: left; } [dir=&quot;rtl&quot;] .secondaryToolbarButton { text-align: right; } .secondaryToolbarButton { position: relative; margin: 0; padding: 0 0 1px; -webkit-padding-start: 36px; padding-inline-start: 36px; height: auto; min-height: 26px; width: auto; min-width: 100%; text-align: start; white-space: normal; border-radius: 0; box-sizing: border-box; display: inline-block; } [dir=&quot;ltr&quot;] .secondaryToolbarButton &gt; span { padding-right: 4px; } [dir=&quot;rtl&quot;] .secondaryToolbarButton &gt; span { padding-left: 4px; } .secondaryToolbarButton &gt; span { -webkit-padding-end: 4px; padding-inline-end: 4px; } #firstPage::before { -webkit-mask-image: var(--secondaryToolbarButton-firstPage-icon); mask-image: var(--secondaryToolbarButton-firstPage-icon); } #lastPage::before { -webkit-mask-image: var(--secondaryToolbarButton-lastPage-icon); mask-image: var(--secondaryToolbarButton-lastPage-icon); } #pageRotateCcw::before { -webkit-mask-image: var(--secondaryToolbarButton-rotateCcw-icon); mask-image: var(--secondaryToolbarButton-rotateCcw-icon); } #pageRotateCw::before { -webkit-mask-image: var(--secondaryToolbarButton-rotateCw-icon); mask-image: var(--secondaryToolbarButton-rotateCw-icon); } #cursorSelectTool::before { -webkit-mask-image: var(--secondaryToolbarButton-selectTool-icon); mask-image: var(--secondaryToolbarButton-selectTool-icon); } #cursorHandTool::before { -webkit-mask-image: var(--secondaryToolbarButton-handTool-icon); mask-image: var(--secondaryToolbarButton-handTool-icon); } #scrollPage::before { -webkit-mask-image: var(--secondaryToolbarButton-scrollPage-icon); mask-image: var(--secondaryToolbarButton-scrollPage-icon); } #scrollVertical::before { -webkit-mask-image: var(--secondaryToolbarButton-scrollVertical-icon); mask-image: var(--secondaryToolbarButton-scrollVertical-icon); } #scrollHorizontal::before { -webkit-mask-image: var(--secondaryToolbarButton-scrollHorizontal-icon); mask-image: var(--secondaryToolbarButton-scrollHorizontal-icon); } #scrollWrapped::before { -webkit-mask-image: var(--secondaryToolbarButton-scrollWrapped-icon); mask-image: var(--secondaryToolbarButton-scrollWrapped-icon); } #spreadNone::before { -webkit-mask-image: var(--secondaryToolbarButton-spreadNone-icon); mask-image: var(--secondaryToolbarButton-spreadNone-icon); } #spreadOdd::before { -webkit-mask-image: var(--secondaryToolbarButton-spreadOdd-icon); mask-image: var(--secondaryToolbarButton-spreadOdd-icon); } #spreadEven::before { -webkit-mask-image: var(--secondaryToolbarButton-spreadEven-icon); mask-image: var(--secondaryToolbarButton-spreadEven-icon); } #documentProperties::before { -webkit-mask-image: var(--secondaryToolbarButton-documentProperties-icon); mask-image: var(--secondaryToolbarButton-documentProperties-icon); } .verticalToolbarSeparator { display: block; margin: 5px 2px; width: 1px; height: 22px; background-color: var(--separator-color); } .horizontalToolbarSeparator { display: block; margin: 6px 0; height: 1px; width: 100%; background-color: var(--doorhanger-separator-color); } .toolbarField { padding: 4px 7px; margin: 3px 0; border-radius: 2px; background-color: var(--field-bg-color); background-clip: padding-box; border: 1px solid var(--field-border-color); box-shadow: none; color: var(--field-color); font-size: 12px; line-height: 16px; outline: none; } [dir=&quot;ltr&quot;] .toolbarField[type=&quot;checkbox&quot;] { margin-left: 7px; } [dir=&quot;rtl&quot;] .toolbarField[type=&quot;checkbox&quot;] { margin-right: 7px; } .toolbarField[type=&quot;checkbox&quot;] { opacity: 0; position: absolute !important; left: 0; margin: 10px 0 3px; -webkit-margin-start: 7px; margin-inline-start: 7px; } #pageNumber { -moz-appearance: textfield; /* hides the spinner in moz */ text-align: right; width: 40px; } #pageNumber.visiblePageIsLoading { background-image: var(--loading-icon); background-repeat: no-repeat; background-position: 3px; } #pageNumber::-webkit-inner-spin-button { -webkit-appearance: none; } .toolbarField:focus { border-color: #0a84ff; } .toolbarLabel { min-width: 16px; padding: 7px; margin: 2px; border-radius: 2px; color: var(--main-color); font-size: 12px; line-height: 14px; text-align: left; -webkit-user-select: none; -moz-user-select: none; user-select: none; cursor: default; } [dir=&quot;ltr&quot;] #numPages.toolbarLabel { padding-left: 3px; } [dir=&quot;rtl&quot;] #numPages.toolbarLabel { padding-right: 3px; } #numPages.toolbarLabel { -webkit-padding-start: 3px; padding-inline-start: 3px; } #thumbnailView, #outlineView, #attachmentsView, #layersView { position: absolute; width: calc(100% - 8px); top: 0; bottom: 0; padding: 4px 4px 0; overflow: auto; -webkit-user-select: none; -moz-user-select: none; user-select: none; } #thumbnailView { width: calc(100% - 60px); padding: 10px 30px 0; } #thumbnailView &gt; a:active, #thumbnailView &gt; a:focus { outline: 0; } [dir=&quot;ltr&quot;] .thumbnail { float: left; } [dir=&quot;rtl&quot;] .thumbnail { float: right; } .thumbnail { float: inline-start; margin: 0 10px 5px; } #thumbnailView &gt; a:last-of-type &gt; .thumbnail { margin-bottom: 10px; } #thumbnailView &gt; a:last-of-type &gt; .thumbnail:not([data-loaded]) { margin-bottom: 9px; } .thumbnail:not([data-loaded]) { border: 1px dashed rgba(132, 132, 132, 1); margin: -1px 9px 4px; } .thumbnailImage { border: 1px solid rgba(0, 0, 0, 0); box-shadow: 0 0 0 1px rgba(0, 0, 0, 0.5), 0 2px 8px rgba(0, 0, 0, 0.3); opacity: 0.8; z-index: 99; background-color: rgba(255, 255, 255, 1); background-clip: content-box; } .thumbnailSelectionRing { border-radius: 2px; padding: 7px; } a:focus &gt; .thumbnail &gt; .thumbnailSelectionRing &gt; .thumbnailImage, .thumbnail:hover &gt; .thumbnailSelectionRing &gt; .thumbnailImage { opacity: 0.9; } a:focus &gt; .thumbnail &gt; .thumbnailSelectionRing, .thumbnail:hover &gt; .thumbnailSelectionRing { background-color: var(--sidebaritem-bg-color); background-clip: padding-box; color: rgba(255, 255, 255, 0.9); } .thumbnail.selected &gt; .thumbnailSelectionRing &gt; .thumbnailImage { opacity: 1; } .thumbnail.selected &gt; .thumbnailSelectionRing { background-color: var(--sidebaritem-bg-color); background-clip: padding-box; color: rgba(255, 255, 255, 1); } [dir=&quot;ltr&quot;] .treeWithDeepNesting &gt; .treeItem,[dir=&quot;ltr&quot;] .treeItem &gt; .treeItems { margin-left: 20px; } [dir=&quot;rtl&quot;] .treeWithDeepNesting &gt; .treeItem,[dir=&quot;rtl&quot;] .treeItem &gt; .treeItems { margin-right: 20px; } .treeWithDeepNesting &gt; .treeItem, .treeItem &gt; .treeItems { -webkit-margin-start: 20px; margin-inline-start: 20px; } [dir=&quot;ltr&quot;] .treeItem &gt; a { padding-left: 4px; } [dir=&quot;rtl&quot;] .treeItem &gt; a { padding-right: 4px; } .treeItem &gt; a { text-decoration: none; display: inline-block; /* Subtract the right padding (left, in RTL mode) of the container: */ min-width: calc(100% - 4px); height: auto; margin-bottom: 1px; padding: 2px 0 5px; -webkit-padding-start: 4px; padding-inline-start: 4px; border-radius: 2px; color: var(--treeitem-color); font-size: 13px; line-height: 15px; -webkit-user-select: none; -moz-user-select: none; user-select: none; white-space: normal; cursor: pointer; } #layersView .treeItem &gt; a * { cursor: pointer; } [dir=&quot;ltr&quot;] #layersView .treeItem &gt; a &gt; label { padding-left: 4px; } [dir=&quot;rtl&quot;] #layersView .treeItem &gt; a &gt; label { padding-right: 4px; } #layersView .treeItem &gt; a &gt; label { -webkit-padding-start: 4px; padding-inline-start: 4px; } [dir=&quot;ltr&quot;] #layersView .treeItem &gt; a &gt; label &gt; input { float: left; } [dir=&quot;rtl&quot;] #layersView .treeItem &gt; a &gt; label &gt; input { float: right; } #layersView .treeItem &gt; a &gt; label &gt; input { float: inline-start; margin-top: 1px; } [dir=&quot;ltr&quot;] .treeItemToggler { float: left; } [dir=&quot;rtl&quot;] .treeItemToggler { float: right; } .treeItemToggler { position: relative; float: inline-start; height: 0; width: 0; color: rgba(255, 255, 255, 0.5); } [dir=&quot;ltr&quot;] .treeItemToggler::before { right: 4px; } [dir=&quot;rtl&quot;] .treeItemToggler::before { left: 4px; } .treeItemToggler::before { inset-inline-end: 4px; -webkit-mask-image: var(--treeitem-expanded-icon); mask-image: var(--treeitem-expanded-icon); } .treeItemToggler.treeItemsHidden::before { -webkit-mask-image: var(--treeitem-collapsed-icon); mask-image: var(--treeitem-collapsed-icon); transform: scaleX(var(--dir-factor)); } .treeItemToggler.treeItemsHidden ~ .treeItems { display: none; } .treeItem.selected &gt; a { background-color: var(--treeitem-selected-bg-color); color: var(--treeitem-selected-color); } .treeItemToggler:hover, .treeItemToggler:hover + a, .treeItemToggler:hover ~ .treeItems, .treeItem &gt; a:hover { background-color: var(--sidebaritem-bg-color); background-clip: padding-box; border-radius: 2px; color: var(--treeitem-hover-color); } .dialogButton { width: auto; margin: 3px 4px 2px !important; padding: 2px 11px; color: var(--main-color); background-color: var(--dialog-button-bg-color); border: var(--dialog-button-border) !important; } dialog { margin: auto; padding: 15px; border-spacing: 4px; color: var(--main-color); font: message-box; font-size: 12px; line-height: 14px; background-color: var(--doorhanger-bg-color); border: 1px solid rgba(0, 0, 0, 0.5); border-radius: 4px; box-shadow: 0 1px 4px rgba(0, 0, 0, 0.3); } dialog::-webkit-backdrop { background-color: rgba(0, 0, 0, 0.2); } dialog::backdrop { background-color: rgba(0, 0, 0, 0.2); } dialog &gt; .row { display: table-row; } dialog &gt; .row &gt; * { display: table-cell; } dialog .toolbarField { margin: 5px 0; } dialog .separator { display: block; margin: 4px 0; height: 1px; width: 100%; background-color: var(--separator-color); } dialog .buttonRow { text-align: center; vertical-align: middle; } dialog :link { color: rgba(255, 255, 255, 1); } #passwordDialog { text-align: center; } #passwordDialog .toolbarField { width: 200px; } #documentPropertiesDialog { text-align: left; } [dir=&quot;ltr&quot;] #documentPropertiesDialog .row &gt; * { text-align: left; } [dir=&quot;rtl&quot;] #documentPropertiesDialog .row &gt; * { text-align: right; } #documentPropertiesDialog .row &gt; * { min-width: 100px; text-align: start; } #documentPropertiesDialog .row &gt; span { width: 125px; word-wrap: break-word; } #documentPropertiesDialog .row &gt; p { max-width: 225px; word-wrap: break-word; } #documentPropertiesDialog .buttonRow { margin-top: 10px; } .grab-to-pan-grab { cursor: grab !important; } .grab-to-pan-grab *:not(input):not(textarea):not(button):not(select):not(:link) { cursor: inherit !important; } .grab-to-pan-grab:active, .grab-to-pan-grabbing { cursor: grabbing !important; position: fixed; background: rgba(0, 0, 0, 0); display: block; top: 0; left: 0; right: 0; bottom: 0; overflow: hidden; z-index: 50000; /* should be higher than anything else in PDF.js! */ } @page { margin: 0; } #printContainer { display: none; } @media print { body { background: rgba(0, 0, 0, 0) none; } body[data-pdfjsprinting] #outerContainer { display: none; } body[data-pdfjsprinting] #printContainer { display: block; } #printContainer { height: 100%; } /* wrapper around (scaled) print canvas elements */ #printContainer &gt; .printedPage { page-break-after: always; page-break-inside: avoid; /* The wrapper always cover the whole page. */ height: 100%; width: 100%; display: flex; flex-direction: column; justify-content: center; align-items: center; } #printContainer &gt; .xfaPrintedPage .xfaPage { position: absolute; } #printContainer &gt; .xfaPrintedPage { page-break-after: always; page-break-inside: avoid; width: 100%; height: 100%; position: relative; } #printContainer &gt; .printedPage canvas, #printContainer &gt; .printedPage img { /* The intrinsic canvas / image size will make sure that we fit the page. */ max-width: 100%; max-height: 100%; direction: ltr; display: block; } } .visibleLargeView, .visibleMediumView { display: none; } @media all and (max-width: 900px) { #toolbarViewerMiddle { display: table; margin: auto; left: auto; position: inherit; transform: none; } } @media all and (max-width: 840px) { #sidebarContainer { background-color: var(--sidebar-narrow-bg-color); } [dir=&quot;ltr&quot;] #outerContainer.sidebarOpen #viewerContainer { left: 0 !important; } [dir=&quot;rtl&quot;] #outerContainer.sidebarOpen #viewerContainer { right: 0 !important; } #outerContainer.sidebarOpen #viewerContainer { inset-inline-start: 0 !important; } } @media all and (max-width: 820px) { #outerContainer .hiddenLargeView { display: none; } #outerContainer .visibleLargeView { display: inherit; } } @media all and (max-width: 750px) { #outerContainer .hiddenMediumView { display: none; } #outerContainer .visibleMediumView { display: inherit; } } @media all and (max-width: 690px) { .hiddenSmallView, .hiddenSmallView * { display: none; } .toolbarButtonSpacer { width: 0; } [dir=&quot;ltr&quot;] .findbar { left: 34px; } [dir=&quot;rtl&quot;] .findbar { right: 34px; } .findbar { inset-inline-start: 34px; } } @media all and (max-width: 560px) { #scaleSelectContainer { display: none; } }","link":"/lib/pdf/web/viewer.css"},{"title":"","text":"/** * @licstart The following is the entire license notice for the * JavaScript code in this page * * Copyright 2022 Mozilla Foundation * * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. * * @licend The above is the entire license notice for the * JavaScript code in this page */ (function webpackUniversalModuleDefinition(root, factory) { if(typeof exports === &apos;object&apos; &amp;&amp; typeof module === &apos;object&apos;) module.exports = factory(); else if(typeof define === &apos;function&apos; &amp;&amp; define.amd) define(&quot;pdfjs-dist/build/pdf&quot;, [], factory); else if(typeof exports === &apos;object&apos;) exports[&quot;pdfjs-dist/build/pdf&quot;] = factory(); else root[&quot;pdfjs-dist/build/pdf&quot;] = root.pdfjsLib = factory(); })(globalThis, () =&gt; { return /******/ (() =&gt; { // webpackBootstrap /******/ &quot;use strict&quot;; /******/ var __webpack_modules__ = ([ /* 0 */, /* 1 */ /***/ ((__unused_webpack_module, exports) =&gt; { Object.defineProperty(exports, &quot;__esModule&quot;, ({ value: true })); exports.VerbosityLevel = exports.Util = exports.UnknownErrorException = exports.UnexpectedResponseException = exports.UNSUPPORTED_FEATURES = exports.TextRenderingMode = exports.StreamType = exports.RenderingIntentFlag = exports.PermissionFlag = exports.PasswordResponses = exports.PasswordException = exports.PageActionEventType = exports.OPS = exports.MissingPDFException = exports.LINE_FACTOR = exports.LINE_DESCENT_FACTOR = exports.InvalidPDFException = exports.ImageKind = exports.IDENTITY_MATRIX = exports.FormatError = exports.FontType = exports.FeatureTest = exports.FONT_IDENTITY_MATRIX = exports.DocumentActionEventType = exports.CMapCompressionType = exports.BaseException = exports.AnnotationType = exports.AnnotationStateModelType = exports.AnnotationReviewState = exports.AnnotationReplyType = exports.AnnotationMode = exports.AnnotationMarkedState = exports.AnnotationFlag = exports.AnnotationFieldFlag = exports.AnnotationEditorType = exports.AnnotationEditorPrefix = exports.AnnotationEditorParamsType = exports.AnnotationBorderStyleType = exports.AnnotationActionEventType = exports.AbortException = void 0; exports.arrayByteLength = arrayByteLength; exports.arraysToBytes = arraysToBytes; exports.assert = assert; exports.bytesToString = bytesToString; exports.createPromiseCapability = createPromiseCapability; exports.createValidAbsoluteUrl = createValidAbsoluteUrl; exports.escapeString = escapeString; exports.getModificationDate = getModificationDate; exports.getVerbosityLevel = getVerbosityLevel; exports.info = info; exports.isArrayBuffer = isArrayBuffer; exports.isArrayEqual = isArrayEqual; exports.isAscii = isAscii; exports.objectFromMap = objectFromMap; exports.objectSize = objectSize; exports.setVerbosityLevel = setVerbosityLevel; exports.shadow = shadow; exports.string32 = string32; exports.stringToBytes = stringToBytes; exports.stringToPDFString = stringToPDFString; exports.stringToUTF16BEString = stringToUTF16BEString; exports.stringToUTF8String = stringToUTF8String; exports.unreachable = unreachable; exports.utf8StringToString = utf8StringToString; exports.warn = warn; ; const IDENTITY_MATRIX = [1, 0, 0, 1, 0, 0]; exports.IDENTITY_MATRIX = IDENTITY_MATRIX; const FONT_IDENTITY_MATRIX = [0.001, 0, 0, 0.001, 0, 0]; exports.FONT_IDENTITY_MATRIX = FONT_IDENTITY_MATRIX; const LINE_FACTOR = 1.35; exports.LINE_FACTOR = LINE_FACTOR; const LINE_DESCENT_FACTOR = 0.35; exports.LINE_DESCENT_FACTOR = LINE_DESCENT_FACTOR; const RenderingIntentFlag = { ANY: 0x01, DISPLAY: 0x02, PRINT: 0x04, ANNOTATIONS_FORMS: 0x10, ANNOTATIONS_STORAGE: 0x20, ANNOTATIONS_DISABLE: 0x40, OPLIST: 0x100 }; exports.RenderingIntentFlag = RenderingIntentFlag; const AnnotationMode = { DISABLE: 0, ENABLE: 1, ENABLE_FORMS: 2, ENABLE_STORAGE: 3 }; exports.AnnotationMode = AnnotationMode; const AnnotationEditorPrefix = &quot;pdfjs_internal_editor_&quot;; exports.AnnotationEditorPrefix = AnnotationEditorPrefix; const AnnotationEditorType = { DISABLE: -1, NONE: 0, FREETEXT: 3, INK: 15 }; exports.AnnotationEditorType = AnnotationEditorType; const AnnotationEditorParamsType = { FREETEXT_SIZE: 1, FREETEXT_COLOR: 2, FREETEXT_OPACITY: 3, INK_COLOR: 11, INK_THICKNESS: 12, INK_OPACITY: 13 }; exports.AnnotationEditorParamsType = AnnotationEditorParamsType; const PermissionFlag = { PRINT: 0x04, MODIFY_CONTENTS: 0x08, COPY: 0x10, MODIFY_ANNOTATIONS: 0x20, FILL_INTERACTIVE_FORMS: 0x100, COPY_FOR_ACCESSIBILITY: 0x200, ASSEMBLE: 0x400, PRINT_HIGH_QUALITY: 0x800 }; exports.PermissionFlag = PermissionFlag; const TextRenderingMode = { FILL: 0, STROKE: 1, FILL_STROKE: 2, INVISIBLE: 3, FILL_ADD_TO_PATH: 4, STROKE_ADD_TO_PATH: 5, FILL_STROKE_ADD_TO_PATH: 6, ADD_TO_PATH: 7, FILL_STROKE_MASK: 3, ADD_TO_PATH_FLAG: 4 }; exports.TextRenderingMode = TextRenderingMode; const ImageKind = { GRAYSCALE_1BPP: 1, RGB_24BPP: 2, RGBA_32BPP: 3 }; exports.ImageKind = ImageKind; const AnnotationType = { TEXT: 1, LINK: 2, FREETEXT: 3, LINE: 4, SQUARE: 5, CIRCLE: 6, POLYGON: 7, POLYLINE: 8, HIGHLIGHT: 9, UNDERLINE: 10, SQUIGGLY: 11, STRIKEOUT: 12, STAMP: 13, CARET: 14, INK: 15, POPUP: 16, FILEATTACHMENT: 17, SOUND: 18, MOVIE: 19, WIDGET: 20, SCREEN: 21, PRINTERMARK: 22, TRAPNET: 23, WATERMARK: 24, THREED: 25, REDACT: 26 }; exports.AnnotationType = AnnotationType; const AnnotationStateModelType = { MARKED: &quot;Marked&quot;, REVIEW: &quot;Review&quot; }; exports.AnnotationStateModelType = AnnotationStateModelType; const AnnotationMarkedState = { MARKED: &quot;Marked&quot;, UNMARKED: &quot;Unmarked&quot; }; exports.AnnotationMarkedState = AnnotationMarkedState; const AnnotationReviewState = { ACCEPTED: &quot;Accepted&quot;, REJECTED: &quot;Rejected&quot;, CANCELLED: &quot;Cancelled&quot;, COMPLETED: &quot;Completed&quot;, NONE: &quot;None&quot; }; exports.AnnotationReviewState = AnnotationReviewState; const AnnotationReplyType = { GROUP: &quot;Group&quot;, REPLY: &quot;R&quot; }; exports.AnnotationReplyType = AnnotationReplyType; const AnnotationFlag = { INVISIBLE: 0x01, HIDDEN: 0x02, PRINT: 0x04, NOZOOM: 0x08, NOROTATE: 0x10, NOVIEW: 0x20, READONLY: 0x40, LOCKED: 0x80, TOGGLENOVIEW: 0x100, LOCKEDCONTENTS: 0x200 }; exports.AnnotationFlag = AnnotationFlag; const AnnotationFieldFlag = { READONLY: 0x0000001, REQUIRED: 0x0000002, NOEXPORT: 0x0000004, MULTILINE: 0x0001000, PASSWORD: 0x0002000, NOTOGGLETOOFF: 0x0004000, RADIO: 0x0008000, PUSHBUTTON: 0x0010000, COMBO: 0x0020000, EDIT: 0x0040000, SORT: 0x0080000, FILESELECT: 0x0100000, MULTISELECT: 0x0200000, DONOTSPELLCHECK: 0x0400000, DONOTSCROLL: 0x0800000, COMB: 0x1000000, RICHTEXT: 0x2000000, RADIOSINUNISON: 0x2000000, COMMITONSELCHANGE: 0x4000000 }; exports.AnnotationFieldFlag = AnnotationFieldFlag; const AnnotationBorderStyleType = { SOLID: 1, DASHED: 2, BEVELED: 3, INSET: 4, UNDERLINE: 5 }; exports.AnnotationBorderStyleType = AnnotationBorderStyleType; const AnnotationActionEventType = { E: &quot;Mouse Enter&quot;, X: &quot;Mouse Exit&quot;, D: &quot;Mouse Down&quot;, U: &quot;Mouse Up&quot;, Fo: &quot;Focus&quot;, Bl: &quot;Blur&quot;, PO: &quot;PageOpen&quot;, PC: &quot;PageClose&quot;, PV: &quot;PageVisible&quot;, PI: &quot;PageInvisible&quot;, K: &quot;Keystroke&quot;, F: &quot;Format&quot;, V: &quot;Validate&quot;, C: &quot;Calculate&quot; }; exports.AnnotationActionEventType = AnnotationActionEventType; const DocumentActionEventType = { WC: &quot;WillClose&quot;, WS: &quot;WillSave&quot;, DS: &quot;DidSave&quot;, WP: &quot;WillPrint&quot;, DP: &quot;DidPrint&quot; }; exports.DocumentActionEventType = DocumentActionEventType; const PageActionEventType = { O: &quot;PageOpen&quot;, C: &quot;PageClose&quot; }; exports.PageActionEventType = PageActionEventType; const StreamType = { UNKNOWN: &quot;UNKNOWN&quot;, FLATE: &quot;FLATE&quot;, LZW: &quot;LZW&quot;, DCT: &quot;DCT&quot;, JPX: &quot;JPX&quot;, JBIG: &quot;JBIG&quot;, A85: &quot;A85&quot;, AHX: &quot;AHX&quot;, CCF: &quot;CCF&quot;, RLX: &quot;RLX&quot; }; exports.StreamType = StreamType; const FontType = { UNKNOWN: &quot;UNKNOWN&quot;, TYPE1: &quot;TYPE1&quot;, TYPE1STANDARD: &quot;TYPE1STANDARD&quot;, TYPE1C: &quot;TYPE1C&quot;, CIDFONTTYPE0: &quot;CIDFONTTYPE0&quot;, CIDFONTTYPE0C: &quot;CIDFONTTYPE0C&quot;, TRUETYPE: &quot;TRUETYPE&quot;, CIDFONTTYPE2: &quot;CIDFONTTYPE2&quot;, TYPE3: &quot;TYPE3&quot;, OPENTYPE: &quot;OPENTYPE&quot;, TYPE0: &quot;TYPE0&quot;, MMTYPE1: &quot;MMTYPE1&quot; }; exports.FontType = FontType; const VerbosityLevel = { ERRORS: 0, WARNINGS: 1, INFOS: 5 }; exports.VerbosityLevel = VerbosityLevel; const CMapCompressionType = { NONE: 0, BINARY: 1 }; exports.CMapCompressionType = CMapCompressionType; const OPS = { dependency: 1, setLineWidth: 2, setLineCap: 3, setLineJoin: 4, setMiterLimit: 5, setDash: 6, setRenderingIntent: 7, setFlatness: 8, setGState: 9, save: 10, restore: 11, transform: 12, moveTo: 13, lineTo: 14, curveTo: 15, curveTo2: 16, curveTo3: 17, closePath: 18, rectangle: 19, stroke: 20, closeStroke: 21, fill: 22, eoFill: 23, fillStroke: 24, eoFillStroke: 25, closeFillStroke: 26, closeEOFillStroke: 27, endPath: 28, clip: 29, eoClip: 30, beginText: 31, endText: 32, setCharSpacing: 33, setWordSpacing: 34, setHScale: 35, setLeading: 36, setFont: 37, setTextRenderingMode: 38, setTextRise: 39, moveText: 40, setLeadingMoveText: 41, setTextMatrix: 42, nextLine: 43, showText: 44, showSpacedText: 45, nextLineShowText: 46, nextLineSetSpacingShowText: 47, setCharWidth: 48, setCharWidthAndBounds: 49, setStrokeColorSpace: 50, setFillColorSpace: 51, setStrokeColor: 52, setStrokeColorN: 53, setFillColor: 54, setFillColorN: 55, setStrokeGray: 56, setFillGray: 57, setStrokeRGBColor: 58, setFillRGBColor: 59, setStrokeCMYKColor: 60, setFillCMYKColor: 61, shadingFill: 62, beginInlineImage: 63, beginImageData: 64, endInlineImage: 65, paintXObject: 66, markPoint: 67, markPointProps: 68, beginMarkedContent: 69, beginMarkedContentProps: 70, endMarkedContent: 71, beginCompat: 72, endCompat: 73, paintFormXObjectBegin: 74, paintFormXObjectEnd: 75, beginGroup: 76, endGroup: 77, beginAnnotation: 80, endAnnotation: 81, paintImageMaskXObject: 83, paintImageMaskXObjectGroup: 84, paintImageXObject: 85, paintInlineImageXObject: 86, paintInlineImageXObjectGroup: 87, paintImageXObjectRepeat: 88, paintImageMaskXObjectRepeat: 89, paintSolidColorImageMask: 90, constructPath: 91 }; exports.OPS = OPS; const UNSUPPORTED_FEATURES = { forms: &quot;forms&quot;, javaScript: &quot;javaScript&quot;, signatures: &quot;signatures&quot;, smask: &quot;smask&quot;, shadingPattern: &quot;shadingPattern&quot;, errorTilingPattern: &quot;errorTilingPattern&quot;, errorExtGState: &quot;errorExtGState&quot;, errorXObject: &quot;errorXObject&quot;, errorFontLoadType3: &quot;errorFontLoadType3&quot;, errorFontState: &quot;errorFontState&quot;, errorFontMissing: &quot;errorFontMissing&quot;, errorFontTranslate: &quot;errorFontTranslate&quot;, errorColorSpace: &quot;errorColorSpace&quot;, errorOperatorList: &quot;errorOperatorList&quot;, errorFontToUnicode: &quot;errorFontToUnicode&quot;, errorFontLoadNative: &quot;errorFontLoadNative&quot;, errorFontBuildPath: &quot;errorFontBuildPath&quot;, errorFontGetPath: &quot;errorFontGetPath&quot;, errorMarkedContent: &quot;errorMarkedContent&quot;, errorContentSubStream: &quot;errorContentSubStream&quot; }; exports.UNSUPPORTED_FEATURES = UNSUPPORTED_FEATURES; const PasswordResponses = { NEED_PASSWORD: 1, INCORRECT_PASSWORD: 2 }; exports.PasswordResponses = PasswordResponses; let verbosity = VerbosityLevel.WARNINGS; function setVerbosityLevel(level) { if (Number.isInteger(level)) { verbosity = level; } } function getVerbosityLevel() { return verbosity; } function info(msg) { if (verbosity &gt;= VerbosityLevel.INFOS) { console.log(`Info: ${msg}`); } } function warn(msg) { if (verbosity &gt;= VerbosityLevel.WARNINGS) { console.log(`Warning: ${msg}`); } } function unreachable(msg) { throw new Error(msg); } function assert(cond, msg) { if (!cond) { unreachable(msg); } } function _isValidProtocol(url) { if (!url) { return false; } switch (url.protocol) { case &quot;http:&quot;: case &quot;https:&quot;: case &quot;ftp:&quot;: case &quot;mailto:&quot;: case &quot;tel:&quot;: return true; default: return false; } } function createValidAbsoluteUrl(url, baseUrl = null, options = null) { if (!url) { return null; } try { if (options &amp;&amp; typeof url === &quot;string&quot;) { if (options.addDefaultProtocol &amp;&amp; url.startsWith(&quot;www.&quot;)) { const dots = url.match(/\\./g); if (dots &amp;&amp; dots.length &gt;= 2) { url = `http://${url}`; } } if (options.tryConvertEncoding) { try { url = stringToUTF8String(url); } catch (ex) {} } } const absoluteUrl = baseUrl ? new URL(url, baseUrl) : new URL(url); if (_isValidProtocol(absoluteUrl)) { return absoluteUrl; } } catch (ex) {} return null; } function shadow(obj, prop, value) { Object.defineProperty(obj, prop, { value, enumerable: true, configurable: true, writable: false }); return value; } const BaseException = function BaseExceptionClosure() { function BaseException(message, name) { if (this.constructor === BaseException) { unreachable(&quot;Cannot initialize BaseException.&quot;); } this.message = message; this.name = name; } BaseException.prototype = new Error(); BaseException.constructor = BaseException; return BaseException; }(); exports.BaseException = BaseException; class PasswordException extends BaseException { constructor(msg, code) { super(msg, &quot;PasswordException&quot;); this.code = code; } } exports.PasswordException = PasswordException; class UnknownErrorException extends BaseException { constructor(msg, details) { super(msg, &quot;UnknownErrorException&quot;); this.details = details; } } exports.UnknownErrorException = UnknownErrorException; class InvalidPDFException extends BaseException { constructor(msg) { super(msg, &quot;InvalidPDFException&quot;); } } exports.InvalidPDFException = InvalidPDFException; class MissingPDFException extends BaseException { constructor(msg) { super(msg, &quot;MissingPDFException&quot;); } } exports.MissingPDFException = MissingPDFException; class UnexpectedResponseException extends BaseException { constructor(msg, status) { super(msg, &quot;UnexpectedResponseException&quot;); this.status = status; } } exports.UnexpectedResponseException = UnexpectedResponseException; class FormatError extends BaseException { constructor(msg) { super(msg, &quot;FormatError&quot;); } } exports.FormatError = FormatError; class AbortException extends BaseException { constructor(msg) { super(msg, &quot;AbortException&quot;); } } exports.AbortException = AbortException; function bytesToString(bytes) { if (typeof bytes !== &quot;object&quot; || bytes === null || bytes.length === undefined) { unreachable(&quot;Invalid argument for bytesToString&quot;); } const length = bytes.length; const MAX_ARGUMENT_COUNT = 8192; if (length &lt; MAX_ARGUMENT_COUNT) { return String.fromCharCode.apply(null, bytes); } const strBuf = []; for (let i = 0; i &lt; length; i += MAX_ARGUMENT_COUNT) { const chunkEnd = Math.min(i + MAX_ARGUMENT_COUNT, length); const chunk = bytes.subarray(i, chunkEnd); strBuf.push(String.fromCharCode.apply(null, chunk)); } return strBuf.join(&quot;&quot;); } function stringToBytes(str) { if (typeof str !== &quot;string&quot;) { unreachable(&quot;Invalid argument for stringToBytes&quot;); } const length = str.length; const bytes = new Uint8Array(length); for (let i = 0; i &lt; length; ++i) { bytes[i] = str.charCodeAt(i) &amp; 0xff; } return bytes; } function arrayByteLength(arr) { if (arr.length !== undefined) { return arr.length; } if (arr.byteLength !== undefined) { return arr.byteLength; } unreachable(&quot;Invalid argument for arrayByteLength&quot;); } function arraysToBytes(arr) { const length = arr.length; if (length === 1 &amp;&amp; arr[0] instanceof Uint8Array) { return arr[0]; } let resultLength = 0; for (let i = 0; i &lt; length; i++) { resultLength += arrayByteLength(arr[i]); } let pos = 0; const data = new Uint8Array(resultLength); for (let i = 0; i &lt; length; i++) { let item = arr[i]; if (!(item instanceof Uint8Array)) { if (typeof item === &quot;string&quot;) { item = stringToBytes(item); } else { item = new Uint8Array(item); } } const itemLength = item.byteLength; data.set(item, pos); pos += itemLength; } return data; } function string32(value) { return String.fromCharCode(value &gt;&gt; 24 &amp; 0xff, value &gt;&gt; 16 &amp; 0xff, value &gt;&gt; 8 &amp; 0xff, value &amp; 0xff); } function objectSize(obj) { return Object.keys(obj).length; } function objectFromMap(map) { const obj = Object.create(null); for (const [key, value] of map) { obj[key] = value; } return obj; } function isLittleEndian() { const buffer8 = new Uint8Array(4); buffer8[0] = 1; const view32 = new Uint32Array(buffer8.buffer, 0, 1); return view32[0] === 1; } function isEvalSupported() { try { new Function(&quot;&quot;); return true; } catch (e) { return false; } } class FeatureTest { static get isLittleEndian() { return shadow(this, &quot;isLittleEndian&quot;, isLittleEndian()); } static get isEvalSupported() { return shadow(this, &quot;isEvalSupported&quot;, isEvalSupported()); } static get isOffscreenCanvasSupported() { return shadow(this, &quot;isOffscreenCanvasSupported&quot;, typeof OffscreenCanvas !== &quot;undefined&quot;); } } exports.FeatureTest = FeatureTest; const hexNumbers = [...Array(256).keys()].map(n =&gt; n.toString(16).padStart(2, &quot;0&quot;)); class Util { static makeHexColor(r, g, b) { return `#${hexNumbers[r]}${hexNumbers[g]}${hexNumbers[b]}`; } static scaleMinMax(transform, minMax) { let temp; if (transform[0]) { if (transform[0] &lt; 0) { temp = minMax[0]; minMax[0] = minMax[1]; minMax[1] = temp; } minMax[0] *= transform[0]; minMax[1] *= transform[0]; if (transform[3] &lt; 0) { temp = minMax[2]; minMax[2] = minMax[3]; minMax[3] = temp; } minMax[2] *= transform[3]; minMax[3] *= transform[3]; } else { temp = minMax[0]; minMax[0] = minMax[2]; minMax[2] = temp; temp = minMax[1]; minMax[1] = minMax[3]; minMax[3] = temp; if (transform[1] &lt; 0) { temp = minMax[2]; minMax[2] = minMax[3]; minMax[3] = temp; } minMax[2] *= transform[1]; minMax[3] *= transform[1]; if (transform[2] &lt; 0) { temp = minMax[0]; minMax[0] = minMax[1]; minMax[1] = temp; } minMax[0] *= transform[2]; minMax[1] *= transform[2]; } minMax[0] += transform[4]; minMax[1] += transform[4]; minMax[2] += transform[5]; minMax[3] += transform[5]; } static transform(m1, m2) { return [m1[0] * m2[0] + m1[2] * m2[1], m1[1] * m2[0] + m1[3] * m2[1], m1[0] * m2[2] + m1[2] * m2[3], m1[1] * m2[2] + m1[3] * m2[3], m1[0] * m2[4] + m1[2] * m2[5] + m1[4], m1[1] * m2[4] + m1[3] * m2[5] + m1[5]]; } static applyTransform(p, m) { const xt = p[0] * m[0] + p[1] * m[2] + m[4]; const yt = p[0] * m[1] + p[1] * m[3] + m[5]; return [xt, yt]; } static applyInverseTransform(p, m) { const d = m[0] * m[3] - m[1] * m[2]; const xt = (p[0] * m[3] - p[1] * m[2] + m[2] * m[5] - m[4] * m[3]) / d; const yt = (-p[0] * m[1] + p[1] * m[0] + m[4] * m[1] - m[5] * m[0]) / d; return [xt, yt]; } static getAxialAlignedBoundingBox(r, m) { const p1 = Util.applyTransform(r, m); const p2 = Util.applyTransform(r.slice(2, 4), m); const p3 = Util.applyTransform([r[0], r[3]], m); const p4 = Util.applyTransform([r[2], r[1]], m); return [Math.min(p1[0], p2[0], p3[0], p4[0]), Math.min(p1[1], p2[1], p3[1], p4[1]), Math.max(p1[0], p2[0], p3[0], p4[0]), Math.max(p1[1], p2[1], p3[1], p4[1])]; } static inverseTransform(m) { const d = m[0] * m[3] - m[1] * m[2]; return [m[3] / d, -m[1] / d, -m[2] / d, m[0] / d, (m[2] * m[5] - m[4] * m[3]) / d, (m[4] * m[1] - m[5] * m[0]) / d]; } static singularValueDecompose2dScale(m) { const transpose = [m[0], m[2], m[1], m[3]]; const a = m[0] * transpose[0] + m[1] * transpose[2]; const b = m[0] * transpose[1] + m[1] * transpose[3]; const c = m[2] * transpose[0] + m[3] * transpose[2]; const d = m[2] * transpose[1] + m[3] * transpose[3]; const first = (a + d) / 2; const second = Math.sqrt((a + d) ** 2 - 4 * (a * d - c * b)) / 2; const sx = first + second || 1; const sy = first - second || 1; return [Math.sqrt(sx), Math.sqrt(sy)]; } static normalizeRect(rect) { const r = rect.slice(0); if (rect[0] &gt; rect[2]) { r[0] = rect[2]; r[2] = rect[0]; } if (rect[1] &gt; rect[3]) { r[1] = rect[3]; r[3] = rect[1]; } return r; } static intersect(rect1, rect2) { const xLow = Math.max(Math.min(rect1[0], rect1[2]), Math.min(rect2[0], rect2[2])); const xHigh = Math.min(Math.max(rect1[0], rect1[2]), Math.max(rect2[0], rect2[2])); if (xLow &gt; xHigh) { return null; } const yLow = Math.max(Math.min(rect1[1], rect1[3]), Math.min(rect2[1], rect2[3])); const yHigh = Math.min(Math.max(rect1[1], rect1[3]), Math.max(rect2[1], rect2[3])); if (yLow &gt; yHigh) { return null; } return [xLow, yLow, xHigh, yHigh]; } static bezierBoundingBox(x0, y0, x1, y1, x2, y2, x3, y3) { const tvalues = [], bounds = [[], []]; let a, b, c, t, t1, t2, b2ac, sqrtb2ac; for (let i = 0; i &lt; 2; ++i) { if (i === 0) { b = 6 * x0 - 12 * x1 + 6 * x2; a = -3 * x0 + 9 * x1 - 9 * x2 + 3 * x3; c = 3 * x1 - 3 * x0; } else { b = 6 * y0 - 12 * y1 + 6 * y2; a = -3 * y0 + 9 * y1 - 9 * y2 + 3 * y3; c = 3 * y1 - 3 * y0; } if (Math.abs(a) &lt; 1e-12) { if (Math.abs(b) &lt; 1e-12) { continue; } t = -c / b; if (0 &lt; t &amp;&amp; t &lt; 1) { tvalues.push(t); } continue; } b2ac = b * b - 4 * c * a; sqrtb2ac = Math.sqrt(b2ac); if (b2ac &lt; 0) { continue; } t1 = (-b + sqrtb2ac) / (2 * a); if (0 &lt; t1 &amp;&amp; t1 &lt; 1) { tvalues.push(t1); } t2 = (-b - sqrtb2ac) / (2 * a); if (0 &lt; t2 &amp;&amp; t2 &lt; 1) { tvalues.push(t2); } } let j = tvalues.length, mt; const jlen = j; while (j--) { t = tvalues[j]; mt = 1 - t; bounds[0][j] = mt * mt * mt * x0 + 3 * mt * mt * t * x1 + 3 * mt * t * t * x2 + t * t * t * x3; bounds[1][j] = mt * mt * mt * y0 + 3 * mt * mt * t * y1 + 3 * mt * t * t * y2 + t * t * t * y3; } bounds[0][jlen] = x0; bounds[1][jlen] = y0; bounds[0][jlen + 1] = x3; bounds[1][jlen + 1] = y3; bounds[0].length = bounds[1].length = jlen + 2; return [Math.min(...bounds[0]), Math.min(...bounds[1]), Math.max(...bounds[0]), Math.max(...bounds[1])]; } } exports.Util = Util; const PDFStringTranslateTable = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0x2d8, 0x2c7, 0x2c6, 0x2d9, 0x2dd, 0x2db, 0x2da, 0x2dc, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0x2022, 0x2020, 0x2021, 0x2026, 0x2014, 0x2013, 0x192, 0x2044, 0x2039, 0x203a, 0x2212, 0x2030, 0x201e, 0x201c, 0x201d, 0x2018, 0x2019, 0x201a, 0x2122, 0xfb01, 0xfb02, 0x141, 0x152, 0x160, 0x178, 0x17d, 0x131, 0x142, 0x153, 0x161, 0x17e, 0, 0x20ac]; function stringToPDFString(str) { if (str[0] &gt;= &quot;\\xEF&quot;) { let encoding; if (str[0] === &quot;\\xFE&quot; &amp;&amp; str[1] === &quot;\\xFF&quot;) { encoding = &quot;utf-16be&quot;; } else if (str[0] === &quot;\\xFF&quot; &amp;&amp; str[1] === &quot;\\xFE&quot;) { encoding = &quot;utf-16le&quot;; } else if (str[0] === &quot;\\xEF&quot; &amp;&amp; str[1] === &quot;\\xBB&quot; &amp;&amp; str[2] === &quot;\\xBF&quot;) { encoding = &quot;utf-8&quot;; } if (encoding) { try { const decoder = new TextDecoder(encoding, { fatal: true }); const buffer = stringToBytes(str); return decoder.decode(buffer); } catch (ex) { warn(`stringToPDFString: &quot;${ex}&quot;.`); } } } const strBuf = []; for (let i = 0, ii = str.length; i &lt; ii; i++) { const code = PDFStringTranslateTable[str.charCodeAt(i)]; strBuf.push(code ? String.fromCharCode(code) : str.charAt(i)); } return strBuf.join(&quot;&quot;); } function escapeString(str) { return str.replace(/([()\\\\\\n\\r])/g, match =&gt; { if (match === &quot;\\n&quot;) { return &quot;\\\\n&quot;; } else if (match === &quot;\\r&quot;) { return &quot;\\\\r&quot;; } return `\\\\${match}`; }); } function isAscii(str) { return /^[\\x00-\\x7F]*$/.test(str); } function stringToUTF16BEString(str) { const buf = [&quot;\\xFE\\xFF&quot;]; for (let i = 0, ii = str.length; i &lt; ii; i++) { const char = str.charCodeAt(i); buf.push(String.fromCharCode(char &gt;&gt; 8 &amp; 0xff), String.fromCharCode(char &amp; 0xff)); } return buf.join(&quot;&quot;); } function stringToUTF8String(str) { return decodeURIComponent(escape(str)); } function utf8StringToString(str) { return unescape(encodeURIComponent(str)); } function isArrayBuffer(v) { return typeof v === &quot;object&quot; &amp;&amp; v !== null &amp;&amp; v.byteLength !== undefined; } function isArrayEqual(arr1, arr2) { if (arr1.length !== arr2.length) { return false; } for (let i = 0, ii = arr1.length; i &lt; ii; i++) { if (arr1[i] !== arr2[i]) { return false; } } return true; } function getModificationDate(date = new Date()) { const buffer = [date.getUTCFullYear().toString(), (date.getUTCMonth() + 1).toString().padStart(2, &quot;0&quot;), date.getUTCDate().toString().padStart(2, &quot;0&quot;), date.getUTCHours().toString().padStart(2, &quot;0&quot;), date.getUTCMinutes().toString().padStart(2, &quot;0&quot;), date.getUTCSeconds().toString().padStart(2, &quot;0&quot;)]; return buffer.join(&quot;&quot;); } function createPromiseCapability() { const capability = Object.create(null); let isSettled = false; Object.defineProperty(capability, &quot;settled&quot;, { get() { return isSettled; } }); capability.promise = new Promise(function (resolve, reject) { capability.resolve = function (data) { isSettled = true; resolve(data); }; capability.reject = function (reason) { isSettled = true; reject(reason); }; }); return capability; } /***/ }), /* 2 */ /***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) =&gt; { Object.defineProperty(exports, &quot;__esModule&quot;, ({ value: true })); exports.build = exports.RenderTask = exports.PDFWorkerUtil = exports.PDFWorker = exports.PDFPageProxy = exports.PDFDocumentProxy = exports.PDFDocumentLoadingTask = exports.PDFDataRangeTransport = exports.LoopbackPort = exports.DefaultStandardFontDataFactory = exports.DefaultCanvasFactory = exports.DefaultCMapReaderFactory = void 0; exports.getDocument = getDocument; exports.setPDFNetworkStreamFactory = setPDFNetworkStreamFactory; exports.version = void 0; var _util = __w_pdfjs_require__(1); var _annotation_storage = __w_pdfjs_require__(3); var _display_utils = __w_pdfjs_require__(6); var _font_loader = __w_pdfjs_require__(9); var _canvas = __w_pdfjs_require__(10); var _worker_options = __w_pdfjs_require__(14); var _is_node = __w_pdfjs_require__(12); var _message_handler = __w_pdfjs_require__(15); var _metadata = __w_pdfjs_require__(16); var _optional_content_config = __w_pdfjs_require__(17); var _transport_stream = __w_pdfjs_require__(18); var _xfa_text = __w_pdfjs_require__(19); const DEFAULT_RANGE_CHUNK_SIZE = 65536; const RENDERING_CANCELLED_TIMEOUT = 100; let DefaultCanvasFactory = _display_utils.DOMCanvasFactory; exports.DefaultCanvasFactory = DefaultCanvasFactory; let DefaultCMapReaderFactory = _display_utils.DOMCMapReaderFactory; exports.DefaultCMapReaderFactory = DefaultCMapReaderFactory; let DefaultStandardFontDataFactory = _display_utils.DOMStandardFontDataFactory; exports.DefaultStandardFontDataFactory = DefaultStandardFontDataFactory; if (_is_node.isNodeJS) { const { NodeCanvasFactory, NodeCMapReaderFactory, NodeStandardFontDataFactory } = __w_pdfjs_require__(20); exports.DefaultCanvasFactory = DefaultCanvasFactory = NodeCanvasFactory; exports.DefaultCMapReaderFactory = DefaultCMapReaderFactory = NodeCMapReaderFactory; exports.DefaultStandardFontDataFactory = DefaultStandardFontDataFactory = NodeStandardFontDataFactory; } let createPDFNetworkStream; function setPDFNetworkStreamFactory(pdfNetworkStreamFactory) { createPDFNetworkStream = pdfNetworkStreamFactory; } function getDocument(src) { const task = new PDFDocumentLoadingTask(); let source; if (typeof src === &quot;string&quot; || src instanceof URL) { source = { url: src }; } else if ((0, _util.isArrayBuffer)(src)) { source = { data: src }; } else if (src instanceof PDFDataRangeTransport) { source = { range: src }; } else { if (typeof src !== &quot;object&quot;) { throw new Error(&quot;Invalid parameter in getDocument, &quot; + &quot;need either string, URL, TypedArray, or parameter object.&quot;); } if (!src.url &amp;&amp; !src.data &amp;&amp; !src.range) { throw new Error(&quot;Invalid parameter object: need either .data, .range or .url&quot;); } source = src; } const params = Object.create(null); let rangeTransport = null, worker = null; for (const key in source) { const value = source[key]; switch (key) { case &quot;url&quot;: if (typeof window !== &quot;undefined&quot;) { try { params[key] = new URL(value, window.location).href; continue; } catch (ex) { (0, _util.warn)(`Cannot create valid URL: &quot;${ex}&quot;.`); } } else if (typeof value === &quot;string&quot; || value instanceof URL) { params[key] = value.toString(); continue; } throw new Error(&quot;Invalid PDF url data: &quot; + &quot;either string or URL-object is expected in the url property.&quot;); case &quot;range&quot;: rangeTransport = value; continue; case &quot;worker&quot;: worker = value; continue; case &quot;data&quot;: if (_is_node.isNodeJS &amp;&amp; typeof Buffer !== &quot;undefined&quot; &amp;&amp; value instanceof Buffer) { params[key] = new Uint8Array(value); } else if (value instanceof Uint8Array) { break; } else if (typeof value === &quot;string&quot;) { params[key] = (0, _util.stringToBytes)(value); } else if (typeof value === &quot;object&quot; &amp;&amp; value !== null &amp;&amp; !isNaN(value.length)) { params[key] = new Uint8Array(value); } else if ((0, _util.isArrayBuffer)(value)) { params[key] = new Uint8Array(value); } else { throw new Error(&quot;Invalid PDF binary data: either TypedArray, &quot; + &quot;string, or array-like object is expected in the data property.&quot;); } continue; } params[key] = value; } params.CMapReaderFactory = params.CMapReaderFactory || DefaultCMapReaderFactory; params.StandardFontDataFactory = params.StandardFontDataFactory || DefaultStandardFontDataFactory; params.ignoreErrors = params.stopAtErrors !== true; params.fontExtraProperties = params.fontExtraProperties === true; params.pdfBug = params.pdfBug === true; params.enableXfa = params.enableXfa === true; if (!Number.isInteger(params.rangeChunkSize) || params.rangeChunkSize &lt; 1) { params.rangeChunkSize = DEFAULT_RANGE_CHUNK_SIZE; } if (typeof params.docBaseUrl !== &quot;string&quot; || (0, _display_utils.isDataScheme)(params.docBaseUrl)) { params.docBaseUrl = null; } if (!Number.isInteger(params.maxImageSize) || params.maxImageSize &lt; -1) { params.maxImageSize = -1; } if (typeof params.cMapUrl !== &quot;string&quot;) { params.cMapUrl = null; } if (typeof params.standardFontDataUrl !== &quot;string&quot;) { params.standardFontDataUrl = null; } if (typeof params.useWorkerFetch !== &quot;boolean&quot;) { params.useWorkerFetch = params.CMapReaderFactory === _display_utils.DOMCMapReaderFactory &amp;&amp; params.StandardFontDataFactory === _display_utils.DOMStandardFontDataFactory; } if (typeof params.isEvalSupported !== &quot;boolean&quot;) { params.isEvalSupported = true; } if (typeof params.isOffscreenCanvasSupported !== &quot;boolean&quot;) { params.isOffscreenCanvasSupported = !_is_node.isNodeJS; } if (typeof params.disableFontFace !== &quot;boolean&quot;) { params.disableFontFace = _is_node.isNodeJS; } if (typeof params.useSystemFonts !== &quot;boolean&quot;) { params.useSystemFonts = !_is_node.isNodeJS &amp;&amp; !params.disableFontFace; } if (typeof params.ownerDocument !== &quot;object&quot; || params.ownerDocument === null) { params.ownerDocument = globalThis.document; } if (typeof params.disableRange !== &quot;boolean&quot;) { params.disableRange = false; } if (typeof params.disableStream !== &quot;boolean&quot;) { params.disableStream = false; } if (typeof params.disableAutoFetch !== &quot;boolean&quot;) { params.disableAutoFetch = false; } (0, _util.setVerbosityLevel)(params.verbosity); if (!worker) { const workerParams = { verbosity: params.verbosity, port: _worker_options.GlobalWorkerOptions.workerPort }; worker = workerParams.port ? PDFWorker.fromPort(workerParams) : new PDFWorker(workerParams); task._worker = worker; } const docId = task.docId; worker.promise.then(function () { if (task.destroyed) { throw new Error(&quot;Loading aborted&quot;); } const workerIdPromise = _fetchDocument(worker, params, rangeTransport, docId); const networkStreamPromise = new Promise(function (resolve) { let networkStream; if (rangeTransport) { networkStream = new _transport_stream.PDFDataTransportStream({ length: params.length, initialData: params.initialData, progressiveDone: params.progressiveDone, contentDispositionFilename: params.contentDispositionFilename, disableRange: params.disableRange, disableStream: params.disableStream }, rangeTransport); } else if (!params.data) { networkStream = createPDFNetworkStream({ url: params.url, length: params.length, httpHeaders: params.httpHeaders, withCredentials: params.withCredentials, rangeChunkSize: params.rangeChunkSize, disableRange: params.disableRange, disableStream: params.disableStream }); } resolve(networkStream); }); return Promise.all([workerIdPromise, networkStreamPromise]).then(function ([workerId, networkStream]) { if (task.destroyed) { throw new Error(&quot;Loading aborted&quot;); } const messageHandler = new _message_handler.MessageHandler(docId, workerId, worker.port); const transport = new WorkerTransport(messageHandler, task, networkStream, params); task._transport = transport; messageHandler.send(&quot;Ready&quot;, null); }); }).catch(task._capability.reject); return task; } async function _fetchDocument(worker, source, pdfDataRangeTransport, docId) { if (worker.destroyed) { throw new Error(&quot;Worker was destroyed&quot;); } if (pdfDataRangeTransport) { source.length = pdfDataRangeTransport.length; source.initialData = pdfDataRangeTransport.initialData; source.progressiveDone = pdfDataRangeTransport.progressiveDone; source.contentDispositionFilename = pdfDataRangeTransport.contentDispositionFilename; } const workerId = await worker.messageHandler.sendWithPromise(&quot;GetDocRequest&quot;, { docId, apiVersion: &apos;3.0.0&apos;, data: source.data, password: source.password, disableAutoFetch: source.disableAutoFetch, rangeChunkSize: source.rangeChunkSize, length: source.length, docBaseUrl: source.docBaseUrl, enableXfa: source.enableXfa, evaluatorOptions: { maxImageSize: source.maxImageSize, disableFontFace: source.disableFontFace, ignoreErrors: source.ignoreErrors, isEvalSupported: source.isEvalSupported, isOffscreenCanvasSupported: source.isOffscreenCanvasSupported, fontExtraProperties: source.fontExtraProperties, useSystemFonts: source.useSystemFonts, cMapUrl: source.useWorkerFetch ? source.cMapUrl : null, standardFontDataUrl: source.useWorkerFetch ? source.standardFontDataUrl : null } }); if (source.data) { source.data = null; } if (worker.destroyed) { throw new Error(&quot;Worker was destroyed&quot;); } return workerId; } class PDFDocumentLoadingTask { static #docId = 0; constructor() { this._capability = (0, _util.createPromiseCapability)(); this._transport = null; this._worker = null; this.docId = `d${PDFDocumentLoadingTask.#docId++}`; this.destroyed = false; this.onPassword = null; this.onProgress = null; this.onUnsupportedFeature = null; } get promise() { return this._capability.promise; } async destroy() { this.destroyed = true; await this._transport?.destroy(); this._transport = null; if (this._worker) { this._worker.destroy(); this._worker = null; } } } exports.PDFDocumentLoadingTask = PDFDocumentLoadingTask; class PDFDataRangeTransport { constructor(length, initialData, progressiveDone = false, contentDispositionFilename = null) { this.length = length; this.initialData = initialData; this.progressiveDone = progressiveDone; this.contentDispositionFilename = contentDispositionFilename; this._rangeListeners = []; this._progressListeners = []; this._progressiveReadListeners = []; this._progressiveDoneListeners = []; this._readyCapability = (0, _util.createPromiseCapability)(); } addRangeListener(listener) { this._rangeListeners.push(listener); } addProgressListener(listener) { this._progressListeners.push(listener); } addProgressiveReadListener(listener) { this._progressiveReadListeners.push(listener); } addProgressiveDoneListener(listener) { this._progressiveDoneListeners.push(listener); } onDataRange(begin, chunk) { for (const listener of this._rangeListeners) { listener(begin, chunk); } } onDataProgress(loaded, total) { this._readyCapability.promise.then(() =&gt; { for (const listener of this._progressListeners) { listener(loaded, total); } }); } onDataProgressiveRead(chunk) { this._readyCapability.promise.then(() =&gt; { for (const listener of this._progressiveReadListeners) { listener(chunk); } }); } onDataProgressiveDone() { this._readyCapability.promise.then(() =&gt; { for (const listener of this._progressiveDoneListeners) { listener(); } }); } transportReady() { this._readyCapability.resolve(); } requestDataRange(begin, end) { (0, _util.unreachable)(&quot;Abstract method PDFDataRangeTransport.requestDataRange&quot;); } abort() {} } exports.PDFDataRangeTransport = PDFDataRangeTransport; class PDFDocumentProxy { constructor(pdfInfo, transport) { this._pdfInfo = pdfInfo; this._transport = transport; } get annotationStorage() { return this._transport.annotationStorage; } get numPages() { return this._pdfInfo.numPages; } get fingerprints() { return this._pdfInfo.fingerprints; } get stats() { return this._transport.stats; } get isPureXfa() { return !!this._transport._htmlForXfa; } get allXfaHtml() { return this._transport._htmlForXfa; } getPage(pageNumber) { return this._transport.getPage(pageNumber); } getPageIndex(ref) { return this._transport.getPageIndex(ref); } getDestinations() { return this._transport.getDestinations(); } getDestination(id) { return this._transport.getDestination(id); } getPageLabels() { return this._transport.getPageLabels(); } getPageLayout() { return this._transport.getPageLayout(); } getPageMode() { return this._transport.getPageMode(); } getViewerPreferences() { return this._transport.getViewerPreferences(); } getOpenAction() { return this._transport.getOpenAction(); } getAttachments() { return this._transport.getAttachments(); } getJavaScript() { return this._transport.getJavaScript(); } getJSActions() { return this._transport.getDocJSActions(); } getOutline() { return this._transport.getOutline(); } getOptionalContentConfig() { return this._transport.getOptionalContentConfig(); } getPermissions() { return this._transport.getPermissions(); } getMetadata() { return this._transport.getMetadata(); } getMarkInfo() { return this._transport.getMarkInfo(); } getData() { return this._transport.getData(); } saveDocument() { return this._transport.saveDocument(); } getDownloadInfo() { return this._transport.downloadInfoCapability.promise; } cleanup(keepLoadedFonts = false) { return this._transport.startCleanup(keepLoadedFonts || this.isPureXfa); } destroy() { return this.loadingTask.destroy(); } get loadingParams() { return this._transport.loadingParams; } get loadingTask() { return this._transport.loadingTask; } getFieldObjects() { return this._transport.getFieldObjects(); } hasJSActions() { return this._transport.hasJSActions(); } getCalculationOrderIds() { return this._transport.getCalculationOrderIds(); } } exports.PDFDocumentProxy = PDFDocumentProxy; class PDFPageProxy { constructor(pageIndex, pageInfo, transport, ownerDocument, pdfBug = false) { this._pageIndex = pageIndex; this._pageInfo = pageInfo; this._ownerDocument = ownerDocument; this._transport = transport; this._stats = pdfBug ? new _display_utils.StatTimer() : null; this._pdfBug = pdfBug; this.commonObjs = transport.commonObjs; this.objs = new PDFObjects(); this._bitmaps = new Set(); this.cleanupAfterRender = false; this.pendingCleanup = false; this._intentStates = new Map(); this._annotationPromises = new Map(); this.destroyed = false; } get pageNumber() { return this._pageIndex + 1; } get rotate() { return this._pageInfo.rotate; } get ref() { return this._pageInfo.ref; } get userUnit() { return this._pageInfo.userUnit; } get view() { return this._pageInfo.view; } getViewport({ scale, rotation = this.rotate, offsetX = 0, offsetY = 0, dontFlip = false } = {}) { return new _display_utils.PageViewport({ viewBox: this.view, scale, rotation, offsetX, offsetY, dontFlip }); } getAnnotations({ intent = &quot;display&quot; } = {}) { const intentArgs = this._transport.getRenderingIntent(intent); let promise = this._annotationPromises.get(intentArgs.cacheKey); if (!promise) { promise = this._transport.getAnnotations(this._pageIndex, intentArgs.renderingIntent); this._annotationPromises.set(intentArgs.cacheKey, promise); } return promise; } getJSActions() { return this._jsActionsPromise ||= this._transport.getPageJSActions(this._pageIndex); } async getXfa() { return this._transport._htmlForXfa?.children[this._pageIndex] || null; } render({ canvasContext, viewport, intent = &quot;display&quot;, annotationMode = _util.AnnotationMode.ENABLE, transform = null, canvasFactory = null, background = null, optionalContentConfigPromise = null, annotationCanvasMap = null, pageColors = null, printAnnotationStorage = null }) { this._stats?.time(&quot;Overall&quot;); const intentArgs = this._transport.getRenderingIntent(intent, annotationMode, printAnnotationStorage); this.pendingCleanup = false; if (!optionalContentConfigPromise) { optionalContentConfigPromise = this._transport.getOptionalContentConfig(); } let intentState = this._intentStates.get(intentArgs.cacheKey); if (!intentState) { intentState = Object.create(null); this._intentStates.set(intentArgs.cacheKey, intentState); } if (intentState.streamReaderCancelTimeout) { clearTimeout(intentState.streamReaderCancelTimeout); intentState.streamReaderCancelTimeout = null; } const canvasFactoryInstance = canvasFactory || new DefaultCanvasFactory({ ownerDocument: this._ownerDocument }); const intentPrint = !!(intentArgs.renderingIntent &amp; _util.RenderingIntentFlag.PRINT); if (!intentState.displayReadyCapability) { intentState.displayReadyCapability = (0, _util.createPromiseCapability)(); intentState.operatorList = { fnArray: [], argsArray: [], lastChunk: false, separateAnnots: null }; this._stats?.time(&quot;Page Request&quot;); this._pumpOperatorList(intentArgs); } const complete = error =&gt; { intentState.renderTasks.delete(internalRenderTask); if (this.cleanupAfterRender || intentPrint) { this.pendingCleanup = true; } this._tryCleanup(); if (error) { internalRenderTask.capability.reject(error); this._abortOperatorList({ intentState, reason: error instanceof Error ? error : new Error(error) }); } else { internalRenderTask.capability.resolve(); } this._stats?.timeEnd(&quot;Rendering&quot;); this._stats?.timeEnd(&quot;Overall&quot;); }; const internalRenderTask = new InternalRenderTask({ callback: complete, params: { canvasContext, viewport, transform, background }, objs: this.objs, commonObjs: this.commonObjs, annotationCanvasMap, operatorList: intentState.operatorList, pageIndex: this._pageIndex, canvasFactory: canvasFactoryInstance, useRequestAnimationFrame: !intentPrint, pdfBug: this._pdfBug, pageColors }); (intentState.renderTasks ||= new Set()).add(internalRenderTask); const renderTask = internalRenderTask.task; Promise.all([intentState.displayReadyCapability.promise, optionalContentConfigPromise]).then(([transparency, optionalContentConfig]) =&gt; { if (this.pendingCleanup) { complete(); return; } this._stats?.time(&quot;Rendering&quot;); internalRenderTask.initializeGraphics({ transparency, optionalContentConfig }); internalRenderTask.operatorListChanged(); }).catch(complete); return renderTask; } getOperatorList({ intent = &quot;display&quot;, annotationMode = _util.AnnotationMode.ENABLE, printAnnotationStorage = null } = {}) { function operatorListChanged() { if (intentState.operatorList.lastChunk) { intentState.opListReadCapability.resolve(intentState.operatorList); intentState.renderTasks.delete(opListTask); } } const intentArgs = this._transport.getRenderingIntent(intent, annotationMode, printAnnotationStorage, true); let intentState = this._intentStates.get(intentArgs.cacheKey); if (!intentState) { intentState = Object.create(null); this._intentStates.set(intentArgs.cacheKey, intentState); } let opListTask; if (!intentState.opListReadCapability) { opListTask = Object.create(null); opListTask.operatorListChanged = operatorListChanged; intentState.opListReadCapability = (0, _util.createPromiseCapability)(); (intentState.renderTasks ||= new Set()).add(opListTask); intentState.operatorList = { fnArray: [], argsArray: [], lastChunk: false, separateAnnots: null }; this._stats?.time(&quot;Page Request&quot;); this._pumpOperatorList(intentArgs); } return intentState.opListReadCapability.promise; } streamTextContent({ disableCombineTextItems = false, includeMarkedContent = false } = {}) { const TEXT_CONTENT_CHUNK_SIZE = 100; return this._transport.messageHandler.sendWithStream(&quot;GetTextContent&quot;, { pageIndex: this._pageIndex, combineTextItems: disableCombineTextItems !== true, includeMarkedContent: includeMarkedContent === true }, { highWaterMark: TEXT_CONTENT_CHUNK_SIZE, size(textContent) { return textContent.items.length; } }); } getTextContent(params = {}) { if (this._transport._htmlForXfa) { return this.getXfa().then(xfa =&gt; { return _xfa_text.XfaText.textContent(xfa); }); } const readableStream = this.streamTextContent(params); return new Promise(function (resolve, reject) { function pump() { reader.read().then(function ({ value, done }) { if (done) { resolve(textContent); return; } Object.assign(textContent.styles, value.styles); textContent.items.push(...value.items); pump(); }, reject); } const reader = readableStream.getReader(); const textContent = { items: [], styles: Object.create(null) }; pump(); }); } getStructTree() { return this._structTreePromise ||= this._transport.getStructTree(this._pageIndex); } _destroy() { this.destroyed = true; const waitOn = []; for (const intentState of this._intentStates.values()) { this._abortOperatorList({ intentState, reason: new Error(&quot;Page was destroyed.&quot;), force: true }); if (intentState.opListReadCapability) { continue; } for (const internalRenderTask of intentState.renderTasks) { waitOn.push(internalRenderTask.completed); internalRenderTask.cancel(); } } this.objs.clear(); for (const bitmap of this._bitmaps) { bitmap.close(); } this._bitmaps.clear(); this._annotationPromises.clear(); this._jsActionsPromise = null; this._structTreePromise = null; this.pendingCleanup = false; return Promise.all(waitOn); } cleanup(resetStats = false) { this.pendingCleanup = true; return this._tryCleanup(resetStats); } _tryCleanup(resetStats = false) { if (!this.pendingCleanup) { return false; } for (const { renderTasks, operatorList } of this._intentStates.values()) { if (renderTasks.size &gt; 0 || !operatorList.lastChunk) { return false; } } this._intentStates.clear(); this.objs.clear(); this._annotationPromises.clear(); this._jsActionsPromise = null; this._structTreePromise = null; if (resetStats &amp;&amp; this._stats) { this._stats = new _display_utils.StatTimer(); } for (const bitmap of this._bitmaps) { bitmap.close(); } this._bitmaps.clear(); this.pendingCleanup = false; return true; } _startRenderPage(transparency, cacheKey) { const intentState = this._intentStates.get(cacheKey); if (!intentState) { return; } this._stats?.timeEnd(&quot;Page Request&quot;); intentState.displayReadyCapability?.resolve(transparency); } _renderPageChunk(operatorListChunk, intentState) { for (let i = 0, ii = operatorListChunk.length; i &lt; ii; i++) { intentState.operatorList.fnArray.push(operatorListChunk.fnArray[i]); intentState.operatorList.argsArray.push(operatorListChunk.argsArray[i]); } intentState.operatorList.lastChunk = operatorListChunk.lastChunk; intentState.operatorList.separateAnnots = operatorListChunk.separateAnnots; for (const internalRenderTask of intentState.renderTasks) { internalRenderTask.operatorListChanged(); } if (operatorListChunk.lastChunk) { this._tryCleanup(); } } _pumpOperatorList({ renderingIntent, cacheKey, annotationStorageMap }) { const readableStream = this._transport.messageHandler.sendWithStream(&quot;GetOperatorList&quot;, { pageIndex: this._pageIndex, intent: renderingIntent, cacheKey, annotationStorage: annotationStorageMap }); const reader = readableStream.getReader(); const intentState = this._intentStates.get(cacheKey); intentState.streamReader = reader; const pump = () =&gt; { reader.read().then(({ value, done }) =&gt; { if (done) { intentState.streamReader = null; return; } if (this._transport.destroyed) { return; } this._renderPageChunk(value, intentState); pump(); }, reason =&gt; { intentState.streamReader = null; if (this._transport.destroyed) { return; } if (intentState.operatorList) { intentState.operatorList.lastChunk = true; for (const internalRenderTask of intentState.renderTasks) { internalRenderTask.operatorListChanged(); } this._tryCleanup(); } if (intentState.displayReadyCapability) { intentState.displayReadyCapability.reject(reason); } else if (intentState.opListReadCapability) { intentState.opListReadCapability.reject(reason); } else { throw reason; } }); }; pump(); } _abortOperatorList({ intentState, reason, force = false }) { if (!intentState.streamReader) { return; } if (!force) { if (intentState.renderTasks.size &gt; 0) { return; } if (reason instanceof _display_utils.RenderingCancelledException) { intentState.streamReaderCancelTimeout = setTimeout(() =&gt; { this._abortOperatorList({ intentState, reason, force: true }); intentState.streamReaderCancelTimeout = null; }, RENDERING_CANCELLED_TIMEOUT); return; } } intentState.streamReader.cancel(new _util.AbortException(reason.message)).catch(() =&gt; {}); intentState.streamReader = null; if (this._transport.destroyed) { return; } for (const [curCacheKey, curIntentState] of this._intentStates) { if (curIntentState === intentState) { this._intentStates.delete(curCacheKey); break; } } this.cleanup(); } get stats() { return this._stats; } } exports.PDFPageProxy = PDFPageProxy; class LoopbackPort { #listeners = []; #deferred = Promise.resolve(); postMessage(obj, transfers) { const event = { data: structuredClone(obj, transfers) }; this.#deferred.then(() =&gt; { for (const listener of this.#listeners) { listener.call(this, event); } }); } addEventListener(name, listener) { this.#listeners.push(listener); } removeEventListener(name, listener) { const i = this.#listeners.indexOf(listener); this.#listeners.splice(i, 1); } terminate() { this.#listeners.length = 0; } } exports.LoopbackPort = LoopbackPort; const PDFWorkerUtil = { isWorkerDisabled: false, fallbackWorkerSrc: null, fakeWorkerId: 0 }; exports.PDFWorkerUtil = PDFWorkerUtil; { if (_is_node.isNodeJS &amp;&amp; typeof require === &quot;function&quot;) { PDFWorkerUtil.isWorkerDisabled = true; PDFWorkerUtil.fallbackWorkerSrc = &quot;./pdf.worker.js&quot;; } else if (typeof document === &quot;object&quot;) { const pdfjsFilePath = document?.currentScript?.src; if (pdfjsFilePath) { PDFWorkerUtil.fallbackWorkerSrc = pdfjsFilePath.replace(/(\\.(?:min\\.)?js)(\\?.*)?$/i, &quot;.worker$1$2&quot;); } } PDFWorkerUtil.isSameOrigin = function (baseUrl, otherUrl) { let base; try { base = new URL(baseUrl); if (!base.origin || base.origin === &quot;null&quot;) { return false; } } catch (e) { return false; } const other = new URL(otherUrl, base); return base.origin === other.origin; }; PDFWorkerUtil.createCDNWrapper = function (url) { const wrapper = `importScripts(&quot;${url}&quot;);`; return URL.createObjectURL(new Blob([wrapper])); }; } class PDFWorker { static #workerPorts = new WeakMap(); constructor({ name = null, port = null, verbosity = (0, _util.getVerbosityLevel)() } = {}) { if (port &amp;&amp; PDFWorker.#workerPorts.has(port)) { throw new Error(&quot;Cannot use more than one PDFWorker per port.&quot;); } this.name = name; this.destroyed = false; this.verbosity = verbosity; this._readyCapability = (0, _util.createPromiseCapability)(); this._port = null; this._webWorker = null; this._messageHandler = null; if (port) { PDFWorker.#workerPorts.set(port, this); this._initializeFromPort(port); return; } this._initialize(); } get promise() { return this._readyCapability.promise; } get port() { return this._port; } get messageHandler() { return this._messageHandler; } _initializeFromPort(port) { this._port = port; this._messageHandler = new _message_handler.MessageHandler(&quot;main&quot;, &quot;worker&quot;, port); this._messageHandler.on(&quot;ready&quot;, function () {}); this._readyCapability.resolve(); this._messageHandler.send(&quot;configure&quot;, { verbosity: this.verbosity }); } _initialize() { if (!PDFWorkerUtil.isWorkerDisabled &amp;&amp; !PDFWorker._mainThreadWorkerMessageHandler) { let { workerSrc } = PDFWorker; try { if (!PDFWorkerUtil.isSameOrigin(window.location.href, workerSrc)) { workerSrc = PDFWorkerUtil.createCDNWrapper(new URL(workerSrc, window.location).href); } const worker = new Worker(workerSrc); const messageHandler = new _message_handler.MessageHandler(&quot;main&quot;, &quot;worker&quot;, worker); const terminateEarly = () =&gt; { worker.removeEventListener(&quot;error&quot;, onWorkerError); messageHandler.destroy(); worker.terminate(); if (this.destroyed) { this._readyCapability.reject(new Error(&quot;Worker was destroyed&quot;)); } else { this._setupFakeWorker(); } }; const onWorkerError = () =&gt; { if (!this._webWorker) { terminateEarly(); } }; worker.addEventListener(&quot;error&quot;, onWorkerError); messageHandler.on(&quot;test&quot;, data =&gt; { worker.removeEventListener(&quot;error&quot;, onWorkerError); if (this.destroyed) { terminateEarly(); return; } if (data) { this._messageHandler = messageHandler; this._port = worker; this._webWorker = worker; this._readyCapability.resolve(); messageHandler.send(&quot;configure&quot;, { verbosity: this.verbosity }); } else { this._setupFakeWorker(); messageHandler.destroy(); worker.terminate(); } }); messageHandler.on(&quot;ready&quot;, data =&gt; { worker.removeEventListener(&quot;error&quot;, onWorkerError); if (this.destroyed) { terminateEarly(); return; } try { sendTest(); } catch (e) { this._setupFakeWorker(); } }); const sendTest = () =&gt; { const testObj = new Uint8Array(); messageHandler.send(&quot;test&quot;, testObj, [testObj.buffer]); }; sendTest(); return; } catch (e) { (0, _util.info)(&quot;The worker has been disabled.&quot;); } } this._setupFakeWorker(); } _setupFakeWorker() { if (!PDFWorkerUtil.isWorkerDisabled) { (0, _util.warn)(&quot;Setting up fake worker.&quot;); PDFWorkerUtil.isWorkerDisabled = true; } PDFWorker._setupFakeWorkerGlobal.then(WorkerMessageHandler =&gt; { if (this.destroyed) { this._readyCapability.reject(new Error(&quot;Worker was destroyed&quot;)); return; } const port = new LoopbackPort(); this._port = port; const id = `fake${PDFWorkerUtil.fakeWorkerId++}`; const workerHandler = new _message_handler.MessageHandler(id + &quot;_worker&quot;, id, port); WorkerMessageHandler.setup(workerHandler, port); const messageHandler = new _message_handler.MessageHandler(id, id + &quot;_worker&quot;, port); this._messageHandler = messageHandler; this._readyCapability.resolve(); messageHandler.send(&quot;configure&quot;, { verbosity: this.verbosity }); }).catch(reason =&gt; { this._readyCapability.reject(new Error(`Setting up fake worker failed: &quot;${reason.message}&quot;.`)); }); } destroy() { this.destroyed = true; if (this._webWorker) { this._webWorker.terminate(); this._webWorker = null; } PDFWorker.#workerPorts.delete(this._port); this._port = null; if (this._messageHandler) { this._messageHandler.destroy(); this._messageHandler = null; } } static fromPort(params) { if (!params?.port) { throw new Error(&quot;PDFWorker.fromPort - invalid method signature.&quot;); } if (this.#workerPorts.has(params.port)) { return this.#workerPorts.get(params.port); } return new PDFWorker(params); } static get workerSrc() { if (_worker_options.GlobalWorkerOptions.workerSrc) { return _worker_options.GlobalWorkerOptions.workerSrc; } if (PDFWorkerUtil.fallbackWorkerSrc !== null) { if (!_is_node.isNodeJS) { (0, _display_utils.deprecated)(&apos;No &quot;GlobalWorkerOptions.workerSrc&quot; specified.&apos;); } return PDFWorkerUtil.fallbackWorkerSrc; } throw new Error(&apos;No &quot;GlobalWorkerOptions.workerSrc&quot; specified.&apos;); } static get _mainThreadWorkerMessageHandler() { try { return globalThis.pdfjsWorker?.WorkerMessageHandler || null; } catch (ex) { return null; } } static get _setupFakeWorkerGlobal() { const loader = async () =&gt; { const mainWorkerMessageHandler = this._mainThreadWorkerMessageHandler; if (mainWorkerMessageHandler) { return mainWorkerMessageHandler; } if (_is_node.isNodeJS &amp;&amp; typeof require === &quot;function&quot;) { const worker = eval(&quot;require&quot;)(this.workerSrc); return worker.WorkerMessageHandler; } await (0, _display_utils.loadScript)(this.workerSrc); return window.pdfjsWorker.WorkerMessageHandler; }; return (0, _util.shadow)(this, &quot;_setupFakeWorkerGlobal&quot;, loader()); } } exports.PDFWorker = PDFWorker; class WorkerTransport { #docStats = null; #pageCache = new Map(); #pagePromises = new Map(); #metadataPromise = null; constructor(messageHandler, loadingTask, networkStream, params) { this.messageHandler = messageHandler; this.loadingTask = loadingTask; this.commonObjs = new PDFObjects(); this.fontLoader = new _font_loader.FontLoader({ onUnsupportedFeature: this._onUnsupportedFeature.bind(this), ownerDocument: params.ownerDocument, styleElement: params.styleElement }); this._params = params; if (!params.useWorkerFetch) { this.CMapReaderFactory = new params.CMapReaderFactory({ baseUrl: params.cMapUrl, isCompressed: params.cMapPacked }); this.StandardFontDataFactory = new params.StandardFontDataFactory({ baseUrl: params.standardFontDataUrl }); } this.destroyed = false; this.destroyCapability = null; this._passwordCapability = null; this._networkStream = networkStream; this._fullReader = null; this._lastProgress = null; this.downloadInfoCapability = (0, _util.createPromiseCapability)(); this.setupMessageHandler(); } get annotationStorage() { return (0, _util.shadow)(this, &quot;annotationStorage&quot;, new _annotation_storage.AnnotationStorage()); } get stats() { return this.#docStats; } getRenderingIntent(intent, annotationMode = _util.AnnotationMode.ENABLE, printAnnotationStorage = null, isOpList = false) { let renderingIntent = _util.RenderingIntentFlag.DISPLAY; let annotationMap = null; switch (intent) { case &quot;any&quot;: renderingIntent = _util.RenderingIntentFlag.ANY; break; case &quot;display&quot;: break; case &quot;print&quot;: renderingIntent = _util.RenderingIntentFlag.PRINT; break; default: (0, _util.warn)(`getRenderingIntent - invalid intent: ${intent}`); } switch (annotationMode) { case _util.AnnotationMode.DISABLE: renderingIntent += _util.RenderingIntentFlag.ANNOTATIONS_DISABLE; break; case _util.AnnotationMode.ENABLE: break; case _util.AnnotationMode.ENABLE_FORMS: renderingIntent += _util.RenderingIntentFlag.ANNOTATIONS_FORMS; break; case _util.AnnotationMode.ENABLE_STORAGE: renderingIntent += _util.RenderingIntentFlag.ANNOTATIONS_STORAGE; const annotationStorage = renderingIntent &amp; _util.RenderingIntentFlag.PRINT &amp;&amp; printAnnotationStorage instanceof _annotation_storage.PrintAnnotationStorage ? printAnnotationStorage : this.annotationStorage; annotationMap = annotationStorage.serializable; break; default: (0, _util.warn)(`getRenderingIntent - invalid annotationMode: ${annotationMode}`); } if (isOpList) { renderingIntent += _util.RenderingIntentFlag.OPLIST; } return { renderingIntent, cacheKey: `${renderingIntent}_${_annotation_storage.AnnotationStorage.getHash(annotationMap)}`, annotationStorageMap: annotationMap }; } destroy() { if (this.destroyCapability) { return this.destroyCapability.promise; } this.destroyed = true; this.destroyCapability = (0, _util.createPromiseCapability)(); if (this._passwordCapability) { this._passwordCapability.reject(new Error(&quot;Worker was destroyed during onPassword callback&quot;)); } const waitOn = []; for (const page of this.#pageCache.values()) { waitOn.push(page._destroy()); } this.#pageCache.clear(); this.#pagePromises.clear(); if (this.hasOwnProperty(&quot;annotationStorage&quot;)) { this.annotationStorage.resetModified(); } const terminated = this.messageHandler.sendWithPromise(&quot;Terminate&quot;, null); waitOn.push(terminated); Promise.all(waitOn).then(() =&gt; { this.commonObjs.clear(); this.fontLoader.clear(); this.#metadataPromise = null; this._getFieldObjectsPromise = null; this._hasJSActionsPromise = null; if (this._networkStream) { this._networkStream.cancelAllRequests(new _util.AbortException(&quot;Worker was terminated.&quot;)); } if (this.messageHandler) { this.messageHandler.destroy(); this.messageHandler = null; } this.destroyCapability.resolve(); }, this.destroyCapability.reject); return this.destroyCapability.promise; } setupMessageHandler() { const { messageHandler, loadingTask } = this; messageHandler.on(&quot;GetReader&quot;, (data, sink) =&gt; { (0, _util.assert)(this._networkStream, &quot;GetReader - no `IPDFStream` instance available.&quot;); this._fullReader = this._networkStream.getFullReader(); this._fullReader.onProgress = evt =&gt; { this._lastProgress = { loaded: evt.loaded, total: evt.total }; }; sink.onPull = () =&gt; { this._fullReader.read().then(function ({ value, done }) { if (done) { sink.close(); return; } (0, _util.assert)((0, _util.isArrayBuffer)(value), &quot;GetReader - expected an ArrayBuffer.&quot;); sink.enqueue(new Uint8Array(value), 1, [value]); }).catch(reason =&gt; { sink.error(reason); }); }; sink.onCancel = reason =&gt; { this._fullReader.cancel(reason); sink.ready.catch(readyReason =&gt; { if (this.destroyed) { return; } throw readyReason; }); }; }); messageHandler.on(&quot;ReaderHeadersReady&quot;, data =&gt; { const headersCapability = (0, _util.createPromiseCapability)(); const fullReader = this._fullReader; fullReader.headersReady.then(() =&gt; { if (!fullReader.isStreamingSupported || !fullReader.isRangeSupported) { if (this._lastProgress) { loadingTask.onProgress?.(this._lastProgress); } fullReader.onProgress = evt =&gt; { loadingTask.onProgress?.({ loaded: evt.loaded, total: evt.total }); }; } headersCapability.resolve({ isStreamingSupported: fullReader.isStreamingSupported, isRangeSupported: fullReader.isRangeSupported, contentLength: fullReader.contentLength }); }, headersCapability.reject); return headersCapability.promise; }); messageHandler.on(&quot;GetRangeReader&quot;, (data, sink) =&gt; { (0, _util.assert)(this._networkStream, &quot;GetRangeReader - no `IPDFStream` instance available.&quot;); const rangeReader = this._networkStream.getRangeReader(data.begin, data.end); if (!rangeReader) { sink.close(); return; } sink.onPull = () =&gt; { rangeReader.read().then(function ({ value, done }) { if (done) { sink.close(); return; } (0, _util.assert)((0, _util.isArrayBuffer)(value), &quot;GetRangeReader - expected an ArrayBuffer.&quot;); sink.enqueue(new Uint8Array(value), 1, [value]); }).catch(reason =&gt; { sink.error(reason); }); }; sink.onCancel = reason =&gt; { rangeReader.cancel(reason); sink.ready.catch(readyReason =&gt; { if (this.destroyed) { return; } throw readyReason; }); }; }); messageHandler.on(&quot;GetDoc&quot;, ({ pdfInfo }) =&gt; { this._numPages = pdfInfo.numPages; this._htmlForXfa = pdfInfo.htmlForXfa; delete pdfInfo.htmlForXfa; loadingTask._capability.resolve(new PDFDocumentProxy(pdfInfo, this)); }); messageHandler.on(&quot;DocException&quot;, function (ex) { let reason; switch (ex.name) { case &quot;PasswordException&quot;: reason = new _util.PasswordException(ex.message, ex.code); break; case &quot;InvalidPDFException&quot;: reason = new _util.InvalidPDFException(ex.message); break; case &quot;MissingPDFException&quot;: reason = new _util.MissingPDFException(ex.message); break; case &quot;UnexpectedResponseException&quot;: reason = new _util.UnexpectedResponseException(ex.message, ex.status); break; case &quot;UnknownErrorException&quot;: reason = new _util.UnknownErrorException(ex.message, ex.details); break; default: (0, _util.unreachable)(&quot;DocException - expected a valid Error.&quot;); } loadingTask._capability.reject(reason); }); messageHandler.on(&quot;PasswordRequest&quot;, exception =&gt; { this._passwordCapability = (0, _util.createPromiseCapability)(); if (loadingTask.onPassword) { const updatePassword = password =&gt; { if (password instanceof Error) { this._passwordCapability.reject(password); } else { this._passwordCapability.resolve({ password }); } }; try { loadingTask.onPassword(updatePassword, exception.code); } catch (ex) { this._passwordCapability.reject(ex); } } else { this._passwordCapability.reject(new _util.PasswordException(exception.message, exception.code)); } return this._passwordCapability.promise; }); messageHandler.on(&quot;DataLoaded&quot;, data =&gt; { loadingTask.onProgress?.({ loaded: data.length, total: data.length }); this.downloadInfoCapability.resolve(data); }); messageHandler.on(&quot;StartRenderPage&quot;, data =&gt; { if (this.destroyed) { return; } const page = this.#pageCache.get(data.pageIndex); page._startRenderPage(data.transparency, data.cacheKey); }); messageHandler.on(&quot;commonobj&quot;, ([id, type, exportedData]) =&gt; { if (this.destroyed) { return; } if (this.commonObjs.has(id)) { return; } switch (type) { case &quot;Font&quot;: const params = this._params; if (&quot;error&quot; in exportedData) { const exportedError = exportedData.error; (0, _util.warn)(`Error during font loading: ${exportedError}`); this.commonObjs.resolve(id, exportedError); break; } let fontRegistry = null; if (params.pdfBug &amp;&amp; globalThis.FontInspector?.enabled) { fontRegistry = { registerFont(font, url) { globalThis.FontInspector.fontAdded(font, url); } }; } const font = new _font_loader.FontFaceObject(exportedData, { isEvalSupported: params.isEvalSupported, disableFontFace: params.disableFontFace, ignoreErrors: params.ignoreErrors, onUnsupportedFeature: this._onUnsupportedFeature.bind(this), fontRegistry }); this.fontLoader.bind(font).catch(reason =&gt; { return messageHandler.sendWithPromise(&quot;FontFallback&quot;, { id }); }).finally(() =&gt; { if (!params.fontExtraProperties &amp;&amp; font.data) { font.data = null; } this.commonObjs.resolve(id, font); }); break; case &quot;FontPath&quot;: case &quot;Image&quot;: this.commonObjs.resolve(id, exportedData); break; default: throw new Error(`Got unknown common object type ${type}`); } }); messageHandler.on(&quot;obj&quot;, ([id, pageIndex, type, imageData]) =&gt; { if (this.destroyed) { return; } const pageProxy = this.#pageCache.get(pageIndex); if (pageProxy.objs.has(id)) { return; } switch (type) { case &quot;Image&quot;: pageProxy.objs.resolve(id, imageData); const MAX_IMAGE_SIZE_TO_STORE = 8000000; if (imageData) { let length; if (imageData.bitmap) { const { bitmap, width, height } = imageData; length = width * height * 4; pageProxy._bitmaps.add(bitmap); } else { length = imageData.data?.length || 0; } if (length &gt; MAX_IMAGE_SIZE_TO_STORE) { pageProxy.cleanupAfterRender = true; } } break; case &quot;Pattern&quot;: pageProxy.objs.resolve(id, imageData); break; default: throw new Error(`Got unknown object type ${type}`); } }); messageHandler.on(&quot;DocProgress&quot;, data =&gt; { if (this.destroyed) { return; } loadingTask.onProgress?.({ loaded: data.loaded, total: data.total }); }); messageHandler.on(&quot;DocStats&quot;, data =&gt; { if (this.destroyed) { return; } this.#docStats = Object.freeze({ streamTypes: Object.freeze(data.streamTypes), fontTypes: Object.freeze(data.fontTypes) }); }); messageHandler.on(&quot;UnsupportedFeature&quot;, this._onUnsupportedFeature.bind(this)); messageHandler.on(&quot;FetchBuiltInCMap&quot;, data =&gt; { if (this.destroyed) { return Promise.reject(new Error(&quot;Worker was destroyed.&quot;)); } if (!this.CMapReaderFactory) { return Promise.reject(new Error(&quot;CMapReaderFactory not initialized, see the `useWorkerFetch` parameter.&quot;)); } return this.CMapReaderFactory.fetch(data); }); messageHandler.on(&quot;FetchStandardFontData&quot;, data =&gt; { if (this.destroyed) { return Promise.reject(new Error(&quot;Worker was destroyed.&quot;)); } if (!this.StandardFontDataFactory) { return Promise.reject(new Error(&quot;StandardFontDataFactory not initialized, see the `useWorkerFetch` parameter.&quot;)); } return this.StandardFontDataFactory.fetch(data); }); } _onUnsupportedFeature({ featureId }) { if (this.destroyed) { return; } this.loadingTask.onUnsupportedFeature?.(featureId); } getData() { return this.messageHandler.sendWithPromise(&quot;GetData&quot;, null); } saveDocument() { if (this.annotationStorage.size &lt;= 0) { (0, _util.warn)(&quot;saveDocument called while `annotationStorage` is empty, &quot; + &quot;please use the getData-method instead.&quot;); } return this.messageHandler.sendWithPromise(&quot;SaveDocument&quot;, { isPureXfa: !!this._htmlForXfa, numPages: this._numPages, annotationStorage: this.annotationStorage.serializable, filename: this._fullReader?.filename ?? null }).finally(() =&gt; { this.annotationStorage.resetModified(); }); } getPage(pageNumber) { if (!Number.isInteger(pageNumber) || pageNumber &lt;= 0 || pageNumber &gt; this._numPages) { return Promise.reject(new Error(&quot;Invalid page request.&quot;)); } const pageIndex = pageNumber - 1, cachedPromise = this.#pagePromises.get(pageIndex); if (cachedPromise) { return cachedPromise; } const promise = this.messageHandler.sendWithPromise(&quot;GetPage&quot;, { pageIndex }).then(pageInfo =&gt; { if (this.destroyed) { throw new Error(&quot;Transport destroyed&quot;); } const page = new PDFPageProxy(pageIndex, pageInfo, this, this._params.ownerDocument, this._params.pdfBug); this.#pageCache.set(pageIndex, page); return page; }); this.#pagePromises.set(pageIndex, promise); return promise; } getPageIndex(ref) { if (typeof ref !== &quot;object&quot; || ref === null || !Number.isInteger(ref.num) || ref.num &lt; 0 || !Number.isInteger(ref.gen) || ref.gen &lt; 0) { return Promise.reject(new Error(&quot;Invalid pageIndex request.&quot;)); } return this.messageHandler.sendWithPromise(&quot;GetPageIndex&quot;, { num: ref.num, gen: ref.gen }); } getAnnotations(pageIndex, intent) { return this.messageHandler.sendWithPromise(&quot;GetAnnotations&quot;, { pageIndex, intent }); } getFieldObjects() { return this._getFieldObjectsPromise ||= this.messageHandler.sendWithPromise(&quot;GetFieldObjects&quot;, null); } hasJSActions() { return this._hasJSActionsPromise ||= this.messageHandler.sendWithPromise(&quot;HasJSActions&quot;, null); } getCalculationOrderIds() { return this.messageHandler.sendWithPromise(&quot;GetCalculationOrderIds&quot;, null); } getDestinations() { return this.messageHandler.sendWithPromise(&quot;GetDestinations&quot;, null); } getDestination(id) { if (typeof id !== &quot;string&quot;) { return Promise.reject(new Error(&quot;Invalid destination request.&quot;)); } return this.messageHandler.sendWithPromise(&quot;GetDestination&quot;, { id }); } getPageLabels() { return this.messageHandler.sendWithPromise(&quot;GetPageLabels&quot;, null); } getPageLayout() { return this.messageHandler.sendWithPromise(&quot;GetPageLayout&quot;, null); } getPageMode() { return this.messageHandler.sendWithPromise(&quot;GetPageMode&quot;, null); } getViewerPreferences() { return this.messageHandler.sendWithPromise(&quot;GetViewerPreferences&quot;, null); } getOpenAction() { return this.messageHandler.sendWithPromise(&quot;GetOpenAction&quot;, null); } getAttachments() { return this.messageHandler.sendWithPromise(&quot;GetAttachments&quot;, null); } getJavaScript() { return this.messageHandler.sendWithPromise(&quot;GetJavaScript&quot;, null); } getDocJSActions() { return this.messageHandler.sendWithPromise(&quot;GetDocJSActions&quot;, null); } getPageJSActions(pageIndex) { return this.messageHandler.sendWithPromise(&quot;GetPageJSActions&quot;, { pageIndex }); } getStructTree(pageIndex) { return this.messageHandler.sendWithPromise(&quot;GetStructTree&quot;, { pageIndex }); } getOutline() { return this.messageHandler.sendWithPromise(&quot;GetOutline&quot;, null); } getOptionalContentConfig() { return this.messageHandler.sendWithPromise(&quot;GetOptionalContentConfig&quot;, null).then(results =&gt; { return new _optional_content_config.OptionalContentConfig(results); }); } getPermissions() { return this.messageHandler.sendWithPromise(&quot;GetPermissions&quot;, null); } getMetadata() { return this.#metadataPromise ||= this.messageHandler.sendWithPromise(&quot;GetMetadata&quot;, null).then(results =&gt; { return { info: results[0], metadata: results[1] ? new _metadata.Metadata(results[1]) : null, contentDispositionFilename: this._fullReader?.filename ?? null, contentLength: this._fullReader?.contentLength ?? null }; }); } getMarkInfo() { return this.messageHandler.sendWithPromise(&quot;GetMarkInfo&quot;, null); } async startCleanup(keepLoadedFonts = false) { if (this.destroyed) { return; } await this.messageHandler.sendWithPromise(&quot;Cleanup&quot;, null); for (const page of this.#pageCache.values()) { const cleanupSuccessful = page.cleanup(); if (!cleanupSuccessful) { throw new Error(`startCleanup: Page ${page.pageNumber} is currently rendering.`); } } this.commonObjs.clear(); if (!keepLoadedFonts) { this.fontLoader.clear(); } this.#metadataPromise = null; this._getFieldObjectsPromise = null; this._hasJSActionsPromise = null; } get loadingParams() { const params = this._params; return (0, _util.shadow)(this, &quot;loadingParams&quot;, { disableAutoFetch: params.disableAutoFetch, enableXfa: params.enableXfa }); } } class PDFObjects { #objs = Object.create(null); #ensureObj(objId) { const obj = this.#objs[objId]; if (obj) { return obj; } return this.#objs[objId] = { capability: (0, _util.createPromiseCapability)(), data: null }; } get(objId, callback = null) { if (callback) { const obj = this.#ensureObj(objId); obj.capability.promise.then(() =&gt; callback(obj.data)); return null; } const obj = this.#objs[objId]; if (!obj?.capability.settled) { throw new Error(`Requesting object that isn&apos;t resolved yet ${objId}.`); } return obj.data; } has(objId) { const obj = this.#objs[objId]; return obj?.capability.settled || false; } resolve(objId, data = null) { const obj = this.#ensureObj(objId); obj.data = data; obj.capability.resolve(); } clear() { this.#objs = Object.create(null); } } class RenderTask { #internalRenderTask = null; constructor(internalRenderTask) { this.#internalRenderTask = internalRenderTask; this.onContinue = null; } get promise() { return this.#internalRenderTask.capability.promise; } cancel() { this.#internalRenderTask.cancel(); } get separateAnnots() { const { separateAnnots } = this.#internalRenderTask.operatorList; if (!separateAnnots) { return false; } const { annotationCanvasMap } = this.#internalRenderTask; return separateAnnots.form || separateAnnots.canvas &amp;&amp; annotationCanvasMap?.size &gt; 0; } } exports.RenderTask = RenderTask; class InternalRenderTask { static #canvasInUse = new WeakSet(); constructor({ callback, params, objs, commonObjs, annotationCanvasMap, operatorList, pageIndex, canvasFactory, useRequestAnimationFrame = false, pdfBug = false, pageColors = null }) { this.callback = callback; this.params = params; this.objs = objs; this.commonObjs = commonObjs; this.annotationCanvasMap = annotationCanvasMap; this.operatorListIdx = null; this.operatorList = operatorList; this._pageIndex = pageIndex; this.canvasFactory = canvasFactory; this._pdfBug = pdfBug; this.pageColors = pageColors; this.running = false; this.graphicsReadyCallback = null; this.graphicsReady = false; this._useRequestAnimationFrame = useRequestAnimationFrame === true &amp;&amp; typeof window !== &quot;undefined&quot;; this.cancelled = false; this.capability = (0, _util.createPromiseCapability)(); this.task = new RenderTask(this); this._cancelBound = this.cancel.bind(this); this._continueBound = this._continue.bind(this); this._scheduleNextBound = this._scheduleNext.bind(this); this._nextBound = this._next.bind(this); this._canvas = params.canvasContext.canvas; } get completed() { return this.capability.promise.catch(function () {}); } initializeGraphics({ transparency = false, optionalContentConfig }) { if (this.cancelled) { return; } if (this._canvas) { if (InternalRenderTask.#canvasInUse.has(this._canvas)) { throw new Error(&quot;Cannot use the same canvas during multiple render() operations. &quot; + &quot;Use different canvas or ensure previous operations were &quot; + &quot;cancelled or completed.&quot;); } InternalRenderTask.#canvasInUse.add(this._canvas); } if (this._pdfBug &amp;&amp; globalThis.StepperManager?.enabled) { this.stepper = globalThis.StepperManager.create(this._pageIndex); this.stepper.init(this.operatorList); this.stepper.nextBreakPoint = this.stepper.getNextBreakPoint(); } const { canvasContext, viewport, transform, background } = this.params; this.gfx = new _canvas.CanvasGraphics(canvasContext, this.commonObjs, this.objs, this.canvasFactory, optionalContentConfig, this.annotationCanvasMap, this.pageColors); this.gfx.beginDrawing({ transform, viewport, transparency, background }); this.operatorListIdx = 0; this.graphicsReady = true; this.graphicsReadyCallback?.(); } cancel(error = null) { this.running = false; this.cancelled = true; this.gfx?.endDrawing(); if (this._canvas) { InternalRenderTask.#canvasInUse.delete(this._canvas); } this.callback(error || new _display_utils.RenderingCancelledException(`Rendering cancelled, page ${this._pageIndex + 1}`, &quot;canvas&quot;)); } operatorListChanged() { if (!this.graphicsReady) { if (!this.graphicsReadyCallback) { this.graphicsReadyCallback = this._continueBound; } return; } this.stepper?.updateOperatorList(this.operatorList); if (this.running) { return; } this._continue(); } _continue() { this.running = true; if (this.cancelled) { return; } if (this.task.onContinue) { this.task.onContinue(this._scheduleNextBound); } else { this._scheduleNext(); } } _scheduleNext() { if (this._useRequestAnimationFrame) { window.requestAnimationFrame(() =&gt; { this._nextBound().catch(this._cancelBound); }); } else { Promise.resolve().then(this._nextBound).catch(this._cancelBound); } } async _next() { if (this.cancelled) { return; } this.operatorListIdx = this.gfx.executeOperatorList(this.operatorList, this.operatorListIdx, this._continueBound, this.stepper); if (this.operatorListIdx === this.operatorList.argsArray.length) { this.running = false; if (this.operatorList.lastChunk) { this.gfx.endDrawing(); if (this._canvas) { InternalRenderTask.#canvasInUse.delete(this._canvas); } this.callback(); } } } } const version = &apos;3.0.0&apos;; exports.version = version; const build = &apos;987062c&apos;; exports.build = build; /***/ }), /* 3 */ /***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) =&gt; { Object.defineProperty(exports, &quot;__esModule&quot;, ({ value: true })); exports.PrintAnnotationStorage = exports.AnnotationStorage = void 0; var _util = __w_pdfjs_require__(1); var _editor = __w_pdfjs_require__(4); var _murmurhash = __w_pdfjs_require__(8); class AnnotationStorage { constructor() { this._storage = new Map(); this._modified = false; this.onSetModified = null; this.onResetModified = null; this.onAnnotationEditor = null; } getValue(key, defaultValue) { const value = this._storage.get(key); if (value === undefined) { return defaultValue; } return Object.assign(defaultValue, value); } getRawValue(key) { return this._storage.get(key); } remove(key) { this._storage.delete(key); if (this._storage.size === 0) { this.resetModified(); } if (typeof this.onAnnotationEditor === &quot;function&quot;) { for (const value of this._storage.values()) { if (value instanceof _editor.AnnotationEditor) { return; } } this.onAnnotationEditor(null); } } setValue(key, value) { const obj = this._storage.get(key); let modified = false; if (obj !== undefined) { for (const [entry, val] of Object.entries(value)) { if (obj[entry] !== val) { modified = true; obj[entry] = val; } } } else { modified = true; this._storage.set(key, value); } if (modified) { this.#setModified(); } if (value instanceof _editor.AnnotationEditor &amp;&amp; typeof this.onAnnotationEditor === &quot;function&quot;) { this.onAnnotationEditor(value.constructor._type); } } has(key) { return this._storage.has(key); } getAll() { return this._storage.size &gt; 0 ? (0, _util.objectFromMap)(this._storage) : null; } get size() { return this._storage.size; } #setModified() { if (!this._modified) { this._modified = true; if (typeof this.onSetModified === &quot;function&quot;) { this.onSetModified(); } } } resetModified() { if (this._modified) { this._modified = false; if (typeof this.onResetModified === &quot;function&quot;) { this.onResetModified(); } } } get print() { return new PrintAnnotationStorage(this); } get serializable() { if (this._storage.size === 0) { return null; } const clone = new Map(); for (const [key, val] of this._storage) { const serialized = val instanceof _editor.AnnotationEditor ? val.serialize() : val; if (serialized) { clone.set(key, serialized); } } return clone; } static getHash(map) { if (!map) { return &quot;&quot;; } const hash = new _murmurhash.MurmurHash3_64(); for (const [key, val] of map) { hash.update(`${key}:${JSON.stringify(val)}`); } return hash.hexdigest(); } } exports.AnnotationStorage = AnnotationStorage; class PrintAnnotationStorage extends AnnotationStorage { #serializable = null; constructor(parent) { super(); this.#serializable = structuredClone(parent.serializable); } get print() { (0, _util.unreachable)(&quot;Should not call PrintAnnotationStorage.print&quot;); } get serializable() { return this.#serializable; } } exports.PrintAnnotationStorage = PrintAnnotationStorage; /***/ }), /* 4 */ /***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) =&gt; { Object.defineProperty(exports, &quot;__esModule&quot;, ({ value: true })); exports.AnnotationEditor = void 0; var _tools = __w_pdfjs_require__(5); var _util = __w_pdfjs_require__(1); class AnnotationEditor { #boundFocusin = this.focusin.bind(this); #boundFocusout = this.focusout.bind(this); #hasBeenSelected = false; #isEditing = false; #isInEditMode = false; #zIndex = AnnotationEditor._zIndex++; static _colorManager = new _tools.ColorManager(); static _zIndex = 1; constructor(parameters) { if (this.constructor === AnnotationEditor) { (0, _util.unreachable)(&quot;Cannot initialize AnnotationEditor.&quot;); } this.parent = parameters.parent; this.id = parameters.id; this.width = this.height = null; this.pageIndex = parameters.parent.pageIndex; this.name = parameters.name; this.div = null; const [width, height] = this.parent.viewportBaseDimensions; this.x = parameters.x / width; this.y = parameters.y / height; this.rotation = this.parent.viewport.rotation; this.isAttachedToDOM = false; } static get _defaultLineColor() { return (0, _util.shadow)(this, &quot;_defaultLineColor&quot;, this._colorManager.getHexCode(&quot;CanvasText&quot;)); } setInBackground() { this.div.style.zIndex = 0; } setInForeground() { this.div.style.zIndex = this.#zIndex; } focusin(event) { if (!this.#hasBeenSelected) { this.parent.setSelected(this); } else { this.#hasBeenSelected = false; } } focusout(event) { if (!this.isAttachedToDOM) { return; } const target = event.relatedTarget; if (target?.closest(`#${this.id}`)) { return; } event.preventDefault(); if (!this.parent.isMultipleSelection) { this.commitOrRemove(); } } commitOrRemove() { if (this.isEmpty()) { this.remove(); } else { this.commit(); } } commit() { this.parent.addToAnnotationStorage(this); } dragstart(event) { const rect = this.parent.div.getBoundingClientRect(); this.startX = event.clientX - rect.x; this.startY = event.clientY - rect.y; event.dataTransfer.setData(&quot;text/plain&quot;, this.id); event.dataTransfer.effectAllowed = &quot;move&quot;; } setAt(x, y, tx, ty) { const [width, height] = this.parent.viewportBaseDimensions; [tx, ty] = this.screenToPageTranslation(tx, ty); this.x = (x + tx) / width; this.y = (y + ty) / height; this.div.style.left = `${100 * this.x}%`; this.div.style.top = `${100 * this.y}%`; } translate(x, y) { const [width, height] = this.parent.viewportBaseDimensions; [x, y] = this.screenToPageTranslation(x, y); this.x += x / width; this.y += y / height; this.div.style.left = `${100 * this.x}%`; this.div.style.top = `${100 * this.y}%`; } screenToPageTranslation(x, y) { const { rotation } = this.parent.viewport; switch (rotation) { case 90: return [y, -x]; case 180: return [-x, -y]; case 270: return [-y, x]; default: return [x, y]; } } setDims(width, height) { const [parentWidth, parentHeight] = this.parent.viewportBaseDimensions; this.div.style.width = `${100 * width / parentWidth}%`; this.div.style.height = `${100 * height / parentHeight}%`; } fixDims() { const { style } = this.div; const { height, width } = style; const widthPercent = width.endsWith(&quot;%&quot;); const heightPercent = height.endsWith(&quot;%&quot;); if (widthPercent &amp;&amp; heightPercent) { return; } const [parentWidth, parentHeight] = this.parent.viewportBaseDimensions; if (!widthPercent) { style.width = `${100 * parseFloat(width) / parentWidth}%`; } if (!heightPercent) { style.height = `${100 * parseFloat(height) / parentHeight}%`; } } getInitialTranslation() { return [0, 0]; } render() { this.div = document.createElement(&quot;div&quot;); this.div.setAttribute(&quot;data-editor-rotation&quot;, (360 - this.rotation) % 360); this.div.className = this.name; this.div.setAttribute(&quot;id&quot;, this.id); this.div.setAttribute(&quot;tabIndex&quot;, 0); this.setInForeground(); this.div.addEventListener(&quot;focusin&quot;, this.#boundFocusin); this.div.addEventListener(&quot;focusout&quot;, this.#boundFocusout); const [tx, ty] = this.getInitialTranslation(); this.translate(tx, ty); (0, _tools.bindEvents)(this, this.div, [&quot;dragstart&quot;, &quot;pointerdown&quot;]); return this.div; } pointerdown(event) { const isMac = _tools.KeyboardManager.platform.isMac; if (event.button !== 0 || event.ctrlKey &amp;&amp; isMac) { event.preventDefault(); return; } if (event.ctrlKey &amp;&amp; !isMac || event.shiftKey || event.metaKey &amp;&amp; isMac) { this.parent.toggleSelected(this); } else { this.parent.setSelected(this); } this.#hasBeenSelected = true; } getRect(tx, ty) { const [parentWidth, parentHeight] = this.parent.viewportBaseDimensions; const [pageWidth, pageHeight] = this.parent.pageDimensions; const shiftX = pageWidth * tx / parentWidth; const shiftY = pageHeight * ty / parentHeight; const x = this.x * pageWidth; const y = this.y * pageHeight; const width = this.width * pageWidth; const height = this.height * pageHeight; switch (this.rotation) { case 0: return [x + shiftX, pageHeight - y - shiftY - height, x + shiftX + width, pageHeight - y - shiftY]; case 90: return [x + shiftY, pageHeight - y + shiftX, x + shiftY + height, pageHeight - y + shiftX + width]; case 180: return [x - shiftX - width, pageHeight - y + shiftY, x - shiftX, pageHeight - y + shiftY + height]; case 270: return [x - shiftY - height, pageHeight - y - shiftX - width, x - shiftY, pageHeight - y - shiftX]; default: throw new Error(&quot;Invalid rotation&quot;); } } getRectInCurrentCoords(rect, pageHeight) { const [x1, y1, x2, y2] = rect; const width = x2 - x1; const height = y2 - y1; switch (this.rotation) { case 0: return [x1, pageHeight - y2, width, height]; case 90: return [x1, pageHeight - y1, height, width]; case 180: return [x2, pageHeight - y1, width, height]; case 270: return [x2, pageHeight - y2, height, width]; default: throw new Error(&quot;Invalid rotation&quot;); } } onceAdded() {} isEmpty() { return false; } enableEditMode() { this.#isInEditMode = true; } disableEditMode() { this.#isInEditMode = false; } isInEditMode() { return this.#isInEditMode; } shouldGetKeyboardEvents() { return false; } needsToBeRebuilt() { return this.div &amp;&amp; !this.isAttachedToDOM; } rebuild() { this.div?.addEventListener(&quot;focusin&quot;, this.#boundFocusin); } serialize() { (0, _util.unreachable)(&quot;An editor must be serializable&quot;); } static deserialize(data, parent) { const editor = new this.prototype.constructor({ parent, id: parent.getNextId() }); editor.rotation = data.rotation; const [pageWidth, pageHeight] = parent.pageDimensions; const [x, y, width, height] = editor.getRectInCurrentCoords(data.rect, pageHeight); editor.x = x / pageWidth; editor.y = y / pageHeight; editor.width = width / pageWidth; editor.height = height / pageHeight; return editor; } remove() { this.div.removeEventListener(&quot;focusin&quot;, this.#boundFocusin); this.div.removeEventListener(&quot;focusout&quot;, this.#boundFocusout); if (!this.isEmpty()) { this.commit(); } this.parent.remove(this); } select() { this.div?.classList.add(&quot;selectedEditor&quot;); } unselect() { this.div?.classList.remove(&quot;selectedEditor&quot;); } updateParams(type, value) {} disableEditing() {} enableEditing() {} get propertiesToUpdate() { return {}; } get contentDiv() { return this.div; } get isEditing() { return this.#isEditing; } set isEditing(value) { this.#isEditing = value; if (value) { this.parent.setSelected(this); this.parent.setActiveEditor(this); } else { this.parent.setActiveEditor(null); } } } exports.AnnotationEditor = AnnotationEditor; /***/ }), /* 5 */ /***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) =&gt; { Object.defineProperty(exports, &quot;__esModule&quot;, ({ value: true })); exports.KeyboardManager = exports.CommandManager = exports.ColorManager = exports.AnnotationEditorUIManager = void 0; exports.bindEvents = bindEvents; exports.opacityToHex = opacityToHex; var _util = __w_pdfjs_require__(1); var _display_utils = __w_pdfjs_require__(6); function bindEvents(obj, element, names) { for (const name of names) { element.addEventListener(name, obj[name].bind(obj)); } } function opacityToHex(opacity) { return Math.round(Math.min(255, Math.max(1, 255 * opacity))).toString(16).padStart(2, &quot;0&quot;); } class IdManager { #id = 0; getId() { return `${_util.AnnotationEditorPrefix}${this.#id++}`; } } class CommandManager { #commands = []; #locked = false; #maxSize; #position = -1; constructor(maxSize = 128) { this.#maxSize = maxSize; } add({ cmd, undo, mustExec, type = NaN, overwriteIfSameType = false, keepUndo = false }) { if (mustExec) { cmd(); } if (this.#locked) { return; } const save = { cmd, undo, type }; if (this.#position === -1) { if (this.#commands.length &gt; 0) { this.#commands.length = 0; } this.#position = 0; this.#commands.push(save); return; } if (overwriteIfSameType &amp;&amp; this.#commands[this.#position].type === type) { if (keepUndo) { save.undo = this.#commands[this.#position].undo; } this.#commands[this.#position] = save; return; } const next = this.#position + 1; if (next === this.#maxSize) { this.#commands.splice(0, 1); } else { this.#position = next; if (next &lt; this.#commands.length) { this.#commands.splice(next); } } this.#commands.push(save); } undo() { if (this.#position === -1) { return; } this.#locked = true; this.#commands[this.#position].undo(); this.#locked = false; this.#position -= 1; } redo() { if (this.#position &lt; this.#commands.length - 1) { this.#position += 1; this.#locked = true; this.#commands[this.#position].cmd(); this.#locked = false; } } hasSomethingToUndo() { return this.#position !== -1; } hasSomethingToRedo() { return this.#position &lt; this.#commands.length - 1; } destroy() { this.#commands = null; } } exports.CommandManager = CommandManager; class KeyboardManager { constructor(callbacks) { this.buffer = []; this.callbacks = new Map(); this.allKeys = new Set(); const isMac = KeyboardManager.platform.isMac; for (const [keys, callback] of callbacks) { for (const key of keys) { const isMacKey = key.startsWith(&quot;mac+&quot;); if (isMac &amp;&amp; isMacKey) { this.callbacks.set(key.slice(4), callback); this.allKeys.add(key.split(&quot;+&quot;).at(-1)); } else if (!isMac &amp;&amp; !isMacKey) { this.callbacks.set(key, callback); this.allKeys.add(key.split(&quot;+&quot;).at(-1)); } } } } static get platform() { const platform = typeof navigator !== &quot;undefined&quot; ? navigator.platform : &quot;&quot;; return (0, _util.shadow)(this, &quot;platform&quot;, { isWin: platform.includes(&quot;Win&quot;), isMac: platform.includes(&quot;Mac&quot;) }); } #serialize(event) { if (event.altKey) { this.buffer.push(&quot;alt&quot;); } if (event.ctrlKey) { this.buffer.push(&quot;ctrl&quot;); } if (event.metaKey) { this.buffer.push(&quot;meta&quot;); } if (event.shiftKey) { this.buffer.push(&quot;shift&quot;); } this.buffer.push(event.key); const str = this.buffer.join(&quot;+&quot;); this.buffer.length = 0; return str; } exec(self, event) { if (!this.allKeys.has(event.key)) { return; } const callback = this.callbacks.get(this.#serialize(event)); if (!callback) { return; } callback.bind(self)(); event.stopPropagation(); event.preventDefault(); } } exports.KeyboardManager = KeyboardManager; class ColorManager { static _colorsMapping = new Map([[&quot;CanvasText&quot;, [0, 0, 0]], [&quot;Canvas&quot;, [255, 255, 255]]]); get _colors() { const colors = new Map([[&quot;CanvasText&quot;, null], [&quot;Canvas&quot;, null]]); (0, _display_utils.getColorValues)(colors); return (0, _util.shadow)(this, &quot;_colors&quot;, colors); } convert(color) { const rgb = (0, _display_utils.getRGB)(color); if (!window.matchMedia(&quot;(forced-colors: active)&quot;).matches) { return rgb; } for (const [name, RGB] of this._colors) { if (RGB.every((x, i) =&gt; x === rgb[i])) { return ColorManager._colorsMapping.get(name); } } return rgb; } getHexCode(name) { const rgb = this._colors.get(name); if (!rgb) { return name; } return _util.Util.makeHexColor(...rgb); } } exports.ColorManager = ColorManager; class AnnotationEditorUIManager { #activeEditor = null; #allEditors = new Map(); #allLayers = new Map(); #commandManager = new CommandManager(); #currentPageIndex = 0; #editorTypes = null; #eventBus = null; #idManager = new IdManager(); #isEnabled = false; #mode = _util.AnnotationEditorType.NONE; #selectedEditors = new Set(); #boundCopy = this.copy.bind(this); #boundCut = this.cut.bind(this); #boundPaste = this.paste.bind(this); #boundKeydown = this.keydown.bind(this); #boundOnEditingAction = this.onEditingAction.bind(this); #boundOnPageChanging = this.onPageChanging.bind(this); #previousStates = { isEditing: false, isEmpty: true, hasSomethingToUndo: false, hasSomethingToRedo: false, hasSelectedEditor: false }; #container = null; static _keyboardManager = new KeyboardManager([[[&quot;ctrl+a&quot;, &quot;mac+meta+a&quot;], AnnotationEditorUIManager.prototype.selectAll], [[&quot;ctrl+z&quot;, &quot;mac+meta+z&quot;], AnnotationEditorUIManager.prototype.undo], [[&quot;ctrl+y&quot;, &quot;ctrl+shift+Z&quot;, &quot;mac+meta+shift+Z&quot;], AnnotationEditorUIManager.prototype.redo], [[&quot;Backspace&quot;, &quot;alt+Backspace&quot;, &quot;ctrl+Backspace&quot;, &quot;shift+Backspace&quot;, &quot;mac+Backspace&quot;, &quot;mac+alt+Backspace&quot;, &quot;mac+ctrl+Backspace&quot;, &quot;Delete&quot;, &quot;ctrl+Delete&quot;, &quot;shift+Delete&quot;], AnnotationEditorUIManager.prototype.delete], [[&quot;Escape&quot;, &quot;mac+Escape&quot;], AnnotationEditorUIManager.prototype.unselectAll]]); constructor(container, eventBus) { this.#container = container; this.#eventBus = eventBus; this.#eventBus._on(&quot;editingaction&quot;, this.#boundOnEditingAction); this.#eventBus._on(&quot;pagechanging&quot;, this.#boundOnPageChanging); } destroy() { this.#removeKeyboardManager(); this.#eventBus._off(&quot;editingaction&quot;, this.#boundOnEditingAction); this.#eventBus._off(&quot;pagechanging&quot;, this.#boundOnPageChanging); for (const layer of this.#allLayers.values()) { layer.destroy(); } this.#allLayers.clear(); this.#allEditors.clear(); this.#activeEditor = null; this.#selectedEditors.clear(); this.#commandManager.destroy(); } onPageChanging({ pageNumber }) { this.#currentPageIndex = pageNumber - 1; } focusMainContainer() { this.#container.focus(); } #addKeyboardManager() { this.#container.addEventListener(&quot;keydown&quot;, this.#boundKeydown); } #removeKeyboardManager() { this.#container.removeEventListener(&quot;keydown&quot;, this.#boundKeydown); } #addCopyPasteListeners() { document.addEventListener(&quot;copy&quot;, this.#boundCopy); document.addEventListener(&quot;cut&quot;, this.#boundCut); document.addEventListener(&quot;paste&quot;, this.#boundPaste); } #removeCopyPasteListeners() { document.removeEventListener(&quot;copy&quot;, this.#boundCopy); document.removeEventListener(&quot;cut&quot;, this.#boundCut); document.removeEventListener(&quot;paste&quot;, this.#boundPaste); } copy(event) { event.preventDefault(); if (this.#activeEditor) { this.#activeEditor.commitOrRemove(); } if (!this.hasSelection) { return; } const editors = []; for (const editor of this.#selectedEditors) { if (!editor.isEmpty()) { editors.push(editor.serialize()); } } if (editors.length === 0) { return; } event.clipboardData.setData(&quot;application/pdfjs&quot;, JSON.stringify(editors)); } cut(event) { this.copy(event); this.delete(); } paste(event) { event.preventDefault(); let data = event.clipboardData.getData(&quot;application/pdfjs&quot;); if (!data) { return; } try { data = JSON.parse(data); } catch (ex) { (0, _util.warn)(`paste: &quot;${ex.message}&quot;.`); return; } if (!Array.isArray(data)) { return; } this.unselectAll(); const layer = this.#allLayers.get(this.#currentPageIndex); try { const newEditors = []; for (const editor of data) { const deserializedEditor = layer.deserialize(editor); if (!deserializedEditor) { return; } newEditors.push(deserializedEditor); } const cmd = () =&gt; { for (const editor of newEditors) { this.#addEditorToLayer(editor); } this.#selectEditors(newEditors); }; const undo = () =&gt; { for (const editor of newEditors) { editor.remove(); } }; this.addCommands({ cmd, undo, mustExec: true }); } catch (ex) { (0, _util.warn)(`paste: &quot;${ex.message}&quot;.`); } } keydown(event) { if (!this.getActive()?.shouldGetKeyboardEvents()) { AnnotationEditorUIManager._keyboardManager.exec(this, event); } } onEditingAction(details) { if ([&quot;undo&quot;, &quot;redo&quot;, &quot;delete&quot;, &quot;selectAll&quot;].includes(details.name)) { this[details.name](); } } #dispatchUpdateStates(details) { const hasChanged = Object.entries(details).some(([key, value]) =&gt; this.#previousStates[key] !== value); if (hasChanged) { this.#eventBus.dispatch(&quot;annotationeditorstateschanged&quot;, { source: this, details: Object.assign(this.#previousStates, details) }); } } #dispatchUpdateUI(details) { this.#eventBus.dispatch(&quot;annotationeditorparamschanged&quot;, { source: this, details }); } setEditingState(isEditing) { if (isEditing) { this.#addKeyboardManager(); this.#addCopyPasteListeners(); this.#dispatchUpdateStates({ isEditing: this.#mode !== _util.AnnotationEditorType.NONE, isEmpty: this.#isEmpty(), hasSomethingToUndo: this.#commandManager.hasSomethingToUndo(), hasSomethingToRedo: this.#commandManager.hasSomethingToRedo(), hasSelectedEditor: false }); } else { this.#removeKeyboardManager(); this.#removeCopyPasteListeners(); this.#dispatchUpdateStates({ isEditing: false }); } } registerEditorTypes(types) { if (this.#editorTypes) { return; } this.#editorTypes = types; for (const editorType of this.#editorTypes) { this.#dispatchUpdateUI(editorType.defaultPropertiesToUpdate); } } getId() { return this.#idManager.getId(); } addLayer(layer) { this.#allLayers.set(layer.pageIndex, layer); if (this.#isEnabled) { layer.enable(); } else { layer.disable(); } } removeLayer(layer) { this.#allLayers.delete(layer.pageIndex); } updateMode(mode) { this.#mode = mode; if (mode === _util.AnnotationEditorType.NONE) { this.setEditingState(false); this.#disableAll(); } else { this.setEditingState(true); this.#enableAll(); for (const layer of this.#allLayers.values()) { layer.updateMode(mode); } } } updateToolbar(mode) { if (mode === this.#mode) { return; } this.#eventBus.dispatch(&quot;switchannotationeditormode&quot;, { source: this, mode }); } updateParams(type, value) { if (!this.#editorTypes) { return; } for (const editor of this.#selectedEditors) { editor.updateParams(type, value); } for (const editorType of this.#editorTypes) { editorType.updateDefaultParams(type, value); } } #enableAll() { if (!this.#isEnabled) { this.#isEnabled = true; for (const layer of this.#allLayers.values()) { layer.enable(); } } } #disableAll() { this.unselectAll(); if (this.#isEnabled) { this.#isEnabled = false; for (const layer of this.#allLayers.values()) { layer.disable(); } } } getEditors(pageIndex) { const editors = []; for (const editor of this.#allEditors.values()) { if (editor.pageIndex === pageIndex) { editors.push(editor); } } return editors; } getEditor(id) { return this.#allEditors.get(id); } addEditor(editor) { this.#allEditors.set(editor.id, editor); } removeEditor(editor) { this.#allEditors.delete(editor.id); this.unselect(editor); } #addEditorToLayer(editor) { const layer = this.#allLayers.get(editor.pageIndex); if (layer) { layer.addOrRebuild(editor); } else { this.addEditor(editor); } } setActiveEditor(editor) { if (this.#activeEditor === editor) { return; } this.#activeEditor = editor; if (editor) { this.#dispatchUpdateUI(editor.propertiesToUpdate); } } toggleSelected(editor) { if (this.#selectedEditors.has(editor)) { this.#selectedEditors.delete(editor); editor.unselect(); this.#dispatchUpdateStates({ hasSelectedEditor: this.hasSelection }); return; } this.#selectedEditors.add(editor); editor.select(); this.#dispatchUpdateUI(editor.propertiesToUpdate); this.#dispatchUpdateStates({ hasSelectedEditor: true }); } setSelected(editor) { for (const ed of this.#selectedEditors) { if (ed !== editor) { ed.unselect(); } } this.#selectedEditors.clear(); this.#selectedEditors.add(editor); editor.select(); this.#dispatchUpdateUI(editor.propertiesToUpdate); this.#dispatchUpdateStates({ hasSelectedEditor: true }); } isSelected(editor) { return this.#selectedEditors.has(editor); } unselect(editor) { editor.unselect(); this.#selectedEditors.delete(editor); this.#dispatchUpdateStates({ hasSelectedEditor: this.hasSelection }); } get hasSelection() { return this.#selectedEditors.size !== 0; } undo() { this.#commandManager.undo(); this.#dispatchUpdateStates({ hasSomethingToUndo: this.#commandManager.hasSomethingToUndo(), hasSomethingToRedo: true, isEmpty: this.#isEmpty() }); } redo() { this.#commandManager.redo(); this.#dispatchUpdateStates({ hasSomethingToUndo: true, hasSomethingToRedo: this.#commandManager.hasSomethingToRedo(), isEmpty: this.#isEmpty() }); } addCommands(params) { this.#commandManager.add(params); this.#dispatchUpdateStates({ hasSomethingToUndo: true, hasSomethingToRedo: false, isEmpty: this.#isEmpty() }); } #isEmpty() { if (this.#allEditors.size === 0) { return true; } if (this.#allEditors.size === 1) { for (const editor of this.#allEditors.values()) { return editor.isEmpty(); } } return false; } delete() { this.commitOrRemove(); if (!this.hasSelection) { return; } const editors = [...this.#selectedEditors]; const cmd = () =&gt; { for (const editor of editors) { editor.remove(); } }; const undo = () =&gt; { for (const editor of editors) { this.#addEditorToLayer(editor); } }; this.addCommands({ cmd, undo, mustExec: true }); } commitOrRemove() { this.#activeEditor?.commitOrRemove(); } #selectEditors(editors) { this.#selectedEditors.clear(); for (const editor of editors) { if (editor.isEmpty()) { continue; } this.#selectedEditors.add(editor); editor.select(); } this.#dispatchUpdateStates({ hasSelectedEditor: true }); } selectAll() { for (const editor of this.#selectedEditors) { editor.commit(); } this.#selectEditors(this.#allEditors.values()); } unselectAll() { if (this.#activeEditor) { this.#activeEditor.commitOrRemove(); return; } if (this.#selectedEditors.size === 0) { return; } for (const editor of this.#selectedEditors) { editor.unselect(); } this.#selectedEditors.clear(); this.#dispatchUpdateStates({ hasSelectedEditor: false }); } isActive(editor) { return this.#activeEditor === editor; } getActive() { return this.#activeEditor; } getMode() { return this.#mode; } } exports.AnnotationEditorUIManager = AnnotationEditorUIManager; /***/ }), /* 6 */ /***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) =&gt; { Object.defineProperty(exports, &quot;__esModule&quot;, ({ value: true })); exports.StatTimer = exports.RenderingCancelledException = exports.PixelsPerInch = exports.PageViewport = exports.PDFDateString = exports.DOMStandardFontDataFactory = exports.DOMSVGFactory = exports.DOMCanvasFactory = exports.DOMCMapReaderFactory = exports.AnnotationPrefix = void 0; exports.deprecated = deprecated; exports.getColorValues = getColorValues; exports.getCurrentTransform = getCurrentTransform; exports.getCurrentTransformInverse = getCurrentTransformInverse; exports.getFilenameFromUrl = getFilenameFromUrl; exports.getPdfFilenameFromUrl = getPdfFilenameFromUrl; exports.getRGB = getRGB; exports.getXfaPageViewport = getXfaPageViewport; exports.isDataScheme = isDataScheme; exports.isPdfFile = isPdfFile; exports.isValidFetchUrl = isValidFetchUrl; exports.loadScript = loadScript; var _base_factory = __w_pdfjs_require__(7); var _util = __w_pdfjs_require__(1); const SVG_NS = &quot;http://www.w3.org/2000/svg&quot;; const AnnotationPrefix = &quot;pdfjs_internal_id_&quot;; exports.AnnotationPrefix = AnnotationPrefix; class PixelsPerInch { static CSS = 96.0; static PDF = 72.0; static PDF_TO_CSS_UNITS = this.CSS / this.PDF; } exports.PixelsPerInch = PixelsPerInch; class DOMCanvasFactory extends _base_factory.BaseCanvasFactory { constructor({ ownerDocument = globalThis.document } = {}) { super(); this._document = ownerDocument; } _createCanvas(width, height) { const canvas = this._document.createElement(&quot;canvas&quot;); canvas.width = width; canvas.height = height; return canvas; } } exports.DOMCanvasFactory = DOMCanvasFactory; async function fetchData(url, asTypedArray = false) { if (isValidFetchUrl(url, document.baseURI)) { const response = await fetch(url); if (!response.ok) { throw new Error(response.statusText); } return asTypedArray ? new Uint8Array(await response.arrayBuffer()) : (0, _util.stringToBytes)(await response.text()); } return new Promise((resolve, reject) =&gt; { const request = new XMLHttpRequest(); request.open(&quot;GET&quot;, url, true); if (asTypedArray) { request.responseType = &quot;arraybuffer&quot;; } request.onreadystatechange = () =&gt; { if (request.readyState !== XMLHttpRequest.DONE) { return; } if (request.status === 200 || request.status === 0) { let data; if (asTypedArray &amp;&amp; request.response) { data = new Uint8Array(request.response); } else if (!asTypedArray &amp;&amp; request.responseText) { data = (0, _util.stringToBytes)(request.responseText); } if (data) { resolve(data); return; } } reject(new Error(request.statusText)); }; request.send(null); }); } class DOMCMapReaderFactory extends _base_factory.BaseCMapReaderFactory { _fetchData(url, compressionType) { return fetchData(url, this.isCompressed).then(data =&gt; { return { cMapData: data, compressionType }; }); } } exports.DOMCMapReaderFactory = DOMCMapReaderFactory; class DOMStandardFontDataFactory extends _base_factory.BaseStandardFontDataFactory { _fetchData(url) { return fetchData(url, true); } } exports.DOMStandardFontDataFactory = DOMStandardFontDataFactory; class DOMSVGFactory extends _base_factory.BaseSVGFactory { _createSVG(type) { return document.createElementNS(SVG_NS, type); } } exports.DOMSVGFactory = DOMSVGFactory; class PageViewport { constructor({ viewBox, scale, rotation, offsetX = 0, offsetY = 0, dontFlip = false }) { this.viewBox = viewBox; this.scale = scale; this.rotation = rotation; this.offsetX = offsetX; this.offsetY = offsetY; const centerX = (viewBox[2] + viewBox[0]) / 2; const centerY = (viewBox[3] + viewBox[1]) / 2; let rotateA, rotateB, rotateC, rotateD; rotation %= 360; if (rotation &lt; 0) { rotation += 360; } switch (rotation) { case 180: rotateA = -1; rotateB = 0; rotateC = 0; rotateD = 1; break; case 90: rotateA = 0; rotateB = 1; rotateC = 1; rotateD = 0; break; case 270: rotateA = 0; rotateB = -1; rotateC = -1; rotateD = 0; break; case 0: rotateA = 1; rotateB = 0; rotateC = 0; rotateD = -1; break; default: throw new Error(&quot;PageViewport: Invalid rotation, must be a multiple of 90 degrees.&quot;); } if (dontFlip) { rotateC = -rotateC; rotateD = -rotateD; } let offsetCanvasX, offsetCanvasY; let width, height; if (rotateA === 0) { offsetCanvasX = Math.abs(centerY - viewBox[1]) * scale + offsetX; offsetCanvasY = Math.abs(centerX - viewBox[0]) * scale + offsetY; width = Math.abs(viewBox[3] - viewBox[1]) * scale; height = Math.abs(viewBox[2] - viewBox[0]) * scale; } else { offsetCanvasX = Math.abs(centerX - viewBox[0]) * scale + offsetX; offsetCanvasY = Math.abs(centerY - viewBox[1]) * scale + offsetY; width = Math.abs(viewBox[2] - viewBox[0]) * scale; height = Math.abs(viewBox[3] - viewBox[1]) * scale; } this.transform = [rotateA * scale, rotateB * scale, rotateC * scale, rotateD * scale, offsetCanvasX - rotateA * scale * centerX - rotateC * scale * centerY, offsetCanvasY - rotateB * scale * centerX - rotateD * scale * centerY]; this.width = width; this.height = height; } clone({ scale = this.scale, rotation = this.rotation, offsetX = this.offsetX, offsetY = this.offsetY, dontFlip = false } = {}) { return new PageViewport({ viewBox: this.viewBox.slice(), scale, rotation, offsetX, offsetY, dontFlip }); } convertToViewportPoint(x, y) { return _util.Util.applyTransform([x, y], this.transform); } convertToViewportRectangle(rect) { const topLeft = _util.Util.applyTransform([rect[0], rect[1]], this.transform); const bottomRight = _util.Util.applyTransform([rect[2], rect[3]], this.transform); return [topLeft[0], topLeft[1], bottomRight[0], bottomRight[1]]; } convertToPdfPoint(x, y) { return _util.Util.applyInverseTransform([x, y], this.transform); } } exports.PageViewport = PageViewport; class RenderingCancelledException extends _util.BaseException { constructor(msg, type) { super(msg, &quot;RenderingCancelledException&quot;); this.type = type; } } exports.RenderingCancelledException = RenderingCancelledException; function isDataScheme(url) { const ii = url.length; let i = 0; while (i &lt; ii &amp;&amp; url[i].trim() === &quot;&quot;) { i++; } return url.substring(i, i + 5).toLowerCase() === &quot;data:&quot;; } function isPdfFile(filename) { return typeof filename === &quot;string&quot; &amp;&amp; /\\.pdf$/i.test(filename); } function getFilenameFromUrl(url) { const anchor = url.indexOf(&quot;#&quot;); const query = url.indexOf(&quot;?&quot;); const end = Math.min(anchor &gt; 0 ? anchor : url.length, query &gt; 0 ? query : url.length); return url.substring(url.lastIndexOf(&quot;/&quot;, end) + 1, end); } function getPdfFilenameFromUrl(url, defaultFilename = &quot;document.pdf&quot;) { if (typeof url !== &quot;string&quot;) { return defaultFilename; } if (isDataScheme(url)) { (0, _util.warn)(&apos;getPdfFilenameFromUrl: ignore &quot;data:&quot;-URL for performance reasons.&apos;); return defaultFilename; } const reURI = /^(?:(?:[^:]+:)?\\/\\/[^/]+)?([^?#]*)(\\?[^#]*)?(#.*)?$/; const reFilename = /[^/?#=]+\\.pdf\\b(?!.*\\.pdf\\b)/i; const splitURI = reURI.exec(url); let suggestedFilename = reFilename.exec(splitURI[1]) || reFilename.exec(splitURI[2]) || reFilename.exec(splitURI[3]); if (suggestedFilename) { suggestedFilename = suggestedFilename[0]; if (suggestedFilename.includes(&quot;%&quot;)) { try { suggestedFilename = reFilename.exec(decodeURIComponent(suggestedFilename))[0]; } catch (ex) {} } } return suggestedFilename || defaultFilename; } class StatTimer { constructor() { this.started = Object.create(null); this.times = []; } time(name) { if (name in this.started) { (0, _util.warn)(`Timer is already running for ${name}`); } this.started[name] = Date.now(); } timeEnd(name) { if (!(name in this.started)) { (0, _util.warn)(`Timer has not been started for ${name}`); } this.times.push({ name, start: this.started[name], end: Date.now() }); delete this.started[name]; } toString() { const outBuf = []; let longest = 0; for (const time of this.times) { const name = time.name; if (name.length &gt; longest) { longest = name.length; } } for (const time of this.times) { const duration = time.end - time.start; outBuf.push(`${time.name.padEnd(longest)} ${duration}ms\\n`); } return outBuf.join(&quot;&quot;); } } exports.StatTimer = StatTimer; function isValidFetchUrl(url, baseUrl) { try { const { protocol } = baseUrl ? new URL(url, baseUrl) : new URL(url); return protocol === &quot;http:&quot; || protocol === &quot;https:&quot;; } catch (ex) { return false; } } function loadScript(src, removeScriptElement = false) { return new Promise((resolve, reject) =&gt; { const script = document.createElement(&quot;script&quot;); script.src = src; script.onload = function (evt) { if (removeScriptElement) { script.remove(); } resolve(evt); }; script.onerror = function () { reject(new Error(`Cannot load script at: ${script.src}`)); }; (document.head || document.documentElement).append(script); }); } function deprecated(details) { console.log(&quot;Deprecated API usage: &quot; + details); } let pdfDateStringRegex; class PDFDateString { static toDateObject(input) { if (!input || typeof input !== &quot;string&quot;) { return null; } if (!pdfDateStringRegex) { pdfDateStringRegex = new RegExp(&quot;^D:&quot; + &quot;(\\\\d{4})&quot; + &quot;(\\\\d{2})?&quot; + &quot;(\\\\d{2})?&quot; + &quot;(\\\\d{2})?&quot; + &quot;(\\\\d{2})?&quot; + &quot;(\\\\d{2})?&quot; + &quot;([Z|+|-])?&quot; + &quot;(\\\\d{2})?&quot; + &quot;&apos;?&quot; + &quot;(\\\\d{2})?&quot; + &quot;&apos;?&quot;); } const matches = pdfDateStringRegex.exec(input); if (!matches) { return null; } const year = parseInt(matches[1], 10); let month = parseInt(matches[2], 10); month = month &gt;= 1 &amp;&amp; month &lt;= 12 ? month - 1 : 0; let day = parseInt(matches[3], 10); day = day &gt;= 1 &amp;&amp; day &lt;= 31 ? day : 1; let hour = parseInt(matches[4], 10); hour = hour &gt;= 0 &amp;&amp; hour &lt;= 23 ? hour : 0; let minute = parseInt(matches[5], 10); minute = minute &gt;= 0 &amp;&amp; minute &lt;= 59 ? minute : 0; let second = parseInt(matches[6], 10); second = second &gt;= 0 &amp;&amp; second &lt;= 59 ? second : 0; const universalTimeRelation = matches[7] || &quot;Z&quot;; let offsetHour = parseInt(matches[8], 10); offsetHour = offsetHour &gt;= 0 &amp;&amp; offsetHour &lt;= 23 ? offsetHour : 0; let offsetMinute = parseInt(matches[9], 10) || 0; offsetMinute = offsetMinute &gt;= 0 &amp;&amp; offsetMinute &lt;= 59 ? offsetMinute : 0; if (universalTimeRelation === &quot;-&quot;) { hour += offsetHour; minute += offsetMinute; } else if (universalTimeRelation === &quot;+&quot;) { hour -= offsetHour; minute -= offsetMinute; } return new Date(Date.UTC(year, month, day, hour, minute, second)); } } exports.PDFDateString = PDFDateString; function getXfaPageViewport(xfaPage, { scale = 1, rotation = 0 }) { const { width, height } = xfaPage.attributes.style; const viewBox = [0, 0, parseInt(width), parseInt(height)]; return new PageViewport({ viewBox, scale, rotation }); } function getRGB(color) { if (color.startsWith(&quot;#&quot;)) { const colorRGB = parseInt(color.slice(1), 16); return [(colorRGB &amp; 0xff0000) &gt;&gt; 16, (colorRGB &amp; 0x00ff00) &gt;&gt; 8, colorRGB &amp; 0x0000ff]; } if (color.startsWith(&quot;rgb(&quot;)) { return color.slice(4, -1).split(&quot;,&quot;).map(x =&gt; parseInt(x)); } if (color.startsWith(&quot;rgba(&quot;)) { return color.slice(5, -1).split(&quot;,&quot;).map(x =&gt; parseInt(x)).slice(0, 3); } (0, _util.warn)(`Not a valid color format: &quot;${color}&quot;`); return [0, 0, 0]; } function getColorValues(colors) { const span = document.createElement(&quot;span&quot;); span.style.visibility = &quot;hidden&quot;; document.body.append(span); for (const name of colors.keys()) { span.style.color = name; const computedColor = window.getComputedStyle(span).color; colors.set(name, getRGB(computedColor)); } span.remove(); } function getCurrentTransform(ctx) { const { a, b, c, d, e, f } = ctx.getTransform(); return [a, b, c, d, e, f]; } function getCurrentTransformInverse(ctx) { const { a, b, c, d, e, f } = ctx.getTransform().invertSelf(); return [a, b, c, d, e, f]; } /***/ }), /* 7 */ /***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) =&gt; { Object.defineProperty(exports, &quot;__esModule&quot;, ({ value: true })); exports.BaseStandardFontDataFactory = exports.BaseSVGFactory = exports.BaseCanvasFactory = exports.BaseCMapReaderFactory = void 0; var _util = __w_pdfjs_require__(1); class BaseCanvasFactory { constructor() { if (this.constructor === BaseCanvasFactory) { (0, _util.unreachable)(&quot;Cannot initialize BaseCanvasFactory.&quot;); } } create(width, height) { if (width &lt;= 0 || height &lt;= 0) { throw new Error(&quot;Invalid canvas size&quot;); } const canvas = this._createCanvas(width, height); return { canvas, context: canvas.getContext(&quot;2d&quot;) }; } reset(canvasAndContext, width, height) { if (!canvasAndContext.canvas) { throw new Error(&quot;Canvas is not specified&quot;); } if (width &lt;= 0 || height &lt;= 0) { throw new Error(&quot;Invalid canvas size&quot;); } canvasAndContext.canvas.width = width; canvasAndContext.canvas.height = height; } destroy(canvasAndContext) { if (!canvasAndContext.canvas) { throw new Error(&quot;Canvas is not specified&quot;); } canvasAndContext.canvas.width = 0; canvasAndContext.canvas.height = 0; canvasAndContext.canvas = null; canvasAndContext.context = null; } _createCanvas(width, height) { (0, _util.unreachable)(&quot;Abstract method `_createCanvas` called.&quot;); } } exports.BaseCanvasFactory = BaseCanvasFactory; class BaseCMapReaderFactory { constructor({ baseUrl = null, isCompressed = false }) { if (this.constructor === BaseCMapReaderFactory) { (0, _util.unreachable)(&quot;Cannot initialize BaseCMapReaderFactory.&quot;); } this.baseUrl = baseUrl; this.isCompressed = isCompressed; } async fetch({ name }) { if (!this.baseUrl) { throw new Error(&apos;The CMap &quot;baseUrl&quot; parameter must be specified, ensure that &apos; + &apos;the &quot;cMapUrl&quot; and &quot;cMapPacked&quot; API parameters are provided.&apos;); } if (!name) { throw new Error(&quot;CMap name must be specified.&quot;); } const url = this.baseUrl + name + (this.isCompressed ? &quot;.bcmap&quot; : &quot;&quot;); const compressionType = this.isCompressed ? _util.CMapCompressionType.BINARY : _util.CMapCompressionType.NONE; return this._fetchData(url, compressionType).catch(reason =&gt; { throw new Error(`Unable to load ${this.isCompressed ? &quot;binary &quot; : &quot;&quot;}CMap at: ${url}`); }); } _fetchData(url, compressionType) { (0, _util.unreachable)(&quot;Abstract method `_fetchData` called.&quot;); } } exports.BaseCMapReaderFactory = BaseCMapReaderFactory; class BaseStandardFontDataFactory { constructor({ baseUrl = null }) { if (this.constructor === BaseStandardFontDataFactory) { (0, _util.unreachable)(&quot;Cannot initialize BaseStandardFontDataFactory.&quot;); } this.baseUrl = baseUrl; } async fetch({ filename }) { if (!this.baseUrl) { throw new Error(&apos;The standard font &quot;baseUrl&quot; parameter must be specified, ensure that &apos; + &apos;the &quot;standardFontDataUrl&quot; API parameter is provided.&apos;); } if (!filename) { throw new Error(&quot;Font filename must be specified.&quot;); } const url = `${this.baseUrl}${filename}`; return this._fetchData(url).catch(reason =&gt; { throw new Error(`Unable to load font data at: ${url}`); }); } _fetchData(url) { (0, _util.unreachable)(&quot;Abstract method `_fetchData` called.&quot;); } } exports.BaseStandardFontDataFactory = BaseStandardFontDataFactory; class BaseSVGFactory { constructor() { if (this.constructor === BaseSVGFactory) { (0, _util.unreachable)(&quot;Cannot initialize BaseSVGFactory.&quot;); } } create(width, height, skipDimensions = false) { if (width &lt;= 0 || height &lt;= 0) { throw new Error(&quot;Invalid SVG dimensions&quot;); } const svg = this._createSVG(&quot;svg:svg&quot;); svg.setAttribute(&quot;version&quot;, &quot;1.1&quot;); if (!skipDimensions) { svg.setAttribute(&quot;width&quot;, `${width}px`); svg.setAttribute(&quot;height&quot;, `${height}px`); } svg.setAttribute(&quot;preserveAspectRatio&quot;, &quot;none&quot;); svg.setAttribute(&quot;viewBox&quot;, `0 0 ${width} ${height}`); return svg; } createElement(type) { if (typeof type !== &quot;string&quot;) { throw new Error(&quot;Invalid SVG element type&quot;); } return this._createSVG(type); } _createSVG(type) { (0, _util.unreachable)(&quot;Abstract method `_createSVG` called.&quot;); } } exports.BaseSVGFactory = BaseSVGFactory; /***/ }), /* 8 */ /***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) =&gt; { Object.defineProperty(exports, &quot;__esModule&quot;, ({ value: true })); exports.MurmurHash3_64 = void 0; var _util = __w_pdfjs_require__(1); const SEED = 0xc3d2e1f0; const MASK_HIGH = 0xffff0000; const MASK_LOW = 0xffff; class MurmurHash3_64 { constructor(seed) { this.h1 = seed ? seed &amp; 0xffffffff : SEED; this.h2 = seed ? seed &amp; 0xffffffff : SEED; } update(input) { let data, length; if (typeof input === &quot;string&quot;) { data = new Uint8Array(input.length * 2); length = 0; for (let i = 0, ii = input.length; i &lt; ii; i++) { const code = input.charCodeAt(i); if (code &lt;= 0xff) { data[length++] = code; } else { data[length++] = code &gt;&gt;&gt; 8; data[length++] = code &amp; 0xff; } } } else if ((0, _util.isArrayBuffer)(input)) { data = input.slice(); length = data.byteLength; } else { throw new Error(&quot;Wrong data format in MurmurHash3_64_update. &quot; + &quot;Input must be a string or array.&quot;); } const blockCounts = length &gt;&gt; 2; const tailLength = length - blockCounts * 4; const dataUint32 = new Uint32Array(data.buffer, 0, blockCounts); let k1 = 0, k2 = 0; let h1 = this.h1, h2 = this.h2; const C1 = 0xcc9e2d51, C2 = 0x1b873593; const C1_LOW = C1 &amp; MASK_LOW, C2_LOW = C2 &amp; MASK_LOW; for (let i = 0; i &lt; blockCounts; i++) { if (i &amp; 1) { k1 = dataUint32[i]; k1 = k1 * C1 &amp; MASK_HIGH | k1 * C1_LOW &amp; MASK_LOW; k1 = k1 &lt;&lt; 15 | k1 &gt;&gt;&gt; 17; k1 = k1 * C2 &amp; MASK_HIGH | k1 * C2_LOW &amp; MASK_LOW; h1 ^= k1; h1 = h1 &lt;&lt; 13 | h1 &gt;&gt;&gt; 19; h1 = h1 * 5 + 0xe6546b64; } else { k2 = dataUint32[i]; k2 = k2 * C1 &amp; MASK_HIGH | k2 * C1_LOW &amp; MASK_LOW; k2 = k2 &lt;&lt; 15 | k2 &gt;&gt;&gt; 17; k2 = k2 * C2 &amp; MASK_HIGH | k2 * C2_LOW &amp; MASK_LOW; h2 ^= k2; h2 = h2 &lt;&lt; 13 | h2 &gt;&gt;&gt; 19; h2 = h2 * 5 + 0xe6546b64; } } k1 = 0; switch (tailLength) { case 3: k1 ^= data[blockCounts * 4 + 2] &lt;&lt; 16; case 2: k1 ^= data[blockCounts * 4 + 1] &lt;&lt; 8; case 1: k1 ^= data[blockCounts * 4]; k1 = k1 * C1 &amp; MASK_HIGH | k1 * C1_LOW &amp; MASK_LOW; k1 = k1 &lt;&lt; 15 | k1 &gt;&gt;&gt; 17; k1 = k1 * C2 &amp; MASK_HIGH | k1 * C2_LOW &amp; MASK_LOW; if (blockCounts &amp; 1) { h1 ^= k1; } else { h2 ^= k1; } } this.h1 = h1; this.h2 = h2; } hexdigest() { let h1 = this.h1, h2 = this.h2; h1 ^= h2 &gt;&gt;&gt; 1; h1 = h1 * 0xed558ccd &amp; MASK_HIGH | h1 * 0x8ccd &amp; MASK_LOW; h2 = h2 * 0xff51afd7 &amp; MASK_HIGH | ((h2 &lt;&lt; 16 | h1 &gt;&gt;&gt; 16) * 0xafd7ed55 &amp; MASK_HIGH) &gt;&gt;&gt; 16; h1 ^= h2 &gt;&gt;&gt; 1; h1 = h1 * 0x1a85ec53 &amp; MASK_HIGH | h1 * 0xec53 &amp; MASK_LOW; h2 = h2 * 0xc4ceb9fe &amp; MASK_HIGH | ((h2 &lt;&lt; 16 | h1 &gt;&gt;&gt; 16) * 0xb9fe1a85 &amp; MASK_HIGH) &gt;&gt;&gt; 16; h1 ^= h2 &gt;&gt;&gt; 1; const hex1 = (h1 &gt;&gt;&gt; 0).toString(16), hex2 = (h2 &gt;&gt;&gt; 0).toString(16); return hex1.padStart(8, &quot;0&quot;) + hex2.padStart(8, &quot;0&quot;); } } exports.MurmurHash3_64 = MurmurHash3_64; /***/ }), /* 9 */ /***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) =&gt; { Object.defineProperty(exports, &quot;__esModule&quot;, ({ value: true })); exports.FontLoader = exports.FontFaceObject = void 0; var _util = __w_pdfjs_require__(1); class FontLoader { constructor({ onUnsupportedFeature, ownerDocument = globalThis.document, styleElement = null }) { this._onUnsupportedFeature = onUnsupportedFeature; this._document = ownerDocument; this.nativeFontFaces = []; this.styleElement = null; this.loadingRequests = []; this.loadTestFontId = 0; } addNativeFontFace(nativeFontFace) { this.nativeFontFaces.push(nativeFontFace); this._document.fonts.add(nativeFontFace); } insertRule(rule) { if (!this.styleElement) { this.styleElement = this._document.createElement(&quot;style&quot;); this._document.documentElement.getElementsByTagName(&quot;head&quot;)[0].append(this.styleElement); } const styleSheet = this.styleElement.sheet; styleSheet.insertRule(rule, styleSheet.cssRules.length); } clear() { for (const nativeFontFace of this.nativeFontFaces) { this._document.fonts.delete(nativeFontFace); } this.nativeFontFaces.length = 0; if (this.styleElement) { this.styleElement.remove(); this.styleElement = null; } } async bind(font) { if (font.attached || font.missingFile) { return; } font.attached = true; if (this.isFontLoadingAPISupported) { const nativeFontFace = font.createNativeFontFace(); if (nativeFontFace) { this.addNativeFontFace(nativeFontFace); try { await nativeFontFace.loaded; } catch (ex) { this._onUnsupportedFeature({ featureId: _util.UNSUPPORTED_FEATURES.errorFontLoadNative }); (0, _util.warn)(`Failed to load font &apos;${nativeFontFace.family}&apos;: &apos;${ex}&apos;.`); font.disableFontFace = true; throw ex; } } return; } const rule = font.createFontFaceRule(); if (rule) { this.insertRule(rule); if (this.isSyncFontLoadingSupported) { return; } await new Promise(resolve =&gt; { const request = this._queueLoadingCallback(resolve); this._prepareFontLoadEvent(font, request); }); } } get isFontLoadingAPISupported() { const hasFonts = !!this._document?.fonts; return (0, _util.shadow)(this, &quot;isFontLoadingAPISupported&quot;, hasFonts); } get isSyncFontLoadingSupported() { let supported = false; if (typeof navigator === &quot;undefined&quot;) { supported = true; } else { const m = /Mozilla\\/5.0.*?rv:(\\d+).*? Gecko/.exec(navigator.userAgent); if (m?.[1] &gt;= 14) { supported = true; } } return (0, _util.shadow)(this, &quot;isSyncFontLoadingSupported&quot;, supported); } _queueLoadingCallback(callback) { function completeRequest() { (0, _util.assert)(!request.done, &quot;completeRequest() cannot be called twice.&quot;); request.done = true; while (loadingRequests.length &gt; 0 &amp;&amp; loadingRequests[0].done) { const otherRequest = loadingRequests.shift(); setTimeout(otherRequest.callback, 0); } } const { loadingRequests } = this; const request = { done: false, complete: completeRequest, callback }; loadingRequests.push(request); return request; } get _loadTestFont() { const testFont = atob(&quot;T1RUTwALAIAAAwAwQ0ZGIDHtZg4AAAOYAAAAgUZGVE1lkzZwAAAEHAAAABxHREVGABQA&quot; + &quot;FQAABDgAAAAeT1MvMlYNYwkAAAEgAAAAYGNtYXABDQLUAAACNAAAAUJoZWFk/xVFDQAA&quot; + &quot;ALwAAAA2aGhlYQdkA+oAAAD0AAAAJGhtdHgD6AAAAAAEWAAAAAZtYXhwAAJQAAAAARgA&quot; + &quot;AAAGbmFtZVjmdH4AAAGAAAAAsXBvc3T/hgAzAAADeAAAACAAAQAAAAEAALZRFsRfDzz1&quot; + &quot;AAsD6AAAAADOBOTLAAAAAM4KHDwAAAAAA+gDIQAAAAgAAgAAAAAAAAABAAADIQAAAFoD&quot; + &quot;6AAAAAAD6AABAAAAAAAAAAAAAAAAAAAAAQAAUAAAAgAAAAQD6AH0AAUAAAKKArwAAACM&quot; + &quot;AooCvAAAAeAAMQECAAACAAYJAAAAAAAAAAAAAQAAAAAAAAAAAAAAAFBmRWQAwAAuAC4D&quot; + &quot;IP84AFoDIQAAAAAAAQAAAAAAAAAAACAAIAABAAAADgCuAAEAAAAAAAAAAQAAAAEAAAAA&quot; + &quot;AAEAAQAAAAEAAAAAAAIAAQAAAAEAAAAAAAMAAQAAAAEAAAAAAAQAAQAAAAEAAAAAAAUA&quot; + &quot;AQAAAAEAAAAAAAYAAQAAAAMAAQQJAAAAAgABAAMAAQQJAAEAAgABAAMAAQQJAAIAAgAB&quot; + &quot;AAMAAQQJAAMAAgABAAMAAQQJAAQAAgABAAMAAQQJAAUAAgABAAMAAQQJAAYAAgABWABY&quot; + &quot;AAAAAAAAAwAAAAMAAAAcAAEAAAAAADwAAwABAAAAHAAEACAAAAAEAAQAAQAAAC7//wAA&quot; + &quot;AC7////TAAEAAAAAAAABBgAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA&quot; + &quot;AAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA&quot; + &quot;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA&quot; + &quot;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA&quot; + &quot;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA&quot; + &quot;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMAAAAAAAD/gwAyAAAAAQAAAAAAAAAAAAAAAAAA&quot; + &quot;AAABAAQEAAEBAQJYAAEBASH4DwD4GwHEAvgcA/gXBIwMAYuL+nz5tQXkD5j3CBLnEQAC&quot; + &quot;AQEBIVhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYAAABAQAADwACAQEEE/t3&quot; + &quot;Dov6fAH6fAT+fPp8+nwHDosMCvm1Cvm1DAz6fBQAAAAAAAABAAAAAMmJbzEAAAAAzgTj&quot; + &quot;FQAAAADOBOQpAAEAAAAAAAAADAAUAAQAAAABAAAAAgABAAAAAAAAAAAD6AAAAAAAAA==&quot;); return (0, _util.shadow)(this, &quot;_loadTestFont&quot;, testFont); } _prepareFontLoadEvent(font, request) { function int32(data, offset) { return data.charCodeAt(offset) &lt;&lt; 24 | data.charCodeAt(offset + 1) &lt;&lt; 16 | data.charCodeAt(offset + 2) &lt;&lt; 8 | data.charCodeAt(offset + 3) &amp; 0xff; } function spliceString(s, offset, remove, insert) { const chunk1 = s.substring(0, offset); const chunk2 = s.substring(offset + remove); return chunk1 + insert + chunk2; } let i, ii; const canvas = this._document.createElement(&quot;canvas&quot;); canvas.width = 1; canvas.height = 1; const ctx = canvas.getContext(&quot;2d&quot;); let called = 0; function isFontReady(name, callback) { if (++called &gt; 30) { (0, _util.warn)(&quot;Load test font never loaded.&quot;); callback(); return; } ctx.font = &quot;30px &quot; + name; ctx.fillText(&quot;.&quot;, 0, 20); const imageData = ctx.getImageData(0, 0, 1, 1); if (imageData.data[3] &gt; 0) { callback(); return; } setTimeout(isFontReady.bind(null, name, callback)); } const loadTestFontId = `lt${Date.now()}${this.loadTestFontId++}`; let data = this._loadTestFont; const COMMENT_OFFSET = 976; data = spliceString(data, COMMENT_OFFSET, loadTestFontId.length, loadTestFontId); const CFF_CHECKSUM_OFFSET = 16; const XXXX_VALUE = 0x58585858; let checksum = int32(data, CFF_CHECKSUM_OFFSET); for (i = 0, ii = loadTestFontId.length - 3; i &lt; ii; i += 4) { checksum = checksum - XXXX_VALUE + int32(loadTestFontId, i) | 0; } if (i &lt; loadTestFontId.length) { checksum = checksum - XXXX_VALUE + int32(loadTestFontId + &quot;XXX&quot;, i) | 0; } data = spliceString(data, CFF_CHECKSUM_OFFSET, 4, (0, _util.string32)(checksum)); const url = `url(data:font/opentype;base64,${btoa(data)});`; const rule = `@font-face {font-family:&quot;${loadTestFontId}&quot;;src:${url}}`; this.insertRule(rule); const div = this._document.createElement(&quot;div&quot;); div.style.visibility = &quot;hidden&quot;; div.style.width = div.style.height = &quot;10px&quot;; div.style.position = &quot;absolute&quot;; div.style.top = div.style.left = &quot;0px&quot;; for (const name of [font.loadedName, loadTestFontId]) { const span = this._document.createElement(&quot;span&quot;); span.textContent = &quot;Hi&quot;; span.style.fontFamily = name; div.append(span); } this._document.body.append(div); isFontReady(loadTestFontId, () =&gt; { div.remove(); request.complete(); }); } } exports.FontLoader = FontLoader; class FontFaceObject { constructor(translatedData, { isEvalSupported = true, disableFontFace = false, ignoreErrors = false, onUnsupportedFeature, fontRegistry = null }) { this.compiledGlyphs = Object.create(null); for (const i in translatedData) { this[i] = translatedData[i]; } this.isEvalSupported = isEvalSupported !== false; this.disableFontFace = disableFontFace === true; this.ignoreErrors = ignoreErrors === true; this._onUnsupportedFeature = onUnsupportedFeature; this.fontRegistry = fontRegistry; } createNativeFontFace() { if (!this.data || this.disableFontFace) { return null; } let nativeFontFace; if (!this.cssFontInfo) { nativeFontFace = new FontFace(this.loadedName, this.data, {}); } else { const css = { weight: this.cssFontInfo.fontWeight }; if (this.cssFontInfo.italicAngle) { css.style = `oblique ${this.cssFontInfo.italicAngle}deg`; } nativeFontFace = new FontFace(this.cssFontInfo.fontFamily, this.data, css); } this.fontRegistry?.registerFont(this); return nativeFontFace; } createFontFaceRule() { if (!this.data || this.disableFontFace) { return null; } const data = (0, _util.bytesToString)(this.data); const url = `url(data:${this.mimetype};base64,${btoa(data)});`; let rule; if (!this.cssFontInfo) { rule = `@font-face {font-family:&quot;${this.loadedName}&quot;;src:${url}}`; } else { let css = `font-weight: ${this.cssFontInfo.fontWeight};`; if (this.cssFontInfo.italicAngle) { css += `font-style: oblique ${this.cssFontInfo.italicAngle}deg;`; } rule = `@font-face {font-family:&quot;${this.cssFontInfo.fontFamily}&quot;;${css}src:${url}}`; } this.fontRegistry?.registerFont(this, url); return rule; } getPathGenerator(objs, character) { if (this.compiledGlyphs[character] !== undefined) { return this.compiledGlyphs[character]; } let cmds; try { cmds = objs.get(this.loadedName + &quot;_path_&quot; + character); } catch (ex) { if (!this.ignoreErrors) { throw ex; } this._onUnsupportedFeature({ featureId: _util.UNSUPPORTED_FEATURES.errorFontGetPath }); (0, _util.warn)(`getPathGenerator - ignoring character: &quot;${ex}&quot;.`); return this.compiledGlyphs[character] = function (c, size) {}; } if (this.isEvalSupported &amp;&amp; _util.FeatureTest.isEvalSupported) { const jsBuf = []; for (const current of cmds) { const args = current.args !== undefined ? current.args.join(&quot;,&quot;) : &quot;&quot;; jsBuf.push(&quot;c.&quot;, current.cmd, &quot;(&quot;, args, &quot;);\\n&quot;); } return this.compiledGlyphs[character] = new Function(&quot;c&quot;, &quot;size&quot;, jsBuf.join(&quot;&quot;)); } return this.compiledGlyphs[character] = function (c, size) { for (const current of cmds) { if (current.cmd === &quot;scale&quot;) { current.args = [size, -size]; } c[current.cmd].apply(c, current.args); } }; } } exports.FontFaceObject = FontFaceObject; /***/ }), /* 10 */ /***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) =&gt; { Object.defineProperty(exports, &quot;__esModule&quot;, ({ value: true })); exports.CanvasGraphics = void 0; var _util = __w_pdfjs_require__(1); var _display_utils = __w_pdfjs_require__(6); var _pattern_helper = __w_pdfjs_require__(11); var _image_utils = __w_pdfjs_require__(13); var _is_node = __w_pdfjs_require__(12); const MIN_FONT_SIZE = 16; const MAX_FONT_SIZE = 100; const MAX_GROUP_SIZE = 4096; const EXECUTION_TIME = 15; const EXECUTION_STEPS = 10; const MAX_SIZE_TO_COMPILE = _is_node.isNodeJS &amp;&amp; typeof Path2D === &quot;undefined&quot; ? -1 : 1000; const FULL_CHUNK_HEIGHT = 16; function mirrorContextOperations(ctx, destCtx) { if (ctx._removeMirroring) { throw new Error(&quot;Context is already forwarding operations.&quot;); } ctx.__originalSave = ctx.save; ctx.__originalRestore = ctx.restore; ctx.__originalRotate = ctx.rotate; ctx.__originalScale = ctx.scale; ctx.__originalTranslate = ctx.translate; ctx.__originalTransform = ctx.transform; ctx.__originalSetTransform = ctx.setTransform; ctx.__originalResetTransform = ctx.resetTransform; ctx.__originalClip = ctx.clip; ctx.__originalMoveTo = ctx.moveTo; ctx.__originalLineTo = ctx.lineTo; ctx.__originalBezierCurveTo = ctx.bezierCurveTo; ctx.__originalRect = ctx.rect; ctx.__originalClosePath = ctx.closePath; ctx.__originalBeginPath = ctx.beginPath; ctx._removeMirroring = () =&gt; { ctx.save = ctx.__originalSave; ctx.restore = ctx.__originalRestore; ctx.rotate = ctx.__originalRotate; ctx.scale = ctx.__originalScale; ctx.translate = ctx.__originalTranslate; ctx.transform = ctx.__originalTransform; ctx.setTransform = ctx.__originalSetTransform; ctx.resetTransform = ctx.__originalResetTransform; ctx.clip = ctx.__originalClip; ctx.moveTo = ctx.__originalMoveTo; ctx.lineTo = ctx.__originalLineTo; ctx.bezierCurveTo = ctx.__originalBezierCurveTo; ctx.rect = ctx.__originalRect; ctx.closePath = ctx.__originalClosePath; ctx.beginPath = ctx.__originalBeginPath; delete ctx._removeMirroring; }; ctx.save = function ctxSave() { destCtx.save(); this.__originalSave(); }; ctx.restore = function ctxRestore() { destCtx.restore(); this.__originalRestore(); }; ctx.translate = function ctxTranslate(x, y) { destCtx.translate(x, y); this.__originalTranslate(x, y); }; ctx.scale = function ctxScale(x, y) { destCtx.scale(x, y); this.__originalScale(x, y); }; ctx.transform = function ctxTransform(a, b, c, d, e, f) { destCtx.transform(a, b, c, d, e, f); this.__originalTransform(a, b, c, d, e, f); }; ctx.setTransform = function ctxSetTransform(a, b, c, d, e, f) { destCtx.setTransform(a, b, c, d, e, f); this.__originalSetTransform(a, b, c, d, e, f); }; ctx.resetTransform = function ctxResetTransform() { destCtx.resetTransform(); this.__originalResetTransform(); }; ctx.rotate = function ctxRotate(angle) { destCtx.rotate(angle); this.__originalRotate(angle); }; ctx.clip = function ctxRotate(rule) { destCtx.clip(rule); this.__originalClip(rule); }; ctx.moveTo = function (x, y) { destCtx.moveTo(x, y); this.__originalMoveTo(x, y); }; ctx.lineTo = function (x, y) { destCtx.lineTo(x, y); this.__originalLineTo(x, y); }; ctx.bezierCurveTo = function (cp1x, cp1y, cp2x, cp2y, x, y) { destCtx.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y); this.__originalBezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y); }; ctx.rect = function (x, y, width, height) { destCtx.rect(x, y, width, height); this.__originalRect(x, y, width, height); }; ctx.closePath = function () { destCtx.closePath(); this.__originalClosePath(); }; ctx.beginPath = function () { destCtx.beginPath(); this.__originalBeginPath(); }; } class CachedCanvases { constructor(canvasFactory) { this.canvasFactory = canvasFactory; this.cache = Object.create(null); } getCanvas(id, width, height) { let canvasEntry; if (this.cache[id] !== undefined) { canvasEntry = this.cache[id]; this.canvasFactory.reset(canvasEntry, width, height); } else { canvasEntry = this.canvasFactory.create(width, height); this.cache[id] = canvasEntry; } return canvasEntry; } delete(id) { delete this.cache[id]; } clear() { for (const id in this.cache) { const canvasEntry = this.cache[id]; this.canvasFactory.destroy(canvasEntry); delete this.cache[id]; } } } function drawImageAtIntegerCoords(ctx, srcImg, srcX, srcY, srcW, srcH, destX, destY, destW, destH) { const [a, b, c, d, tx, ty] = (0, _display_utils.getCurrentTransform)(ctx); if (b === 0 &amp;&amp; c === 0) { const tlX = destX * a + tx; const rTlX = Math.round(tlX); const tlY = destY * d + ty; const rTlY = Math.round(tlY); const brX = (destX + destW) * a + tx; const rWidth = Math.abs(Math.round(brX) - rTlX) || 1; const brY = (destY + destH) * d + ty; const rHeight = Math.abs(Math.round(brY) - rTlY) || 1; ctx.setTransform(Math.sign(a), 0, 0, Math.sign(d), rTlX, rTlY); ctx.drawImage(srcImg, srcX, srcY, srcW, srcH, 0, 0, rWidth, rHeight); ctx.setTransform(a, b, c, d, tx, ty); return [rWidth, rHeight]; } if (a === 0 &amp;&amp; d === 0) { const tlX = destY * c + tx; const rTlX = Math.round(tlX); const tlY = destX * b + ty; const rTlY = Math.round(tlY); const brX = (destY + destH) * c + tx; const rWidth = Math.abs(Math.round(brX) - rTlX) || 1; const brY = (destX + destW) * b + ty; const rHeight = Math.abs(Math.round(brY) - rTlY) || 1; ctx.setTransform(0, Math.sign(b), Math.sign(c), 0, rTlX, rTlY); ctx.drawImage(srcImg, srcX, srcY, srcW, srcH, 0, 0, rHeight, rWidth); ctx.setTransform(a, b, c, d, tx, ty); return [rHeight, rWidth]; } ctx.drawImage(srcImg, srcX, srcY, srcW, srcH, destX, destY, destW, destH); const scaleX = Math.hypot(a, b); const scaleY = Math.hypot(c, d); return [scaleX * destW, scaleY * destH]; } function compileType3Glyph(imgData) { const { width, height } = imgData; if (width &gt; MAX_SIZE_TO_COMPILE || height &gt; MAX_SIZE_TO_COMPILE) { return null; } const POINT_TO_PROCESS_LIMIT = 1000; const POINT_TYPES = new Uint8Array([0, 2, 4, 0, 1, 0, 5, 4, 8, 10, 0, 8, 0, 2, 1, 0]); const width1 = width + 1; let points = new Uint8Array(width1 * (height + 1)); let i, j, j0; const lineSize = width + 7 &amp; ~7; let data = new Uint8Array(lineSize * height), pos = 0; for (const elem of imgData.data) { let mask = 128; while (mask &gt; 0) { data[pos++] = elem &amp; mask ? 0 : 255; mask &gt;&gt;= 1; } } let count = 0; pos = 0; if (data[pos] !== 0) { points[0] = 1; ++count; } for (j = 1; j &lt; width; j++) { if (data[pos] !== data[pos + 1]) { points[j] = data[pos] ? 2 : 1; ++count; } pos++; } if (data[pos] !== 0) { points[j] = 2; ++count; } for (i = 1; i &lt; height; i++) { pos = i * lineSize; j0 = i * width1; if (data[pos - lineSize] !== data[pos]) { points[j0] = data[pos] ? 1 : 8; ++count; } let sum = (data[pos] ? 4 : 0) + (data[pos - lineSize] ? 8 : 0); for (j = 1; j &lt; width; j++) { sum = (sum &gt;&gt; 2) + (data[pos + 1] ? 4 : 0) + (data[pos - lineSize + 1] ? 8 : 0); if (POINT_TYPES[sum]) { points[j0 + j] = POINT_TYPES[sum]; ++count; } pos++; } if (data[pos - lineSize] !== data[pos]) { points[j0 + j] = data[pos] ? 2 : 4; ++count; } if (count &gt; POINT_TO_PROCESS_LIMIT) { return null; } } pos = lineSize * (height - 1); j0 = i * width1; if (data[pos] !== 0) { points[j0] = 8; ++count; } for (j = 1; j &lt; width; j++) { if (data[pos] !== data[pos + 1]) { points[j0 + j] = data[pos] ? 4 : 8; ++count; } pos++; } if (data[pos] !== 0) { points[j0 + j] = 4; ++count; } if (count &gt; POINT_TO_PROCESS_LIMIT) { return null; } const steps = new Int32Array([0, width1, -1, 0, -width1, 0, 0, 0, 1]); const path = new Path2D(); for (i = 0; count &amp;&amp; i &lt;= height; i++) { let p = i * width1; const end = p + width; while (p &lt; end &amp;&amp; !points[p]) { p++; } if (p === end) { continue; } path.moveTo(p % width1, i); const p0 = p; let type = points[p]; do { const step = steps[type]; do { p += step; } while (!points[p]); const pp = points[p]; if (pp !== 5 &amp;&amp; pp !== 10) { type = pp; points[p] = 0; } else { type = pp &amp; 0x33 * type &gt;&gt; 4; points[p] &amp;= type &gt;&gt; 2 | type &lt;&lt; 2; } path.lineTo(p % width1, p / width1 | 0); if (!points[p]) { --count; } } while (p0 !== p); --i; } data = null; points = null; const drawOutline = function (c) { c.save(); c.scale(1 / width, -1 / height); c.translate(0, -height); c.fill(path); c.beginPath(); c.restore(); }; return drawOutline; } class CanvasExtraState { constructor(width, height) { this.alphaIsShape = false; this.fontSize = 0; this.fontSizeScale = 1; this.textMatrix = _util.IDENTITY_MATRIX; this.textMatrixScale = 1; this.fontMatrix = _util.FONT_IDENTITY_MATRIX; this.leading = 0; this.x = 0; this.y = 0; this.lineX = 0; this.lineY = 0; this.charSpacing = 0; this.wordSpacing = 0; this.textHScale = 1; this.textRenderingMode = _util.TextRenderingMode.FILL; this.textRise = 0; this.fillColor = &quot;#000000&quot;; this.strokeColor = &quot;#000000&quot;; this.patternFill = false; this.fillAlpha = 1; this.strokeAlpha = 1; this.lineWidth = 1; this.activeSMask = null; this.transferMaps = null; this.startNewPathAndClipBox([0, 0, width, height]); } clone() { const clone = Object.create(this); clone.clipBox = this.clipBox.slice(); return clone; } setCurrentPoint(x, y) { this.x = x; this.y = y; } updatePathMinMax(transform, x, y) { [x, y] = _util.Util.applyTransform([x, y], transform); this.minX = Math.min(this.minX, x); this.minY = Math.min(this.minY, y); this.maxX = Math.max(this.maxX, x); this.maxY = Math.max(this.maxY, y); } updateRectMinMax(transform, rect) { const p1 = _util.Util.applyTransform(rect, transform); const p2 = _util.Util.applyTransform(rect.slice(2), transform); this.minX = Math.min(this.minX, p1[0], p2[0]); this.minY = Math.min(this.minY, p1[1], p2[1]); this.maxX = Math.max(this.maxX, p1[0], p2[0]); this.maxY = Math.max(this.maxY, p1[1], p2[1]); } updateScalingPathMinMax(transform, minMax) { _util.Util.scaleMinMax(transform, minMax); this.minX = Math.min(this.minX, minMax[0]); this.maxX = Math.max(this.maxX, minMax[1]); this.minY = Math.min(this.minY, minMax[2]); this.maxY = Math.max(this.maxY, minMax[3]); } updateCurvePathMinMax(transform, x0, y0, x1, y1, x2, y2, x3, y3, minMax) { const box = _util.Util.bezierBoundingBox(x0, y0, x1, y1, x2, y2, x3, y3); if (minMax) { minMax[0] = Math.min(minMax[0], box[0], box[2]); minMax[1] = Math.max(minMax[1], box[0], box[2]); minMax[2] = Math.min(minMax[2], box[1], box[3]); minMax[3] = Math.max(minMax[3], box[1], box[3]); return; } this.updateRectMinMax(transform, box); } getPathBoundingBox(pathType = _pattern_helper.PathType.FILL, transform = null) { const box = [this.minX, this.minY, this.maxX, this.maxY]; if (pathType === _pattern_helper.PathType.STROKE) { if (!transform) { (0, _util.unreachable)(&quot;Stroke bounding box must include transform.&quot;); } const scale = _util.Util.singularValueDecompose2dScale(transform); const xStrokePad = scale[0] * this.lineWidth / 2; const yStrokePad = scale[1] * this.lineWidth / 2; box[0] -= xStrokePad; box[1] -= yStrokePad; box[2] += xStrokePad; box[3] += yStrokePad; } return box; } updateClipFromPath() { const intersect = _util.Util.intersect(this.clipBox, this.getPathBoundingBox()); this.startNewPathAndClipBox(intersect || [0, 0, 0, 0]); } isEmptyClip() { return this.minX === Infinity; } startNewPathAndClipBox(box) { this.clipBox = box; this.minX = Infinity; this.minY = Infinity; this.maxX = 0; this.maxY = 0; } getClippedPathBoundingBox(pathType = _pattern_helper.PathType.FILL, transform = null) { return _util.Util.intersect(this.clipBox, this.getPathBoundingBox(pathType, transform)); } } function putBinaryImageData(ctx, imgData, transferMaps = null) { if (typeof ImageData !== &quot;undefined&quot; &amp;&amp; imgData instanceof ImageData) { ctx.putImageData(imgData, 0, 0); return; } const height = imgData.height, width = imgData.width; const partialChunkHeight = height % FULL_CHUNK_HEIGHT; const fullChunks = (height - partialChunkHeight) / FULL_CHUNK_HEIGHT; const totalChunks = partialChunkHeight === 0 ? fullChunks : fullChunks + 1; const chunkImgData = ctx.createImageData(width, FULL_CHUNK_HEIGHT); let srcPos = 0, destPos; const src = imgData.data; const dest = chunkImgData.data; let i, j, thisChunkHeight, elemsInThisChunk; let transferMapRed, transferMapGreen, transferMapBlue, transferMapGray; if (transferMaps) { switch (transferMaps.length) { case 1: transferMapRed = transferMaps[0]; transferMapGreen = transferMaps[0]; transferMapBlue = transferMaps[0]; transferMapGray = transferMaps[0]; break; case 4: transferMapRed = transferMaps[0]; transferMapGreen = transferMaps[1]; transferMapBlue = transferMaps[2]; transferMapGray = transferMaps[3]; break; } } if (imgData.kind === _util.ImageKind.GRAYSCALE_1BPP) { const srcLength = src.byteLength; const dest32 = new Uint32Array(dest.buffer, 0, dest.byteLength &gt;&gt; 2); const dest32DataLength = dest32.length; const fullSrcDiff = width + 7 &gt;&gt; 3; let white = 0xffffffff; let black = _util.FeatureTest.isLittleEndian ? 0xff000000 : 0x000000ff; if (transferMapGray) { if (transferMapGray[0] === 0xff &amp;&amp; transferMapGray[0xff] === 0) { [white, black] = [black, white]; } } for (i = 0; i &lt; totalChunks; i++) { thisChunkHeight = i &lt; fullChunks ? FULL_CHUNK_HEIGHT : partialChunkHeight; destPos = 0; for (j = 0; j &lt; thisChunkHeight; j++) { const srcDiff = srcLength - srcPos; let k = 0; const kEnd = srcDiff &gt; fullSrcDiff ? width : srcDiff * 8 - 7; const kEndUnrolled = kEnd &amp; ~7; let mask = 0; let srcByte = 0; for (; k &lt; kEndUnrolled; k += 8) { srcByte = src[srcPos++]; dest32[destPos++] = srcByte &amp; 128 ? white : black; dest32[destPos++] = srcByte &amp; 64 ? white : black; dest32[destPos++] = srcByte &amp; 32 ? white : black; dest32[destPos++] = srcByte &amp; 16 ? white : black; dest32[destPos++] = srcByte &amp; 8 ? white : black; dest32[destPos++] = srcByte &amp; 4 ? white : black; dest32[destPos++] = srcByte &amp; 2 ? white : black; dest32[destPos++] = srcByte &amp; 1 ? white : black; } for (; k &lt; kEnd; k++) { if (mask === 0) { srcByte = src[srcPos++]; mask = 128; } dest32[destPos++] = srcByte &amp; mask ? white : black; mask &gt;&gt;= 1; } } while (destPos &lt; dest32DataLength) { dest32[destPos++] = 0; } ctx.putImageData(chunkImgData, 0, i * FULL_CHUNK_HEIGHT); } } else if (imgData.kind === _util.ImageKind.RGBA_32BPP) { const hasTransferMaps = !!(transferMapRed || transferMapGreen || transferMapBlue); j = 0; elemsInThisChunk = width * FULL_CHUNK_HEIGHT * 4; for (i = 0; i &lt; fullChunks; i++) { dest.set(src.subarray(srcPos, srcPos + elemsInThisChunk)); srcPos += elemsInThisChunk; if (hasTransferMaps) { for (let k = 0; k &lt; elemsInThisChunk; k += 4) { if (transferMapRed) { dest[k + 0] = transferMapRed[dest[k + 0]]; } if (transferMapGreen) { dest[k + 1] = transferMapGreen[dest[k + 1]]; } if (transferMapBlue) { dest[k + 2] = transferMapBlue[dest[k + 2]]; } } } ctx.putImageData(chunkImgData, 0, j); j += FULL_CHUNK_HEIGHT; } if (i &lt; totalChunks) { elemsInThisChunk = width * partialChunkHeight * 4; dest.set(src.subarray(srcPos, srcPos + elemsInThisChunk)); if (hasTransferMaps) { for (let k = 0; k &lt; elemsInThisChunk; k += 4) { if (transferMapRed) { dest[k + 0] = transferMapRed[dest[k + 0]]; } if (transferMapGreen) { dest[k + 1] = transferMapGreen[dest[k + 1]]; } if (transferMapBlue) { dest[k + 2] = transferMapBlue[dest[k + 2]]; } } } ctx.putImageData(chunkImgData, 0, j); } } else if (imgData.kind === _util.ImageKind.RGB_24BPP) { const hasTransferMaps = !!(transferMapRed || transferMapGreen || transferMapBlue); thisChunkHeight = FULL_CHUNK_HEIGHT; elemsInThisChunk = width * thisChunkHeight; for (i = 0; i &lt; totalChunks; i++) { if (i &gt;= fullChunks) { thisChunkHeight = partialChunkHeight; elemsInThisChunk = width * thisChunkHeight; } destPos = 0; for (j = elemsInThisChunk; j--;) { dest[destPos++] = src[srcPos++]; dest[destPos++] = src[srcPos++]; dest[destPos++] = src[srcPos++]; dest[destPos++] = 255; } if (hasTransferMaps) { for (let k = 0; k &lt; destPos; k += 4) { if (transferMapRed) { dest[k + 0] = transferMapRed[dest[k + 0]]; } if (transferMapGreen) { dest[k + 1] = transferMapGreen[dest[k + 1]]; } if (transferMapBlue) { dest[k + 2] = transferMapBlue[dest[k + 2]]; } } } ctx.putImageData(chunkImgData, 0, i * FULL_CHUNK_HEIGHT); } } else { throw new Error(`bad image kind: ${imgData.kind}`); } } function putBinaryImageMask(ctx, imgData) { if (imgData.bitmap) { ctx.drawImage(imgData.bitmap, 0, 0); return; } const height = imgData.height, width = imgData.width; const partialChunkHeight = height % FULL_CHUNK_HEIGHT; const fullChunks = (height - partialChunkHeight) / FULL_CHUNK_HEIGHT; const totalChunks = partialChunkHeight === 0 ? fullChunks : fullChunks + 1; const chunkImgData = ctx.createImageData(width, FULL_CHUNK_HEIGHT); let srcPos = 0; const src = imgData.data; const dest = chunkImgData.data; for (let i = 0; i &lt; totalChunks; i++) { const thisChunkHeight = i &lt; fullChunks ? FULL_CHUNK_HEIGHT : partialChunkHeight; ({ srcPos } = (0, _image_utils.applyMaskImageData)({ src, srcPos, dest, width, height: thisChunkHeight })); ctx.putImageData(chunkImgData, 0, i * FULL_CHUNK_HEIGHT); } } function copyCtxState(sourceCtx, destCtx) { const properties = [&quot;strokeStyle&quot;, &quot;fillStyle&quot;, &quot;fillRule&quot;, &quot;globalAlpha&quot;, &quot;lineWidth&quot;, &quot;lineCap&quot;, &quot;lineJoin&quot;, &quot;miterLimit&quot;, &quot;globalCompositeOperation&quot;, &quot;font&quot;]; for (const property of properties) { if (sourceCtx[property] !== undefined) { destCtx[property] = sourceCtx[property]; } } if (sourceCtx.setLineDash !== undefined) { destCtx.setLineDash(sourceCtx.getLineDash()); destCtx.lineDashOffset = sourceCtx.lineDashOffset; } } function resetCtxToDefault(ctx, foregroundColor) { ctx.strokeStyle = ctx.fillStyle = foregroundColor || &quot;#000000&quot;; ctx.fillRule = &quot;nonzero&quot;; ctx.globalAlpha = 1; ctx.lineWidth = 1; ctx.lineCap = &quot;butt&quot;; ctx.lineJoin = &quot;miter&quot;; ctx.miterLimit = 10; ctx.globalCompositeOperation = &quot;source-over&quot;; ctx.font = &quot;10px sans-serif&quot;; if (ctx.setLineDash !== undefined) { ctx.setLineDash([]); ctx.lineDashOffset = 0; } } function composeSMaskBackdrop(bytes, r0, g0, b0) { const length = bytes.length; for (let i = 3; i &lt; length; i += 4) { const alpha = bytes[i]; if (alpha === 0) { bytes[i - 3] = r0; bytes[i - 2] = g0; bytes[i - 1] = b0; } else if (alpha &lt; 255) { const alpha_ = 255 - alpha; bytes[i - 3] = bytes[i - 3] * alpha + r0 * alpha_ &gt;&gt; 8; bytes[i - 2] = bytes[i - 2] * alpha + g0 * alpha_ &gt;&gt; 8; bytes[i - 1] = bytes[i - 1] * alpha + b0 * alpha_ &gt;&gt; 8; } } } function composeSMaskAlpha(maskData, layerData, transferMap) { const length = maskData.length; const scale = 1 / 255; for (let i = 3; i &lt; length; i += 4) { const alpha = transferMap ? transferMap[maskData[i]] : maskData[i]; layerData[i] = layerData[i] * alpha * scale | 0; } } function composeSMaskLuminosity(maskData, layerData, transferMap) { const length = maskData.length; for (let i = 3; i &lt; length; i += 4) { const y = maskData[i - 3] * 77 + maskData[i - 2] * 152 + maskData[i - 1] * 28; layerData[i] = transferMap ? layerData[i] * transferMap[y &gt;&gt; 8] &gt;&gt; 8 : layerData[i] * y &gt;&gt; 16; } } function genericComposeSMask(maskCtx, layerCtx, width, height, subtype, backdrop, transferMap, layerOffsetX, layerOffsetY, maskOffsetX, maskOffsetY) { const hasBackdrop = !!backdrop; const r0 = hasBackdrop ? backdrop[0] : 0; const g0 = hasBackdrop ? backdrop[1] : 0; const b0 = hasBackdrop ? backdrop[2] : 0; let composeFn; if (subtype === &quot;Luminosity&quot;) { composeFn = composeSMaskLuminosity; } else { composeFn = composeSMaskAlpha; } const PIXELS_TO_PROCESS = 1048576; const chunkSize = Math.min(height, Math.ceil(PIXELS_TO_PROCESS / width)); for (let row = 0; row &lt; height; row += chunkSize) { const chunkHeight = Math.min(chunkSize, height - row); const maskData = maskCtx.getImageData(layerOffsetX - maskOffsetX, row + (layerOffsetY - maskOffsetY), width, chunkHeight); const layerData = layerCtx.getImageData(layerOffsetX, row + layerOffsetY, width, chunkHeight); if (hasBackdrop) { composeSMaskBackdrop(maskData.data, r0, g0, b0); } composeFn(maskData.data, layerData.data, transferMap); layerCtx.putImageData(layerData, layerOffsetX, row + layerOffsetY); } } function composeSMask(ctx, smask, layerCtx, layerBox) { const layerOffsetX = layerBox[0]; const layerOffsetY = layerBox[1]; const layerWidth = layerBox[2] - layerOffsetX; const layerHeight = layerBox[3] - layerOffsetY; if (layerWidth === 0 || layerHeight === 0) { return; } genericComposeSMask(smask.context, layerCtx, layerWidth, layerHeight, smask.subtype, smask.backdrop, smask.transferMap, layerOffsetX, layerOffsetY, smask.offsetX, smask.offsetY); ctx.save(); ctx.globalAlpha = 1; ctx.globalCompositeOperation = &quot;source-over&quot;; ctx.setTransform(1, 0, 0, 1, 0, 0); ctx.drawImage(layerCtx.canvas, 0, 0); ctx.restore(); } function getImageSmoothingEnabled(transform, interpolate) { const scale = _util.Util.singularValueDecompose2dScale(transform); scale[0] = Math.fround(scale[0]); scale[1] = Math.fround(scale[1]); const actualScale = Math.fround((globalThis.devicePixelRatio || 1) * _display_utils.PixelsPerInch.PDF_TO_CSS_UNITS); if (interpolate !== undefined) { return interpolate; } else if (scale[0] &lt;= actualScale || scale[1] &lt;= actualScale) { return true; } return false; } const LINE_CAP_STYLES = [&quot;butt&quot;, &quot;round&quot;, &quot;square&quot;]; const LINE_JOIN_STYLES = [&quot;miter&quot;, &quot;round&quot;, &quot;bevel&quot;]; const NORMAL_CLIP = {}; const EO_CLIP = {}; class CanvasGraphics { constructor(canvasCtx, commonObjs, objs, canvasFactory, optionalContentConfig, annotationCanvasMap, pageColors) { this.ctx = canvasCtx; this.current = new CanvasExtraState(this.ctx.canvas.width, this.ctx.canvas.height); this.stateStack = []; this.pendingClip = null; this.pendingEOFill = false; this.res = null; this.xobjs = null; this.commonObjs = commonObjs; this.objs = objs; this.canvasFactory = canvasFactory; this.groupStack = []; this.processingType3 = null; this.baseTransform = null; this.baseTransformStack = []; this.groupLevel = 0; this.smaskStack = []; this.smaskCounter = 0; this.tempSMask = null; this.suspendedCtx = null; this.contentVisible = true; this.markedContentStack = []; this.optionalContentConfig = optionalContentConfig; this.cachedCanvases = new CachedCanvases(this.canvasFactory); this.cachedPatterns = new Map(); this.annotationCanvasMap = annotationCanvasMap; this.viewportScale = 1; this.outputScaleX = 1; this.outputScaleY = 1; this.backgroundColor = pageColors?.background || null; this.foregroundColor = pageColors?.foreground || null; this._cachedScaleForStroking = null; this._cachedGetSinglePixelWidth = null; this._cachedBitmapsMap = new Map(); } getObject(data, fallback = null) { if (typeof data === &quot;string&quot;) { return data.startsWith(&quot;g_&quot;) ? this.commonObjs.get(data) : this.objs.get(data); } return fallback; } beginDrawing({ transform, viewport, transparency = false, background = null }) { const width = this.ctx.canvas.width; const height = this.ctx.canvas.height; const defaultBackgroundColor = background || &quot;#ffffff&quot;; this.ctx.save(); if (this.foregroundColor &amp;&amp; this.backgroundColor) { this.ctx.fillStyle = this.foregroundColor; const fg = this.foregroundColor = this.ctx.fillStyle; this.ctx.fillStyle = this.backgroundColor; const bg = this.backgroundColor = this.ctx.fillStyle; let isValidDefaultBg = true; let defaultBg = defaultBackgroundColor; this.ctx.fillStyle = defaultBackgroundColor; defaultBg = this.ctx.fillStyle; isValidDefaultBg = typeof defaultBg === &quot;string&quot; &amp;&amp; /^#[0-9A-Fa-f]{6}$/.test(defaultBg); if (fg === &quot;#000000&quot; &amp;&amp; bg === &quot;#ffffff&quot; || fg === bg || !isValidDefaultBg) { this.foregroundColor = this.backgroundColor = null; } else { const [rB, gB, bB] = (0, _display_utils.getRGB)(defaultBg); const newComp = x =&gt; { x /= 255; return x &lt;= 0.03928 ? x / 12.92 : ((x + 0.055) / 1.055) ** 2.4; }; const lumB = Math.round(0.2126 * newComp(rB) + 0.7152 * newComp(gB) + 0.0722 * newComp(bB)); this.selectColor = (r, g, b) =&gt; { const lumC = 0.2126 * newComp(r) + 0.7152 * newComp(g) + 0.0722 * newComp(b); return Math.round(lumC) === lumB ? bg : fg; }; } } this.ctx.fillStyle = this.backgroundColor || defaultBackgroundColor; this.ctx.fillRect(0, 0, width, height); this.ctx.restore(); if (transparency) { const transparentCanvas = this.cachedCanvases.getCanvas(&quot;transparent&quot;, width, height); this.compositeCtx = this.ctx; this.transparentCanvas = transparentCanvas.canvas; this.ctx = transparentCanvas.context; this.ctx.save(); this.ctx.transform(...(0, _display_utils.getCurrentTransform)(this.compositeCtx)); } this.ctx.save(); resetCtxToDefault(this.ctx, this.foregroundColor); if (transform) { this.ctx.transform(...transform); this.outputScaleX = transform[0]; this.outputScaleY = transform[0]; } this.ctx.transform(...viewport.transform); this.viewportScale = viewport.scale; this.baseTransform = (0, _display_utils.getCurrentTransform)(this.ctx); } executeOperatorList(operatorList, executionStartIdx, continueCallback, stepper) { const argsArray = operatorList.argsArray; const fnArray = operatorList.fnArray; let i = executionStartIdx || 0; const argsArrayLen = argsArray.length; if (argsArrayLen === i) { return i; } const chunkOperations = argsArrayLen - i &gt; EXECUTION_STEPS &amp;&amp; typeof continueCallback === &quot;function&quot;; const endTime = chunkOperations ? Date.now() + EXECUTION_TIME : 0; let steps = 0; const commonObjs = this.commonObjs; const objs = this.objs; let fnId; while (true) { if (stepper !== undefined &amp;&amp; i === stepper.nextBreakPoint) { stepper.breakIt(i, continueCallback); return i; } fnId = fnArray[i]; if (fnId !== _util.OPS.dependency) { this[fnId].apply(this, argsArray[i]); } else { for (const depObjId of argsArray[i]) { const objsPool = depObjId.startsWith(&quot;g_&quot;) ? commonObjs : objs; if (!objsPool.has(depObjId)) { objsPool.get(depObjId, continueCallback); return i; } } } i++; if (i === argsArrayLen) { return i; } if (chunkOperations &amp;&amp; ++steps &gt; EXECUTION_STEPS) { if (Date.now() &gt; endTime) { continueCallback(); return i; } steps = 0; } } } #restoreInitialState() { while (this.stateStack.length || this.inSMaskMode) { this.restore(); } this.ctx.restore(); if (this.transparentCanvas) { this.ctx = this.compositeCtx; this.ctx.save(); this.ctx.setTransform(1, 0, 0, 1, 0, 0); this.ctx.drawImage(this.transparentCanvas, 0, 0); this.ctx.restore(); this.transparentCanvas = null; } } endDrawing() { this.#restoreInitialState(); this.cachedCanvases.clear(); this.cachedPatterns.clear(); for (const cache of this._cachedBitmapsMap.values()) { for (const canvas of cache.values()) { if (typeof HTMLCanvasElement !== &quot;undefined&quot; &amp;&amp; canvas instanceof HTMLCanvasElement) { canvas.width = canvas.height = 0; } } cache.clear(); } this._cachedBitmapsMap.clear(); } _scaleImage(img, inverseTransform) { const width = img.width; const height = img.height; let widthScale = Math.max(Math.hypot(inverseTransform[0], inverseTransform[1]), 1); let heightScale = Math.max(Math.hypot(inverseTransform[2], inverseTransform[3]), 1); let paintWidth = width, paintHeight = height; let tmpCanvasId = &quot;prescale1&quot;; let tmpCanvas, tmpCtx; while (widthScale &gt; 2 &amp;&amp; paintWidth &gt; 1 || heightScale &gt; 2 &amp;&amp; paintHeight &gt; 1) { let newWidth = paintWidth, newHeight = paintHeight; if (widthScale &gt; 2 &amp;&amp; paintWidth &gt; 1) { newWidth = Math.ceil(paintWidth / 2); widthScale /= paintWidth / newWidth; } if (heightScale &gt; 2 &amp;&amp; paintHeight &gt; 1) { newHeight = Math.ceil(paintHeight / 2); heightScale /= paintHeight / newHeight; } tmpCanvas = this.cachedCanvases.getCanvas(tmpCanvasId, newWidth, newHeight); tmpCtx = tmpCanvas.context; tmpCtx.clearRect(0, 0, newWidth, newHeight); tmpCtx.drawImage(img, 0, 0, paintWidth, paintHeight, 0, 0, newWidth, newHeight); img = tmpCanvas.canvas; paintWidth = newWidth; paintHeight = newHeight; tmpCanvasId = tmpCanvasId === &quot;prescale1&quot; ? &quot;prescale2&quot; : &quot;prescale1&quot;; } return { img, paintWidth, paintHeight }; } _createMaskCanvas(img) { const ctx = this.ctx; const { width, height } = img; const fillColor = this.current.fillColor; const isPatternFill = this.current.patternFill; const currentTransform = (0, _display_utils.getCurrentTransform)(ctx); let cache, cacheKey, scaled, maskCanvas; if ((img.bitmap || img.data) &amp;&amp; img.count &gt; 1) { const mainKey = img.bitmap || img.data.buffer; cacheKey = JSON.stringify(isPatternFill ? currentTransform : [currentTransform.slice(0, 4), fillColor]); cache = this._cachedBitmapsMap.get(mainKey); if (!cache) { cache = new Map(); this._cachedBitmapsMap.set(mainKey, cache); } const cachedImage = cache.get(cacheKey); if (cachedImage &amp;&amp; !isPatternFill) { const offsetX = Math.round(Math.min(currentTransform[0], currentTransform[2]) + currentTransform[4]); const offsetY = Math.round(Math.min(currentTransform[1], currentTransform[3]) + currentTransform[5]); return { canvas: cachedImage, offsetX, offsetY }; } scaled = cachedImage; } if (!scaled) { maskCanvas = this.cachedCanvases.getCanvas(&quot;maskCanvas&quot;, width, height); putBinaryImageMask(maskCanvas.context, img); } let maskToCanvas = _util.Util.transform(currentTransform, [1 / width, 0, 0, -1 / height, 0, 0]); maskToCanvas = _util.Util.transform(maskToCanvas, [1, 0, 0, 1, 0, -height]); const cord1 = _util.Util.applyTransform([0, 0], maskToCanvas); const cord2 = _util.Util.applyTransform([width, height], maskToCanvas); const rect = _util.Util.normalizeRect([cord1[0], cord1[1], cord2[0], cord2[1]]); const drawnWidth = Math.round(rect[2] - rect[0]) || 1; const drawnHeight = Math.round(rect[3] - rect[1]) || 1; const fillCanvas = this.cachedCanvases.getCanvas(&quot;fillCanvas&quot;, drawnWidth, drawnHeight); const fillCtx = fillCanvas.context; const offsetX = Math.min(cord1[0], cord2[0]); const offsetY = Math.min(cord1[1], cord2[1]); fillCtx.translate(-offsetX, -offsetY); fillCtx.transform(...maskToCanvas); if (!scaled) { scaled = this._scaleImage(maskCanvas.canvas, (0, _display_utils.getCurrentTransformInverse)(fillCtx)); scaled = scaled.img; if (cache &amp;&amp; isPatternFill) { cache.set(cacheKey, scaled); } } fillCtx.imageSmoothingEnabled = getImageSmoothingEnabled((0, _display_utils.getCurrentTransform)(fillCtx), img.interpolate); drawImageAtIntegerCoords(fillCtx, scaled, 0, 0, scaled.width, scaled.height, 0, 0, width, height); fillCtx.globalCompositeOperation = &quot;source-in&quot;; const inverse = _util.Util.transform((0, _display_utils.getCurrentTransformInverse)(fillCtx), [1, 0, 0, 1, -offsetX, -offsetY]); fillCtx.fillStyle = isPatternFill ? fillColor.getPattern(ctx, this, inverse, _pattern_helper.PathType.FILL) : fillColor; fillCtx.fillRect(0, 0, width, height); if (cache &amp;&amp; !isPatternFill) { this.cachedCanvases.delete(&quot;fillCanvas&quot;); cache.set(cacheKey, fillCanvas.canvas); } return { canvas: fillCanvas.canvas, offsetX: Math.round(offsetX), offsetY: Math.round(offsetY) }; } setLineWidth(width) { if (width !== this.current.lineWidth) { this._cachedScaleForStroking = null; } this.current.lineWidth = width; this.ctx.lineWidth = width; } setLineCap(style) { this.ctx.lineCap = LINE_CAP_STYLES[style]; } setLineJoin(style) { this.ctx.lineJoin = LINE_JOIN_STYLES[style]; } setMiterLimit(limit) { this.ctx.miterLimit = limit; } setDash(dashArray, dashPhase) { const ctx = this.ctx; if (ctx.setLineDash !== undefined) { ctx.setLineDash(dashArray); ctx.lineDashOffset = dashPhase; } } setRenderingIntent(intent) {} setFlatness(flatness) {} setGState(states) { for (const [key, value] of states) { switch (key) { case &quot;LW&quot;: this.setLineWidth(value); break; case &quot;LC&quot;: this.setLineCap(value); break; case &quot;LJ&quot;: this.setLineJoin(value); break; case &quot;ML&quot;: this.setMiterLimit(value); break; case &quot;D&quot;: this.setDash(value[0], value[1]); break; case &quot;RI&quot;: this.setRenderingIntent(value); break; case &quot;FL&quot;: this.setFlatness(value); break; case &quot;Font&quot;: this.setFont(value[0], value[1]); break; case &quot;CA&quot;: this.current.strokeAlpha = value; break; case &quot;ca&quot;: this.current.fillAlpha = value; this.ctx.globalAlpha = value; break; case &quot;BM&quot;: this.ctx.globalCompositeOperation = value; break; case &quot;SMask&quot;: this.current.activeSMask = value ? this.tempSMask : null; this.tempSMask = null; this.checkSMaskState(); break; case &quot;TR&quot;: this.current.transferMaps = value; } } } get inSMaskMode() { return !!this.suspendedCtx; } checkSMaskState() { const inSMaskMode = this.inSMaskMode; if (this.current.activeSMask &amp;&amp; !inSMaskMode) { this.beginSMaskMode(); } else if (!this.current.activeSMask &amp;&amp; inSMaskMode) { this.endSMaskMode(); } } beginSMaskMode() { if (this.inSMaskMode) { throw new Error(&quot;beginSMaskMode called while already in smask mode&quot;); } const drawnWidth = this.ctx.canvas.width; const drawnHeight = this.ctx.canvas.height; const cacheId = &quot;smaskGroupAt&quot; + this.groupLevel; const scratchCanvas = this.cachedCanvases.getCanvas(cacheId, drawnWidth, drawnHeight); this.suspendedCtx = this.ctx; this.ctx = scratchCanvas.context; const ctx = this.ctx; ctx.setTransform(...(0, _display_utils.getCurrentTransform)(this.suspendedCtx)); copyCtxState(this.suspendedCtx, ctx); mirrorContextOperations(ctx, this.suspendedCtx); this.setGState([[&quot;BM&quot;, &quot;source-over&quot;], [&quot;ca&quot;, 1], [&quot;CA&quot;, 1]]); } endSMaskMode() { if (!this.inSMaskMode) { throw new Error(&quot;endSMaskMode called while not in smask mode&quot;); } this.ctx._removeMirroring(); copyCtxState(this.ctx, this.suspendedCtx); this.ctx = this.suspendedCtx; this.suspendedCtx = null; } compose(dirtyBox) { if (!this.current.activeSMask) { return; } if (!dirtyBox) { dirtyBox = [0, 0, this.ctx.canvas.width, this.ctx.canvas.height]; } else { dirtyBox[0] = Math.floor(dirtyBox[0]); dirtyBox[1] = Math.floor(dirtyBox[1]); dirtyBox[2] = Math.ceil(dirtyBox[2]); dirtyBox[3] = Math.ceil(dirtyBox[3]); } const smask = this.current.activeSMask; const suspendedCtx = this.suspendedCtx; composeSMask(suspendedCtx, smask, this.ctx, dirtyBox); this.ctx.save(); this.ctx.setTransform(1, 0, 0, 1, 0, 0); this.ctx.clearRect(0, 0, this.ctx.canvas.width, this.ctx.canvas.height); this.ctx.restore(); } save() { if (this.inSMaskMode) { copyCtxState(this.ctx, this.suspendedCtx); this.suspendedCtx.save(); } else { this.ctx.save(); } const old = this.current; this.stateStack.push(old); this.current = old.clone(); } restore() { if (this.stateStack.length === 0 &amp;&amp; this.inSMaskMode) { this.endSMaskMode(); } if (this.stateStack.length !== 0) { this.current = this.stateStack.pop(); if (this.inSMaskMode) { this.suspendedCtx.restore(); copyCtxState(this.suspendedCtx, this.ctx); } else { this.ctx.restore(); } this.checkSMaskState(); this.pendingClip = null; this._cachedScaleForStroking = null; this._cachedGetSinglePixelWidth = null; } } transform(a, b, c, d, e, f) { this.ctx.transform(a, b, c, d, e, f); this._cachedScaleForStroking = null; this._cachedGetSinglePixelWidth = null; } constructPath(ops, args, minMax) { const ctx = this.ctx; const current = this.current; let x = current.x, y = current.y; let startX, startY; const currentTransform = (0, _display_utils.getCurrentTransform)(ctx); const isScalingMatrix = currentTransform[0] === 0 &amp;&amp; currentTransform[3] === 0 || currentTransform[1] === 0 &amp;&amp; currentTransform[2] === 0; const minMaxForBezier = isScalingMatrix ? minMax.slice(0) : null; for (let i = 0, j = 0, ii = ops.length; i &lt; ii; i++) { switch (ops[i] | 0) { case _util.OPS.rectangle: x = args[j++]; y = args[j++]; const width = args[j++]; const height = args[j++]; const xw = x + width; const yh = y + height; ctx.moveTo(x, y); if (width === 0 || height === 0) { ctx.lineTo(xw, yh); } else { ctx.lineTo(xw, y); ctx.lineTo(xw, yh); ctx.lineTo(x, yh); } if (!isScalingMatrix) { current.updateRectMinMax(currentTransform, [x, y, xw, yh]); } ctx.closePath(); break; case _util.OPS.moveTo: x = args[j++]; y = args[j++]; ctx.moveTo(x, y); if (!isScalingMatrix) { current.updatePathMinMax(currentTransform, x, y); } break; case _util.OPS.lineTo: x = args[j++]; y = args[j++]; ctx.lineTo(x, y); if (!isScalingMatrix) { current.updatePathMinMax(currentTransform, x, y); } break; case _util.OPS.curveTo: startX = x; startY = y; x = args[j + 4]; y = args[j + 5]; ctx.bezierCurveTo(args[j], args[j + 1], args[j + 2], args[j + 3], x, y); current.updateCurvePathMinMax(currentTransform, startX, startY, args[j], args[j + 1], args[j + 2], args[j + 3], x, y, minMaxForBezier); j += 6; break; case _util.OPS.curveTo2: startX = x; startY = y; ctx.bezierCurveTo(x, y, args[j], args[j + 1], args[j + 2], args[j + 3]); current.updateCurvePathMinMax(currentTransform, startX, startY, x, y, args[j], args[j + 1], args[j + 2], args[j + 3], minMaxForBezier); x = args[j + 2]; y = args[j + 3]; j += 4; break; case _util.OPS.curveTo3: startX = x; startY = y; x = args[j + 2]; y = args[j + 3]; ctx.bezierCurveTo(args[j], args[j + 1], x, y, x, y); current.updateCurvePathMinMax(currentTransform, startX, startY, args[j], args[j + 1], x, y, x, y, minMaxForBezier); j += 4; break; case _util.OPS.closePath: ctx.closePath(); break; } } if (isScalingMatrix) { current.updateScalingPathMinMax(currentTransform, minMaxForBezier); } current.setCurrentPoint(x, y); } closePath() { this.ctx.closePath(); } stroke(consumePath) { consumePath = typeof consumePath !== &quot;undefined&quot; ? consumePath : true; const ctx = this.ctx; const strokeColor = this.current.strokeColor; ctx.globalAlpha = this.current.strokeAlpha; if (this.contentVisible) { if (typeof strokeColor === &quot;object&quot; &amp;&amp; strokeColor?.getPattern) { ctx.save(); ctx.strokeStyle = strokeColor.getPattern(ctx, this, (0, _display_utils.getCurrentTransformInverse)(ctx), _pattern_helper.PathType.STROKE); this.rescaleAndStroke(false); ctx.restore(); } else { this.rescaleAndStroke(true); } } if (consumePath) { this.consumePath(this.current.getClippedPathBoundingBox()); } ctx.globalAlpha = this.current.fillAlpha; } closeStroke() { this.closePath(); this.stroke(); } fill(consumePath) { consumePath = typeof consumePath !== &quot;undefined&quot; ? consumePath : true; const ctx = this.ctx; const fillColor = this.current.fillColor; const isPatternFill = this.current.patternFill; let needRestore = false; if (isPatternFill) { ctx.save(); ctx.fillStyle = fillColor.getPattern(ctx, this, (0, _display_utils.getCurrentTransformInverse)(ctx), _pattern_helper.PathType.FILL); needRestore = true; } const intersect = this.current.getClippedPathBoundingBox(); if (this.contentVisible &amp;&amp; intersect !== null) { if (this.pendingEOFill) { ctx.fill(&quot;evenodd&quot;); this.pendingEOFill = false; } else { ctx.fill(); } } if (needRestore) { ctx.restore(); } if (consumePath) { this.consumePath(intersect); } } eoFill() { this.pendingEOFill = true; this.fill(); } fillStroke() { this.fill(false); this.stroke(false); this.consumePath(); } eoFillStroke() { this.pendingEOFill = true; this.fillStroke(); } closeFillStroke() { this.closePath(); this.fillStroke(); } closeEOFillStroke() { this.pendingEOFill = true; this.closePath(); this.fillStroke(); } endPath() { this.consumePath(); } clip() { this.pendingClip = NORMAL_CLIP; } eoClip() { this.pendingClip = EO_CLIP; } beginText() { this.current.textMatrix = _util.IDENTITY_MATRIX; this.current.textMatrixScale = 1; this.current.x = this.current.lineX = 0; this.current.y = this.current.lineY = 0; } endText() { const paths = this.pendingTextPaths; const ctx = this.ctx; if (paths === undefined) { ctx.beginPath(); return; } ctx.save(); ctx.beginPath(); for (const path of paths) { ctx.setTransform(...path.transform); ctx.translate(path.x, path.y); path.addToPath(ctx, path.fontSize); } ctx.restore(); ctx.clip(); ctx.beginPath(); delete this.pendingTextPaths; } setCharSpacing(spacing) { this.current.charSpacing = spacing; } setWordSpacing(spacing) { this.current.wordSpacing = spacing; } setHScale(scale) { this.current.textHScale = scale / 100; } setLeading(leading) { this.current.leading = -leading; } setFont(fontRefName, size) { const fontObj = this.commonObjs.get(fontRefName); const current = this.current; if (!fontObj) { throw new Error(`Can&apos;t find font for ${fontRefName}`); } current.fontMatrix = fontObj.fontMatrix || _util.FONT_IDENTITY_MATRIX; if (current.fontMatrix[0] === 0 || current.fontMatrix[3] === 0) { (0, _util.warn)(&quot;Invalid font matrix for font &quot; + fontRefName); } if (size &lt; 0) { size = -size; current.fontDirection = -1; } else { current.fontDirection = 1; } this.current.font = fontObj; this.current.fontSize = size; if (fontObj.isType3Font) { return; } const name = fontObj.loadedName || &quot;sans-serif&quot;; let bold = &quot;normal&quot;; if (fontObj.black) { bold = &quot;900&quot;; } else if (fontObj.bold) { bold = &quot;bold&quot;; } const italic = fontObj.italic ? &quot;italic&quot; : &quot;normal&quot;; const typeface = `&quot;${name}&quot;, ${fontObj.fallbackName}`; let browserFontSize = size; if (size &lt; MIN_FONT_SIZE) { browserFontSize = MIN_FONT_SIZE; } else if (size &gt; MAX_FONT_SIZE) { browserFontSize = MAX_FONT_SIZE; } this.current.fontSizeScale = size / browserFontSize; this.ctx.font = `${italic} ${bold} ${browserFontSize}px ${typeface}`; } setTextRenderingMode(mode) { this.current.textRenderingMode = mode; } setTextRise(rise) { this.current.textRise = rise; } moveText(x, y) { this.current.x = this.current.lineX += x; this.current.y = this.current.lineY += y; } setLeadingMoveText(x, y) { this.setLeading(-y); this.moveText(x, y); } setTextMatrix(a, b, c, d, e, f) { this.current.textMatrix = [a, b, c, d, e, f]; this.current.textMatrixScale = Math.hypot(a, b); this.current.x = this.current.lineX = 0; this.current.y = this.current.lineY = 0; } nextLine() { this.moveText(0, this.current.leading); } paintChar(character, x, y, patternTransform) { const ctx = this.ctx; const current = this.current; const font = current.font; const textRenderingMode = current.textRenderingMode; const fontSize = current.fontSize / current.fontSizeScale; const fillStrokeMode = textRenderingMode &amp; _util.TextRenderingMode.FILL_STROKE_MASK; const isAddToPathSet = !!(textRenderingMode &amp; _util.TextRenderingMode.ADD_TO_PATH_FLAG); const patternFill = current.patternFill &amp;&amp; !font.missingFile; let addToPath; if (font.disableFontFace || isAddToPathSet || patternFill) { addToPath = font.getPathGenerator(this.commonObjs, character); } if (font.disableFontFace || patternFill) { ctx.save(); ctx.translate(x, y); ctx.beginPath(); addToPath(ctx, fontSize); if (patternTransform) { ctx.setTransform(...patternTransform); } if (fillStrokeMode === _util.TextRenderingMode.FILL || fillStrokeMode === _util.TextRenderingMode.FILL_STROKE) { ctx.fill(); } if (fillStrokeMode === _util.TextRenderingMode.STROKE || fillStrokeMode === _util.TextRenderingMode.FILL_STROKE) { ctx.stroke(); } ctx.restore(); } else { if (fillStrokeMode === _util.TextRenderingMode.FILL || fillStrokeMode === _util.TextRenderingMode.FILL_STROKE) { ctx.fillText(character, x, y); } if (fillStrokeMode === _util.TextRenderingMode.STROKE || fillStrokeMode === _util.TextRenderingMode.FILL_STROKE) { ctx.strokeText(character, x, y); } } if (isAddToPathSet) { const paths = this.pendingTextPaths || (this.pendingTextPaths = []); paths.push({ transform: (0, _display_utils.getCurrentTransform)(ctx), x, y, fontSize, addToPath }); } } get isFontSubpixelAAEnabled() { const { context: ctx } = this.cachedCanvases.getCanvas(&quot;isFontSubpixelAAEnabled&quot;, 10, 10); ctx.scale(1.5, 1); ctx.fillText(&quot;I&quot;, 0, 10); const data = ctx.getImageData(0, 0, 10, 10).data; let enabled = false; for (let i = 3; i &lt; data.length; i += 4) { if (data[i] &gt; 0 &amp;&amp; data[i] &lt; 255) { enabled = true; break; } } return (0, _util.shadow)(this, &quot;isFontSubpixelAAEnabled&quot;, enabled); } showText(glyphs) { const current = this.current; const font = current.font; if (font.isType3Font) { return this.showType3Text(glyphs); } const fontSize = current.fontSize; if (fontSize === 0) { return undefined; } const ctx = this.ctx; const fontSizeScale = current.fontSizeScale; const charSpacing = current.charSpacing; const wordSpacing = current.wordSpacing; const fontDirection = current.fontDirection; const textHScale = current.textHScale * fontDirection; const glyphsLength = glyphs.length; const vertical = font.vertical; const spacingDir = vertical ? 1 : -1; const defaultVMetrics = font.defaultVMetrics; const widthAdvanceScale = fontSize * current.fontMatrix[0]; const simpleFillText = current.textRenderingMode === _util.TextRenderingMode.FILL &amp;&amp; !font.disableFontFace &amp;&amp; !current.patternFill; ctx.save(); ctx.transform(...current.textMatrix); ctx.translate(current.x, current.y + current.textRise); if (fontDirection &gt; 0) { ctx.scale(textHScale, -1); } else { ctx.scale(textHScale, 1); } let patternTransform; if (current.patternFill) { ctx.save(); const pattern = current.fillColor.getPattern(ctx, this, (0, _display_utils.getCurrentTransformInverse)(ctx), _pattern_helper.PathType.FILL); patternTransform = (0, _display_utils.getCurrentTransform)(ctx); ctx.restore(); ctx.fillStyle = pattern; } let lineWidth = current.lineWidth; const scale = current.textMatrixScale; if (scale === 0 || lineWidth === 0) { const fillStrokeMode = current.textRenderingMode &amp; _util.TextRenderingMode.FILL_STROKE_MASK; if (fillStrokeMode === _util.TextRenderingMode.STROKE || fillStrokeMode === _util.TextRenderingMode.FILL_STROKE) { lineWidth = this.getSinglePixelWidth(); } } else { lineWidth /= scale; } if (fontSizeScale !== 1.0) { ctx.scale(fontSizeScale, fontSizeScale); lineWidth /= fontSizeScale; } ctx.lineWidth = lineWidth; let x = 0, i; for (i = 0; i &lt; glyphsLength; ++i) { const glyph = glyphs[i]; if (typeof glyph === &quot;number&quot;) { x += spacingDir * glyph * fontSize / 1000; continue; } let restoreNeeded = false; const spacing = (glyph.isSpace ? wordSpacing : 0) + charSpacing; const character = glyph.fontChar; const accent = glyph.accent; let scaledX, scaledY; let width = glyph.width; if (vertical) { const vmetric = glyph.vmetric || defaultVMetrics; const vx = -(glyph.vmetric ? vmetric[1] : width * 0.5) * widthAdvanceScale; const vy = vmetric[2] * widthAdvanceScale; width = vmetric ? -vmetric[0] : width; scaledX = vx / fontSizeScale; scaledY = (x + vy) / fontSizeScale; } else { scaledX = x / fontSizeScale; scaledY = 0; } if (font.remeasure &amp;&amp; width &gt; 0) { const measuredWidth = ctx.measureText(character).width * 1000 / fontSize * fontSizeScale; if (width &lt; measuredWidth &amp;&amp; this.isFontSubpixelAAEnabled) { const characterScaleX = width / measuredWidth; restoreNeeded = true; ctx.save(); ctx.scale(characterScaleX, 1); scaledX /= characterScaleX; } else if (width !== measuredWidth) { scaledX += (width - measuredWidth) / 2000 * fontSize / fontSizeScale; } } if (this.contentVisible &amp;&amp; (glyph.isInFont || font.missingFile)) { if (simpleFillText &amp;&amp; !accent) { ctx.fillText(character, scaledX, scaledY); } else { this.paintChar(character, scaledX, scaledY, patternTransform); if (accent) { const scaledAccentX = scaledX + fontSize * accent.offset.x / fontSizeScale; const scaledAccentY = scaledY - fontSize * accent.offset.y / fontSizeScale; this.paintChar(accent.fontChar, scaledAccentX, scaledAccentY, patternTransform); } } } let charWidth; if (vertical) { charWidth = width * widthAdvanceScale - spacing * fontDirection; } else { charWidth = width * widthAdvanceScale + spacing * fontDirection; } x += charWidth; if (restoreNeeded) { ctx.restore(); } } if (vertical) { current.y -= x; } else { current.x += x * textHScale; } ctx.restore(); this.compose(); return undefined; } showType3Text(glyphs) { const ctx = this.ctx; const current = this.current; const font = current.font; const fontSize = current.fontSize; const fontDirection = current.fontDirection; const spacingDir = font.vertical ? 1 : -1; const charSpacing = current.charSpacing; const wordSpacing = current.wordSpacing; const textHScale = current.textHScale * fontDirection; const fontMatrix = current.fontMatrix || _util.FONT_IDENTITY_MATRIX; const glyphsLength = glyphs.length; const isTextInvisible = current.textRenderingMode === _util.TextRenderingMode.INVISIBLE; let i, glyph, width, spacingLength; if (isTextInvisible || fontSize === 0) { return; } this._cachedScaleForStroking = null; this._cachedGetSinglePixelWidth = null; ctx.save(); ctx.transform(...current.textMatrix); ctx.translate(current.x, current.y); ctx.scale(textHScale, fontDirection); for (i = 0; i &lt; glyphsLength; ++i) { glyph = glyphs[i]; if (typeof glyph === &quot;number&quot;) { spacingLength = spacingDir * glyph * fontSize / 1000; this.ctx.translate(spacingLength, 0); current.x += spacingLength * textHScale; continue; } const spacing = (glyph.isSpace ? wordSpacing : 0) + charSpacing; const operatorList = font.charProcOperatorList[glyph.operatorListId]; if (!operatorList) { (0, _util.warn)(`Type3 character &quot;${glyph.operatorListId}&quot; is not available.`); continue; } if (this.contentVisible) { this.processingType3 = glyph; this.save(); ctx.scale(fontSize, fontSize); ctx.transform(...fontMatrix); this.executeOperatorList(operatorList); this.restore(); } const transformed = _util.Util.applyTransform([glyph.width, 0], fontMatrix); width = transformed[0] * fontSize + spacing; ctx.translate(width, 0); current.x += width * textHScale; } ctx.restore(); this.processingType3 = null; } setCharWidth(xWidth, yWidth) {} setCharWidthAndBounds(xWidth, yWidth, llx, lly, urx, ury) { this.ctx.rect(llx, lly, urx - llx, ury - lly); this.ctx.clip(); this.endPath(); } getColorN_Pattern(IR) { let pattern; if (IR[0] === &quot;TilingPattern&quot;) { const color = IR[1]; const baseTransform = this.baseTransform || (0, _display_utils.getCurrentTransform)(this.ctx); const canvasGraphicsFactory = { createCanvasGraphics: ctx =&gt; { return new CanvasGraphics(ctx, this.commonObjs, this.objs, this.canvasFactory); } }; pattern = new _pattern_helper.TilingPattern(IR, color, this.ctx, canvasGraphicsFactory, baseTransform); } else { pattern = this._getPattern(IR[1], IR[2]); } return pattern; } setStrokeColorN() { this.current.strokeColor = this.getColorN_Pattern(arguments); } setFillColorN() { this.current.fillColor = this.getColorN_Pattern(arguments); this.current.patternFill = true; } setStrokeRGBColor(r, g, b) { const color = this.selectColor?.(r, g, b) || _util.Util.makeHexColor(r, g, b); this.ctx.strokeStyle = color; this.current.strokeColor = color; } setFillRGBColor(r, g, b) { const color = this.selectColor?.(r, g, b) || _util.Util.makeHexColor(r, g, b); this.ctx.fillStyle = color; this.current.fillColor = color; this.current.patternFill = false; } _getPattern(objId, matrix = null) { let pattern; if (this.cachedPatterns.has(objId)) { pattern = this.cachedPatterns.get(objId); } else { pattern = (0, _pattern_helper.getShadingPattern)(this.objs.get(objId)); this.cachedPatterns.set(objId, pattern); } if (matrix) { pattern.matrix = matrix; } return pattern; } shadingFill(objId) { if (!this.contentVisible) { return; } const ctx = this.ctx; this.save(); const pattern = this._getPattern(objId); ctx.fillStyle = pattern.getPattern(ctx, this, (0, _display_utils.getCurrentTransformInverse)(ctx), _pattern_helper.PathType.SHADING); const inv = (0, _display_utils.getCurrentTransformInverse)(ctx); if (inv) { const canvas = ctx.canvas; const width = canvas.width; const height = canvas.height; const bl = _util.Util.applyTransform([0, 0], inv); const br = _util.Util.applyTransform([0, height], inv); const ul = _util.Util.applyTransform([width, 0], inv); const ur = _util.Util.applyTransform([width, height], inv); const x0 = Math.min(bl[0], br[0], ul[0], ur[0]); const y0 = Math.min(bl[1], br[1], ul[1], ur[1]); const x1 = Math.max(bl[0], br[0], ul[0], ur[0]); const y1 = Math.max(bl[1], br[1], ul[1], ur[1]); this.ctx.fillRect(x0, y0, x1 - x0, y1 - y0); } else { this.ctx.fillRect(-1e10, -1e10, 2e10, 2e10); } this.compose(this.current.getClippedPathBoundingBox()); this.restore(); } beginInlineImage() { (0, _util.unreachable)(&quot;Should not call beginInlineImage&quot;); } beginImageData() { (0, _util.unreachable)(&quot;Should not call beginImageData&quot;); } paintFormXObjectBegin(matrix, bbox) { if (!this.contentVisible) { return; } this.save(); this.baseTransformStack.push(this.baseTransform); if (Array.isArray(matrix) &amp;&amp; matrix.length === 6) { this.transform(...matrix); } this.baseTransform = (0, _display_utils.getCurrentTransform)(this.ctx); if (bbox) { const width = bbox[2] - bbox[0]; const height = bbox[3] - bbox[1]; this.ctx.rect(bbox[0], bbox[1], width, height); this.current.updateRectMinMax((0, _display_utils.getCurrentTransform)(this.ctx), bbox); this.clip(); this.endPath(); } } paintFormXObjectEnd() { if (!this.contentVisible) { return; } this.restore(); this.baseTransform = this.baseTransformStack.pop(); } beginGroup(group) { if (!this.contentVisible) { return; } this.save(); if (this.inSMaskMode) { this.endSMaskMode(); this.current.activeSMask = null; } const currentCtx = this.ctx; if (!group.isolated) { (0, _util.info)(&quot;TODO: Support non-isolated groups.&quot;); } if (group.knockout) { (0, _util.warn)(&quot;Knockout groups not supported.&quot;); } const currentTransform = (0, _display_utils.getCurrentTransform)(currentCtx); if (group.matrix) { currentCtx.transform(...group.matrix); } if (!group.bbox) { throw new Error(&quot;Bounding box is required.&quot;); } let bounds = _util.Util.getAxialAlignedBoundingBox(group.bbox, (0, _display_utils.getCurrentTransform)(currentCtx)); const canvasBounds = [0, 0, currentCtx.canvas.width, currentCtx.canvas.height]; bounds = _util.Util.intersect(bounds, canvasBounds) || [0, 0, 0, 0]; const offsetX = Math.floor(bounds[0]); const offsetY = Math.floor(bounds[1]); let drawnWidth = Math.max(Math.ceil(bounds[2]) - offsetX, 1); let drawnHeight = Math.max(Math.ceil(bounds[3]) - offsetY, 1); let scaleX = 1, scaleY = 1; if (drawnWidth &gt; MAX_GROUP_SIZE) { scaleX = drawnWidth / MAX_GROUP_SIZE; drawnWidth = MAX_GROUP_SIZE; } if (drawnHeight &gt; MAX_GROUP_SIZE) { scaleY = drawnHeight / MAX_GROUP_SIZE; drawnHeight = MAX_GROUP_SIZE; } this.current.startNewPathAndClipBox([0, 0, drawnWidth, drawnHeight]); let cacheId = &quot;groupAt&quot; + this.groupLevel; if (group.smask) { cacheId += &quot;_smask_&quot; + this.smaskCounter++ % 2; } const scratchCanvas = this.cachedCanvases.getCanvas(cacheId, drawnWidth, drawnHeight); const groupCtx = scratchCanvas.context; groupCtx.scale(1 / scaleX, 1 / scaleY); groupCtx.translate(-offsetX, -offsetY); groupCtx.transform(...currentTransform); if (group.smask) { this.smaskStack.push({ canvas: scratchCanvas.canvas, context: groupCtx, offsetX, offsetY, scaleX, scaleY, subtype: group.smask.subtype, backdrop: group.smask.backdrop, transferMap: group.smask.transferMap || null, startTransformInverse: null }); } else { currentCtx.setTransform(1, 0, 0, 1, 0, 0); currentCtx.translate(offsetX, offsetY); currentCtx.scale(scaleX, scaleY); currentCtx.save(); } copyCtxState(currentCtx, groupCtx); this.ctx = groupCtx; this.setGState([[&quot;BM&quot;, &quot;source-over&quot;], [&quot;ca&quot;, 1], [&quot;CA&quot;, 1]]); this.groupStack.push(currentCtx); this.groupLevel++; } endGroup(group) { if (!this.contentVisible) { return; } this.groupLevel--; const groupCtx = this.ctx; const ctx = this.groupStack.pop(); this.ctx = ctx; this.ctx.imageSmoothingEnabled = false; if (group.smask) { this.tempSMask = this.smaskStack.pop(); this.restore(); } else { this.ctx.restore(); const currentMtx = (0, _display_utils.getCurrentTransform)(this.ctx); this.restore(); this.ctx.save(); this.ctx.setTransform(...currentMtx); const dirtyBox = _util.Util.getAxialAlignedBoundingBox([0, 0, groupCtx.canvas.width, groupCtx.canvas.height], currentMtx); this.ctx.drawImage(groupCtx.canvas, 0, 0); this.ctx.restore(); this.compose(dirtyBox); } } beginAnnotation(id, rect, transform, matrix, hasOwnCanvas) { this.#restoreInitialState(); resetCtxToDefault(this.ctx, this.foregroundColor); this.ctx.save(); this.save(); if (this.baseTransform) { this.ctx.setTransform(...this.baseTransform); } if (Array.isArray(rect) &amp;&amp; rect.length === 4) { const width = rect[2] - rect[0]; const height = rect[3] - rect[1]; if (hasOwnCanvas &amp;&amp; this.annotationCanvasMap) { transform = transform.slice(); transform[4] -= rect[0]; transform[5] -= rect[1]; rect = rect.slice(); rect[0] = rect[1] = 0; rect[2] = width; rect[3] = height; const [scaleX, scaleY] = _util.Util.singularValueDecompose2dScale((0, _display_utils.getCurrentTransform)(this.ctx)); const { viewportScale } = this; const canvasWidth = Math.ceil(width * this.outputScaleX * viewportScale); const canvasHeight = Math.ceil(height * this.outputScaleY * viewportScale); this.annotationCanvas = this.canvasFactory.create(canvasWidth, canvasHeight); const { canvas, context } = this.annotationCanvas; this.annotationCanvasMap.set(id, canvas); this.annotationCanvas.savedCtx = this.ctx; this.ctx = context; this.ctx.setTransform(scaleX, 0, 0, -scaleY, 0, height * scaleY); resetCtxToDefault(this.ctx, this.foregroundColor); } else { resetCtxToDefault(this.ctx, this.foregroundColor); this.ctx.rect(rect[0], rect[1], width, height); this.ctx.clip(); this.endPath(); } } this.current = new CanvasExtraState(this.ctx.canvas.width, this.ctx.canvas.height); this.transform(...transform); this.transform(...matrix); } endAnnotation() { if (this.annotationCanvas) { this.ctx = this.annotationCanvas.savedCtx; delete this.annotationCanvas.savedCtx; delete this.annotationCanvas; } } paintImageMaskXObject(img) { if (!this.contentVisible) { return; } const count = img.count; img = this.getObject(img.data, img); img.count = count; const ctx = this.ctx; const glyph = this.processingType3; if (glyph) { if (glyph.compiled === undefined) { glyph.compiled = compileType3Glyph(img); } if (glyph.compiled) { glyph.compiled(ctx); return; } } const mask = this._createMaskCanvas(img); const maskCanvas = mask.canvas; ctx.save(); ctx.setTransform(1, 0, 0, 1, 0, 0); ctx.drawImage(maskCanvas, mask.offsetX, mask.offsetY); ctx.restore(); this.compose(); } paintImageMaskXObjectRepeat(img, scaleX, skewX = 0, skewY = 0, scaleY, positions) { if (!this.contentVisible) { return; } img = this.getObject(img.data, img); const ctx = this.ctx; ctx.save(); const currentTransform = (0, _display_utils.getCurrentTransform)(ctx); ctx.transform(scaleX, skewX, skewY, scaleY, 0, 0); const mask = this._createMaskCanvas(img); ctx.setTransform(1, 0, 0, 1, 0, 0); for (let i = 0, ii = positions.length; i &lt; ii; i += 2) { const trans = _util.Util.transform(currentTransform, [scaleX, skewX, skewY, scaleY, positions[i], positions[i + 1]]); const [x, y] = _util.Util.applyTransform([0, 0], trans); ctx.drawImage(mask.canvas, x, y); } ctx.restore(); this.compose(); } paintImageMaskXObjectGroup(images) { if (!this.contentVisible) { return; } const ctx = this.ctx; const fillColor = this.current.fillColor; const isPatternFill = this.current.patternFill; for (const image of images) { const { data, width, height, transform } = image; const maskCanvas = this.cachedCanvases.getCanvas(&quot;maskCanvas&quot;, width, height); const maskCtx = maskCanvas.context; maskCtx.save(); const img = this.getObject(data, image); putBinaryImageMask(maskCtx, img); maskCtx.globalCompositeOperation = &quot;source-in&quot;; maskCtx.fillStyle = isPatternFill ? fillColor.getPattern(maskCtx, this, (0, _display_utils.getCurrentTransformInverse)(ctx), _pattern_helper.PathType.FILL) : fillColor; maskCtx.fillRect(0, 0, width, height); maskCtx.restore(); ctx.save(); ctx.transform(...transform); ctx.scale(1, -1); drawImageAtIntegerCoords(ctx, maskCanvas.canvas, 0, 0, width, height, 0, -1, 1, 1); ctx.restore(); } this.compose(); } paintImageXObject(objId) { if (!this.contentVisible) { return; } const imgData = this.getObject(objId); if (!imgData) { (0, _util.warn)(&quot;Dependent image isn&apos;t ready yet&quot;); return; } this.paintInlineImageXObject(imgData); } paintImageXObjectRepeat(objId, scaleX, scaleY, positions) { if (!this.contentVisible) { return; } const imgData = this.getObject(objId); if (!imgData) { (0, _util.warn)(&quot;Dependent image isn&apos;t ready yet&quot;); return; } const width = imgData.width; const height = imgData.height; const map = []; for (let i = 0, ii = positions.length; i &lt; ii; i += 2) { map.push({ transform: [scaleX, 0, 0, scaleY, positions[i], positions[i + 1]], x: 0, y: 0, w: width, h: height }); } this.paintInlineImageXObjectGroup(imgData, map); } paintInlineImageXObject(imgData) { if (!this.contentVisible) { return; } const width = imgData.width; const height = imgData.height; const ctx = this.ctx; this.save(); ctx.scale(1 / width, -1 / height); let imgToPaint; if (typeof HTMLElement === &quot;function&quot; &amp;&amp; imgData instanceof HTMLElement || !imgData.data) { imgToPaint = imgData; } else { const tmpCanvas = this.cachedCanvases.getCanvas(&quot;inlineImage&quot;, width, height); const tmpCtx = tmpCanvas.context; putBinaryImageData(tmpCtx, imgData, this.current.transferMaps); imgToPaint = tmpCanvas.canvas; } const scaled = this._scaleImage(imgToPaint, (0, _display_utils.getCurrentTransformInverse)(ctx)); ctx.imageSmoothingEnabled = getImageSmoothingEnabled((0, _display_utils.getCurrentTransform)(ctx), imgData.interpolate); drawImageAtIntegerCoords(ctx, scaled.img, 0, 0, scaled.paintWidth, scaled.paintHeight, 0, -height, width, height); this.compose(); this.restore(); } paintInlineImageXObjectGroup(imgData, map) { if (!this.contentVisible) { return; } const ctx = this.ctx; const w = imgData.width; const h = imgData.height; const tmpCanvas = this.cachedCanvases.getCanvas(&quot;inlineImage&quot;, w, h); const tmpCtx = tmpCanvas.context; putBinaryImageData(tmpCtx, imgData, this.current.transferMaps); for (const entry of map) { ctx.save(); ctx.transform(...entry.transform); ctx.scale(1, -1); drawImageAtIntegerCoords(ctx, tmpCanvas.canvas, entry.x, entry.y, entry.w, entry.h, 0, -1, 1, 1); ctx.restore(); } this.compose(); } paintSolidColorImageMask() { if (!this.contentVisible) { return; } this.ctx.fillRect(0, 0, 1, 1); this.compose(); } markPoint(tag) {} markPointProps(tag, properties) {} beginMarkedContent(tag) { this.markedContentStack.push({ visible: true }); } beginMarkedContentProps(tag, properties) { if (tag === &quot;OC&quot;) { this.markedContentStack.push({ visible: this.optionalContentConfig.isVisible(properties) }); } else { this.markedContentStack.push({ visible: true }); } this.contentVisible = this.isContentVisible(); } endMarkedContent() { this.markedContentStack.pop(); this.contentVisible = this.isContentVisible(); } beginCompat() {} endCompat() {} consumePath(clipBox) { const isEmpty = this.current.isEmptyClip(); if (this.pendingClip) { this.current.updateClipFromPath(); } if (!this.pendingClip) { this.compose(clipBox); } const ctx = this.ctx; if (this.pendingClip) { if (!isEmpty) { if (this.pendingClip === EO_CLIP) { ctx.clip(&quot;evenodd&quot;); } else { ctx.clip(); } } this.pendingClip = null; } this.current.startNewPathAndClipBox(this.current.clipBox); ctx.beginPath(); } getSinglePixelWidth() { if (!this._cachedGetSinglePixelWidth) { const m = (0, _display_utils.getCurrentTransform)(this.ctx); if (m[1] === 0 &amp;&amp; m[2] === 0) { this._cachedGetSinglePixelWidth = 1 / Math.min(Math.abs(m[0]), Math.abs(m[3])); } else { const absDet = Math.abs(m[0] * m[3] - m[2] * m[1]); const normX = Math.hypot(m[0], m[2]); const normY = Math.hypot(m[1], m[3]); this._cachedGetSinglePixelWidth = Math.max(normX, normY) / absDet; } } return this._cachedGetSinglePixelWidth; } getScaleForStroking() { if (!this._cachedScaleForStroking) { const { lineWidth } = this.current; const m = (0, _display_utils.getCurrentTransform)(this.ctx); let scaleX, scaleY; if (m[1] === 0 &amp;&amp; m[2] === 0) { const normX = Math.abs(m[0]); const normY = Math.abs(m[3]); if (lineWidth === 0) { scaleX = 1 / normX; scaleY = 1 / normY; } else { const scaledXLineWidth = normX * lineWidth; const scaledYLineWidth = normY * lineWidth; scaleX = scaledXLineWidth &lt; 1 ? 1 / scaledXLineWidth : 1; scaleY = scaledYLineWidth &lt; 1 ? 1 / scaledYLineWidth : 1; } } else { const absDet = Math.abs(m[0] * m[3] - m[2] * m[1]); const normX = Math.hypot(m[0], m[1]); const normY = Math.hypot(m[2], m[3]); if (lineWidth === 0) { scaleX = normY / absDet; scaleY = normX / absDet; } else { const baseArea = lineWidth * absDet; scaleX = normY &gt; baseArea ? normY / baseArea : 1; scaleY = normX &gt; baseArea ? normX / baseArea : 1; } } this._cachedScaleForStroking = [scaleX, scaleY]; } return this._cachedScaleForStroking; } rescaleAndStroke(saveRestore) { const { ctx } = this; const { lineWidth } = this.current; const [scaleX, scaleY] = this.getScaleForStroking(); ctx.lineWidth = lineWidth || 1; if (scaleX === 1 &amp;&amp; scaleY === 1) { ctx.stroke(); return; } let savedMatrix, savedDashes, savedDashOffset; if (saveRestore) { savedMatrix = (0, _display_utils.getCurrentTransform)(ctx); savedDashes = ctx.getLineDash().slice(); savedDashOffset = ctx.lineDashOffset; } ctx.scale(scaleX, scaleY); const scale = Math.max(scaleX, scaleY); ctx.setLineDash(ctx.getLineDash().map(x =&gt; x / scale)); ctx.lineDashOffset /= scale; ctx.stroke(); if (saveRestore) { ctx.setTransform(...savedMatrix); ctx.setLineDash(savedDashes); ctx.lineDashOffset = savedDashOffset; } } isContentVisible() { for (let i = this.markedContentStack.length - 1; i &gt;= 0; i--) { if (!this.markedContentStack[i].visible) { return false; } } return true; } } exports.CanvasGraphics = CanvasGraphics; for (const op in _util.OPS) { if (CanvasGraphics.prototype[op] !== undefined) { CanvasGraphics.prototype[_util.OPS[op]] = CanvasGraphics.prototype[op]; } } /***/ }), /* 11 */ /***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) =&gt; { Object.defineProperty(exports, &quot;__esModule&quot;, ({ value: true })); exports.TilingPattern = exports.PathType = void 0; exports.getShadingPattern = getShadingPattern; var _util = __w_pdfjs_require__(1); var _display_utils = __w_pdfjs_require__(6); var _is_node = __w_pdfjs_require__(12); const PathType = { FILL: &quot;Fill&quot;, STROKE: &quot;Stroke&quot;, SHADING: &quot;Shading&quot; }; exports.PathType = PathType; function applyBoundingBox(ctx, bbox) { if (!bbox || _is_node.isNodeJS) { return; } const width = bbox[2] - bbox[0]; const height = bbox[3] - bbox[1]; const region = new Path2D(); region.rect(bbox[0], bbox[1], width, height); ctx.clip(region); } class BaseShadingPattern { constructor() { if (this.constructor === BaseShadingPattern) { (0, _util.unreachable)(&quot;Cannot initialize BaseShadingPattern.&quot;); } } getPattern() { (0, _util.unreachable)(&quot;Abstract method `getPattern` called.&quot;); } } class RadialAxialShadingPattern extends BaseShadingPattern { constructor(IR) { super(); this._type = IR[1]; this._bbox = IR[2]; this._colorStops = IR[3]; this._p0 = IR[4]; this._p1 = IR[5]; this._r0 = IR[6]; this._r1 = IR[7]; this.matrix = null; } _createGradient(ctx) { let grad; if (this._type === &quot;axial&quot;) { grad = ctx.createLinearGradient(this._p0[0], this._p0[1], this._p1[0], this._p1[1]); } else if (this._type === &quot;radial&quot;) { grad = ctx.createRadialGradient(this._p0[0], this._p0[1], this._r0, this._p1[0], this._p1[1], this._r1); } for (const colorStop of this._colorStops) { grad.addColorStop(colorStop[0], colorStop[1]); } return grad; } getPattern(ctx, owner, inverse, pathType) { let pattern; if (pathType === PathType.STROKE || pathType === PathType.FILL) { const ownerBBox = owner.current.getClippedPathBoundingBox(pathType, (0, _display_utils.getCurrentTransform)(ctx)) || [0, 0, 0, 0]; const width = Math.ceil(ownerBBox[2] - ownerBBox[0]) || 1; const height = Math.ceil(ownerBBox[3] - ownerBBox[1]) || 1; const tmpCanvas = owner.cachedCanvases.getCanvas(&quot;pattern&quot;, width, height, true); const tmpCtx = tmpCanvas.context; tmpCtx.clearRect(0, 0, tmpCtx.canvas.width, tmpCtx.canvas.height); tmpCtx.beginPath(); tmpCtx.rect(0, 0, tmpCtx.canvas.width, tmpCtx.canvas.height); tmpCtx.translate(-ownerBBox[0], -ownerBBox[1]); inverse = _util.Util.transform(inverse, [1, 0, 0, 1, ownerBBox[0], ownerBBox[1]]); tmpCtx.transform(...owner.baseTransform); if (this.matrix) { tmpCtx.transform(...this.matrix); } applyBoundingBox(tmpCtx, this._bbox); tmpCtx.fillStyle = this._createGradient(tmpCtx); tmpCtx.fill(); pattern = ctx.createPattern(tmpCanvas.canvas, &quot;no-repeat&quot;); const domMatrix = new DOMMatrix(inverse); pattern.setTransform(domMatrix); } else { applyBoundingBox(ctx, this._bbox); pattern = this._createGradient(ctx); } return pattern; } } function drawTriangle(data, context, p1, p2, p3, c1, c2, c3) { const coords = context.coords, colors = context.colors; const bytes = data.data, rowSize = data.width * 4; let tmp; if (coords[p1 + 1] &gt; coords[p2 + 1]) { tmp = p1; p1 = p2; p2 = tmp; tmp = c1; c1 = c2; c2 = tmp; } if (coords[p2 + 1] &gt; coords[p3 + 1]) { tmp = p2; p2 = p3; p3 = tmp; tmp = c2; c2 = c3; c3 = tmp; } if (coords[p1 + 1] &gt; coords[p2 + 1]) { tmp = p1; p1 = p2; p2 = tmp; tmp = c1; c1 = c2; c2 = tmp; } const x1 = (coords[p1] + context.offsetX) * context.scaleX; const y1 = (coords[p1 + 1] + context.offsetY) * context.scaleY; const x2 = (coords[p2] + context.offsetX) * context.scaleX; const y2 = (coords[p2 + 1] + context.offsetY) * context.scaleY; const x3 = (coords[p3] + context.offsetX) * context.scaleX; const y3 = (coords[p3 + 1] + context.offsetY) * context.scaleY; if (y1 &gt;= y3) { return; } const c1r = colors[c1], c1g = colors[c1 + 1], c1b = colors[c1 + 2]; const c2r = colors[c2], c2g = colors[c2 + 1], c2b = colors[c2 + 2]; const c3r = colors[c3], c3g = colors[c3 + 1], c3b = colors[c3 + 2]; const minY = Math.round(y1), maxY = Math.round(y3); let xa, car, cag, cab; let xb, cbr, cbg, cbb; for (let y = minY; y &lt;= maxY; y++) { if (y &lt; y2) { let k; if (y &lt; y1) { k = 0; } else { k = (y1 - y) / (y1 - y2); } xa = x1 - (x1 - x2) * k; car = c1r - (c1r - c2r) * k; cag = c1g - (c1g - c2g) * k; cab = c1b - (c1b - c2b) * k; } else { let k; if (y &gt; y3) { k = 1; } else if (y2 === y3) { k = 0; } else { k = (y2 - y) / (y2 - y3); } xa = x2 - (x2 - x3) * k; car = c2r - (c2r - c3r) * k; cag = c2g - (c2g - c3g) * k; cab = c2b - (c2b - c3b) * k; } let k; if (y &lt; y1) { k = 0; } else if (y &gt; y3) { k = 1; } else { k = (y1 - y) / (y1 - y3); } xb = x1 - (x1 - x3) * k; cbr = c1r - (c1r - c3r) * k; cbg = c1g - (c1g - c3g) * k; cbb = c1b - (c1b - c3b) * k; const x1_ = Math.round(Math.min(xa, xb)); const x2_ = Math.round(Math.max(xa, xb)); let j = rowSize * y + x1_ * 4; for (let x = x1_; x &lt;= x2_; x++) { k = (xa - x) / (xa - xb); if (k &lt; 0) { k = 0; } else if (k &gt; 1) { k = 1; } bytes[j++] = car - (car - cbr) * k | 0; bytes[j++] = cag - (cag - cbg) * k | 0; bytes[j++] = cab - (cab - cbb) * k | 0; bytes[j++] = 255; } } } function drawFigure(data, figure, context) { const ps = figure.coords; const cs = figure.colors; let i, ii; switch (figure.type) { case &quot;lattice&quot;: const verticesPerRow = figure.verticesPerRow; const rows = Math.floor(ps.length / verticesPerRow) - 1; const cols = verticesPerRow - 1; for (i = 0; i &lt; rows; i++) { let q = i * verticesPerRow; for (let j = 0; j &lt; cols; j++, q++) { drawTriangle(data, context, ps[q], ps[q + 1], ps[q + verticesPerRow], cs[q], cs[q + 1], cs[q + verticesPerRow]); drawTriangle(data, context, ps[q + verticesPerRow + 1], ps[q + 1], ps[q + verticesPerRow], cs[q + verticesPerRow + 1], cs[q + 1], cs[q + verticesPerRow]); } } break; case &quot;triangles&quot;: for (i = 0, ii = ps.length; i &lt; ii; i += 3) { drawTriangle(data, context, ps[i], ps[i + 1], ps[i + 2], cs[i], cs[i + 1], cs[i + 2]); } break; default: throw new Error(&quot;illegal figure&quot;); } } class MeshShadingPattern extends BaseShadingPattern { constructor(IR) { super(); this._coords = IR[2]; this._colors = IR[3]; this._figures = IR[4]; this._bounds = IR[5]; this._bbox = IR[7]; this._background = IR[8]; this.matrix = null; } _createMeshCanvas(combinedScale, backgroundColor, cachedCanvases) { const EXPECTED_SCALE = 1.1; const MAX_PATTERN_SIZE = 3000; const BORDER_SIZE = 2; const offsetX = Math.floor(this._bounds[0]); const offsetY = Math.floor(this._bounds[1]); const boundsWidth = Math.ceil(this._bounds[2]) - offsetX; const boundsHeight = Math.ceil(this._bounds[3]) - offsetY; const width = Math.min(Math.ceil(Math.abs(boundsWidth * combinedScale[0] * EXPECTED_SCALE)), MAX_PATTERN_SIZE); const height = Math.min(Math.ceil(Math.abs(boundsHeight * combinedScale[1] * EXPECTED_SCALE)), MAX_PATTERN_SIZE); const scaleX = boundsWidth / width; const scaleY = boundsHeight / height; const context = { coords: this._coords, colors: this._colors, offsetX: -offsetX, offsetY: -offsetY, scaleX: 1 / scaleX, scaleY: 1 / scaleY }; const paddedWidth = width + BORDER_SIZE * 2; const paddedHeight = height + BORDER_SIZE * 2; const tmpCanvas = cachedCanvases.getCanvas(&quot;mesh&quot;, paddedWidth, paddedHeight, false); const tmpCtx = tmpCanvas.context; const data = tmpCtx.createImageData(width, height); if (backgroundColor) { const bytes = data.data; for (let i = 0, ii = bytes.length; i &lt; ii; i += 4) { bytes[i] = backgroundColor[0]; bytes[i + 1] = backgroundColor[1]; bytes[i + 2] = backgroundColor[2]; bytes[i + 3] = 255; } } for (const figure of this._figures) { drawFigure(data, figure, context); } tmpCtx.putImageData(data, BORDER_SIZE, BORDER_SIZE); const canvas = tmpCanvas.canvas; return { canvas, offsetX: offsetX - BORDER_SIZE * scaleX, offsetY: offsetY - BORDER_SIZE * scaleY, scaleX, scaleY }; } getPattern(ctx, owner, inverse, pathType) { applyBoundingBox(ctx, this._bbox); let scale; if (pathType === PathType.SHADING) { scale = _util.Util.singularValueDecompose2dScale((0, _display_utils.getCurrentTransform)(ctx)); } else { scale = _util.Util.singularValueDecompose2dScale(owner.baseTransform); if (this.matrix) { const matrixScale = _util.Util.singularValueDecompose2dScale(this.matrix); scale = [scale[0] * matrixScale[0], scale[1] * matrixScale[1]]; } } const temporaryPatternCanvas = this._createMeshCanvas(scale, pathType === PathType.SHADING ? null : this._background, owner.cachedCanvases); if (pathType !== PathType.SHADING) { ctx.setTransform(...owner.baseTransform); if (this.matrix) { ctx.transform(...this.matrix); } } ctx.translate(temporaryPatternCanvas.offsetX, temporaryPatternCanvas.offsetY); ctx.scale(temporaryPatternCanvas.scaleX, temporaryPatternCanvas.scaleY); return ctx.createPattern(temporaryPatternCanvas.canvas, &quot;no-repeat&quot;); } } class DummyShadingPattern extends BaseShadingPattern { getPattern() { return &quot;hotpink&quot;; } } function getShadingPattern(IR) { switch (IR[0]) { case &quot;RadialAxial&quot;: return new RadialAxialShadingPattern(IR); case &quot;Mesh&quot;: return new MeshShadingPattern(IR); case &quot;Dummy&quot;: return new DummyShadingPattern(); } throw new Error(`Unknown IR type: ${IR[0]}`); } const PaintType = { COLORED: 1, UNCOLORED: 2 }; class TilingPattern { static get MAX_PATTERN_SIZE() { return (0, _util.shadow)(this, &quot;MAX_PATTERN_SIZE&quot;, 3000); } constructor(IR, color, ctx, canvasGraphicsFactory, baseTransform) { this.operatorList = IR[2]; this.matrix = IR[3] || [1, 0, 0, 1, 0, 0]; this.bbox = IR[4]; this.xstep = IR[5]; this.ystep = IR[6]; this.paintType = IR[7]; this.tilingType = IR[8]; this.color = color; this.ctx = ctx; this.canvasGraphicsFactory = canvasGraphicsFactory; this.baseTransform = baseTransform; } createPatternCanvas(owner) { const operatorList = this.operatorList; const bbox = this.bbox; const xstep = this.xstep; const ystep = this.ystep; const paintType = this.paintType; const tilingType = this.tilingType; const color = this.color; const canvasGraphicsFactory = this.canvasGraphicsFactory; (0, _util.info)(&quot;TilingType: &quot; + tilingType); const x0 = bbox[0], y0 = bbox[1], x1 = bbox[2], y1 = bbox[3]; const matrixScale = _util.Util.singularValueDecompose2dScale(this.matrix); const curMatrixScale = _util.Util.singularValueDecompose2dScale(this.baseTransform); const combinedScale = [matrixScale[0] * curMatrixScale[0], matrixScale[1] * curMatrixScale[1]]; const dimx = this.getSizeAndScale(xstep, this.ctx.canvas.width, combinedScale[0]); const dimy = this.getSizeAndScale(ystep, this.ctx.canvas.height, combinedScale[1]); const tmpCanvas = owner.cachedCanvases.getCanvas(&quot;pattern&quot;, dimx.size, dimy.size, true); const tmpCtx = tmpCanvas.context; const graphics = canvasGraphicsFactory.createCanvasGraphics(tmpCtx); graphics.groupLevel = owner.groupLevel; this.setFillAndStrokeStyleToContext(graphics, paintType, color); let adjustedX0 = x0; let adjustedY0 = y0; let adjustedX1 = x1; let adjustedY1 = y1; if (x0 &lt; 0) { adjustedX0 = 0; adjustedX1 += Math.abs(x0); } if (y0 &lt; 0) { adjustedY0 = 0; adjustedY1 += Math.abs(y0); } tmpCtx.translate(-(dimx.scale * adjustedX0), -(dimy.scale * adjustedY0)); graphics.transform(dimx.scale, 0, 0, dimy.scale, 0, 0); tmpCtx.save(); this.clipBbox(graphics, adjustedX0, adjustedY0, adjustedX1, adjustedY1); graphics.baseTransform = (0, _display_utils.getCurrentTransform)(graphics.ctx); graphics.executeOperatorList(operatorList); graphics.endDrawing(); return { canvas: tmpCanvas.canvas, scaleX: dimx.scale, scaleY: dimy.scale, offsetX: adjustedX0, offsetY: adjustedY0 }; } getSizeAndScale(step, realOutputSize, scale) { step = Math.abs(step); const maxSize = Math.max(TilingPattern.MAX_PATTERN_SIZE, realOutputSize); let size = Math.ceil(step * scale); if (size &gt;= maxSize) { size = maxSize; } else { scale = size / step; } return { scale, size }; } clipBbox(graphics, x0, y0, x1, y1) { const bboxWidth = x1 - x0; const bboxHeight = y1 - y0; graphics.ctx.rect(x0, y0, bboxWidth, bboxHeight); graphics.current.updateRectMinMax((0, _display_utils.getCurrentTransform)(graphics.ctx), [x0, y0, x1, y1]); graphics.clip(); graphics.endPath(); } setFillAndStrokeStyleToContext(graphics, paintType, color) { const context = graphics.ctx, current = graphics.current; switch (paintType) { case PaintType.COLORED: const ctx = this.ctx; context.fillStyle = ctx.fillStyle; context.strokeStyle = ctx.strokeStyle; current.fillColor = ctx.fillStyle; current.strokeColor = ctx.strokeStyle; break; case PaintType.UNCOLORED: const cssColor = _util.Util.makeHexColor(color[0], color[1], color[2]); context.fillStyle = cssColor; context.strokeStyle = cssColor; current.fillColor = cssColor; current.strokeColor = cssColor; break; default: throw new _util.FormatError(`Unsupported paint type: ${paintType}`); } } getPattern(ctx, owner, inverse, pathType) { let matrix = inverse; if (pathType !== PathType.SHADING) { matrix = _util.Util.transform(matrix, owner.baseTransform); if (this.matrix) { matrix = _util.Util.transform(matrix, this.matrix); } } const temporaryPatternCanvas = this.createPatternCanvas(owner); let domMatrix = new DOMMatrix(matrix); domMatrix = domMatrix.translate(temporaryPatternCanvas.offsetX, temporaryPatternCanvas.offsetY); domMatrix = domMatrix.scale(1 / temporaryPatternCanvas.scaleX, 1 / temporaryPatternCanvas.scaleY); const pattern = ctx.createPattern(temporaryPatternCanvas.canvas, &quot;repeat&quot;); pattern.setTransform(domMatrix); return pattern; } } exports.TilingPattern = TilingPattern; /***/ }), /* 12 */ /***/ ((__unused_webpack_module, exports) =&gt; { Object.defineProperty(exports, &quot;__esModule&quot;, ({ value: true })); exports.isNodeJS = void 0; const isNodeJS = typeof process === &quot;object&quot; &amp;&amp; process + &quot;&quot; === &quot;[object process]&quot; &amp;&amp; !process.versions.nw &amp;&amp; !(process.versions.electron &amp;&amp; process.type &amp;&amp; process.type !== &quot;browser&quot;); exports.isNodeJS = isNodeJS; /***/ }), /* 13 */ /***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) =&gt; { Object.defineProperty(exports, &quot;__esModule&quot;, ({ value: true })); exports.applyMaskImageData = applyMaskImageData; var _util = __w_pdfjs_require__(1); function applyMaskImageData({ src, srcPos = 0, dest, destPos = 0, width, height, inverseDecode = false }) { const opaque = _util.FeatureTest.isLittleEndian ? 0xff000000 : 0x000000ff; const [zeroMapping, oneMapping] = !inverseDecode ? [opaque, 0] : [0, opaque]; const widthInSource = width &gt;&gt; 3; const widthRemainder = width &amp; 7; const srcLength = src.length; dest = new Uint32Array(dest.buffer); for (let i = 0; i &lt; height; i++) { for (const max = srcPos + widthInSource; srcPos &lt; max; srcPos++) { const elem = srcPos &lt; srcLength ? src[srcPos] : 255; dest[destPos++] = elem &amp; 0b10000000 ? oneMapping : zeroMapping; dest[destPos++] = elem &amp; 0b1000000 ? oneMapping : zeroMapping; dest[destPos++] = elem &amp; 0b100000 ? oneMapping : zeroMapping; dest[destPos++] = elem &amp; 0b10000 ? oneMapping : zeroMapping; dest[destPos++] = elem &amp; 0b1000 ? oneMapping : zeroMapping; dest[destPos++] = elem &amp; 0b100 ? oneMapping : zeroMapping; dest[destPos++] = elem &amp; 0b10 ? oneMapping : zeroMapping; dest[destPos++] = elem &amp; 0b1 ? oneMapping : zeroMapping; } if (widthRemainder === 0) { continue; } const elem = srcPos &lt; srcLength ? src[srcPos++] : 255; for (let j = 0; j &lt; widthRemainder; j++) { dest[destPos++] = elem &amp; 1 &lt;&lt; 7 - j ? oneMapping : zeroMapping; } } return { srcPos, destPos }; } /***/ }), /* 14 */ /***/ ((__unused_webpack_module, exports) =&gt; { Object.defineProperty(exports, &quot;__esModule&quot;, ({ value: true })); exports.GlobalWorkerOptions = void 0; const GlobalWorkerOptions = Object.create(null); exports.GlobalWorkerOptions = GlobalWorkerOptions; GlobalWorkerOptions.workerPort = GlobalWorkerOptions.workerPort === undefined ? null : GlobalWorkerOptions.workerPort; GlobalWorkerOptions.workerSrc = GlobalWorkerOptions.workerSrc === undefined ? &quot;&quot; : GlobalWorkerOptions.workerSrc; /***/ }), /* 15 */ /***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) =&gt; { Object.defineProperty(exports, &quot;__esModule&quot;, ({ value: true })); exports.MessageHandler = void 0; var _util = __w_pdfjs_require__(1); const CallbackKind = { UNKNOWN: 0, DATA: 1, ERROR: 2 }; const StreamKind = { UNKNOWN: 0, CANCEL: 1, CANCEL_COMPLETE: 2, CLOSE: 3, ENQUEUE: 4, ERROR: 5, PULL: 6, PULL_COMPLETE: 7, START_COMPLETE: 8 }; function wrapReason(reason) { if (!(reason instanceof Error || typeof reason === &quot;object&quot; &amp;&amp; reason !== null)) { (0, _util.unreachable)(&apos;wrapReason: Expected &quot;reason&quot; to be a (possibly cloned) Error.&apos;); } switch (reason.name) { case &quot;AbortException&quot;: return new _util.AbortException(reason.message); case &quot;MissingPDFException&quot;: return new _util.MissingPDFException(reason.message); case &quot;PasswordException&quot;: return new _util.PasswordException(reason.message, reason.code); case &quot;UnexpectedResponseException&quot;: return new _util.UnexpectedResponseException(reason.message, reason.status); case &quot;UnknownErrorException&quot;: return new _util.UnknownErrorException(reason.message, reason.details); default: return new _util.UnknownErrorException(reason.message, reason.toString()); } } class MessageHandler { constructor(sourceName, targetName, comObj) { this.sourceName = sourceName; this.targetName = targetName; this.comObj = comObj; this.callbackId = 1; this.streamId = 1; this.streamSinks = Object.create(null); this.streamControllers = Object.create(null); this.callbackCapabilities = Object.create(null); this.actionHandler = Object.create(null); this._onComObjOnMessage = event =&gt; { const data = event.data; if (data.targetName !== this.sourceName) { return; } if (data.stream) { this._processStreamMessage(data); return; } if (data.callback) { const callbackId = data.callbackId; const capability = this.callbackCapabilities[callbackId]; if (!capability) { throw new Error(`Cannot resolve callback ${callbackId}`); } delete this.callbackCapabilities[callbackId]; if (data.callback === CallbackKind.DATA) { capability.resolve(data.data); } else if (data.callback === CallbackKind.ERROR) { capability.reject(wrapReason(data.reason)); } else { throw new Error(&quot;Unexpected callback case&quot;); } return; } const action = this.actionHandler[data.action]; if (!action) { throw new Error(`Unknown action from worker: ${data.action}`); } if (data.callbackId) { const cbSourceName = this.sourceName; const cbTargetName = data.sourceName; new Promise(function (resolve) { resolve(action(data.data)); }).then(function (result) { comObj.postMessage({ sourceName: cbSourceName, targetName: cbTargetName, callback: CallbackKind.DATA, callbackId: data.callbackId, data: result }); }, function (reason) { comObj.postMessage({ sourceName: cbSourceName, targetName: cbTargetName, callback: CallbackKind.ERROR, callbackId: data.callbackId, reason: wrapReason(reason) }); }); return; } if (data.streamId) { this._createStreamSink(data); return; } action(data.data); }; comObj.addEventListener(&quot;message&quot;, this._onComObjOnMessage); } on(actionName, handler) { const ah = this.actionHandler; if (ah[actionName]) { throw new Error(`There is already an actionName called &quot;${actionName}&quot;`); } ah[actionName] = handler; } send(actionName, data, transfers) { this.comObj.postMessage({ sourceName: this.sourceName, targetName: this.targetName, action: actionName, data }, transfers); } sendWithPromise(actionName, data, transfers) { const callbackId = this.callbackId++; const capability = (0, _util.createPromiseCapability)(); this.callbackCapabilities[callbackId] = capability; try { this.comObj.postMessage({ sourceName: this.sourceName, targetName: this.targetName, action: actionName, callbackId, data }, transfers); } catch (ex) { capability.reject(ex); } return capability.promise; } sendWithStream(actionName, data, queueingStrategy, transfers) { const streamId = this.streamId++, sourceName = this.sourceName, targetName = this.targetName, comObj = this.comObj; return new ReadableStream({ start: controller =&gt; { const startCapability = (0, _util.createPromiseCapability)(); this.streamControllers[streamId] = { controller, startCall: startCapability, pullCall: null, cancelCall: null, isClosed: false }; comObj.postMessage({ sourceName, targetName, action: actionName, streamId, data, desiredSize: controller.desiredSize }, transfers); return startCapability.promise; }, pull: controller =&gt; { const pullCapability = (0, _util.createPromiseCapability)(); this.streamControllers[streamId].pullCall = pullCapability; comObj.postMessage({ sourceName, targetName, stream: StreamKind.PULL, streamId, desiredSize: controller.desiredSize }); return pullCapability.promise; }, cancel: reason =&gt; { (0, _util.assert)(reason instanceof Error, &quot;cancel must have a valid reason&quot;); const cancelCapability = (0, _util.createPromiseCapability)(); this.streamControllers[streamId].cancelCall = cancelCapability; this.streamControllers[streamId].isClosed = true; comObj.postMessage({ sourceName, targetName, stream: StreamKind.CANCEL, streamId, reason: wrapReason(reason) }); return cancelCapability.promise; } }, queueingStrategy); } _createStreamSink(data) { const streamId = data.streamId, sourceName = this.sourceName, targetName = data.sourceName, comObj = this.comObj; const self = this, action = this.actionHandler[data.action]; const streamSink = { enqueue(chunk, size = 1, transfers) { if (this.isCancelled) { return; } const lastDesiredSize = this.desiredSize; this.desiredSize -= size; if (lastDesiredSize &gt; 0 &amp;&amp; this.desiredSize &lt;= 0) { this.sinkCapability = (0, _util.createPromiseCapability)(); this.ready = this.sinkCapability.promise; } comObj.postMessage({ sourceName, targetName, stream: StreamKind.ENQUEUE, streamId, chunk }, transfers); }, close() { if (this.isCancelled) { return; } this.isCancelled = true; comObj.postMessage({ sourceName, targetName, stream: StreamKind.CLOSE, streamId }); delete self.streamSinks[streamId]; }, error(reason) { (0, _util.assert)(reason instanceof Error, &quot;error must have a valid reason&quot;); if (this.isCancelled) { return; } this.isCancelled = true; comObj.postMessage({ sourceName, targetName, stream: StreamKind.ERROR, streamId, reason: wrapReason(reason) }); }, sinkCapability: (0, _util.createPromiseCapability)(), onPull: null, onCancel: null, isCancelled: false, desiredSize: data.desiredSize, ready: null }; streamSink.sinkCapability.resolve(); streamSink.ready = streamSink.sinkCapability.promise; this.streamSinks[streamId] = streamSink; new Promise(function (resolve) { resolve(action(data.data, streamSink)); }).then(function () { comObj.postMessage({ sourceName, targetName, stream: StreamKind.START_COMPLETE, streamId, success: true }); }, function (reason) { comObj.postMessage({ sourceName, targetName, stream: StreamKind.START_COMPLETE, streamId, reason: wrapReason(reason) }); }); } _processStreamMessage(data) { const streamId = data.streamId, sourceName = this.sourceName, targetName = data.sourceName, comObj = this.comObj; const streamController = this.streamControllers[streamId], streamSink = this.streamSinks[streamId]; switch (data.stream) { case StreamKind.START_COMPLETE: if (data.success) { streamController.startCall.resolve(); } else { streamController.startCall.reject(wrapReason(data.reason)); } break; case StreamKind.PULL_COMPLETE: if (data.success) { streamController.pullCall.resolve(); } else { streamController.pullCall.reject(wrapReason(data.reason)); } break; case StreamKind.PULL: if (!streamSink) { comObj.postMessage({ sourceName, targetName, stream: StreamKind.PULL_COMPLETE, streamId, success: true }); break; } if (streamSink.desiredSize &lt;= 0 &amp;&amp; data.desiredSize &gt; 0) { streamSink.sinkCapability.resolve(); } streamSink.desiredSize = data.desiredSize; new Promise(function (resolve) { resolve(streamSink.onPull &amp;&amp; streamSink.onPull()); }).then(function () { comObj.postMessage({ sourceName, targetName, stream: StreamKind.PULL_COMPLETE, streamId, success: true }); }, function (reason) { comObj.postMessage({ sourceName, targetName, stream: StreamKind.PULL_COMPLETE, streamId, reason: wrapReason(reason) }); }); break; case StreamKind.ENQUEUE: (0, _util.assert)(streamController, &quot;enqueue should have stream controller&quot;); if (streamController.isClosed) { break; } streamController.controller.enqueue(data.chunk); break; case StreamKind.CLOSE: (0, _util.assert)(streamController, &quot;close should have stream controller&quot;); if (streamController.isClosed) { break; } streamController.isClosed = true; streamController.controller.close(); this._deleteStreamController(streamController, streamId); break; case StreamKind.ERROR: (0, _util.assert)(streamController, &quot;error should have stream controller&quot;); streamController.controller.error(wrapReason(data.reason)); this._deleteStreamController(streamController, streamId); break; case StreamKind.CANCEL_COMPLETE: if (data.success) { streamController.cancelCall.resolve(); } else { streamController.cancelCall.reject(wrapReason(data.reason)); } this._deleteStreamController(streamController, streamId); break; case StreamKind.CANCEL: if (!streamSink) { break; } new Promise(function (resolve) { resolve(streamSink.onCancel &amp;&amp; streamSink.onCancel(wrapReason(data.reason))); }).then(function () { comObj.postMessage({ sourceName, targetName, stream: StreamKind.CANCEL_COMPLETE, streamId, success: true }); }, function (reason) { comObj.postMessage({ sourceName, targetName, stream: StreamKind.CANCEL_COMPLETE, streamId, reason: wrapReason(reason) }); }); streamSink.sinkCapability.reject(wrapReason(data.reason)); streamSink.isCancelled = true; delete this.streamSinks[streamId]; break; default: throw new Error(&quot;Unexpected stream case&quot;); } } async _deleteStreamController(streamController, streamId) { await Promise.allSettled([streamController.startCall &amp;&amp; streamController.startCall.promise, streamController.pullCall &amp;&amp; streamController.pullCall.promise, streamController.cancelCall &amp;&amp; streamController.cancelCall.promise]); delete this.streamControllers[streamId]; } destroy() { this.comObj.removeEventListener(&quot;message&quot;, this._onComObjOnMessage); } } exports.MessageHandler = MessageHandler; /***/ }), /* 16 */ /***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) =&gt; { Object.defineProperty(exports, &quot;__esModule&quot;, ({ value: true })); exports.Metadata = void 0; var _util = __w_pdfjs_require__(1); class Metadata { #metadataMap; #data; constructor({ parsedData, rawData }) { this.#metadataMap = parsedData; this.#data = rawData; } getRaw() { return this.#data; } get(name) { return this.#metadataMap.get(name) ?? null; } getAll() { return (0, _util.objectFromMap)(this.#metadataMap); } has(name) { return this.#metadataMap.has(name); } } exports.Metadata = Metadata; /***/ }), /* 17 */ /***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) =&gt; { Object.defineProperty(exports, &quot;__esModule&quot;, ({ value: true })); exports.OptionalContentConfig = void 0; var _util = __w_pdfjs_require__(1); var _murmurhash = __w_pdfjs_require__(8); const INTERNAL = Symbol(&quot;INTERNAL&quot;); class OptionalContentGroup { #visible = true; constructor(name, intent) { this.name = name; this.intent = intent; } get visible() { return this.#visible; } _setVisible(internal, visible) { if (internal !== INTERNAL) { (0, _util.unreachable)(&quot;Internal method `_setVisible` called.&quot;); } this.#visible = visible; } } class OptionalContentConfig { #cachedGetHash = null; #groups = new Map(); #initialHash = null; #order = null; constructor(data) { this.name = null; this.creator = null; if (data === null) { return; } this.name = data.name; this.creator = data.creator; this.#order = data.order; for (const group of data.groups) { this.#groups.set(group.id, new OptionalContentGroup(group.name, group.intent)); } if (data.baseState === &quot;OFF&quot;) { for (const group of this.#groups.values()) { group._setVisible(INTERNAL, false); } } for (const on of data.on) { this.#groups.get(on)._setVisible(INTERNAL, true); } for (const off of data.off) { this.#groups.get(off)._setVisible(INTERNAL, false); } this.#initialHash = this.getHash(); } #evaluateVisibilityExpression(array) { const length = array.length; if (length &lt; 2) { return true; } const operator = array[0]; for (let i = 1; i &lt; length; i++) { const element = array[i]; let state; if (Array.isArray(element)) { state = this.#evaluateVisibilityExpression(element); } else if (this.#groups.has(element)) { state = this.#groups.get(element).visible; } else { (0, _util.warn)(`Optional content group not found: ${element}`); return true; } switch (operator) { case &quot;And&quot;: if (!state) { return false; } break; case &quot;Or&quot;: if (state) { return true; } break; case &quot;Not&quot;: return !state; default: return true; } } return operator === &quot;And&quot;; } isVisible(group) { if (this.#groups.size === 0) { return true; } if (!group) { (0, _util.warn)(&quot;Optional content group not defined.&quot;); return true; } if (group.type === &quot;OCG&quot;) { if (!this.#groups.has(group.id)) { (0, _util.warn)(`Optional content group not found: ${group.id}`); return true; } return this.#groups.get(group.id).visible; } else if (group.type === &quot;OCMD&quot;) { if (group.expression) { return this.#evaluateVisibilityExpression(group.expression); } if (!group.policy || group.policy === &quot;AnyOn&quot;) { for (const id of group.ids) { if (!this.#groups.has(id)) { (0, _util.warn)(`Optional content group not found: ${id}`); return true; } if (this.#groups.get(id).visible) { return true; } } return false; } else if (group.policy === &quot;AllOn&quot;) { for (const id of group.ids) { if (!this.#groups.has(id)) { (0, _util.warn)(`Optional content group not found: ${id}`); return true; } if (!this.#groups.get(id).visible) { return false; } } return true; } else if (group.policy === &quot;AnyOff&quot;) { for (const id of group.ids) { if (!this.#groups.has(id)) { (0, _util.warn)(`Optional content group not found: ${id}`); return true; } if (!this.#groups.get(id).visible) { return true; } } return false; } else if (group.policy === &quot;AllOff&quot;) { for (const id of group.ids) { if (!this.#groups.has(id)) { (0, _util.warn)(`Optional content group not found: ${id}`); return true; } if (this.#groups.get(id).visible) { return false; } } return true; } (0, _util.warn)(`Unknown optional content policy ${group.policy}.`); return true; } (0, _util.warn)(`Unknown group type ${group.type}.`); return true; } setVisibility(id, visible = true) { if (!this.#groups.has(id)) { (0, _util.warn)(`Optional content group not found: ${id}`); return; } this.#groups.get(id)._setVisible(INTERNAL, !!visible); this.#cachedGetHash = null; } get hasInitialVisibility() { return this.getHash() === this.#initialHash; } getOrder() { if (!this.#groups.size) { return null; } if (this.#order) { return this.#order.slice(); } return [...this.#groups.keys()]; } getGroups() { return this.#groups.size &gt; 0 ? (0, _util.objectFromMap)(this.#groups) : null; } getGroup(id) { return this.#groups.get(id) || null; } getHash() { if (this.#cachedGetHash !== null) { return this.#cachedGetHash; } const hash = new _murmurhash.MurmurHash3_64(); for (const [id, group] of this.#groups) { hash.update(`${id}:${group.visible}`); } return this.#cachedGetHash = hash.hexdigest(); } } exports.OptionalContentConfig = OptionalContentConfig; /***/ }), /* 18 */ /***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) =&gt; { Object.defineProperty(exports, &quot;__esModule&quot;, ({ value: true })); exports.PDFDataTransportStream = void 0; var _util = __w_pdfjs_require__(1); var _display_utils = __w_pdfjs_require__(6); class PDFDataTransportStream { constructor(params, pdfDataRangeTransport) { (0, _util.assert)(pdfDataRangeTransport, &apos;PDFDataTransportStream - missing required &quot;pdfDataRangeTransport&quot; argument.&apos;); this._queuedChunks = []; this._progressiveDone = params.progressiveDone || false; this._contentDispositionFilename = params.contentDispositionFilename || null; const initialData = params.initialData; if (initialData?.length &gt; 0) { const buffer = new Uint8Array(initialData).buffer; this._queuedChunks.push(buffer); } this._pdfDataRangeTransport = pdfDataRangeTransport; this._isStreamingSupported = !params.disableStream; this._isRangeSupported = !params.disableRange; this._contentLength = params.length; this._fullRequestReader = null; this._rangeReaders = []; this._pdfDataRangeTransport.addRangeListener((begin, chunk) =&gt; { this._onReceiveData({ begin, chunk }); }); this._pdfDataRangeTransport.addProgressListener((loaded, total) =&gt; { this._onProgress({ loaded, total }); }); this._pdfDataRangeTransport.addProgressiveReadListener(chunk =&gt; { this._onReceiveData({ chunk }); }); this._pdfDataRangeTransport.addProgressiveDoneListener(() =&gt; { this._onProgressiveDone(); }); this._pdfDataRangeTransport.transportReady(); } _onReceiveData(args) { const buffer = new Uint8Array(args.chunk).buffer; if (args.begin === undefined) { if (this._fullRequestReader) { this._fullRequestReader._enqueue(buffer); } else { this._queuedChunks.push(buffer); } } else { const found = this._rangeReaders.some(function (rangeReader) { if (rangeReader._begin !== args.begin) { return false; } rangeReader._enqueue(buffer); return true; }); (0, _util.assert)(found, &quot;_onReceiveData - no `PDFDataTransportStreamRangeReader` instance found.&quot;); } } get _progressiveDataLength() { return this._fullRequestReader?._loaded ?? 0; } _onProgress(evt) { if (evt.total === undefined) { this._rangeReaders[0]?.onProgress?.({ loaded: evt.loaded }); } else { this._fullRequestReader?.onProgress?.({ loaded: evt.loaded, total: evt.total }); } } _onProgressiveDone() { this._fullRequestReader?.progressiveDone(); this._progressiveDone = true; } _removeRangeReader(reader) { const i = this._rangeReaders.indexOf(reader); if (i &gt;= 0) { this._rangeReaders.splice(i, 1); } } getFullReader() { (0, _util.assert)(!this._fullRequestReader, &quot;PDFDataTransportStream.getFullReader can only be called once.&quot;); const queuedChunks = this._queuedChunks; this._queuedChunks = null; return new PDFDataTransportStreamReader(this, queuedChunks, this._progressiveDone, this._contentDispositionFilename); } getRangeReader(begin, end) { if (end &lt;= this._progressiveDataLength) { return null; } const reader = new PDFDataTransportStreamRangeReader(this, begin, end); this._pdfDataRangeTransport.requestDataRange(begin, end); this._rangeReaders.push(reader); return reader; } cancelAllRequests(reason) { this._fullRequestReader?.cancel(reason); for (const reader of this._rangeReaders.slice(0)) { reader.cancel(reason); } this._pdfDataRangeTransport.abort(); } } exports.PDFDataTransportStream = PDFDataTransportStream; class PDFDataTransportStreamReader { constructor(stream, queuedChunks, progressiveDone = false, contentDispositionFilename = null) { this._stream = stream; this._done = progressiveDone || false; this._filename = (0, _display_utils.isPdfFile)(contentDispositionFilename) ? contentDispositionFilename : null; this._queuedChunks = queuedChunks || []; this._loaded = 0; for (const chunk of this._queuedChunks) { this._loaded += chunk.byteLength; } this._requests = []; this._headersReady = Promise.resolve(); stream._fullRequestReader = this; this.onProgress = null; } _enqueue(chunk) { if (this._done) { return; } if (this._requests.length &gt; 0) { const requestCapability = this._requests.shift(); requestCapability.resolve({ value: chunk, done: false }); } else { this._queuedChunks.push(chunk); } this._loaded += chunk.byteLength; } get headersReady() { return this._headersReady; } get filename() { return this._filename; } get isRangeSupported() { return this._stream._isRangeSupported; } get isStreamingSupported() { return this._stream._isStreamingSupported; } get contentLength() { return this._stream._contentLength; } async read() { if (this._queuedChunks.length &gt; 0) { const chunk = this._queuedChunks.shift(); return { value: chunk, done: false }; } if (this._done) { return { value: undefined, done: true }; } const requestCapability = (0, _util.createPromiseCapability)(); this._requests.push(requestCapability); return requestCapability.promise; } cancel(reason) { this._done = true; for (const requestCapability of this._requests) { requestCapability.resolve({ value: undefined, done: true }); } this._requests.length = 0; } progressiveDone() { if (this._done) { return; } this._done = true; } } class PDFDataTransportStreamRangeReader { constructor(stream, begin, end) { this._stream = stream; this._begin = begin; this._end = end; this._queuedChunk = null; this._requests = []; this._done = false; this.onProgress = null; } _enqueue(chunk) { if (this._done) { return; } if (this._requests.length === 0) { this._queuedChunk = chunk; } else { const requestsCapability = this._requests.shift(); requestsCapability.resolve({ value: chunk, done: false }); for (const requestCapability of this._requests) { requestCapability.resolve({ value: undefined, done: true }); } this._requests.length = 0; } this._done = true; this._stream._removeRangeReader(this); } get isStreamingSupported() { return false; } async read() { if (this._queuedChunk) { const chunk = this._queuedChunk; this._queuedChunk = null; return { value: chunk, done: false }; } if (this._done) { return { value: undefined, done: true }; } const requestCapability = (0, _util.createPromiseCapability)(); this._requests.push(requestCapability); return requestCapability.promise; } cancel(reason) { this._done = true; for (const requestCapability of this._requests) { requestCapability.resolve({ value: undefined, done: true }); } this._requests.length = 0; this._stream._removeRangeReader(this); } } /***/ }), /* 19 */ /***/ ((__unused_webpack_module, exports) =&gt; { Object.defineProperty(exports, &quot;__esModule&quot;, ({ value: true })); exports.XfaText = void 0; class XfaText { static textContent(xfa) { const items = []; const output = { items, styles: Object.create(null) }; function walk(node) { if (!node) { return; } let str = null; const name = node.name; if (name === &quot;#text&quot;) { str = node.value; } else if (!XfaText.shouldBuildText(name)) { return; } else if (node?.attributes?.textContent) { str = node.attributes.textContent; } else if (node.value) { str = node.value; } if (str !== null) { items.push({ str }); } if (!node.children) { return; } for (const child of node.children) { walk(child); } } walk(xfa); return output; } static shouldBuildText(name) { return !(name === &quot;textarea&quot; || name === &quot;input&quot; || name === &quot;option&quot; || name === &quot;select&quot;); } } exports.XfaText = XfaText; /***/ }), /* 20 */ /***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) =&gt; { Object.defineProperty(exports, &quot;__esModule&quot;, ({ value: true })); exports.NodeStandardFontDataFactory = exports.NodeCanvasFactory = exports.NodeCMapReaderFactory = void 0; var _base_factory = __w_pdfjs_require__(7); ; const fetchData = function (url) { return new Promise((resolve, reject) =&gt; { const fs = require(&quot;fs&quot;); fs.readFile(url, (error, data) =&gt; { if (error || !data) { reject(new Error(error)); return; } resolve(new Uint8Array(data)); }); }); }; class NodeCanvasFactory extends _base_factory.BaseCanvasFactory { _createCanvas(width, height) { const Canvas = require(&quot;canvas&quot;); return Canvas.createCanvas(width, height); } } exports.NodeCanvasFactory = NodeCanvasFactory; class NodeCMapReaderFactory extends _base_factory.BaseCMapReaderFactory { _fetchData(url, compressionType) { return fetchData(url).then(data =&gt; { return { cMapData: data, compressionType }; }); } } exports.NodeCMapReaderFactory = NodeCMapReaderFactory; class NodeStandardFontDataFactory extends _base_factory.BaseStandardFontDataFactory { _fetchData(url) { return fetchData(url); } } exports.NodeStandardFontDataFactory = NodeStandardFontDataFactory; /***/ }), /* 21 */ /***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) =&gt; { Object.defineProperty(exports, &quot;__esModule&quot;, ({ value: true })); exports.AnnotationEditorLayer = void 0; var _tools = __w_pdfjs_require__(5); var _util = __w_pdfjs_require__(1); var _freetext = __w_pdfjs_require__(22); var _ink = __w_pdfjs_require__(23); class AnnotationEditorLayer { #accessibilityManager; #allowClick = false; #boundPointerup = this.pointerup.bind(this); #boundPointerdown = this.pointerdown.bind(this); #editors = new Map(); #hadPointerDown = false; #isCleaningUp = false; #uiManager; static _initialized = false; constructor(options) { if (!AnnotationEditorLayer._initialized) { AnnotationEditorLayer._initialized = true; _freetext.FreeTextEditor.initialize(options.l10n); _ink.InkEditor.initialize(options.l10n); } options.uiManager.registerEditorTypes([_freetext.FreeTextEditor, _ink.InkEditor]); this.#uiManager = options.uiManager; this.annotationStorage = options.annotationStorage; this.pageIndex = options.pageIndex; this.div = options.div; this.#accessibilityManager = options.accessibilityManager; this.#uiManager.addLayer(this); } updateToolbar(mode) { this.#uiManager.updateToolbar(mode); } updateMode(mode = this.#uiManager.getMode()) { this.#cleanup(); if (mode === _util.AnnotationEditorType.INK) { this.addInkEditorIfNeeded(false); this.disableClick(); } else { this.enableClick(); } this.#uiManager.unselectAll(); this.div.classList.toggle(&quot;freeTextEditing&quot;, mode === _util.AnnotationEditorType.FREETEXT); this.div.classList.toggle(&quot;inkEditing&quot;, mode === _util.AnnotationEditorType.INK); } addInkEditorIfNeeded(isCommitting) { if (!isCommitting &amp;&amp; this.#uiManager.getMode() !== _util.AnnotationEditorType.INK) { return; } if (!isCommitting) { for (const editor of this.#editors.values()) { if (editor.isEmpty()) { editor.setInBackground(); return; } } } const editor = this.#createAndAddNewEditor({ offsetX: 0, offsetY: 0 }); editor.setInBackground(); } setEditingState(isEditing) { this.#uiManager.setEditingState(isEditing); } addCommands(params) { this.#uiManager.addCommands(params); } enable() { this.div.style.pointerEvents = &quot;auto&quot;; for (const editor of this.#editors.values()) { editor.enableEditing(); } } disable() { this.div.style.pointerEvents = &quot;none&quot;; for (const editor of this.#editors.values()) { editor.disableEditing(); } } setActiveEditor(editor) { const currentActive = this.#uiManager.getActive(); if (currentActive === editor) { return; } this.#uiManager.setActiveEditor(editor); } enableClick() { this.div.addEventListener(&quot;pointerdown&quot;, this.#boundPointerdown); this.div.addEventListener(&quot;pointerup&quot;, this.#boundPointerup); } disableClick() { this.div.removeEventListener(&quot;pointerdown&quot;, this.#boundPointerdown); this.div.removeEventListener(&quot;pointerup&quot;, this.#boundPointerup); } attach(editor) { this.#editors.set(editor.id, editor); } detach(editor) { this.#editors.delete(editor.id); this.#accessibilityManager?.removePointerInTextLayer(editor.contentDiv); } remove(editor) { this.#uiManager.removeEditor(editor); this.detach(editor); this.annotationStorage.remove(editor.id); editor.div.style.display = &quot;none&quot;; setTimeout(() =&gt; { editor.div.style.display = &quot;&quot;; editor.div.remove(); editor.isAttachedToDOM = false; if (document.activeElement === document.body) { this.#uiManager.focusMainContainer(); } }, 0); if (!this.#isCleaningUp) { this.addInkEditorIfNeeded(false); } } #changeParent(editor) { if (editor.parent === this) { return; } this.attach(editor); editor.pageIndex = this.pageIndex; editor.parent?.detach(editor); editor.parent = this; if (editor.div &amp;&amp; editor.isAttachedToDOM) { editor.div.remove(); this.div.append(editor.div); } } add(editor) { this.#changeParent(editor); this.#uiManager.addEditor(editor); this.attach(editor); if (!editor.isAttachedToDOM) { const div = editor.render(); this.div.append(div); editor.isAttachedToDOM = true; } this.moveEditorInDOM(editor); editor.onceAdded(); this.addToAnnotationStorage(editor); } moveEditorInDOM(editor) { this.#accessibilityManager?.moveElementInDOM(this.div, editor.div, editor.contentDiv, true); } addToAnnotationStorage(editor) { if (!editor.isEmpty() &amp;&amp; !this.annotationStorage.has(editor.id)) { this.annotationStorage.setValue(editor.id, editor); } } addOrRebuild(editor) { if (editor.needsToBeRebuilt()) { editor.rebuild(); } else { this.add(editor); } } addANewEditor(editor) { const cmd = () =&gt; { this.addOrRebuild(editor); }; const undo = () =&gt; { editor.remove(); }; this.addCommands({ cmd, undo, mustExec: true }); } addUndoableEditor(editor) { const cmd = () =&gt; { this.addOrRebuild(editor); }; const undo = () =&gt; { editor.remove(); }; this.addCommands({ cmd, undo, mustExec: false }); } getNextId() { return this.#uiManager.getId(); } #createNewEditor(params) { switch (this.#uiManager.getMode()) { case _util.AnnotationEditorType.FREETEXT: return new _freetext.FreeTextEditor(params); case _util.AnnotationEditorType.INK: return new _ink.InkEditor(params); } return null; } deserialize(data) { switch (data.annotationType) { case _util.AnnotationEditorType.FREETEXT: return _freetext.FreeTextEditor.deserialize(data, this); case _util.AnnotationEditorType.INK: return _ink.InkEditor.deserialize(data, this); } return null; } #createAndAddNewEditor(event) { const id = this.getNextId(); const editor = this.#createNewEditor({ parent: this, id, x: event.offsetX, y: event.offsetY }); if (editor) { this.add(editor); } return editor; } setSelected(editor) { this.#uiManager.setSelected(editor); } toggleSelected(editor) { this.#uiManager.toggleSelected(editor); } isSelected(editor) { return this.#uiManager.isSelected(editor); } unselect(editor) { this.#uiManager.unselect(editor); } pointerup(event) { const isMac = _tools.KeyboardManager.platform.isMac; if (event.button !== 0 || event.ctrlKey &amp;&amp; isMac) { return; } if (event.target !== this.div) { return; } if (!this.#hadPointerDown) { return; } this.#hadPointerDown = false; if (!this.#allowClick) { this.#allowClick = true; return; } this.#createAndAddNewEditor(event); } pointerdown(event) { const isMac = _tools.KeyboardManager.platform.isMac; if (event.button !== 0 || event.ctrlKey &amp;&amp; isMac) { return; } if (event.target !== this.div) { return; } this.#hadPointerDown = true; const editor = this.#uiManager.getActive(); this.#allowClick = !editor || editor.isEmpty(); } drop(event) { const id = event.dataTransfer.getData(&quot;text/plain&quot;); const editor = this.#uiManager.getEditor(id); if (!editor) { return; } event.preventDefault(); event.dataTransfer.dropEffect = &quot;move&quot;; this.#changeParent(editor); const rect = this.div.getBoundingClientRect(); const endX = event.clientX - rect.x; const endY = event.clientY - rect.y; editor.translate(endX - editor.startX, endY - editor.startY); this.moveEditorInDOM(editor); editor.div.focus(); } dragover(event) { event.preventDefault(); } destroy() { if (this.#uiManager.getActive()?.parent === this) { this.#uiManager.setActiveEditor(null); } for (const editor of this.#editors.values()) { this.#accessibilityManager?.removePointerInTextLayer(editor.contentDiv); editor.isAttachedToDOM = false; editor.div.remove(); editor.parent = null; } this.div = null; this.#editors.clear(); this.#uiManager.removeLayer(this); } #cleanup() { this.#isCleaningUp = true; for (const editor of this.#editors.values()) { if (editor.isEmpty()) { editor.remove(); } } this.#isCleaningUp = false; } render(parameters) { this.viewport = parameters.viewport; (0, _tools.bindEvents)(this, this.div, [&quot;dragover&quot;, &quot;drop&quot;]); this.setDimensions(); for (const editor of this.#uiManager.getEditors(this.pageIndex)) { this.add(editor); } this.updateMode(); } update(parameters) { this.#uiManager.commitOrRemove(); this.viewport = parameters.viewport; this.setDimensions(); this.updateMode(); } get scaleFactor() { return this.viewport.scale; } get pageDimensions() { const [pageLLx, pageLLy, pageURx, pageURy] = this.viewport.viewBox; const width = pageURx - pageLLx; const height = pageURy - pageLLy; return [width, height]; } get viewportBaseDimensions() { const { width, height, rotation } = this.viewport; return rotation % 180 === 0 ? [width, height] : [height, width]; } setDimensions() { const { width, height, rotation } = this.viewport; const flipOrientation = rotation % 180 !== 0, widthStr = Math.floor(width) + &quot;px&quot;, heightStr = Math.floor(height) + &quot;px&quot;; this.div.style.width = flipOrientation ? heightStr : widthStr; this.div.style.height = flipOrientation ? widthStr : heightStr; this.div.setAttribute(&quot;data-main-rotation&quot;, rotation); } } exports.AnnotationEditorLayer = AnnotationEditorLayer; /***/ }), /* 22 */ /***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) =&gt; { Object.defineProperty(exports, &quot;__esModule&quot;, ({ value: true })); exports.FreeTextEditor = void 0; var _util = __w_pdfjs_require__(1); var _tools = __w_pdfjs_require__(5); var _editor = __w_pdfjs_require__(4); class FreeTextEditor extends _editor.AnnotationEditor { #boundEditorDivBlur = this.editorDivBlur.bind(this); #boundEditorDivFocus = this.editorDivFocus.bind(this); #boundEditorDivInput = this.editorDivInput.bind(this); #boundEditorDivKeydown = this.editorDivKeydown.bind(this); #color; #content = &quot;&quot;; #editorDivId = `${this.id}-editor`; #hasAlreadyBeenCommitted = false; #fontSize; static _freeTextDefaultContent = &quot;&quot;; static _l10nPromise; static _internalPadding = 0; static _defaultColor = null; static _defaultFontSize = 10; static _keyboardManager = new _tools.KeyboardManager([[[&quot;ctrl+Enter&quot;, &quot;mac+meta+Enter&quot;, &quot;Escape&quot;, &quot;mac+Escape&quot;], FreeTextEditor.prototype.commitOrRemove]]); static _type = &quot;freetext&quot;; constructor(params) { super({ ...params, name: &quot;freeTextEditor&quot; }); this.#color = params.color || FreeTextEditor._defaultColor || _editor.AnnotationEditor._defaultLineColor; this.#fontSize = params.fontSize || FreeTextEditor._defaultFontSize; } static initialize(l10n) { this._l10nPromise = new Map([&quot;free_text2_default_content&quot;, &quot;editor_free_text2_aria_label&quot;].map(str =&gt; [str, l10n.get(str)])); const style = getComputedStyle(document.documentElement); this._internalPadding = parseFloat(style.getPropertyValue(&quot;--freetext-padding&quot;)); } static updateDefaultParams(type, value) { switch (type) { case _util.AnnotationEditorParamsType.FREETEXT_SIZE: FreeTextEditor._defaultFontSize = value; break; case _util.AnnotationEditorParamsType.FREETEXT_COLOR: FreeTextEditor._defaultColor = value; break; } } updateParams(type, value) { switch (type) { case _util.AnnotationEditorParamsType.FREETEXT_SIZE: this.#updateFontSize(value); break; case _util.AnnotationEditorParamsType.FREETEXT_COLOR: this.#updateColor(value); break; } } static get defaultPropertiesToUpdate() { return [[_util.AnnotationEditorParamsType.FREETEXT_SIZE, FreeTextEditor._defaultFontSize], [_util.AnnotationEditorParamsType.FREETEXT_COLOR, FreeTextEditor._defaultColor || _editor.AnnotationEditor._defaultLineColor]]; } get propertiesToUpdate() { return [[_util.AnnotationEditorParamsType.FREETEXT_SIZE, this.#fontSize], [_util.AnnotationEditorParamsType.FREETEXT_COLOR, this.#color]]; } #updateFontSize(fontSize) { const setFontsize = size =&gt; { this.editorDiv.style.fontSize = `calc(${size}px * var(--scale-factor))`; this.translate(0, -(size - this.#fontSize) * this.parent.scaleFactor); this.#fontSize = size; this.#setEditorDimensions(); }; const savedFontsize = this.#fontSize; this.parent.addCommands({ cmd: () =&gt; { setFontsize(fontSize); }, undo: () =&gt; { setFontsize(savedFontsize); }, mustExec: true, type: _util.AnnotationEditorParamsType.FREETEXT_SIZE, overwriteIfSameType: true, keepUndo: true }); } #updateColor(color) { const savedColor = this.#color; this.parent.addCommands({ cmd: () =&gt; { this.#color = color; this.editorDiv.style.color = color; }, undo: () =&gt; { this.#color = savedColor; this.editorDiv.style.color = savedColor; }, mustExec: true, type: _util.AnnotationEditorParamsType.FREETEXT_COLOR, overwriteIfSameType: true, keepUndo: true }); } getInitialTranslation() { return [-FreeTextEditor._internalPadding * this.parent.scaleFactor, -(FreeTextEditor._internalPadding + this.#fontSize) * this.parent.scaleFactor]; } rebuild() { super.rebuild(); if (this.div === null) { return; } if (!this.isAttachedToDOM) { this.parent.add(this); } } enableEditMode() { if (this.isInEditMode()) { return; } this.parent.setEditingState(false); this.parent.updateToolbar(_util.AnnotationEditorType.FREETEXT); super.enableEditMode(); this.overlayDiv.classList.remove(&quot;enabled&quot;); this.editorDiv.contentEditable = true; this.div.draggable = false; this.div.removeAttribute(&quot;aria-activedescendant&quot;); this.editorDiv.addEventListener(&quot;keydown&quot;, this.#boundEditorDivKeydown); this.editorDiv.addEventListener(&quot;focus&quot;, this.#boundEditorDivFocus); this.editorDiv.addEventListener(&quot;blur&quot;, this.#boundEditorDivBlur); this.editorDiv.addEventListener(&quot;input&quot;, this.#boundEditorDivInput); } disableEditMode() { if (!this.isInEditMode()) { return; } this.parent.setEditingState(true); super.disableEditMode(); this.overlayDiv.classList.add(&quot;enabled&quot;); this.editorDiv.contentEditable = false; this.div.setAttribute(&quot;aria-activedescendant&quot;, this.#editorDivId); this.div.draggable = true; this.editorDiv.removeEventListener(&quot;keydown&quot;, this.#boundEditorDivKeydown); this.editorDiv.removeEventListener(&quot;focus&quot;, this.#boundEditorDivFocus); this.editorDiv.removeEventListener(&quot;blur&quot;, this.#boundEditorDivBlur); this.editorDiv.removeEventListener(&quot;input&quot;, this.#boundEditorDivInput); this.div.focus(); this.isEditing = false; this.parent.div.classList.add(&quot;freeTextEditing&quot;); } focusin(event) { super.focusin(event); if (event.target !== this.editorDiv) { this.editorDiv.focus(); } } onceAdded() { if (this.width) { return; } this.enableEditMode(); this.editorDiv.focus(); } isEmpty() { return !this.editorDiv || this.editorDiv.innerText.trim() === &quot;&quot;; } remove() { this.isEditing = false; this.parent.setEditingState(true); this.parent.div.classList.add(&quot;freeTextEditing&quot;); super.remove(); } #extractText() { const divs = this.editorDiv.getElementsByTagName(&quot;div&quot;); if (divs.length === 0) { return this.editorDiv.innerText; } const buffer = []; for (const div of divs) { const first = div.firstChild; if (first?.nodeName === &quot;#text&quot;) { buffer.push(first.data); } else { buffer.push(&quot;&quot;); } } return buffer.join(&quot;\\n&quot;); } #setEditorDimensions() { const [parentWidth, parentHeight] = this.parent.viewportBaseDimensions; const rect = this.div.getBoundingClientRect(); this.width = rect.width / parentWidth; this.height = rect.height / parentHeight; } commit() { super.commit(); if (!this.#hasAlreadyBeenCommitted) { this.#hasAlreadyBeenCommitted = true; this.parent.addUndoableEditor(this); } this.disableEditMode(); this.#content = this.#extractText().trimEnd(); this.#setEditorDimensions(); } shouldGetKeyboardEvents() { return this.isInEditMode(); } dblclick(event) { this.enableEditMode(); this.editorDiv.focus(); } keydown(event) { if (event.target === this.div &amp;&amp; event.key === &quot;Enter&quot;) { this.enableEditMode(); this.editorDiv.focus(); } } editorDivKeydown(event) { FreeTextEditor._keyboardManager.exec(this, event); } editorDivFocus(event) { this.isEditing = true; } editorDivBlur(event) { this.isEditing = false; } editorDivInput(event) { this.parent.div.classList.toggle(&quot;freeTextEditing&quot;, this.isEmpty()); } disableEditing() { this.editorDiv.setAttribute(&quot;role&quot;, &quot;comment&quot;); this.editorDiv.removeAttribute(&quot;aria-multiline&quot;); } enableEditing() { this.editorDiv.setAttribute(&quot;role&quot;, &quot;textbox&quot;); this.editorDiv.setAttribute(&quot;aria-multiline&quot;, true); } render() { if (this.div) { return this.div; } let baseX, baseY; if (this.width) { baseX = this.x; baseY = this.y; } super.render(); this.editorDiv = document.createElement(&quot;div&quot;); this.editorDiv.className = &quot;internal&quot;; this.editorDiv.setAttribute(&quot;id&quot;, this.#editorDivId); this.enableEditing(); FreeTextEditor._l10nPromise.get(&quot;editor_free_text2_aria_label&quot;).then(msg =&gt; this.editorDiv?.setAttribute(&quot;aria-label&quot;, msg)); FreeTextEditor._l10nPromise.get(&quot;free_text2_default_content&quot;).then(msg =&gt; this.editorDiv?.setAttribute(&quot;default-content&quot;, msg)); this.editorDiv.contentEditable = true; const { style } = this.editorDiv; style.fontSize = `calc(${this.#fontSize}px * var(--scale-factor))`; style.color = this.#color; this.div.append(this.editorDiv); this.overlayDiv = document.createElement(&quot;div&quot;); this.overlayDiv.classList.add(&quot;overlay&quot;, &quot;enabled&quot;); this.div.append(this.overlayDiv); (0, _tools.bindEvents)(this, this.div, [&quot;dblclick&quot;, &quot;keydown&quot;]); if (this.width) { const [parentWidth, parentHeight] = this.parent.viewportBaseDimensions; this.setAt(baseX * parentWidth, baseY * parentHeight, this.width * parentWidth, this.height * parentHeight); for (const line of this.#content.split(&quot;\\n&quot;)) { const div = document.createElement(&quot;div&quot;); div.append(line ? document.createTextNode(line) : document.createElement(&quot;br&quot;)); this.editorDiv.append(div); } this.div.draggable = true; this.editorDiv.contentEditable = false; } else { this.div.draggable = false; this.editorDiv.contentEditable = true; } return this.div; } get contentDiv() { return this.editorDiv; } static deserialize(data, parent) { const editor = super.deserialize(data, parent); editor.#fontSize = data.fontSize; editor.#color = _util.Util.makeHexColor(...data.color); editor.#content = data.value; return editor; } serialize() { if (this.isEmpty()) { return null; } const padding = FreeTextEditor._internalPadding * this.parent.scaleFactor; const rect = this.getRect(padding, padding); const color = _editor.AnnotationEditor._colorManager.convert(getComputedStyle(this.editorDiv).color); return { annotationType: _util.AnnotationEditorType.FREETEXT, color, fontSize: this.#fontSize, value: this.#content, pageIndex: this.parent.pageIndex, rect, rotation: this.rotation }; } } exports.FreeTextEditor = FreeTextEditor; /***/ }), /* 23 */ /***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) =&gt; { Object.defineProperty(exports, &quot;__esModule&quot;, ({ value: true })); exports.InkEditor = void 0; Object.defineProperty(exports, &quot;fitCurve&quot;, ({ enumerable: true, get: function () { return _pdfjsFitCurve.fitCurve; } })); var _util = __w_pdfjs_require__(1); var _editor = __w_pdfjs_require__(4); var _pdfjsFitCurve = __w_pdfjs_require__(24); var _tools = __w_pdfjs_require__(5); const RESIZER_SIZE = 16; const TIME_TO_WAIT_BEFORE_FIXING_DIMS = 100; class InkEditor extends _editor.AnnotationEditor { #aspectRatio = 0; #baseHeight = 0; #baseWidth = 0; #boundCanvasPointermove = this.canvasPointermove.bind(this); #boundCanvasPointerleave = this.canvasPointerleave.bind(this); #boundCanvasPointerup = this.canvasPointerup.bind(this); #boundCanvasPointerdown = this.canvasPointerdown.bind(this); #disableEditing = false; #isCanvasInitialized = false; #lastPoint = null; #observer = null; #realWidth = 0; #realHeight = 0; #requestFrameCallback = null; static _defaultColor = null; static _defaultOpacity = 1; static _defaultThickness = 1; static _l10nPromise; static _type = &quot;ink&quot;; constructor(params) { super({ ...params, name: &quot;inkEditor&quot; }); this.color = params.color || null; this.thickness = params.thickness || null; this.opacity = params.opacity || null; this.paths = []; this.bezierPath2D = []; this.currentPath = []; this.scaleFactor = 1; this.translationX = this.translationY = 0; this.x = 0; this.y = 0; } static initialize(l10n) { this._l10nPromise = new Map([&quot;editor_ink_canvas_aria_label&quot;, &quot;editor_ink2_aria_label&quot;].map(str =&gt; [str, l10n.get(str)])); } static updateDefaultParams(type, value) { switch (type) { case _util.AnnotationEditorParamsType.INK_THICKNESS: InkEditor._defaultThickness = value; break; case _util.AnnotationEditorParamsType.INK_COLOR: InkEditor._defaultColor = value; break; case _util.AnnotationEditorParamsType.INK_OPACITY: InkEditor._defaultOpacity = value / 100; break; } } updateParams(type, value) { switch (type) { case _util.AnnotationEditorParamsType.INK_THICKNESS: this.#updateThickness(value); break; case _util.AnnotationEditorParamsType.INK_COLOR: this.#updateColor(value); break; case _util.AnnotationEditorParamsType.INK_OPACITY: this.#updateOpacity(value); break; } } static get defaultPropertiesToUpdate() { return [[_util.AnnotationEditorParamsType.INK_THICKNESS, InkEditor._defaultThickness], [_util.AnnotationEditorParamsType.INK_COLOR, InkEditor._defaultColor || _editor.AnnotationEditor._defaultLineColor], [_util.AnnotationEditorParamsType.INK_OPACITY, Math.round(InkEditor._defaultOpacity * 100)]]; } get propertiesToUpdate() { return [[_util.AnnotationEditorParamsType.INK_THICKNESS, this.thickness || InkEditor._defaultThickness], [_util.AnnotationEditorParamsType.INK_COLOR, this.color || InkEditor._defaultColor || _editor.AnnotationEditor._defaultLineColor], [_util.AnnotationEditorParamsType.INK_OPACITY, Math.round(100 * (this.opacity ?? InkEditor._defaultOpacity))]]; } #updateThickness(thickness) { const savedThickness = this.thickness; this.parent.addCommands({ cmd: () =&gt; { this.thickness = thickness; this.#fitToContent(); }, undo: () =&gt; { this.thickness = savedThickness; this.#fitToContent(); }, mustExec: true, type: _util.AnnotationEditorParamsType.INK_THICKNESS, overwriteIfSameType: true, keepUndo: true }); } #updateColor(color) { const savedColor = this.color; this.parent.addCommands({ cmd: () =&gt; { this.color = color; this.#redraw(); }, undo: () =&gt; { this.color = savedColor; this.#redraw(); }, mustExec: true, type: _util.AnnotationEditorParamsType.INK_COLOR, overwriteIfSameType: true, keepUndo: true }); } #updateOpacity(opacity) { opacity /= 100; const savedOpacity = this.opacity; this.parent.addCommands({ cmd: () =&gt; { this.opacity = opacity; this.#redraw(); }, undo: () =&gt; { this.opacity = savedOpacity; this.#redraw(); }, mustExec: true, type: _util.AnnotationEditorParamsType.INK_OPACITY, overwriteIfSameType: true, keepUndo: true }); } rebuild() { super.rebuild(); if (this.div === null) { return; } if (!this.canvas) { this.#createCanvas(); this.#createObserver(); } if (!this.isAttachedToDOM) { this.parent.add(this); this.#setCanvasDims(); } this.#fitToContent(); } remove() { if (this.canvas === null) { return; } if (!this.isEmpty()) { this.commit(); } this.canvas.width = this.canvas.height = 0; this.canvas.remove(); this.canvas = null; this.#observer.disconnect(); this.#observer = null; super.remove(); } enableEditMode() { if (this.#disableEditing || this.canvas === null) { return; } super.enableEditMode(); this.div.draggable = false; this.canvas.addEventListener(&quot;pointerdown&quot;, this.#boundCanvasPointerdown); this.canvas.addEventListener(&quot;pointerup&quot;, this.#boundCanvasPointerup); } disableEditMode() { if (!this.isInEditMode() || this.canvas === null) { return; } super.disableEditMode(); this.div.draggable = !this.isEmpty(); this.div.classList.remove(&quot;editing&quot;); this.canvas.removeEventListener(&quot;pointerdown&quot;, this.#boundCanvasPointerdown); this.canvas.removeEventListener(&quot;pointerup&quot;, this.#boundCanvasPointerup); } onceAdded() { this.div.draggable = !this.isEmpty(); } isEmpty() { return this.paths.length === 0 || this.paths.length === 1 &amp;&amp; this.paths[0].length === 0; } #getInitialBBox() { const { width, height, rotation } = this.parent.viewport; switch (rotation) { case 90: return [0, width, width, height]; case 180: return [width, height, width, height]; case 270: return [height, 0, width, height]; default: return [0, 0, width, height]; } } #setStroke() { this.ctx.lineWidth = this.thickness * this.parent.scaleFactor / this.scaleFactor; this.ctx.lineCap = &quot;round&quot;; this.ctx.lineJoin = &quot;round&quot;; this.ctx.miterLimit = 10; this.ctx.strokeStyle = `${this.color}${(0, _tools.opacityToHex)(this.opacity)}`; } #startDrawing(x, y) { this.isEditing = true; if (!this.#isCanvasInitialized) { this.#isCanvasInitialized = true; this.#setCanvasDims(); this.thickness ||= InkEditor._defaultThickness; this.color ||= InkEditor._defaultColor || _editor.AnnotationEditor._defaultLineColor; this.opacity ??= InkEditor._defaultOpacity; } this.currentPath.push([x, y]); this.#lastPoint = null; this.#setStroke(); this.ctx.beginPath(); this.ctx.moveTo(x, y); this.#requestFrameCallback = () =&gt; { if (!this.#requestFrameCallback) { return; } if (this.#lastPoint) { if (this.isEmpty()) { this.ctx.setTransform(1, 0, 0, 1, 0, 0); this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height); } else { this.#redraw(); } this.ctx.lineTo(...this.#lastPoint); this.#lastPoint = null; this.ctx.stroke(); } window.requestAnimationFrame(this.#requestFrameCallback); }; window.requestAnimationFrame(this.#requestFrameCallback); } #draw(x, y) { const [lastX, lastY] = this.currentPath.at(-1); if (x === lastX &amp;&amp; y === lastY) { return; } this.currentPath.push([x, y]); this.#lastPoint = [x, y]; } #stopDrawing(x, y) { this.ctx.closePath(); this.#requestFrameCallback = null; x = Math.min(Math.max(x, 0), this.canvas.width); y = Math.min(Math.max(y, 0), this.canvas.height); const [lastX, lastY] = this.currentPath.at(-1); if (x !== lastX || y !== lastY) { this.currentPath.push([x, y]); } let bezier; if (this.currentPath.length !== 1) { bezier = (0, _pdfjsFitCurve.fitCurve)(this.currentPath, 30, null); } else { const xy = [x, y]; bezier = [[xy, xy.slice(), xy.slice(), xy]]; } const path2D = InkEditor.#buildPath2D(bezier); this.currentPath.length = 0; const cmd = () =&gt; { this.paths.push(bezier); this.bezierPath2D.push(path2D); this.rebuild(); }; const undo = () =&gt; { this.paths.pop(); this.bezierPath2D.pop(); if (this.paths.length === 0) { this.remove(); } else { if (!this.canvas) { this.#createCanvas(); this.#createObserver(); } this.#fitToContent(); } }; this.parent.addCommands({ cmd, undo, mustExec: true }); } #redraw() { if (this.isEmpty()) { this.#updateTransform(); return; } this.#setStroke(); const { canvas, ctx } = this; ctx.setTransform(1, 0, 0, 1, 0, 0); ctx.clearRect(0, 0, canvas.width, canvas.height); this.#updateTransform(); for (const path of this.bezierPath2D) { ctx.stroke(path); } } commit() { if (this.#disableEditing) { return; } super.commit(); this.isEditing = false; this.disableEditMode(); this.setInForeground(); this.#disableEditing = true; this.div.classList.add(&quot;disabled&quot;); this.#fitToContent(true); this.parent.addInkEditorIfNeeded(true); this.parent.moveEditorInDOM(this); this.div.focus(); } focusin(event) { super.focusin(event); this.enableEditMode(); } canvasPointerdown(event) { if (event.button !== 0 || !this.isInEditMode() || this.#disableEditing) { return; } this.setInForeground(); if (event.type !== &quot;mouse&quot;) { this.div.focus(); } event.stopPropagation(); this.canvas.addEventListener(&quot;pointerleave&quot;, this.#boundCanvasPointerleave); this.canvas.addEventListener(&quot;pointermove&quot;, this.#boundCanvasPointermove); this.#startDrawing(event.offsetX, event.offsetY); } canvasPointermove(event) { event.stopPropagation(); this.#draw(event.offsetX, event.offsetY); } canvasPointerup(event) { if (event.button !== 0) { return; } if (this.isInEditMode() &amp;&amp; this.currentPath.length !== 0) { event.stopPropagation(); this.#endDrawing(event); this.setInBackground(); } } canvasPointerleave(event) { this.#endDrawing(event); this.setInBackground(); } #endDrawing(event) { this.#stopDrawing(event.offsetX, event.offsetY); this.canvas.removeEventListener(&quot;pointerleave&quot;, this.#boundCanvasPointerleave); this.canvas.removeEventListener(&quot;pointermove&quot;, this.#boundCanvasPointermove); this.parent.addToAnnotationStorage(this); } #createCanvas() { this.canvas = document.createElement(&quot;canvas&quot;); this.canvas.width = this.canvas.height = 0; this.canvas.className = &quot;inkEditorCanvas&quot;; InkEditor._l10nPromise.get(&quot;editor_ink_canvas_aria_label&quot;).then(msg =&gt; this.canvas?.setAttribute(&quot;aria-label&quot;, msg)); this.div.append(this.canvas); this.ctx = this.canvas.getContext(&quot;2d&quot;); } #createObserver() { let timeoutId = null; this.#observer = new ResizeObserver(entries =&gt; { const rect = entries[0].contentRect; if (rect.width &amp;&amp; rect.height) { if (timeoutId !== null) { clearTimeout(timeoutId); } timeoutId = setTimeout(() =&gt; { this.fixDims(); timeoutId = null; }, TIME_TO_WAIT_BEFORE_FIXING_DIMS); this.setDimensions(rect.width, rect.height); } }); this.#observer.observe(this.div); } render() { if (this.div) { return this.div; } let baseX, baseY; if (this.width) { baseX = this.x; baseY = this.y; } super.render(); InkEditor._l10nPromise.get(&quot;editor_ink2_aria_label&quot;).then(msg =&gt; this.div?.setAttribute(&quot;aria-label&quot;, msg)); const [x, y, w, h] = this.#getInitialBBox(); this.setAt(x, y, 0, 0); this.setDims(w, h); this.#createCanvas(); if (this.width) { const [parentWidth, parentHeight] = this.parent.viewportBaseDimensions; this.setAt(baseX * parentWidth, baseY * parentHeight, this.width * parentWidth, this.height * parentHeight); this.#isCanvasInitialized = true; this.#setCanvasDims(); this.setDims(this.width * parentWidth, this.height * parentHeight); this.#redraw(); this.#setMinDims(); this.div.classList.add(&quot;disabled&quot;); } else { this.div.classList.add(&quot;editing&quot;); this.enableEditMode(); } this.#createObserver(); return this.div; } #setCanvasDims() { if (!this.#isCanvasInitialized) { return; } const [parentWidth, parentHeight] = this.parent.viewportBaseDimensions; this.canvas.width = Math.ceil(this.width * parentWidth); this.canvas.height = Math.ceil(this.height * parentHeight); this.#updateTransform(); } setDimensions(width, height) { const roundedWidth = Math.round(width); const roundedHeight = Math.round(height); if (this.#realWidth === roundedWidth &amp;&amp; this.#realHeight === roundedHeight) { return; } this.#realWidth = roundedWidth; this.#realHeight = roundedHeight; this.canvas.style.visibility = &quot;hidden&quot;; if (this.#aspectRatio &amp;&amp; Math.abs(this.#aspectRatio - width / height) &gt; 1e-2) { height = Math.ceil(width / this.#aspectRatio); this.setDims(width, height); } const [parentWidth, parentHeight] = this.parent.viewportBaseDimensions; this.width = width / parentWidth; this.height = height / parentHeight; if (this.#disableEditing) { this.#setScaleFactor(width, height); } this.#setCanvasDims(); this.#redraw(); this.canvas.style.visibility = &quot;visible&quot;; } #setScaleFactor(width, height) { const padding = this.#getPadding(); const scaleFactorW = (width - padding) / this.#baseWidth; const scaleFactorH = (height - padding) / this.#baseHeight; this.scaleFactor = Math.min(scaleFactorW, scaleFactorH); } #updateTransform() { const padding = this.#getPadding() / 2; this.ctx.setTransform(this.scaleFactor, 0, 0, this.scaleFactor, this.translationX * this.scaleFactor + padding, this.translationY * this.scaleFactor + padding); } static #buildPath2D(bezier) { const path2D = new Path2D(); for (let i = 0, ii = bezier.length; i &lt; ii; i++) { const [first, control1, control2, second] = bezier[i]; if (i === 0) { path2D.moveTo(...first); } path2D.bezierCurveTo(control1[0], control1[1], control2[0], control2[1], second[0], second[1]); } return path2D; } #serializePaths(s, tx, ty, h) { const NUMBER_OF_POINTS_ON_BEZIER_CURVE = 4; const paths = []; const padding = this.thickness / 2; let buffer, points; for (const bezier of this.paths) { buffer = []; points = []; for (let i = 0, ii = bezier.length; i &lt; ii; i++) { const [first, control1, control2, second] = bezier[i]; const p10 = s * (first[0] + tx) + padding; const p11 = h - s * (first[1] + ty) - padding; const p20 = s * (control1[0] + tx) + padding; const p21 = h - s * (control1[1] + ty) - padding; const p30 = s * (control2[0] + tx) + padding; const p31 = h - s * (control2[1] + ty) - padding; const p40 = s * (second[0] + tx) + padding; const p41 = h - s * (second[1] + ty) - padding; if (i === 0) { buffer.push(p10, p11); points.push(p10, p11); } buffer.push(p20, p21, p30, p31, p40, p41); this.#extractPointsOnBezier(p10, p11, p20, p21, p30, p31, p40, p41, NUMBER_OF_POINTS_ON_BEZIER_CURVE, points); } paths.push({ bezier: buffer, points }); } return paths; } #extractPointsOnBezier(p10, p11, p20, p21, p30, p31, p40, p41, n, points) { if (this.#isAlmostFlat(p10, p11, p20, p21, p30, p31, p40, p41)) { points.push(p40, p41); return; } for (let i = 1; i &lt; n - 1; i++) { const t = i / n; const mt = 1 - t; let q10 = t * p10 + mt * p20; let q11 = t * p11 + mt * p21; let q20 = t * p20 + mt * p30; let q21 = t * p21 + mt * p31; const q30 = t * p30 + mt * p40; const q31 = t * p31 + mt * p41; q10 = t * q10 + mt * q20; q11 = t * q11 + mt * q21; q20 = t * q20 + mt * q30; q21 = t * q21 + mt * q31; q10 = t * q10 + mt * q20; q11 = t * q11 + mt * q21; points.push(q10, q11); } points.push(p40, p41); } #isAlmostFlat(p10, p11, p20, p21, p30, p31, p40, p41) { const tol = 10; const ax = (3 * p20 - 2 * p10 - p40) ** 2; const ay = (3 * p21 - 2 * p11 - p41) ** 2; const bx = (3 * p30 - p10 - 2 * p40) ** 2; const by = (3 * p31 - p11 - 2 * p41) ** 2; return Math.max(ax, bx) + Math.max(ay, by) &lt;= tol; } #getBbox() { let xMin = Infinity; let xMax = -Infinity; let yMin = Infinity; let yMax = -Infinity; for (const path of this.paths) { for (const [first, control1, control2, second] of path) { const bbox = _util.Util.bezierBoundingBox(...first, ...control1, ...control2, ...second); xMin = Math.min(xMin, bbox[0]); yMin = Math.min(yMin, bbox[1]); xMax = Math.max(xMax, bbox[2]); yMax = Math.max(yMax, bbox[3]); } } return [xMin, yMin, xMax, yMax]; } #getPadding() { return this.#disableEditing ? Math.ceil(this.thickness * this.parent.scaleFactor) : 0; } #fitToContent(firstTime = false) { if (this.isEmpty()) { return; } if (!this.#disableEditing) { this.#redraw(); return; } const bbox = this.#getBbox(); const padding = this.#getPadding(); this.#baseWidth = Math.max(RESIZER_SIZE, bbox[2] - bbox[0]); this.#baseHeight = Math.max(RESIZER_SIZE, bbox[3] - bbox[1]); const width = Math.ceil(padding + this.#baseWidth * this.scaleFactor); const height = Math.ceil(padding + this.#baseHeight * this.scaleFactor); const [parentWidth, parentHeight] = this.parent.viewportBaseDimensions; this.width = width / parentWidth; this.height = height / parentHeight; this.#aspectRatio = width / height; this.#setMinDims(); const prevTranslationX = this.translationX; const prevTranslationY = this.translationY; this.translationX = -bbox[0]; this.translationY = -bbox[1]; this.#setCanvasDims(); this.#redraw(); this.#realWidth = width; this.#realHeight = height; this.setDims(width, height); const unscaledPadding = firstTime ? padding / this.scaleFactor / 2 : 0; this.translate(prevTranslationX - this.translationX - unscaledPadding, prevTranslationY - this.translationY - unscaledPadding); } #setMinDims() { const { style } = this.div; if (this.#aspectRatio &gt;= 1) { style.minHeight = `${RESIZER_SIZE}px`; style.minWidth = `${Math.round(this.#aspectRatio * RESIZER_SIZE)}px`; } else { style.minWidth = `${RESIZER_SIZE}px`; style.minHeight = `${Math.round(RESIZER_SIZE / this.#aspectRatio)}px`; } } static deserialize(data, parent) { const editor = super.deserialize(data, parent); editor.thickness = data.thickness; editor.color = _util.Util.makeHexColor(...data.color); editor.opacity = data.opacity; const [pageWidth, pageHeight] = parent.pageDimensions; const width = editor.width * pageWidth; const height = editor.height * pageHeight; const scaleFactor = parent.scaleFactor; const padding = data.thickness / 2; editor.#aspectRatio = width / height; editor.#disableEditing = true; editor.#realWidth = Math.round(width); editor.#realHeight = Math.round(height); for (const { bezier } of data.paths) { const path = []; editor.paths.push(path); let p0 = scaleFactor * (bezier[0] - padding); let p1 = scaleFactor * (height - bezier[1] - padding); for (let i = 2, ii = bezier.length; i &lt; ii; i += 6) { const p10 = scaleFactor * (bezier[i] - padding); const p11 = scaleFactor * (height - bezier[i + 1] - padding); const p20 = scaleFactor * (bezier[i + 2] - padding); const p21 = scaleFactor * (height - bezier[i + 3] - padding); const p30 = scaleFactor * (bezier[i + 4] - padding); const p31 = scaleFactor * (height - bezier[i + 5] - padding); path.push([[p0, p1], [p10, p11], [p20, p21], [p30, p31]]); p0 = p30; p1 = p31; } const path2D = this.#buildPath2D(path); editor.bezierPath2D.push(path2D); } const bbox = editor.#getBbox(); editor.#baseWidth = Math.max(RESIZER_SIZE, bbox[2] - bbox[0]); editor.#baseHeight = Math.max(RESIZER_SIZE, bbox[3] - bbox[1]); editor.#setScaleFactor(width, height); return editor; } serialize() { if (this.isEmpty()) { return null; } const rect = this.getRect(0, 0); const height = this.rotation % 180 === 0 ? rect[3] - rect[1] : rect[2] - rect[0]; const color = _editor.AnnotationEditor._colorManager.convert(this.ctx.strokeStyle); return { annotationType: _util.AnnotationEditorType.INK, color, thickness: this.thickness, opacity: this.opacity, paths: this.#serializePaths(this.scaleFactor / this.parent.scaleFactor, this.translationX, this.translationY, height), pageIndex: this.parent.pageIndex, rect, rotation: this.rotation }; } } exports.InkEditor = InkEditor; /***/ }), /* 24 */ /***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) =&gt; { Object.defineProperty(exports, &quot;__esModule&quot;, ({ value: true })); exports.fitCurve = void 0; const fitCurve = __w_pdfjs_require__(25); exports.fitCurve = fitCurve; /***/ }), /* 25 */ /***/ ((module) =&gt; { function fitCurve(points, maxError, progressCallback) { if (!Array.isArray(points)) { throw new TypeError(&quot;First argument should be an array&quot;); } points.forEach(point =&gt; { if (!Array.isArray(point) || point.some(item =&gt; typeof item !== &apos;number&apos;) || point.length !== points[0].length) { throw Error(&quot;Each point should be an array of numbers. Each point should have the same amount of numbers.&quot;); } }); points = points.filter((point, i) =&gt; i === 0 || !point.every((val, j) =&gt; val === points[i - 1][j])); if (points.length &lt; 2) { return []; } const len = points.length; const leftTangent = createTangent(points[1], points[0]); const rightTangent = createTangent(points[len - 2], points[len - 1]); return fitCubic(points, leftTangent, rightTangent, maxError, progressCallback); } function fitCubic(points, leftTangent, rightTangent, error, progressCallback) { const MaxIterations = 20; var bezCurve, u, uPrime, maxError, prevErr, splitPoint, prevSplit, centerVector, toCenterTangent, fromCenterTangent, beziers, dist, i; if (points.length === 2) { dist = maths.vectorLen(maths.subtract(points[0], points[1])) / 3.0; bezCurve = [points[0], maths.addArrays(points[0], maths.mulItems(leftTangent, dist)), maths.addArrays(points[1], maths.mulItems(rightTangent, dist)), points[1]]; return [bezCurve]; } u = chordLengthParameterize(points); [bezCurve, maxError, splitPoint] = generateAndReport(points, u, u, leftTangent, rightTangent, progressCallback); if (maxError === 0 || maxError &lt; error) { return [bezCurve]; } if (maxError &lt; error * error) { uPrime = u; prevErr = maxError; prevSplit = splitPoint; for (i = 0; i &lt; MaxIterations; i++) { uPrime = reparameterize(bezCurve, points, uPrime); [bezCurve, maxError, splitPoint] = generateAndReport(points, u, uPrime, leftTangent, rightTangent, progressCallback); if (maxError &lt; error) { return [bezCurve]; } else if (splitPoint === prevSplit) { let errChange = maxError / prevErr; if (errChange &gt; .9999 &amp;&amp; errChange &lt; 1.0001) { break; } } prevErr = maxError; prevSplit = splitPoint; } } beziers = []; centerVector = maths.subtract(points[splitPoint - 1], points[splitPoint + 1]); if (centerVector.every(val =&gt; val === 0)) { centerVector = maths.subtract(points[splitPoint - 1], points[splitPoint]); [centerVector[0], centerVector[1]] = [-centerVector[1], centerVector[0]]; } toCenterTangent = maths.normalize(centerVector); fromCenterTangent = maths.mulItems(toCenterTangent, -1); beziers = beziers.concat(fitCubic(points.slice(0, splitPoint + 1), leftTangent, toCenterTangent, error, progressCallback)); beziers = beziers.concat(fitCubic(points.slice(splitPoint), fromCenterTangent, rightTangent, error, progressCallback)); return beziers; } ; function generateAndReport(points, paramsOrig, paramsPrime, leftTangent, rightTangent, progressCallback) { var bezCurve, maxError, splitPoint; bezCurve = generateBezier(points, paramsPrime, leftTangent, rightTangent, progressCallback); [maxError, splitPoint] = computeMaxError(points, bezCurve, paramsOrig); if (progressCallback) { progressCallback({ bez: bezCurve, points: points, params: paramsOrig, maxErr: maxError, maxPoint: splitPoint }); } return [bezCurve, maxError, splitPoint]; } function generateBezier(points, parameters, leftTangent, rightTangent) { var bezCurve, A, a, C, X, det_C0_C1, det_C0_X, det_X_C1, alpha_l, alpha_r, epsilon, segLength, i, len, tmp, u, ux, firstPoint = points[0], lastPoint = points[points.length - 1]; bezCurve = [firstPoint, null, null, lastPoint]; A = maths.zeros_Xx2x2(parameters.length); for (i = 0, len = parameters.length; i &lt; len; i++) { u = parameters[i]; ux = 1 - u; a = A[i]; a[0] = maths.mulItems(leftTangent, 3 * u * (ux * ux)); a[1] = maths.mulItems(rightTangent, 3 * ux * (u * u)); } C = [[0, 0], [0, 0]]; X = [0, 0]; for (i = 0, len = points.length; i &lt; len; i++) { u = parameters[i]; a = A[i]; C[0][0] += maths.dot(a[0], a[0]); C[0][1] += maths.dot(a[0], a[1]); C[1][0] += maths.dot(a[0], a[1]); C[1][1] += maths.dot(a[1], a[1]); tmp = maths.subtract(points[i], bezier.q([firstPoint, firstPoint, lastPoint, lastPoint], u)); X[0] += maths.dot(a[0], tmp); X[1] += maths.dot(a[1], tmp); } det_C0_C1 = C[0][0] * C[1][1] - C[1][0] * C[0][1]; det_C0_X = C[0][0] * X[1] - C[1][0] * X[0]; det_X_C1 = X[0] * C[1][1] - X[1] * C[0][1]; alpha_l = det_C0_C1 === 0 ? 0 : det_X_C1 / det_C0_C1; alpha_r = det_C0_C1 === 0 ? 0 : det_C0_X / det_C0_C1; segLength = maths.vectorLen(maths.subtract(firstPoint, lastPoint)); epsilon = 1.0e-6 * segLength; if (alpha_l &lt; epsilon || alpha_r &lt; epsilon) { bezCurve[1] = maths.addArrays(firstPoint, maths.mulItems(leftTangent, segLength / 3.0)); bezCurve[2] = maths.addArrays(lastPoint, maths.mulItems(rightTangent, segLength / 3.0)); } else { bezCurve[1] = maths.addArrays(firstPoint, maths.mulItems(leftTangent, alpha_l)); bezCurve[2] = maths.addArrays(lastPoint, maths.mulItems(rightTangent, alpha_r)); } return bezCurve; } ; function reparameterize(bezier, points, parameters) { return parameters.map((p, i) =&gt; newtonRaphsonRootFind(bezier, points[i], p)); } ; function newtonRaphsonRootFind(bez, point, u) { var d = maths.subtract(bezier.q(bez, u), point), qprime = bezier.qprime(bez, u), numerator = maths.mulMatrix(d, qprime), denominator = maths.sum(maths.squareItems(qprime)) + 2 * maths.mulMatrix(d, bezier.qprimeprime(bez, u)); if (denominator === 0) { return u; } else { return u - numerator / denominator; } } ; function chordLengthParameterize(points) { var u = [], currU, prevU, prevP; points.forEach((p, i) =&gt; { currU = i ? prevU + maths.vectorLen(maths.subtract(p, prevP)) : 0; u.push(currU); prevU = currU; prevP = p; }); u = u.map(x =&gt; x / prevU); return u; } ; function computeMaxError(points, bez, parameters) { var dist, maxDist, splitPoint, v, i, count, point, t; maxDist = 0; splitPoint = Math.floor(points.length / 2); const t_distMap = mapTtoRelativeDistances(bez, 10); for (i = 0, count = points.length; i &lt; count; i++) { point = points[i]; t = find_t(bez, parameters[i], t_distMap, 10); v = maths.subtract(bezier.q(bez, t), point); dist = v[0] * v[0] + v[1] * v[1]; if (dist &gt; maxDist) { maxDist = dist; splitPoint = i; } } return [maxDist, splitPoint]; } ; var mapTtoRelativeDistances = function (bez, B_parts) { var B_t_curr; var B_t_dist = [0]; var B_t_prev = bez[0]; var sumLen = 0; for (var i = 1; i &lt;= B_parts; i++) { B_t_curr = bezier.q(bez, i / B_parts); sumLen += maths.vectorLen(maths.subtract(B_t_curr, B_t_prev)); B_t_dist.push(sumLen); B_t_prev = B_t_curr; } B_t_dist = B_t_dist.map(x =&gt; x / sumLen); return B_t_dist; }; function find_t(bez, param, t_distMap, B_parts) { if (param &lt; 0) { return 0; } if (param &gt; 1) { return 1; } var lenMax, lenMin, tMax, tMin, t; for (var i = 1; i &lt;= B_parts; i++) { if (param &lt;= t_distMap[i]) { tMin = (i - 1) / B_parts; tMax = i / B_parts; lenMin = t_distMap[i - 1]; lenMax = t_distMap[i]; t = (param - lenMin) / (lenMax - lenMin) * (tMax - tMin) + tMin; break; } } return t; } function createTangent(pointA, pointB) { return maths.normalize(maths.subtract(pointA, pointB)); } class maths { static zeros_Xx2x2(x) { var zs = []; while (x--) { zs.push([0, 0]); } return zs; } static mulItems(items, multiplier) { return items.map(x =&gt; x * multiplier); } static mulMatrix(m1, m2) { return m1.reduce((sum, x1, i) =&gt; sum + x1 * m2[i], 0); } static subtract(arr1, arr2) { return arr1.map((x1, i) =&gt; x1 - arr2[i]); } static addArrays(arr1, arr2) { return arr1.map((x1, i) =&gt; x1 + arr2[i]); } static addItems(items, addition) { return items.map(x =&gt; x + addition); } static sum(items) { return items.reduce((sum, x) =&gt; sum + x); } static dot(m1, m2) { return maths.mulMatrix(m1, m2); } static vectorLen(v) { return Math.hypot(...v); } static divItems(items, divisor) { return items.map(x =&gt; x / divisor); } static squareItems(items) { return items.map(x =&gt; x * x); } static normalize(v) { return this.divItems(v, this.vectorLen(v)); } } class bezier { static q(ctrlPoly, t) { var tx = 1.0 - t; var pA = maths.mulItems(ctrlPoly[0], tx * tx * tx), pB = maths.mulItems(ctrlPoly[1], 3 * tx * tx * t), pC = maths.mulItems(ctrlPoly[2], 3 * tx * t * t), pD = maths.mulItems(ctrlPoly[3], t * t * t); return maths.addArrays(maths.addArrays(pA, pB), maths.addArrays(pC, pD)); } static qprime(ctrlPoly, t) { var tx = 1.0 - t; var pA = maths.mulItems(maths.subtract(ctrlPoly[1], ctrlPoly[0]), 3 * tx * tx), pB = maths.mulItems(maths.subtract(ctrlPoly[2], ctrlPoly[1]), 6 * tx * t), pC = maths.mulItems(maths.subtract(ctrlPoly[3], ctrlPoly[2]), 3 * t * t); return maths.addArrays(maths.addArrays(pA, pB), pC); } static qprimeprime(ctrlPoly, t) { return maths.addArrays(maths.mulItems(maths.addArrays(maths.subtract(ctrlPoly[2], maths.mulItems(ctrlPoly[1], 2)), ctrlPoly[0]), 6 * (1.0 - t)), maths.mulItems(maths.addArrays(maths.subtract(ctrlPoly[3], maths.mulItems(ctrlPoly[2], 2)), ctrlPoly[1]), 6 * t)); } } module.exports = fitCurve; module.exports.fitCubic = fitCubic; module.exports.createTangent = createTangent; /***/ }), /* 26 */ /***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) =&gt; { Object.defineProperty(exports, &quot;__esModule&quot;, ({ value: true })); exports.AnnotationLayer = void 0; var _util = __w_pdfjs_require__(1); var _display_utils = __w_pdfjs_require__(6); var _annotation_storage = __w_pdfjs_require__(3); var _scripting_utils = __w_pdfjs_require__(27); var _xfa_layer = __w_pdfjs_require__(28); const DEFAULT_TAB_INDEX = 1000; const DEFAULT_FONT_SIZE = 9; const GetElementsByNameSet = new WeakSet(); function getRectDims(rect) { return { width: rect[2] - rect[0], height: rect[3] - rect[1] }; } class AnnotationElementFactory { static create(parameters) { const subtype = parameters.data.annotationType; switch (subtype) { case _util.AnnotationType.LINK: return new LinkAnnotationElement(parameters); case _util.AnnotationType.TEXT: return new TextAnnotationElement(parameters); case _util.AnnotationType.WIDGET: const fieldType = parameters.data.fieldType; switch (fieldType) { case &quot;Tx&quot;: return new TextWidgetAnnotationElement(parameters); case &quot;Btn&quot;: if (parameters.data.radioButton) { return new RadioButtonWidgetAnnotationElement(parameters); } else if (parameters.data.checkBox) { return new CheckboxWidgetAnnotationElement(parameters); } return new PushButtonWidgetAnnotationElement(parameters); case &quot;Ch&quot;: return new ChoiceWidgetAnnotationElement(parameters); } return new WidgetAnnotationElement(parameters); case _util.AnnotationType.POPUP: return new PopupAnnotationElement(parameters); case _util.AnnotationType.FREETEXT: return new FreeTextAnnotationElement(parameters); case _util.AnnotationType.LINE: return new LineAnnotationElement(parameters); case _util.AnnotationType.SQUARE: return new SquareAnnotationElement(parameters); case _util.AnnotationType.CIRCLE: return new CircleAnnotationElement(parameters); case _util.AnnotationType.POLYLINE: return new PolylineAnnotationElement(parameters); case _util.AnnotationType.CARET: return new CaretAnnotationElement(parameters); case _util.AnnotationType.INK: return new InkAnnotationElement(parameters); case _util.AnnotationType.POLYGON: return new PolygonAnnotationElement(parameters); case _util.AnnotationType.HIGHLIGHT: return new HighlightAnnotationElement(parameters); case _util.AnnotationType.UNDERLINE: return new UnderlineAnnotationElement(parameters); case _util.AnnotationType.SQUIGGLY: return new SquigglyAnnotationElement(parameters); case _util.AnnotationType.STRIKEOUT: return new StrikeOutAnnotationElement(parameters); case _util.AnnotationType.STAMP: return new StampAnnotationElement(parameters); case _util.AnnotationType.FILEATTACHMENT: return new FileAttachmentAnnotationElement(parameters); default: return new AnnotationElement(parameters); } } } class AnnotationElement { constructor(parameters, { isRenderable = false, ignoreBorder = false, createQuadrilaterals = false } = {}) { this.isRenderable = isRenderable; this.data = parameters.data; this.layer = parameters.layer; this.page = parameters.page; this.viewport = parameters.viewport; this.linkService = parameters.linkService; this.downloadManager = parameters.downloadManager; this.imageResourcesPath = parameters.imageResourcesPath; this.renderForms = parameters.renderForms; this.svgFactory = parameters.svgFactory; this.annotationStorage = parameters.annotationStorage; this.enableScripting = parameters.enableScripting; this.hasJSActions = parameters.hasJSActions; this._fieldObjects = parameters.fieldObjects; this._mouseState = parameters.mouseState; if (isRenderable) { this.container = this._createContainer(ignoreBorder); } if (createQuadrilaterals) { this.quadrilaterals = this._createQuadrilaterals(ignoreBorder); } } _createContainer(ignoreBorder = false) { const data = this.data, page = this.page, viewport = this.viewport; const container = document.createElement(&quot;section&quot;); const { width, height } = getRectDims(data.rect); const [pageLLx, pageLLy, pageURx, pageURy] = viewport.viewBox; const pageWidth = pageURx - pageLLx; const pageHeight = pageURy - pageLLy; container.setAttribute(&quot;data-annotation-id&quot;, data.id); const rect = _util.Util.normalizeRect([data.rect[0], page.view[3] - data.rect[1] + page.view[1], data.rect[2], page.view[3] - data.rect[3] + page.view[1]]); if (!ignoreBorder &amp;&amp; data.borderStyle.width &gt; 0) { container.style.borderWidth = `${data.borderStyle.width}px`; const horizontalRadius = data.borderStyle.horizontalCornerRadius; const verticalRadius = data.borderStyle.verticalCornerRadius; if (horizontalRadius &gt; 0 || verticalRadius &gt; 0) { const radius = `calc(${horizontalRadius}px * var(--scale-factor)) / calc(${verticalRadius}px * var(--scale-factor))`; container.style.borderRadius = radius; } else if (this instanceof RadioButtonWidgetAnnotationElement) { const radius = `calc(${width}px * var(--scale-factor)) / calc(${height}px * var(--scale-factor))`; container.style.borderRadius = radius; } switch (data.borderStyle.style) { case _util.AnnotationBorderStyleType.SOLID: container.style.borderStyle = &quot;solid&quot;; break; case _util.AnnotationBorderStyleType.DASHED: container.style.borderStyle = &quot;dashed&quot;; break; case _util.AnnotationBorderStyleType.BEVELED: (0, _util.warn)(&quot;Unimplemented border style: beveled&quot;); break; case _util.AnnotationBorderStyleType.INSET: (0, _util.warn)(&quot;Unimplemented border style: inset&quot;); break; case _util.AnnotationBorderStyleType.UNDERLINE: container.style.borderBottomStyle = &quot;solid&quot;; break; default: break; } const borderColor = data.borderColor || null; if (borderColor) { container.style.borderColor = _util.Util.makeHexColor(borderColor[0] | 0, borderColor[1] | 0, borderColor[2] | 0); } else { container.style.borderWidth = 0; } } container.style.left = `${100 * (rect[0] - pageLLx) / pageWidth}%`; container.style.top = `${100 * (rect[1] - pageLLy) / pageHeight}%`; const { rotation } = data; if (data.hasOwnCanvas || rotation === 0) { container.style.width = `${100 * width / pageWidth}%`; container.style.height = `${100 * height / pageHeight}%`; } else { this.setRotation(rotation, container); } return container; } setRotation(angle, container = this.container) { const [pageLLx, pageLLy, pageURx, pageURy] = this.viewport.viewBox; const pageWidth = pageURx - pageLLx; const pageHeight = pageURy - pageLLy; const { width, height } = getRectDims(this.data.rect); let elementWidth, elementHeight; if (angle % 180 === 0) { elementWidth = 100 * width / pageWidth; elementHeight = 100 * height / pageHeight; } else { elementWidth = 100 * height / pageWidth; elementHeight = 100 * width / pageHeight; } container.style.width = `${elementWidth}%`; container.style.height = `${elementHeight}%`; container.setAttribute(&quot;data-main-rotation&quot;, (360 - angle) % 360); } get _commonActions() { const setColor = (jsName, styleName, event) =&gt; { const color = event.detail[jsName]; event.target.style[styleName] = _scripting_utils.ColorConverters[`${color[0]}_HTML`](color.slice(1)); }; return (0, _util.shadow)(this, &quot;_commonActions&quot;, { display: event =&gt; { const hidden = event.detail.display % 2 === 1; this.container.style.visibility = hidden ? &quot;hidden&quot; : &quot;visible&quot;; this.annotationStorage.setValue(this.data.id, { hidden, print: event.detail.display === 0 || event.detail.display === 3 }); }, print: event =&gt; { this.annotationStorage.setValue(this.data.id, { print: event.detail.print }); }, hidden: event =&gt; { this.container.style.visibility = event.detail.hidden ? &quot;hidden&quot; : &quot;visible&quot;; this.annotationStorage.setValue(this.data.id, { hidden: event.detail.hidden }); }, focus: event =&gt; { setTimeout(() =&gt; event.target.focus({ preventScroll: false }), 0); }, userName: event =&gt; { event.target.title = event.detail.userName; }, readonly: event =&gt; { if (event.detail.readonly) { event.target.setAttribute(&quot;readonly&quot;, &quot;&quot;); } else { event.target.removeAttribute(&quot;readonly&quot;); } }, required: event =&gt; { this._setRequired(event.target, event.detail.required); }, bgColor: event =&gt; { setColor(&quot;bgColor&quot;, &quot;backgroundColor&quot;, event); }, fillColor: event =&gt; { setColor(&quot;fillColor&quot;, &quot;backgroundColor&quot;, event); }, fgColor: event =&gt; { setColor(&quot;fgColor&quot;, &quot;color&quot;, event); }, textColor: event =&gt; { setColor(&quot;textColor&quot;, &quot;color&quot;, event); }, borderColor: event =&gt; { setColor(&quot;borderColor&quot;, &quot;borderColor&quot;, event); }, strokeColor: event =&gt; { setColor(&quot;strokeColor&quot;, &quot;borderColor&quot;, event); }, rotation: event =&gt; { const angle = event.detail.rotation; this.setRotation(angle); this.annotationStorage.setValue(this.data.id, { rotation: angle }); } }); } _dispatchEventFromSandbox(actions, jsEvent) { const commonActions = this._commonActions; for (const name of Object.keys(jsEvent.detail)) { const action = actions[name] || commonActions[name]; action?.(jsEvent); } } _setDefaultPropertiesFromJS(element) { if (!this.enableScripting) { return; } const storedData = this.annotationStorage.getRawValue(this.data.id); if (!storedData) { return; } const commonActions = this._commonActions; for (const [actionName, detail] of Object.entries(storedData)) { const action = commonActions[actionName]; if (action) { const eventProxy = { detail: { [actionName]: detail }, target: element }; action(eventProxy); delete storedData[actionName]; } } } _createQuadrilaterals(ignoreBorder = false) { if (!this.data.quadPoints) { return null; } const quadrilaterals = []; const savedRect = this.data.rect; for (const quadPoint of this.data.quadPoints) { this.data.rect = [quadPoint[2].x, quadPoint[2].y, quadPoint[1].x, quadPoint[1].y]; quadrilaterals.push(this._createContainer(ignoreBorder)); } this.data.rect = savedRect; return quadrilaterals; } _createPopup(trigger, data) { let container = this.container; if (this.quadrilaterals) { trigger = trigger || this.quadrilaterals; container = this.quadrilaterals[0]; } if (!trigger) { trigger = document.createElement(&quot;div&quot;); trigger.className = &quot;popupTriggerArea&quot;; container.append(trigger); } const popupElement = new PopupElement({ container, trigger, color: data.color, titleObj: data.titleObj, modificationDate: data.modificationDate, contentsObj: data.contentsObj, richText: data.richText, hideWrapper: true }); const popup = popupElement.render(); popup.style.left = &quot;100%&quot;; container.append(popup); } _renderQuadrilaterals(className) { for (const quadrilateral of this.quadrilaterals) { quadrilateral.className = className; } return this.quadrilaterals; } render() { (0, _util.unreachable)(&quot;Abstract method `AnnotationElement.render` called&quot;); } _getElementsByName(name, skipId = null) { const fields = []; if (this._fieldObjects) { const fieldObj = this._fieldObjects[name]; if (fieldObj) { for (const { page, id, exportValues } of fieldObj) { if (page === -1) { continue; } if (id === skipId) { continue; } const exportValue = typeof exportValues === &quot;string&quot; ? exportValues : null; const domElement = document.querySelector(`[data-element-id=&quot;${id}&quot;]`); if (domElement &amp;&amp; !GetElementsByNameSet.has(domElement)) { (0, _util.warn)(`_getElementsByName - element not allowed: ${id}`); continue; } fields.push({ id, exportValue, domElement }); } } return fields; } for (const domElement of document.getElementsByName(name)) { const { exportValue } = domElement; const id = domElement.getAttribute(&quot;data-element-id&quot;); if (id === skipId) { continue; } if (!GetElementsByNameSet.has(domElement)) { continue; } fields.push({ id, exportValue, domElement }); } return fields; } static get platform() { const platform = typeof navigator !== &quot;undefined&quot; ? navigator.platform : &quot;&quot;; return (0, _util.shadow)(this, &quot;platform&quot;, { isWin: platform.includes(&quot;Win&quot;), isMac: platform.includes(&quot;Mac&quot;) }); } } class LinkAnnotationElement extends AnnotationElement { constructor(parameters, options = null) { super(parameters, { isRenderable: true, ignoreBorder: !!options?.ignoreBorder, createQuadrilaterals: true }); this.isTooltipOnly = parameters.data.isTooltipOnly; } render() { const { data, linkService } = this; const link = document.createElement(&quot;a&quot;); link.setAttribute(&quot;data-element-id&quot;, data.id); let isBound = false; if (data.url) { linkService.addLinkAttributes(link, data.url, data.newWindow); isBound = true; } else if (data.action) { this._bindNamedAction(link, data.action); isBound = true; } else if (data.attachment) { this._bindAttachment(link, data.attachment); isBound = true; } else if (data.setOCGState) { this.#bindSetOCGState(link, data.setOCGState); isBound = true; } else if (data.dest) { this._bindLink(link, data.dest); isBound = true; } else { if (data.actions &amp;&amp; (data.actions.Action || data.actions[&quot;Mouse Up&quot;] || data.actions[&quot;Mouse Down&quot;]) &amp;&amp; this.enableScripting &amp;&amp; this.hasJSActions) { this._bindJSAction(link, data); isBound = true; } if (data.resetForm) { this._bindResetFormAction(link, data.resetForm); isBound = true; } else if (this.isTooltipOnly &amp;&amp; !isBound) { this._bindLink(link, &quot;&quot;); isBound = true; } } if (this.quadrilaterals) { return this._renderQuadrilaterals(&quot;linkAnnotation&quot;).map((quadrilateral, index) =&gt; { const linkElement = index === 0 ? link : link.cloneNode(); quadrilateral.append(linkElement); return quadrilateral; }); } this.container.className = &quot;linkAnnotation&quot;; if (isBound) { this.container.append(link); } return this.container; } _bindLink(link, destination) { link.href = this.linkService.getDestinationHash(destination); link.onclick = () =&gt; { if (destination) { this.linkService.goToDestination(destination); } return false; }; if (destination || destination === &quot;&quot;) { link.className = &quot;internalLink&quot;; } } _bindNamedAction(link, action) { link.href = this.linkService.getAnchorUrl(&quot;&quot;); link.onclick = () =&gt; { this.linkService.executeNamedAction(action); return false; }; link.className = &quot;internalLink&quot;; } _bindAttachment(link, attachment) { link.href = this.linkService.getAnchorUrl(&quot;&quot;); link.onclick = () =&gt; { this.downloadManager?.openOrDownloadData(this.container, attachment.content, attachment.filename); return false; }; link.className = &quot;internalLink&quot;; } #bindSetOCGState(link, action) { link.href = this.linkService.getAnchorUrl(&quot;&quot;); link.onclick = () =&gt; { this.linkService.executeSetOCGState(action); return false; }; link.className = &quot;internalLink&quot;; } _bindJSAction(link, data) { link.href = this.linkService.getAnchorUrl(&quot;&quot;); const map = new Map([[&quot;Action&quot;, &quot;onclick&quot;], [&quot;Mouse Up&quot;, &quot;onmouseup&quot;], [&quot;Mouse Down&quot;, &quot;onmousedown&quot;]]); for (const name of Object.keys(data.actions)) { const jsName = map.get(name); if (!jsName) { continue; } link[jsName] = () =&gt; { this.linkService.eventBus?.dispatch(&quot;dispatcheventinsandbox&quot;, { source: this, detail: { id: data.id, name } }); return false; }; } if (!link.onclick) { link.onclick = () =&gt; false; } link.className = &quot;internalLink&quot;; } _bindResetFormAction(link, resetForm) { const otherClickAction = link.onclick; if (!otherClickAction) { link.href = this.linkService.getAnchorUrl(&quot;&quot;); } link.className = &quot;internalLink&quot;; if (!this._fieldObjects) { (0, _util.warn)(`_bindResetFormAction - &quot;resetForm&quot; action not supported, ` + &quot;ensure that the `fieldObjects` parameter is provided.&quot;); if (!otherClickAction) { link.onclick = () =&gt; false; } return; } link.onclick = () =&gt; { otherClickAction?.(); const { fields: resetFormFields, refs: resetFormRefs, include } = resetForm; const allFields = []; if (resetFormFields.length !== 0 || resetFormRefs.length !== 0) { const fieldIds = new Set(resetFormRefs); for (const fieldName of resetFormFields) { const fields = this._fieldObjects[fieldName] || []; for (const { id } of fields) { fieldIds.add(id); } } for (const fields of Object.values(this._fieldObjects)) { for (const field of fields) { if (fieldIds.has(field.id) === include) { allFields.push(field); } } } } else { for (const fields of Object.values(this._fieldObjects)) { allFields.push(...fields); } } const storage = this.annotationStorage; const allIds = []; for (const field of allFields) { const { id } = field; allIds.push(id); switch (field.type) { case &quot;text&quot;: { const value = field.defaultValue || &quot;&quot;; storage.setValue(id, { value }); break; } case &quot;checkbox&quot;: case &quot;radiobutton&quot;: { const value = field.defaultValue === field.exportValues; storage.setValue(id, { value }); break; } case &quot;combobox&quot;: case &quot;listbox&quot;: { const value = field.defaultValue || &quot;&quot;; storage.setValue(id, { value }); break; } default: continue; } const domElement = document.querySelector(`[data-element-id=&quot;${id}&quot;]`); if (!domElement) { continue; } else if (!GetElementsByNameSet.has(domElement)) { (0, _util.warn)(`_bindResetFormAction - element not allowed: ${id}`); continue; } domElement.dispatchEvent(new Event(&quot;resetform&quot;)); } if (this.enableScripting) { this.linkService.eventBus?.dispatch(&quot;dispatcheventinsandbox&quot;, { source: this, detail: { id: &quot;app&quot;, ids: allIds, name: &quot;ResetForm&quot; } }); } return false; }; } } class TextAnnotationElement extends AnnotationElement { constructor(parameters) { const isRenderable = !!(parameters.data.hasPopup || parameters.data.titleObj?.str || parameters.data.contentsObj?.str || parameters.data.richText?.str); super(parameters, { isRenderable }); } render() { this.container.className = &quot;textAnnotation&quot;; const image = document.createElement(&quot;img&quot;); image.src = this.imageResourcesPath + &quot;annotation-&quot; + this.data.name.toLowerCase() + &quot;.svg&quot;; image.alt = &quot;[ Annotation]&quot;; image.dataset.l10nId = &quot;text_annotation_type&quot;; image.dataset.l10nArgs = JSON.stringify({ type: this.data.name }); if (!this.data.hasPopup) { this._createPopup(image, this.data); } this.container.append(image); return this.container; } } class WidgetAnnotationElement extends AnnotationElement { render() { if (this.data.alternativeText) { this.container.title = this.data.alternativeText; } return this.container; } _getKeyModifier(event) { const { isWin, isMac } = AnnotationElement.platform; return isWin &amp;&amp; event.ctrlKey || isMac &amp;&amp; event.metaKey; } _setEventListener(element, baseName, eventName, valueGetter) { if (baseName.includes(&quot;mouse&quot;)) { element.addEventListener(baseName, event =&gt; { this.linkService.eventBus?.dispatch(&quot;dispatcheventinsandbox&quot;, { source: this, detail: { id: this.data.id, name: eventName, value: valueGetter(event), shift: event.shiftKey, modifier: this._getKeyModifier(event) } }); }); } else { element.addEventListener(baseName, event =&gt; { this.linkService.eventBus?.dispatch(&quot;dispatcheventinsandbox&quot;, { source: this, detail: { id: this.data.id, name: eventName, value: valueGetter(event) } }); }); } } _setEventListeners(element, names, getter) { for (const [baseName, eventName] of names) { if (eventName === &quot;Action&quot; || this.data.actions?.[eventName]) { this._setEventListener(element, baseName, eventName, getter); } } } _setBackgroundColor(element) { const color = this.data.backgroundColor || null; element.style.backgroundColor = color === null ? &quot;transparent&quot; : _util.Util.makeHexColor(color[0], color[1], color[2]); } _setTextStyle(element) { const TEXT_ALIGNMENT = [&quot;left&quot;, &quot;center&quot;, &quot;right&quot;]; const { fontColor } = this.data.defaultAppearanceData; const fontSize = this.data.defaultAppearanceData.fontSize || DEFAULT_FONT_SIZE; const style = element.style; let computedFontSize; const BORDER_SIZE = 2; const roundToOneDecimal = x =&gt; Math.round(10 * x) / 10; if (this.data.multiLine) { const height = Math.abs(this.data.rect[3] - this.data.rect[1] - BORDER_SIZE); const numberOfLines = Math.round(height / (_util.LINE_FACTOR * fontSize)) || 1; const lineHeight = height / numberOfLines; computedFontSize = Math.min(fontSize, roundToOneDecimal(lineHeight / _util.LINE_FACTOR)); } else { const height = Math.abs(this.data.rect[3] - this.data.rect[1] - BORDER_SIZE); computedFontSize = Math.min(fontSize, roundToOneDecimal(height / _util.LINE_FACTOR)); } style.fontSize = `calc(${computedFontSize}px * var(--scale-factor))`; style.color = _util.Util.makeHexColor(fontColor[0], fontColor[1], fontColor[2]); if (this.data.textAlignment !== null) { style.textAlign = TEXT_ALIGNMENT[this.data.textAlignment]; } } _setRequired(element, isRequired) { if (isRequired) { element.setAttribute(&quot;required&quot;, true); } else { element.removeAttribute(&quot;required&quot;); } element.setAttribute(&quot;aria-required&quot;, isRequired); } } class TextWidgetAnnotationElement extends WidgetAnnotationElement { constructor(parameters) { const isRenderable = parameters.renderForms || !parameters.data.hasAppearance &amp;&amp; !!parameters.data.fieldValue; super(parameters, { isRenderable }); } setPropertyOnSiblings(base, key, value, keyInStorage) { const storage = this.annotationStorage; for (const element of this._getElementsByName(base.name, base.id)) { if (element.domElement) { element.domElement[key] = value; } storage.setValue(element.id, { [keyInStorage]: value }); } } render() { const storage = this.annotationStorage; const id = this.data.id; this.container.className = &quot;textWidgetAnnotation&quot;; let element = null; if (this.renderForms) { const storedData = storage.getValue(id, { value: this.data.fieldValue }); let textContent = storedData.formattedValue || storedData.value || &quot;&quot;; const maxLen = storage.getValue(id, { charLimit: this.data.maxLen }).charLimit; if (maxLen &amp;&amp; textContent.length &gt; maxLen) { textContent = textContent.slice(0, maxLen); } const elementData = { userValue: textContent, formattedValue: null, valueOnFocus: &quot;&quot; }; if (this.data.multiLine) { element = document.createElement(&quot;textarea&quot;); element.textContent = textContent; if (this.data.doNotScroll) { element.style.overflowY = &quot;hidden&quot;; } } else { element = document.createElement(&quot;input&quot;); element.type = &quot;text&quot;; element.setAttribute(&quot;value&quot;, textContent); if (this.data.doNotScroll) { element.style.overflowX = &quot;hidden&quot;; } } GetElementsByNameSet.add(element); element.setAttribute(&quot;data-element-id&quot;, id); element.disabled = this.data.readOnly; element.name = this.data.fieldName; element.tabIndex = DEFAULT_TAB_INDEX; this._setRequired(element, this.data.required); if (maxLen) { element.maxLength = maxLen; } element.addEventListener(&quot;input&quot;, event =&gt; { storage.setValue(id, { value: event.target.value }); this.setPropertyOnSiblings(element, &quot;value&quot;, event.target.value, &quot;value&quot;); }); element.addEventListener(&quot;resetform&quot;, event =&gt; { const defaultValue = this.data.defaultFieldValue ?? &quot;&quot;; element.value = elementData.userValue = defaultValue; elementData.formattedValue = null; }); let blurListener = event =&gt; { const { formattedValue } = elementData; if (formattedValue !== null &amp;&amp; formattedValue !== undefined) { event.target.value = formattedValue; } event.target.scrollLeft = 0; }; if (this.enableScripting &amp;&amp; this.hasJSActions) { element.addEventListener(&quot;focus&quot;, event =&gt; { if (elementData.userValue) { event.target.value = elementData.userValue; } elementData.valueOnFocus = event.target.value; }); element.addEventListener(&quot;updatefromsandbox&quot;, jsEvent =&gt; { const actions = { value(event) { elementData.userValue = event.detail.value ?? &quot;&quot;; storage.setValue(id, { value: elementData.userValue.toString() }); event.target.value = elementData.userValue; }, formattedValue(event) { const { formattedValue } = event.detail; elementData.formattedValue = formattedValue; if (formattedValue !== null &amp;&amp; formattedValue !== undefined &amp;&amp; event.target !== document.activeElement) { event.target.value = formattedValue; } storage.setValue(id, { formattedValue }); }, selRange(event) { event.target.setSelectionRange(...event.detail.selRange); }, charLimit: event =&gt; { const { charLimit } = event.detail; const { target } = event; if (charLimit === 0) { target.removeAttribute(&quot;maxLength&quot;); return; } target.setAttribute(&quot;maxLength&quot;, charLimit); let value = elementData.userValue; if (!value || value.length &lt;= charLimit) { return; } value = value.slice(0, charLimit); target.value = elementData.userValue = value; storage.setValue(id, { value }); this.linkService.eventBus?.dispatch(&quot;dispatcheventinsandbox&quot;, { source: this, detail: { id, name: &quot;Keystroke&quot;, value, willCommit: true, commitKey: 1, selStart: target.selectionStart, selEnd: target.selectionEnd } }); } }; this._dispatchEventFromSandbox(actions, jsEvent); }); element.addEventListener(&quot;keydown&quot;, event =&gt; { let commitKey = -1; if (event.key === &quot;Escape&quot;) { commitKey = 0; } else if (event.key === &quot;Enter&quot;) { commitKey = 2; } else if (event.key === &quot;Tab&quot;) { commitKey = 3; } if (commitKey === -1) { return; } const { value } = event.target; if (elementData.valueOnFocus === value) { return; } elementData.userValue = value; this.linkService.eventBus?.dispatch(&quot;dispatcheventinsandbox&quot;, { source: this, detail: { id, name: &quot;Keystroke&quot;, value, willCommit: true, commitKey, selStart: event.target.selectionStart, selEnd: event.target.selectionEnd } }); }); const _blurListener = blurListener; blurListener = null; element.addEventListener(&quot;blur&quot;, event =&gt; { const { value } = event.target; elementData.userValue = value; if (this._mouseState.isDown &amp;&amp; elementData.valueOnFocus !== value) { this.linkService.eventBus?.dispatch(&quot;dispatcheventinsandbox&quot;, { source: this, detail: { id, name: &quot;Keystroke&quot;, value, willCommit: true, commitKey: 1, selStart: event.target.selectionStart, selEnd: event.target.selectionEnd } }); } _blurListener(event); }); if (this.data.actions?.Keystroke) { element.addEventListener(&quot;beforeinput&quot;, event =&gt; { const { data, target } = event; const { value, selectionStart, selectionEnd } = target; let selStart = selectionStart, selEnd = selectionEnd; switch (event.inputType) { case &quot;deleteWordBackward&quot;: { const match = value.substring(0, selectionStart).match(/\\w*[^\\w]*$/); if (match) { selStart -= match[0].length; } break; } case &quot;deleteWordForward&quot;: { const match = value.substring(selectionStart).match(/^[^\\w]*\\w*/); if (match) { selEnd += match[0].length; } break; } case &quot;deleteContentBackward&quot;: if (selectionStart === selectionEnd) { selStart -= 1; } break; case &quot;deleteContentForward&quot;: if (selectionStart === selectionEnd) { selEnd += 1; } break; } event.preventDefault(); this.linkService.eventBus?.dispatch(&quot;dispatcheventinsandbox&quot;, { source: this, detail: { id, name: &quot;Keystroke&quot;, value, change: data || &quot;&quot;, willCommit: false, selStart, selEnd } }); }); } this._setEventListeners(element, [[&quot;focus&quot;, &quot;Focus&quot;], [&quot;blur&quot;, &quot;Blur&quot;], [&quot;mousedown&quot;, &quot;Mouse Down&quot;], [&quot;mouseenter&quot;, &quot;Mouse Enter&quot;], [&quot;mouseleave&quot;, &quot;Mouse Exit&quot;], [&quot;mouseup&quot;, &quot;Mouse Up&quot;]], event =&gt; event.target.value); } if (blurListener) { element.addEventListener(&quot;blur&quot;, blurListener); } if (this.data.comb) { const fieldWidth = this.data.rect[2] - this.data.rect[0]; const combWidth = fieldWidth / maxLen; element.classList.add(&quot;comb&quot;); element.style.letterSpacing = `calc(${combWidth}px * var(--scale-factor) - 1ch)`; } } else { element = document.createElement(&quot;div&quot;); element.textContent = this.data.fieldValue; element.style.verticalAlign = &quot;middle&quot;; element.style.display = &quot;table-cell&quot;; } this._setTextStyle(element); this._setBackgroundColor(element); this._setDefaultPropertiesFromJS(element); this.container.append(element); return this.container; } } class CheckboxWidgetAnnotationElement extends WidgetAnnotationElement { constructor(parameters) { super(parameters, { isRenderable: parameters.renderForms }); } render() { const storage = this.annotationStorage; const data = this.data; const id = data.id; let value = storage.getValue(id, { value: data.exportValue === data.fieldValue }).value; if (typeof value === &quot;string&quot;) { value = value !== &quot;Off&quot;; storage.setValue(id, { value }); } this.container.className = &quot;buttonWidgetAnnotation checkBox&quot;; const element = document.createElement(&quot;input&quot;); GetElementsByNameSet.add(element); element.setAttribute(&quot;data-element-id&quot;, id); element.disabled = data.readOnly; this._setRequired(element, this.data.required); element.type = &quot;checkbox&quot;; element.name = data.fieldName; if (value) { element.setAttribute(&quot;checked&quot;, true); } element.setAttribute(&quot;exportValue&quot;, data.exportValue); element.tabIndex = DEFAULT_TAB_INDEX; element.addEventListener(&quot;change&quot;, event =&gt; { const { name, checked } = event.target; for (const checkbox of this._getElementsByName(name, id)) { const curChecked = checked &amp;&amp; checkbox.exportValue === data.exportValue; if (checkbox.domElement) { checkbox.domElement.checked = curChecked; } storage.setValue(checkbox.id, { value: curChecked }); } storage.setValue(id, { value: checked }); }); element.addEventListener(&quot;resetform&quot;, event =&gt; { const defaultValue = data.defaultFieldValue || &quot;Off&quot;; event.target.checked = defaultValue === data.exportValue; }); if (this.enableScripting &amp;&amp; this.hasJSActions) { element.addEventListener(&quot;updatefromsandbox&quot;, jsEvent =&gt; { const actions = { value(event) { event.target.checked = event.detail.value !== &quot;Off&quot;; storage.setValue(id, { value: event.target.checked }); } }; this._dispatchEventFromSandbox(actions, jsEvent); }); this._setEventListeners(element, [[&quot;change&quot;, &quot;Validate&quot;], [&quot;change&quot;, &quot;Action&quot;], [&quot;focus&quot;, &quot;Focus&quot;], [&quot;blur&quot;, &quot;Blur&quot;], [&quot;mousedown&quot;, &quot;Mouse Down&quot;], [&quot;mouseenter&quot;, &quot;Mouse Enter&quot;], [&quot;mouseleave&quot;, &quot;Mouse Exit&quot;], [&quot;mouseup&quot;, &quot;Mouse Up&quot;]], event =&gt; event.target.checked); } this._setBackgroundColor(element); this._setDefaultPropertiesFromJS(element); this.container.append(element); return this.container; } } class RadioButtonWidgetAnnotationElement extends WidgetAnnotationElement { constructor(parameters) { super(parameters, { isRenderable: parameters.renderForms }); } render() { this.container.className = &quot;buttonWidgetAnnotation radioButton&quot;; const storage = this.annotationStorage; const data = this.data; const id = data.id; let value = storage.getValue(id, { value: data.fieldValue === data.buttonValue }).value; if (typeof value === &quot;string&quot;) { value = value !== data.buttonValue; storage.setValue(id, { value }); } const element = document.createElement(&quot;input&quot;); GetElementsByNameSet.add(element); element.setAttribute(&quot;data-element-id&quot;, id); element.disabled = data.readOnly; this._setRequired(element, this.data.required); element.type = &quot;radio&quot;; element.name = data.fieldName; if (value) { element.setAttribute(&quot;checked&quot;, true); } element.tabIndex = DEFAULT_TAB_INDEX; element.addEventListener(&quot;change&quot;, event =&gt; { const { name, checked } = event.target; for (const radio of this._getElementsByName(name, id)) { storage.setValue(radio.id, { value: false }); } storage.setValue(id, { value: checked }); }); element.addEventListener(&quot;resetform&quot;, event =&gt; { const defaultValue = data.defaultFieldValue; event.target.checked = defaultValue !== null &amp;&amp; defaultValue !== undefined &amp;&amp; defaultValue === data.buttonValue; }); if (this.enableScripting &amp;&amp; this.hasJSActions) { const pdfButtonValue = data.buttonValue; element.addEventListener(&quot;updatefromsandbox&quot;, jsEvent =&gt; { const actions = { value: event =&gt; { const checked = pdfButtonValue === event.detail.value; for (const radio of this._getElementsByName(event.target.name)) { const curChecked = checked &amp;&amp; radio.id === id; if (radio.domElement) { radio.domElement.checked = curChecked; } storage.setValue(radio.id, { value: curChecked }); } } }; this._dispatchEventFromSandbox(actions, jsEvent); }); this._setEventListeners(element, [[&quot;change&quot;, &quot;Validate&quot;], [&quot;change&quot;, &quot;Action&quot;], [&quot;focus&quot;, &quot;Focus&quot;], [&quot;blur&quot;, &quot;Blur&quot;], [&quot;mousedown&quot;, &quot;Mouse Down&quot;], [&quot;mouseenter&quot;, &quot;Mouse Enter&quot;], [&quot;mouseleave&quot;, &quot;Mouse Exit&quot;], [&quot;mouseup&quot;, &quot;Mouse Up&quot;]], event =&gt; event.target.checked); } this._setBackgroundColor(element); this._setDefaultPropertiesFromJS(element); this.container.append(element); return this.container; } } class PushButtonWidgetAnnotationElement extends LinkAnnotationElement { constructor(parameters) { super(parameters, { ignoreBorder: parameters.data.hasAppearance }); } render() { const container = super.render(); container.className = &quot;buttonWidgetAnnotation pushButton&quot;; if (this.data.alternativeText) { container.title = this.data.alternativeText; } const linkElement = container.lastChild; if (this.enableScripting &amp;&amp; this.hasJSActions &amp;&amp; linkElement) { this._setDefaultPropertiesFromJS(linkElement); linkElement.addEventListener(&quot;updatefromsandbox&quot;, jsEvent =&gt; { this._dispatchEventFromSandbox({}, jsEvent); }); } return container; } } class ChoiceWidgetAnnotationElement extends WidgetAnnotationElement { constructor(parameters) { super(parameters, { isRenderable: parameters.renderForms }); } render() { this.container.className = &quot;choiceWidgetAnnotation&quot;; const storage = this.annotationStorage; const id = this.data.id; const storedData = storage.getValue(id, { value: this.data.fieldValue }); const selectElement = document.createElement(&quot;select&quot;); GetElementsByNameSet.add(selectElement); selectElement.setAttribute(&quot;data-element-id&quot;, id); selectElement.disabled = this.data.readOnly; this._setRequired(selectElement, this.data.required); selectElement.name = this.data.fieldName; selectElement.tabIndex = DEFAULT_TAB_INDEX; let addAnEmptyEntry = this.data.combo &amp;&amp; this.data.options.length &gt; 0; if (!this.data.combo) { selectElement.size = this.data.options.length; if (this.data.multiSelect) { selectElement.multiple = true; } } selectElement.addEventListener(&quot;resetform&quot;, event =&gt; { const defaultValue = this.data.defaultFieldValue; for (const option of selectElement.options) { option.selected = option.value === defaultValue; } }); for (const option of this.data.options) { const optionElement = document.createElement(&quot;option&quot;); optionElement.textContent = option.displayValue; optionElement.value = option.exportValue; if (storedData.value.includes(option.exportValue)) { optionElement.setAttribute(&quot;selected&quot;, true); addAnEmptyEntry = false; } selectElement.append(optionElement); } let removeEmptyEntry = null; if (addAnEmptyEntry) { const noneOptionElement = document.createElement(&quot;option&quot;); noneOptionElement.value = &quot; &quot;; noneOptionElement.setAttribute(&quot;hidden&quot;, true); noneOptionElement.setAttribute(&quot;selected&quot;, true); selectElement.prepend(noneOptionElement); removeEmptyEntry = () =&gt; { noneOptionElement.remove(); selectElement.removeEventListener(&quot;input&quot;, removeEmptyEntry); removeEmptyEntry = null; }; selectElement.addEventListener(&quot;input&quot;, removeEmptyEntry); } const getValue = (event, isExport) =&gt; { const name = isExport ? &quot;value&quot; : &quot;textContent&quot;; const options = event.target.options; if (!event.target.multiple) { return options.selectedIndex === -1 ? null : options[options.selectedIndex][name]; } return Array.prototype.filter.call(options, option =&gt; option.selected).map(option =&gt; option[name]); }; const getItems = event =&gt; { const options = event.target.options; return Array.prototype.map.call(options, option =&gt; { return { displayValue: option.textContent, exportValue: option.value }; }); }; if (this.enableScripting &amp;&amp; this.hasJSActions) { selectElement.addEventListener(&quot;updatefromsandbox&quot;, jsEvent =&gt; { const actions = { value(event) { removeEmptyEntry?.(); const value = event.detail.value; const values = new Set(Array.isArray(value) ? value : [value]); for (const option of selectElement.options) { option.selected = values.has(option.value); } storage.setValue(id, { value: getValue(event, true) }); }, multipleSelection(event) { selectElement.multiple = true; }, remove(event) { const options = selectElement.options; const index = event.detail.remove; options[index].selected = false; selectElement.remove(index); if (options.length &gt; 0) { const i = Array.prototype.findIndex.call(options, option =&gt; option.selected); if (i === -1) { options[0].selected = true; } } storage.setValue(id, { value: getValue(event, true), items: getItems(event) }); }, clear(event) { while (selectElement.length !== 0) { selectElement.remove(0); } storage.setValue(id, { value: null, items: [] }); }, insert(event) { const { index, displayValue, exportValue } = event.detail.insert; const selectChild = selectElement.children[index]; const optionElement = document.createElement(&quot;option&quot;); optionElement.textContent = displayValue; optionElement.value = exportValue; if (selectChild) { selectChild.before(optionElement); } else { selectElement.append(optionElement); } storage.setValue(id, { value: getValue(event, true), items: getItems(event) }); }, items(event) { const { items } = event.detail; while (selectElement.length !== 0) { selectElement.remove(0); } for (const item of items) { const { displayValue, exportValue } = item; const optionElement = document.createElement(&quot;option&quot;); optionElement.textContent = displayValue; optionElement.value = exportValue; selectElement.append(optionElement); } if (selectElement.options.length &gt; 0) { selectElement.options[0].selected = true; } storage.setValue(id, { value: getValue(event, true), items: getItems(event) }); }, indices(event) { const indices = new Set(event.detail.indices); for (const option of event.target.options) { option.selected = indices.has(option.index); } storage.setValue(id, { value: getValue(event, true) }); }, editable(event) { event.target.disabled = !event.detail.editable; } }; this._dispatchEventFromSandbox(actions, jsEvent); }); selectElement.addEventListener(&quot;input&quot;, event =&gt; { const exportValue = getValue(event, true); const value = getValue(event, false); storage.setValue(id, { value: exportValue }); this.linkService.eventBus?.dispatch(&quot;dispatcheventinsandbox&quot;, { source: this, detail: { id, name: &quot;Keystroke&quot;, value, changeEx: exportValue, willCommit: true, commitKey: 1, keyDown: false } }); }); this._setEventListeners(selectElement, [[&quot;focus&quot;, &quot;Focus&quot;], [&quot;blur&quot;, &quot;Blur&quot;], [&quot;mousedown&quot;, &quot;Mouse Down&quot;], [&quot;mouseenter&quot;, &quot;Mouse Enter&quot;], [&quot;mouseleave&quot;, &quot;Mouse Exit&quot;], [&quot;mouseup&quot;, &quot;Mouse Up&quot;], [&quot;input&quot;, &quot;Action&quot;]], event =&gt; event.target.checked); } else { selectElement.addEventListener(&quot;input&quot;, function (event) { storage.setValue(id, { value: getValue(event, true) }); }); } if (this.data.combo) { this._setTextStyle(selectElement); } else {} this._setBackgroundColor(selectElement); this._setDefaultPropertiesFromJS(selectElement); this.container.append(selectElement); return this.container; } } class PopupAnnotationElement extends AnnotationElement { static IGNORE_TYPES = new Set([&quot;Line&quot;, &quot;Square&quot;, &quot;Circle&quot;, &quot;PolyLine&quot;, &quot;Polygon&quot;, &quot;Ink&quot;]); constructor(parameters) { const { data } = parameters; const isRenderable = !PopupAnnotationElement.IGNORE_TYPES.has(data.parentType) &amp;&amp; !!(data.titleObj?.str || data.contentsObj?.str || data.richText?.str); super(parameters, { isRenderable }); } render() { this.container.className = &quot;popupAnnotation&quot;; const parentElements = this.layer.querySelectorAll(`[data-annotation-id=&quot;${this.data.parentId}&quot;]`); if (parentElements.length === 0) { return this.container; } const popup = new PopupElement({ container: this.container, trigger: Array.from(parentElements), color: this.data.color, titleObj: this.data.titleObj, modificationDate: this.data.modificationDate, contentsObj: this.data.contentsObj, richText: this.data.richText }); const page = this.page; const rect = _util.Util.normalizeRect([this.data.parentRect[0], page.view[3] - this.data.parentRect[1] + page.view[1], this.data.parentRect[2], page.view[3] - this.data.parentRect[3] + page.view[1]]); const popupLeft = rect[0] + this.data.parentRect[2] - this.data.parentRect[0]; const popupTop = rect[1]; const [pageLLx, pageLLy, pageURx, pageURy] = this.viewport.viewBox; const pageWidth = pageURx - pageLLx; const pageHeight = pageURy - pageLLy; this.container.style.left = `${100 * (popupLeft - pageLLx) / pageWidth}%`; this.container.style.top = `${100 * (popupTop - pageLLy) / pageHeight}%`; this.container.append(popup.render()); return this.container; } } class PopupElement { constructor(parameters) { this.container = parameters.container; this.trigger = parameters.trigger; this.color = parameters.color; this.titleObj = parameters.titleObj; this.modificationDate = parameters.modificationDate; this.contentsObj = parameters.contentsObj; this.richText = parameters.richText; this.hideWrapper = parameters.hideWrapper || false; this.pinned = false; } render() { const BACKGROUND_ENLIGHT = 0.7; const wrapper = document.createElement(&quot;div&quot;); wrapper.className = &quot;popupWrapper&quot;; this.hideElement = this.hideWrapper ? wrapper : this.container; this.hideElement.hidden = true; const popup = document.createElement(&quot;div&quot;); popup.className = &quot;popup&quot;; const color = this.color; if (color) { const r = BACKGROUND_ENLIGHT * (255 - color[0]) + color[0]; const g = BACKGROUND_ENLIGHT * (255 - color[1]) + color[1]; const b = BACKGROUND_ENLIGHT * (255 - color[2]) + color[2]; popup.style.backgroundColor = _util.Util.makeHexColor(r | 0, g | 0, b | 0); } const title = document.createElement(&quot;h1&quot;); title.dir = this.titleObj.dir; title.textContent = this.titleObj.str; popup.append(title); const dateObject = _display_utils.PDFDateString.toDateObject(this.modificationDate); if (dateObject) { const modificationDate = document.createElement(&quot;span&quot;); modificationDate.className = &quot;popupDate&quot;; modificationDate.textContent = &quot;1667031860289, &quot;; modificationDate.dataset.l10nId = &quot;annotation_date_string&quot;; modificationDate.dataset.l10nArgs = JSON.stringify({ date: dateObject.toLocaleDateString(), time: dateObject.toLocaleTimeString() }); popup.append(modificationDate); } if (this.richText?.str &amp;&amp; (!this.contentsObj?.str || this.contentsObj.str === this.richText.str)) { _xfa_layer.XfaLayer.render({ xfaHtml: this.richText.html, intent: &quot;richText&quot;, div: popup }); popup.lastChild.className = &quot;richText popupContent&quot;; } else { const contents = this._formatContents(this.contentsObj); popup.append(contents); } if (!Array.isArray(this.trigger)) { this.trigger = [this.trigger]; } for (const element of this.trigger) { element.addEventListener(&quot;click&quot;, this._toggle.bind(this)); element.addEventListener(&quot;mouseover&quot;, this._show.bind(this, false)); element.addEventListener(&quot;mouseout&quot;, this._hide.bind(this, false)); } popup.addEventListener(&quot;click&quot;, this._hide.bind(this, true)); wrapper.append(popup); return wrapper; } _formatContents({ str, dir }) { const p = document.createElement(&quot;p&quot;); p.className = &quot;popupContent&quot;; p.dir = dir; const lines = str.split(/(?:\\r\\n?|\\n)/); for (let i = 0, ii = lines.length; i &lt; ii; ++i) { const line = lines[i]; p.append(document.createTextNode(line)); if (i &lt; ii - 1) { p.append(document.createElement(&quot;br&quot;)); } } return p; } _toggle() { if (this.pinned) { this._hide(true); } else { this._show(true); } } _show(pin = false) { if (pin) { this.pinned = true; } if (this.hideElement.hidden) { this.hideElement.hidden = false; this.container.style.zIndex = parseInt(this.container.style.zIndex) + 1000; } } _hide(unpin = true) { if (unpin) { this.pinned = false; } if (!this.hideElement.hidden &amp;&amp; !this.pinned) { this.hideElement.hidden = true; this.container.style.zIndex = parseInt(this.container.style.zIndex) - 1000; } } } class FreeTextAnnotationElement extends AnnotationElement { constructor(parameters) { const isRenderable = !!(parameters.data.hasPopup || parameters.data.titleObj?.str || parameters.data.contentsObj?.str || parameters.data.richText?.str); super(parameters, { isRenderable, ignoreBorder: true }); this.textContent = parameters.data.textContent; } render() { this.container.className = &quot;freeTextAnnotation&quot;; if (this.textContent) { const content = document.createElement(&quot;div&quot;); content.className = &quot;annotationTextContent&quot;; content.setAttribute(&quot;role&quot;, &quot;comment&quot;); for (const line of this.textContent) { const lineSpan = document.createElement(&quot;span&quot;); lineSpan.textContent = line; content.append(lineSpan); } this.container.append(content); } if (!this.data.hasPopup) { this._createPopup(null, this.data); } return this.container; } } class LineAnnotationElement extends AnnotationElement { constructor(parameters) { const isRenderable = !!(parameters.data.hasPopup || parameters.data.titleObj?.str || parameters.data.contentsObj?.str || parameters.data.richText?.str); super(parameters, { isRenderable, ignoreBorder: true }); } render() { this.container.className = &quot;lineAnnotation&quot;; const data = this.data; const { width, height } = getRectDims(data.rect); const svg = this.svgFactory.create(width, height, true); const line = this.svgFactory.createElement(&quot;svg:line&quot;); line.setAttribute(&quot;x1&quot;, data.rect[2] - data.lineCoordinates[0]); line.setAttribute(&quot;y1&quot;, data.rect[3] - data.lineCoordinates[1]); line.setAttribute(&quot;x2&quot;, data.rect[2] - data.lineCoordinates[2]); line.setAttribute(&quot;y2&quot;, data.rect[3] - data.lineCoordinates[3]); line.setAttribute(&quot;stroke-width&quot;, data.borderStyle.width || 1); line.setAttribute(&quot;stroke&quot;, &quot;transparent&quot;); line.setAttribute(&quot;fill&quot;, &quot;transparent&quot;); svg.append(line); this.container.append(svg); this._createPopup(line, data); return this.container; } } class SquareAnnotationElement extends AnnotationElement { constructor(parameters) { const isRenderable = !!(parameters.data.hasPopup || parameters.data.titleObj?.str || parameters.data.contentsObj?.str || parameters.data.richText?.str); super(parameters, { isRenderable, ignoreBorder: true }); } render() { this.container.className = &quot;squareAnnotation&quot;; const data = this.data; const { width, height } = getRectDims(data.rect); const svg = this.svgFactory.create(width, height, true); const borderWidth = data.borderStyle.width; const square = this.svgFactory.createElement(&quot;svg:rect&quot;); square.setAttribute(&quot;x&quot;, borderWidth / 2); square.setAttribute(&quot;y&quot;, borderWidth / 2); square.setAttribute(&quot;width&quot;, width - borderWidth); square.setAttribute(&quot;height&quot;, height - borderWidth); square.setAttribute(&quot;stroke-width&quot;, borderWidth || 1); square.setAttribute(&quot;stroke&quot;, &quot;transparent&quot;); square.setAttribute(&quot;fill&quot;, &quot;transparent&quot;); svg.append(square); this.container.append(svg); this._createPopup(square, data); return this.container; } } class CircleAnnotationElement extends AnnotationElement { constructor(parameters) { const isRenderable = !!(parameters.data.hasPopup || parameters.data.titleObj?.str || parameters.data.contentsObj?.str || parameters.data.richText?.str); super(parameters, { isRenderable, ignoreBorder: true }); } render() { this.container.className = &quot;circleAnnotation&quot;; const data = this.data; const { width, height } = getRectDims(data.rect); const svg = this.svgFactory.create(width, height, true); const borderWidth = data.borderStyle.width; const circle = this.svgFactory.createElement(&quot;svg:ellipse&quot;); circle.setAttribute(&quot;cx&quot;, width / 2); circle.setAttribute(&quot;cy&quot;, height / 2); circle.setAttribute(&quot;rx&quot;, width / 2 - borderWidth / 2); circle.setAttribute(&quot;ry&quot;, height / 2 - borderWidth / 2); circle.setAttribute(&quot;stroke-width&quot;, borderWidth || 1); circle.setAttribute(&quot;stroke&quot;, &quot;transparent&quot;); circle.setAttribute(&quot;fill&quot;, &quot;transparent&quot;); svg.append(circle); this.container.append(svg); this._createPopup(circle, data); return this.container; } } class PolylineAnnotationElement extends AnnotationElement { constructor(parameters) { const isRenderable = !!(parameters.data.hasPopup || parameters.data.titleObj?.str || parameters.data.contentsObj?.str || parameters.data.richText?.str); super(parameters, { isRenderable, ignoreBorder: true }); this.containerClassName = &quot;polylineAnnotation&quot;; this.svgElementName = &quot;svg:polyline&quot;; } render() { this.container.className = this.containerClassName; const data = this.data; const { width, height } = getRectDims(data.rect); const svg = this.svgFactory.create(width, height, true); let points = []; for (const coordinate of data.vertices) { const x = coordinate.x - data.rect[0]; const y = data.rect[3] - coordinate.y; points.push(x + &quot;,&quot; + y); } points = points.join(&quot; &quot;); const polyline = this.svgFactory.createElement(this.svgElementName); polyline.setAttribute(&quot;points&quot;, points); polyline.setAttribute(&quot;stroke-width&quot;, data.borderStyle.width || 1); polyline.setAttribute(&quot;stroke&quot;, &quot;transparent&quot;); polyline.setAttribute(&quot;fill&quot;, &quot;transparent&quot;); svg.append(polyline); this.container.append(svg); this._createPopup(polyline, data); return this.container; } } class PolygonAnnotationElement extends PolylineAnnotationElement { constructor(parameters) { super(parameters); this.containerClassName = &quot;polygonAnnotation&quot;; this.svgElementName = &quot;svg:polygon&quot;; } } class CaretAnnotationElement extends AnnotationElement { constructor(parameters) { const isRenderable = !!(parameters.data.hasPopup || parameters.data.titleObj?.str || parameters.data.contentsObj?.str || parameters.data.richText?.str); super(parameters, { isRenderable, ignoreBorder: true }); } render() { this.container.className = &quot;caretAnnotation&quot;; if (!this.data.hasPopup) { this._createPopup(null, this.data); } return this.container; } } class InkAnnotationElement extends AnnotationElement { constructor(parameters) { const isRenderable = !!(parameters.data.hasPopup || parameters.data.titleObj?.str || parameters.data.contentsObj?.str || parameters.data.richText?.str); super(parameters, { isRenderable, ignoreBorder: true }); this.containerClassName = &quot;inkAnnotation&quot;; this.svgElementName = &quot;svg:polyline&quot;; } render() { this.container.className = this.containerClassName; const data = this.data; const { width, height } = getRectDims(data.rect); const svg = this.svgFactory.create(width, height, true); for (const inkList of data.inkLists) { let points = []; for (const coordinate of inkList) { const x = coordinate.x - data.rect[0]; const y = data.rect[3] - coordinate.y; points.push(`${x},${y}`); } points = points.join(&quot; &quot;); const polyline = this.svgFactory.createElement(this.svgElementName); polyline.setAttribute(&quot;points&quot;, points); polyline.setAttribute(&quot;stroke-width&quot;, data.borderStyle.width || 1); polyline.setAttribute(&quot;stroke&quot;, &quot;transparent&quot;); polyline.setAttribute(&quot;fill&quot;, &quot;transparent&quot;); this._createPopup(polyline, data); svg.append(polyline); } this.container.append(svg); return this.container; } } class HighlightAnnotationElement extends AnnotationElement { constructor(parameters) { const isRenderable = !!(parameters.data.hasPopup || parameters.data.titleObj?.str || parameters.data.contentsObj?.str || parameters.data.richText?.str); super(parameters, { isRenderable, ignoreBorder: true, createQuadrilaterals: true }); } render() { if (!this.data.hasPopup) { this._createPopup(null, this.data); } if (this.quadrilaterals) { return this._renderQuadrilaterals(&quot;highlightAnnotation&quot;); } this.container.className = &quot;highlightAnnotation&quot;; return this.container; } } class UnderlineAnnotationElement extends AnnotationElement { constructor(parameters) { const isRenderable = !!(parameters.data.hasPopup || parameters.data.titleObj?.str || parameters.data.contentsObj?.str || parameters.data.richText?.str); super(parameters, { isRenderable, ignoreBorder: true, createQuadrilaterals: true }); } render() { if (!this.data.hasPopup) { this._createPopup(null, this.data); } if (this.quadrilaterals) { return this._renderQuadrilaterals(&quot;underlineAnnotation&quot;); } this.container.className = &quot;underlineAnnotation&quot;; return this.container; } } class SquigglyAnnotationElement extends AnnotationElement { constructor(parameters) { const isRenderable = !!(parameters.data.hasPopup || parameters.data.titleObj?.str || parameters.data.contentsObj?.str || parameters.data.richText?.str); super(parameters, { isRenderable, ignoreBorder: true, createQuadrilaterals: true }); } render() { if (!this.data.hasPopup) { this._createPopup(null, this.data); } if (this.quadrilaterals) { return this._renderQuadrilaterals(&quot;squigglyAnnotation&quot;); } this.container.className = &quot;squigglyAnnotation&quot;; return this.container; } } class StrikeOutAnnotationElement extends AnnotationElement { constructor(parameters) { const isRenderable = !!(parameters.data.hasPopup || parameters.data.titleObj?.str || parameters.data.contentsObj?.str || parameters.data.richText?.str); super(parameters, { isRenderable, ignoreBorder: true, createQuadrilaterals: true }); } render() { if (!this.data.hasPopup) { this._createPopup(null, this.data); } if (this.quadrilaterals) { return this._renderQuadrilaterals(&quot;strikeoutAnnotation&quot;); } this.container.className = &quot;strikeoutAnnotation&quot;; return this.container; } } class StampAnnotationElement extends AnnotationElement { constructor(parameters) { const isRenderable = !!(parameters.data.hasPopup || parameters.data.titleObj?.str || parameters.data.contentsObj?.str || parameters.data.richText?.str); super(parameters, { isRenderable, ignoreBorder: true }); } render() { this.container.className = &quot;stampAnnotation&quot;; if (!this.data.hasPopup) { this._createPopup(null, this.data); } return this.container; } } class FileAttachmentAnnotationElement extends AnnotationElement { constructor(parameters) { super(parameters, { isRenderable: true }); const { filename, content } = this.data.file; this.filename = (0, _display_utils.getFilenameFromUrl)(filename); this.content = content; this.linkService.eventBus?.dispatch(&quot;fileattachmentannotation&quot;, { source: this, filename, content }); } render() { this.container.className = &quot;fileAttachmentAnnotation&quot;; const trigger = document.createElement(&quot;div&quot;); trigger.className = &quot;popupTriggerArea&quot;; trigger.addEventListener(&quot;dblclick&quot;, this._download.bind(this)); if (!this.data.hasPopup &amp;&amp; (this.data.titleObj?.str || this.data.contentsObj?.str || this.data.richText)) { this._createPopup(trigger, this.data); } this.container.append(trigger); return this.container; } _download() { this.downloadManager?.openOrDownloadData(this.container, this.content, this.filename); } } class AnnotationLayer { static #appendElement(element, id, div, accessibilityManager) { const contentElement = element.firstChild || element; contentElement.id = `${_display_utils.AnnotationPrefix}${id}`; div.append(element); accessibilityManager?.moveElementInDOM(div, element, contentElement, false); } static render(parameters) { const { annotations, div, viewport, accessibilityManager } = parameters; this.#setDimensions(div, viewport); let zIndex = 0; for (const data of annotations) { if (data.annotationType !== _util.AnnotationType.POPUP) { const { width, height } = getRectDims(data.rect); if (width &lt;= 0 || height &lt;= 0) { continue; } } const element = AnnotationElementFactory.create({ data, layer: div, page: parameters.page, viewport, linkService: parameters.linkService, downloadManager: parameters.downloadManager, imageResourcesPath: parameters.imageResourcesPath || &quot;&quot;, renderForms: parameters.renderForms !== false, svgFactory: new _display_utils.DOMSVGFactory(), annotationStorage: parameters.annotationStorage || new _annotation_storage.AnnotationStorage(), enableScripting: parameters.enableScripting, hasJSActions: parameters.hasJSActions, fieldObjects: parameters.fieldObjects, mouseState: parameters.mouseState || { isDown: false } }); if (element.isRenderable) { const rendered = element.render(); if (data.hidden) { rendered.style.visibility = &quot;hidden&quot;; } if (Array.isArray(rendered)) { for (const renderedElement of rendered) { renderedElement.style.zIndex = zIndex++; AnnotationLayer.#appendElement(renderedElement, data.id, div, accessibilityManager); } } else { rendered.style.zIndex = zIndex++; if (element instanceof PopupAnnotationElement) { div.prepend(rendered); } else { AnnotationLayer.#appendElement(rendered, data.id, div, accessibilityManager); } } } } this.#setAnnotationCanvasMap(div, parameters.annotationCanvasMap); } static update(parameters) { const { annotationCanvasMap, div, viewport } = parameters; this.#setDimensions(div, viewport); this.#setAnnotationCanvasMap(div, annotationCanvasMap); div.hidden = false; } static #setDimensions(div, { width, height, rotation }) { const { style } = div; const flipOrientation = rotation % 180 !== 0, widthStr = Math.floor(width) + &quot;px&quot;, heightStr = Math.floor(height) + &quot;px&quot;; style.width = flipOrientation ? heightStr : widthStr; style.height = flipOrientation ? widthStr : heightStr; div.setAttribute(&quot;data-main-rotation&quot;, rotation); } static #setAnnotationCanvasMap(div, annotationCanvasMap) { if (!annotationCanvasMap) { return; } for (const [id, canvas] of annotationCanvasMap) { const element = div.querySelector(`[data-annotation-id=&quot;${id}&quot;]`); if (!element) { continue; } const { firstChild } = element; if (!firstChild) { element.append(canvas); } else if (firstChild.nodeName === &quot;CANVAS&quot;) { firstChild.replaceWith(canvas); } else { firstChild.before(canvas); } } annotationCanvasMap.clear(); } } exports.AnnotationLayer = AnnotationLayer; /***/ }), /* 27 */ /***/ ((__unused_webpack_module, exports) =&gt; { Object.defineProperty(exports, &quot;__esModule&quot;, ({ value: true })); exports.ColorConverters = void 0; function makeColorComp(n) { return Math.floor(Math.max(0, Math.min(1, n)) * 255).toString(16).padStart(2, &quot;0&quot;); } class ColorConverters { static CMYK_G([c, y, m, k]) { return [&quot;G&quot;, 1 - Math.min(1, 0.3 * c + 0.59 * m + 0.11 * y + k)]; } static G_CMYK([g]) { return [&quot;CMYK&quot;, 0, 0, 0, 1 - g]; } static G_RGB([g]) { return [&quot;RGB&quot;, g, g, g]; } static G_HTML([g]) { const G = makeColorComp(g); return `#${G}${G}${G}`; } static RGB_G([r, g, b]) { return [&quot;G&quot;, 0.3 * r + 0.59 * g + 0.11 * b]; } static RGB_HTML([r, g, b]) { const R = makeColorComp(r); const G = makeColorComp(g); const B = makeColorComp(b); return `#${R}${G}${B}`; } static T_HTML() { return &quot;#00000000&quot;; } static CMYK_RGB([c, y, m, k]) { return [&quot;RGB&quot;, 1 - Math.min(1, c + k), 1 - Math.min(1, m + k), 1 - Math.min(1, y + k)]; } static CMYK_HTML(components) { const rgb = this.CMYK_RGB(components).slice(1); return this.RGB_HTML(rgb); } static RGB_CMYK([r, g, b]) { const c = 1 - r; const m = 1 - g; const y = 1 - b; const k = Math.min(c, m, y); return [&quot;CMYK&quot;, c, m, y, k]; } } exports.ColorConverters = ColorConverters; /***/ }), /* 28 */ /***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) =&gt; { Object.defineProperty(exports, &quot;__esModule&quot;, ({ value: true })); exports.XfaLayer = void 0; var _xfa_text = __w_pdfjs_require__(19); class XfaLayer { static setupStorage(html, id, element, storage, intent) { const storedData = storage.getValue(id, { value: null }); switch (element.name) { case &quot;textarea&quot;: if (storedData.value !== null) { html.textContent = storedData.value; } if (intent === &quot;print&quot;) { break; } html.addEventListener(&quot;input&quot;, event =&gt; { storage.setValue(id, { value: event.target.value }); }); break; case &quot;input&quot;: if (element.attributes.type === &quot;radio&quot; || element.attributes.type === &quot;checkbox&quot;) { if (storedData.value === element.attributes.xfaOn) { html.setAttribute(&quot;checked&quot;, true); } else if (storedData.value === element.attributes.xfaOff) { html.removeAttribute(&quot;checked&quot;); } if (intent === &quot;print&quot;) { break; } html.addEventListener(&quot;change&quot;, event =&gt; { storage.setValue(id, { value: event.target.checked ? event.target.getAttribute(&quot;xfaOn&quot;) : event.target.getAttribute(&quot;xfaOff&quot;) }); }); } else { if (storedData.value !== null) { html.setAttribute(&quot;value&quot;, storedData.value); } if (intent === &quot;print&quot;) { break; } html.addEventListener(&quot;input&quot;, event =&gt; { storage.setValue(id, { value: event.target.value }); }); } break; case &quot;select&quot;: if (storedData.value !== null) { for (const option of element.children) { if (option.attributes.value === storedData.value) { option.attributes.selected = true; } } } html.addEventListener(&quot;input&quot;, event =&gt; { const options = event.target.options; const value = options.selectedIndex === -1 ? &quot;&quot; : options[options.selectedIndex].value; storage.setValue(id, { value }); }); break; } } static setAttributes({ html, element, storage = null, intent, linkService }) { const { attributes } = element; const isHTMLAnchorElement = html instanceof HTMLAnchorElement; if (attributes.type === &quot;radio&quot;) { attributes.name = `${attributes.name}-${intent}`; } for (const [key, value] of Object.entries(attributes)) { if (value === null || value === undefined) { continue; } switch (key) { case &quot;class&quot;: if (value.length) { html.setAttribute(key, value.join(&quot; &quot;)); } break; case &quot;dataId&quot;: break; case &quot;id&quot;: html.setAttribute(&quot;data-element-id&quot;, value); break; case &quot;style&quot;: Object.assign(html.style, value); break; case &quot;textContent&quot;: html.textContent = value; break; default: if (!isHTMLAnchorElement || key !== &quot;href&quot; &amp;&amp; key !== &quot;newWindow&quot;) { html.setAttribute(key, value); } } } if (isHTMLAnchorElement) { linkService.addLinkAttributes(html, attributes.href, attributes.newWindow); } if (storage &amp;&amp; attributes.dataId) { this.setupStorage(html, attributes.dataId, element, storage); } } static render(parameters) { const storage = parameters.annotationStorage; const linkService = parameters.linkService; const root = parameters.xfaHtml; const intent = parameters.intent || &quot;display&quot;; const rootHtml = document.createElement(root.name); if (root.attributes) { this.setAttributes({ html: rootHtml, element: root, intent, linkService }); } const stack = [[root, -1, rootHtml]]; const rootDiv = parameters.div; rootDiv.append(rootHtml); if (parameters.viewport) { const transform = `matrix(${parameters.viewport.transform.join(&quot;,&quot;)})`; rootDiv.style.transform = transform; } if (intent !== &quot;richText&quot;) { rootDiv.setAttribute(&quot;class&quot;, &quot;xfaLayer xfaFont&quot;); } const textDivs = []; while (stack.length &gt; 0) { const [parent, i, html] = stack.at(-1); if (i + 1 === parent.children.length) { stack.pop(); continue; } const child = parent.children[++stack.at(-1)[1]]; if (child === null) { continue; } const { name } = child; if (name === &quot;#text&quot;) { const node = document.createTextNode(child.value); textDivs.push(node); html.append(node); continue; } let childHtml; if (child?.attributes?.xmlns) { childHtml = document.createElementNS(child.attributes.xmlns, name); } else { childHtml = document.createElement(name); } html.append(childHtml); if (child.attributes) { this.setAttributes({ html: childHtml, element: child, storage, intent, linkService }); } if (child.children &amp;&amp; child.children.length &gt; 0) { stack.push([child, -1, childHtml]); } else if (child.value) { const node = document.createTextNode(child.value); if (_xfa_text.XfaText.shouldBuildText(name)) { textDivs.push(node); } childHtml.append(node); } } for (const el of rootDiv.querySelectorAll(&quot;.xfaNonInteractive input, .xfaNonInteractive textarea&quot;)) { el.setAttribute(&quot;readOnly&quot;, true); } return { textDivs }; } static update(parameters) { const transform = `matrix(${parameters.viewport.transform.join(&quot;,&quot;)})`; parameters.div.style.transform = transform; parameters.div.hidden = false; } } exports.XfaLayer = XfaLayer; /***/ }), /* 29 */ /***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) =&gt; { Object.defineProperty(exports, &quot;__esModule&quot;, ({ value: true })); exports.TextLayerRenderTask = void 0; exports.renderTextLayer = renderTextLayer; var _util = __w_pdfjs_require__(1); const MAX_TEXT_DIVS_TO_RENDER = 100000; const DEFAULT_FONT_SIZE = 30; const DEFAULT_FONT_ASCENT = 0.8; const ascentCache = new Map(); function getAscent(fontFamily, ctx) { const cachedAscent = ascentCache.get(fontFamily); if (cachedAscent) { return cachedAscent; } ctx.save(); ctx.font = `${DEFAULT_FONT_SIZE}px ${fontFamily}`; const metrics = ctx.measureText(&quot;&quot;); let ascent = metrics.fontBoundingBoxAscent; let descent = Math.abs(metrics.fontBoundingBoxDescent); if (ascent) { ctx.restore(); const ratio = ascent / (ascent + descent); ascentCache.set(fontFamily, ratio); return ratio; } ctx.strokeStyle = &quot;red&quot;; ctx.clearRect(0, 0, DEFAULT_FONT_SIZE, DEFAULT_FONT_SIZE); ctx.strokeText(&quot;g&quot;, 0, 0); let pixels = ctx.getImageData(0, 0, DEFAULT_FONT_SIZE, DEFAULT_FONT_SIZE).data; descent = 0; for (let i = pixels.length - 1 - 3; i &gt;= 0; i -= 4) { if (pixels[i] &gt; 0) { descent = Math.ceil(i / 4 / DEFAULT_FONT_SIZE); break; } } ctx.clearRect(0, 0, DEFAULT_FONT_SIZE, DEFAULT_FONT_SIZE); ctx.strokeText(&quot;A&quot;, 0, DEFAULT_FONT_SIZE); pixels = ctx.getImageData(0, 0, DEFAULT_FONT_SIZE, DEFAULT_FONT_SIZE).data; ascent = 0; for (let i = 0, ii = pixels.length; i &lt; ii; i += 4) { if (pixels[i] &gt; 0) { ascent = DEFAULT_FONT_SIZE - Math.floor(i / 4 / DEFAULT_FONT_SIZE); break; } } ctx.restore(); if (ascent) { const ratio = ascent / (ascent + descent); ascentCache.set(fontFamily, ratio); return ratio; } ascentCache.set(fontFamily, DEFAULT_FONT_ASCENT); return DEFAULT_FONT_ASCENT; } function appendText(task, geom, styles, ctx) { const textDiv = document.createElement(&quot;span&quot;); const textDivProperties = { angle: 0, canvasWidth: 0, hasText: geom.str !== &quot;&quot;, hasEOL: geom.hasEOL, fontSize: 0 }; task._textDivs.push(textDiv); const tx = _util.Util.transform(task._viewport.transform, geom.transform); let angle = Math.atan2(tx[1], tx[0]); const style = styles[geom.fontName]; if (style.vertical) { angle += Math.PI / 2; } const fontHeight = Math.hypot(tx[2], tx[3]); const fontAscent = fontHeight * getAscent(style.fontFamily, ctx); let left, top; if (angle === 0) { left = tx[4]; top = tx[5] - fontAscent; } else { left = tx[4] + fontAscent * Math.sin(angle); top = tx[5] - fontAscent * Math.cos(angle); } textDiv.style.left = `${left}px`; textDiv.style.top = `${top}px`; textDiv.style.fontSize = `${fontHeight}px`; textDiv.style.fontFamily = style.fontFamily; textDivProperties.fontSize = fontHeight; textDiv.setAttribute(&quot;role&quot;, &quot;presentation&quot;); textDiv.textContent = geom.str; textDiv.dir = geom.dir; if (task._fontInspectorEnabled) { textDiv.dataset.fontName = geom.fontName; } if (angle !== 0) { textDivProperties.angle = angle * (180 / Math.PI); } let shouldScaleText = false; if (geom.str.length &gt; 1) { shouldScaleText = true; } else if (geom.str !== &quot; &quot; &amp;&amp; geom.transform[0] !== geom.transform[3]) { const absScaleX = Math.abs(geom.transform[0]), absScaleY = Math.abs(geom.transform[3]); if (absScaleX !== absScaleY &amp;&amp; Math.max(absScaleX, absScaleY) / Math.min(absScaleX, absScaleY) &gt; 1.5) { shouldScaleText = true; } } if (shouldScaleText) { if (style.vertical) { textDivProperties.canvasWidth = geom.height * task._viewport.scale; } else { textDivProperties.canvasWidth = geom.width * task._viewport.scale; } } task._textDivProperties.set(textDiv, textDivProperties); if (task._textContentStream) { task._layoutText(textDiv); } } function render(task) { if (task._canceled) { return; } const textDivs = task._textDivs; const capability = task._capability; const textDivsLength = textDivs.length; if (textDivsLength &gt; MAX_TEXT_DIVS_TO_RENDER) { task._renderingDone = true; capability.resolve(); return; } if (!task._textContentStream) { for (const textDiv of textDivs) { task._layoutText(textDiv); } } task._renderingDone = true; capability.resolve(); } class TextLayerRenderTask { constructor({ textContent, textContentStream, container, viewport, textDivs, textContentItemsStr }) { this._textContent = textContent; this._textContentStream = textContentStream; this._container = container; this._document = container.ownerDocument; this._viewport = viewport; this._textDivs = textDivs || []; this._textContentItemsStr = textContentItemsStr || []; this._fontInspectorEnabled = !!globalThis.FontInspector?.enabled; this._reader = null; this._layoutTextLastFontSize = null; this._layoutTextLastFontFamily = null; this._layoutTextCtx = null; this._textDivProperties = new WeakMap(); this._renderingDone = false; this._canceled = false; this._capability = (0, _util.createPromiseCapability)(); this._renderTimer = null; this._bounds = []; this._devicePixelRatio = globalThis.devicePixelRatio || 1; this._capability.promise.finally(() =&gt; { this._textDivProperties = null; if (this._layoutTextCtx) { this._layoutTextCtx.canvas.width = 0; this._layoutTextCtx.canvas.height = 0; this._layoutTextCtx = null; } }).catch(() =&gt; {}); } get promise() { return this._capability.promise; } cancel() { this._canceled = true; if (this._reader) { this._reader.cancel(new _util.AbortException(&quot;TextLayer task cancelled.&quot;)).catch(() =&gt; {}); this._reader = null; } if (this._renderTimer !== null) { clearTimeout(this._renderTimer); this._renderTimer = null; } this._capability.reject(new Error(&quot;TextLayer task cancelled.&quot;)); } _processItems(items, styleCache) { for (const item of items) { if (item.str === undefined) { if (item.type === &quot;beginMarkedContentProps&quot; || item.type === &quot;beginMarkedContent&quot;) { const parent = this._container; this._container = document.createElement(&quot;span&quot;); this._container.classList.add(&quot;markedContent&quot;); if (item.id !== null) { this._container.setAttribute(&quot;id&quot;, `${item.id}`); } parent.append(this._container); } else if (item.type === &quot;endMarkedContent&quot;) { this._container = this._container.parentNode; } continue; } this._textContentItemsStr.push(item.str); appendText(this, item, styleCache, this._layoutTextCtx); } } _layoutText(textDiv) { const textDivProperties = this._textDivProperties.get(textDiv); let transform = &quot;&quot;; if (textDivProperties.canvasWidth !== 0 &amp;&amp; textDivProperties.hasText) { const { fontFamily } = textDiv.style; const { fontSize } = textDivProperties; if (fontSize !== this._layoutTextLastFontSize || fontFamily !== this._layoutTextLastFontFamily) { this._layoutTextCtx.font = `${fontSize * this._devicePixelRatio}px ${fontFamily}`; this._layoutTextLastFontSize = fontSize; this._layoutTextLastFontFamily = fontFamily; } const { width } = this._layoutTextCtx.measureText(textDiv.textContent); if (width &gt; 0) { transform = `scaleX(${this._devicePixelRatio * textDivProperties.canvasWidth / width})`; } } if (textDivProperties.angle !== 0) { transform = `rotate(${textDivProperties.angle}deg) ${transform}`; } if (transform.length &gt; 0) { textDiv.style.transform = transform; } if (textDivProperties.hasText) { this._container.append(textDiv); } if (textDivProperties.hasEOL) { const br = document.createElement(&quot;br&quot;); br.setAttribute(&quot;role&quot;, &quot;presentation&quot;); this._container.append(br); } } _render(timeout = 0) { const capability = (0, _util.createPromiseCapability)(); let styleCache = Object.create(null); const canvas = this._document.createElement(&quot;canvas&quot;); canvas.height = canvas.width = DEFAULT_FONT_SIZE; this._layoutTextCtx = canvas.getContext(&quot;2d&quot;, { alpha: false }); if (this._textContent) { const textItems = this._textContent.items; const textStyles = this._textContent.styles; this._processItems(textItems, textStyles); capability.resolve(); } else if (this._textContentStream) { const pump = () =&gt; { this._reader.read().then(({ value, done }) =&gt; { if (done) { capability.resolve(); return; } Object.assign(styleCache, value.styles); this._processItems(value.items, styleCache); pump(); }, capability.reject); }; this._reader = this._textContentStream.getReader(); pump(); } else { throw new Error(&apos;Neither &quot;textContent&quot; nor &quot;textContentStream&quot; parameters specified.&apos;); } capability.promise.then(() =&gt; { styleCache = null; if (!timeout) { render(this); } else { this._renderTimer = setTimeout(() =&gt; { render(this); this._renderTimer = null; }, timeout); } }, this._capability.reject); } } exports.TextLayerRenderTask = TextLayerRenderTask; function renderTextLayer(renderParameters) { const task = new TextLayerRenderTask({ textContent: renderParameters.textContent, textContentStream: renderParameters.textContentStream, container: renderParameters.container, viewport: renderParameters.viewport, textDivs: renderParameters.textDivs, textContentItemsStr: renderParameters.textContentItemsStr }); task._render(renderParameters.timeout); return task; } /***/ }), /* 30 */ /***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) =&gt; { Object.defineProperty(exports, &quot;__esModule&quot;, ({ value: true })); exports.SVGGraphics = void 0; var _display_utils = __w_pdfjs_require__(6); var _util = __w_pdfjs_require__(1); var _is_node = __w_pdfjs_require__(12); let SVGGraphics = class { constructor() { (0, _util.unreachable)(&quot;Not implemented: SVGGraphics&quot;); } }; exports.SVGGraphics = SVGGraphics; { const SVG_DEFAULTS = { fontStyle: &quot;normal&quot;, fontWeight: &quot;normal&quot;, fillColor: &quot;#000000&quot; }; const XML_NS = &quot;http://www.w3.org/XML/1998/namespace&quot;; const XLINK_NS = &quot;http://www.w3.org/1999/xlink&quot;; const LINE_CAP_STYLES = [&quot;butt&quot;, &quot;round&quot;, &quot;square&quot;]; const LINE_JOIN_STYLES = [&quot;miter&quot;, &quot;round&quot;, &quot;bevel&quot;]; const createObjectURL = function (data, contentType = &quot;&quot;, forceDataSchema = false) { if (URL.createObjectURL &amp;&amp; typeof Blob !== &quot;undefined&quot; &amp;&amp; !forceDataSchema) { return URL.createObjectURL(new Blob([data], { type: contentType })); } const digits = &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=&quot;; let buffer = `data:${contentType};base64,`; for (let i = 0, ii = data.length; i &lt; ii; i += 3) { const b1 = data[i] &amp; 0xff; const b2 = data[i + 1] &amp; 0xff; const b3 = data[i + 2] &amp; 0xff; const d1 = b1 &gt;&gt; 2, d2 = (b1 &amp; 3) &lt;&lt; 4 | b2 &gt;&gt; 4; const d3 = i + 1 &lt; ii ? (b2 &amp; 0xf) &lt;&lt; 2 | b3 &gt;&gt; 6 : 64; const d4 = i + 2 &lt; ii ? b3 &amp; 0x3f : 64; buffer += digits[d1] + digits[d2] + digits[d3] + digits[d4]; } return buffer; }; const convertImgDataToPng = function () { const PNG_HEADER = new Uint8Array([0x89, 0x50, 0x4e, 0x47, 0x0d, 0x0a, 0x1a, 0x0a]); const CHUNK_WRAPPER_SIZE = 12; const crcTable = new Int32Array(256); for (let i = 0; i &lt; 256; i++) { let c = i; for (let h = 0; h &lt; 8; h++) { if (c &amp; 1) { c = 0xedb88320 ^ c &gt;&gt; 1 &amp; 0x7fffffff; } else { c = c &gt;&gt; 1 &amp; 0x7fffffff; } } crcTable[i] = c; } function crc32(data, start, end) { let crc = -1; for (let i = start; i &lt; end; i++) { const a = (crc ^ data[i]) &amp; 0xff; const b = crcTable[a]; crc = crc &gt;&gt;&gt; 8 ^ b; } return crc ^ -1; } function writePngChunk(type, body, data, offset) { let p = offset; const len = body.length; data[p] = len &gt;&gt; 24 &amp; 0xff; data[p + 1] = len &gt;&gt; 16 &amp; 0xff; data[p + 2] = len &gt;&gt; 8 &amp; 0xff; data[p + 3] = len &amp; 0xff; p += 4; data[p] = type.charCodeAt(0) &amp; 0xff; data[p + 1] = type.charCodeAt(1) &amp; 0xff; data[p + 2] = type.charCodeAt(2) &amp; 0xff; data[p + 3] = type.charCodeAt(3) &amp; 0xff; p += 4; data.set(body, p); p += body.length; const crc = crc32(data, offset + 4, p); data[p] = crc &gt;&gt; 24 &amp; 0xff; data[p + 1] = crc &gt;&gt; 16 &amp; 0xff; data[p + 2] = crc &gt;&gt; 8 &amp; 0xff; data[p + 3] = crc &amp; 0xff; } function adler32(data, start, end) { let a = 1; let b = 0; for (let i = start; i &lt; end; ++i) { a = (a + (data[i] &amp; 0xff)) % 65521; b = (b + a) % 65521; } return b &lt;&lt; 16 | a; } function deflateSync(literals) { if (!_is_node.isNodeJS) { return deflateSyncUncompressed(literals); } try { let input; if (parseInt(process.versions.node) &gt;= 8) { input = literals; } else { input = Buffer.from(literals); } const output = require(&quot;zlib&quot;).deflateSync(input, { level: 9 }); return output instanceof Uint8Array ? output : new Uint8Array(output); } catch (e) { (0, _util.warn)(&quot;Not compressing PNG because zlib.deflateSync is unavailable: &quot; + e); } return deflateSyncUncompressed(literals); } function deflateSyncUncompressed(literals) { let len = literals.length; const maxBlockLength = 0xffff; const deflateBlocks = Math.ceil(len / maxBlockLength); const idat = new Uint8Array(2 + len + deflateBlocks * 5 + 4); let pi = 0; idat[pi++] = 0x78; idat[pi++] = 0x9c; let pos = 0; while (len &gt; maxBlockLength) { idat[pi++] = 0x00; idat[pi++] = 0xff; idat[pi++] = 0xff; idat[pi++] = 0x00; idat[pi++] = 0x00; idat.set(literals.subarray(pos, pos + maxBlockLength), pi); pi += maxBlockLength; pos += maxBlockLength; len -= maxBlockLength; } idat[pi++] = 0x01; idat[pi++] = len &amp; 0xff; idat[pi++] = len &gt;&gt; 8 &amp; 0xff; idat[pi++] = ~len &amp; 0xffff &amp; 0xff; idat[pi++] = (~len &amp; 0xffff) &gt;&gt; 8 &amp; 0xff; idat.set(literals.subarray(pos), pi); pi += literals.length - pos; const adler = adler32(literals, 0, literals.length); idat[pi++] = adler &gt;&gt; 24 &amp; 0xff; idat[pi++] = adler &gt;&gt; 16 &amp; 0xff; idat[pi++] = adler &gt;&gt; 8 &amp; 0xff; idat[pi++] = adler &amp; 0xff; return idat; } function encode(imgData, kind, forceDataSchema, isMask) { const width = imgData.width; const height = imgData.height; let bitDepth, colorType, lineSize; const bytes = imgData.data; switch (kind) { case _util.ImageKind.GRAYSCALE_1BPP: colorType = 0; bitDepth = 1; lineSize = width + 7 &gt;&gt; 3; break; case _util.ImageKind.RGB_24BPP: colorType = 2; bitDepth = 8; lineSize = width * 3; break; case _util.ImageKind.RGBA_32BPP: colorType = 6; bitDepth = 8; lineSize = width * 4; break; default: throw new Error(&quot;invalid format&quot;); } const literals = new Uint8Array((1 + lineSize) * height); let offsetLiterals = 0, offsetBytes = 0; for (let y = 0; y &lt; height; ++y) { literals[offsetLiterals++] = 0; literals.set(bytes.subarray(offsetBytes, offsetBytes + lineSize), offsetLiterals); offsetBytes += lineSize; offsetLiterals += lineSize; } if (kind === _util.ImageKind.GRAYSCALE_1BPP &amp;&amp; isMask) { offsetLiterals = 0; for (let y = 0; y &lt; height; y++) { offsetLiterals++; for (let i = 0; i &lt; lineSize; i++) { literals[offsetLiterals++] ^= 0xff; } } } const ihdr = new Uint8Array([width &gt;&gt; 24 &amp; 0xff, width &gt;&gt; 16 &amp; 0xff, width &gt;&gt; 8 &amp; 0xff, width &amp; 0xff, height &gt;&gt; 24 &amp; 0xff, height &gt;&gt; 16 &amp; 0xff, height &gt;&gt; 8 &amp; 0xff, height &amp; 0xff, bitDepth, colorType, 0x00, 0x00, 0x00]); const idat = deflateSync(literals); const pngLength = PNG_HEADER.length + CHUNK_WRAPPER_SIZE * 3 + ihdr.length + idat.length; const data = new Uint8Array(pngLength); let offset = 0; data.set(PNG_HEADER, offset); offset += PNG_HEADER.length; writePngChunk(&quot;IHDR&quot;, ihdr, data, offset); offset += CHUNK_WRAPPER_SIZE + ihdr.length; writePngChunk(&quot;IDATA&quot;, idat, data, offset); offset += CHUNK_WRAPPER_SIZE + idat.length; writePngChunk(&quot;IEND&quot;, new Uint8Array(0), data, offset); return createObjectURL(data, &quot;image/png&quot;, forceDataSchema); } return function convertImgDataToPng(imgData, forceDataSchema, isMask) { const kind = imgData.kind === undefined ? _util.ImageKind.GRAYSCALE_1BPP : imgData.kind; return encode(imgData, kind, forceDataSchema, isMask); }; }(); class SVGExtraState { constructor() { this.fontSizeScale = 1; this.fontWeight = SVG_DEFAULTS.fontWeight; this.fontSize = 0; this.textMatrix = _util.IDENTITY_MATRIX; this.fontMatrix = _util.FONT_IDENTITY_MATRIX; this.leading = 0; this.textRenderingMode = _util.TextRenderingMode.FILL; this.textMatrixScale = 1; this.x = 0; this.y = 0; this.lineX = 0; this.lineY = 0; this.charSpacing = 0; this.wordSpacing = 0; this.textHScale = 1; this.textRise = 0; this.fillColor = SVG_DEFAULTS.fillColor; this.strokeColor = &quot;#000000&quot;; this.fillAlpha = 1; this.strokeAlpha = 1; this.lineWidth = 1; this.lineJoin = &quot;&quot;; this.lineCap = &quot;&quot;; this.miterLimit = 0; this.dashArray = []; this.dashPhase = 0; this.dependencies = []; this.activeClipUrl = null; this.clipGroup = null; this.maskId = &quot;&quot;; } clone() { return Object.create(this); } setCurrentPoint(x, y) { this.x = x; this.y = y; } } function opListToTree(opList) { let opTree = []; const tmp = []; for (const opListElement of opList) { if (opListElement.fn === &quot;save&quot;) { opTree.push({ fnId: 92, fn: &quot;group&quot;, items: [] }); tmp.push(opTree); opTree = opTree.at(-1).items; continue; } if (opListElement.fn === &quot;restore&quot;) { opTree = tmp.pop(); } else { opTree.push(opListElement); } } return opTree; } function pf(value) { if (Number.isInteger(value)) { return value.toString(); } const s = value.toFixed(10); let i = s.length - 1; if (s[i] !== &quot;0&quot;) { return s; } do { i--; } while (s[i] === &quot;0&quot;); return s.substring(0, s[i] === &quot;.&quot; ? i : i + 1); } function pm(m) { if (m[4] === 0 &amp;&amp; m[5] === 0) { if (m[1] === 0 &amp;&amp; m[2] === 0) { if (m[0] === 1 &amp;&amp; m[3] === 1) { return &quot;&quot;; } return `scale(${pf(m[0])} ${pf(m[3])})`; } if (m[0] === m[3] &amp;&amp; m[1] === -m[2]) { const a = Math.acos(m[0]) * 180 / Math.PI; return `rotate(${pf(a)})`; } } else { if (m[0] === 1 &amp;&amp; m[1] === 0 &amp;&amp; m[2] === 0 &amp;&amp; m[3] === 1) { return `translate(${pf(m[4])} ${pf(m[5])})`; } } return `matrix(${pf(m[0])} ${pf(m[1])} ${pf(m[2])} ${pf(m[3])} ${pf(m[4])} ` + `${pf(m[5])})`; } let clipCount = 0; let maskCount = 0; let shadingCount = 0; exports.SVGGraphics = SVGGraphics = class { constructor(commonObjs, objs, forceDataSchema = false) { (0, _display_utils.deprecated)(&quot;The SVG back-end is no longer maintained and *may* be removed in the future.&quot;); this.svgFactory = new _display_utils.DOMSVGFactory(); this.current = new SVGExtraState(); this.transformMatrix = _util.IDENTITY_MATRIX; this.transformStack = []; this.extraStack = []; this.commonObjs = commonObjs; this.objs = objs; this.pendingClip = null; this.pendingEOFill = false; this.embedFonts = false; this.embeddedFonts = Object.create(null); this.cssStyle = null; this.forceDataSchema = !!forceDataSchema; this._operatorIdMapping = []; for (const op in _util.OPS) { this._operatorIdMapping[_util.OPS[op]] = op; } } getObject(data, fallback = null) { if (typeof data === &quot;string&quot;) { return data.startsWith(&quot;g_&quot;) ? this.commonObjs.get(data) : this.objs.get(data); } return fallback; } save() { this.transformStack.push(this.transformMatrix); const old = this.current; this.extraStack.push(old); this.current = old.clone(); } restore() { this.transformMatrix = this.transformStack.pop(); this.current = this.extraStack.pop(); this.pendingClip = null; this.tgrp = null; } group(items) { this.save(); this.executeOpTree(items); this.restore(); } loadDependencies(operatorList) { const fnArray = operatorList.fnArray; const argsArray = operatorList.argsArray; for (let i = 0, ii = fnArray.length; i &lt; ii; i++) { if (fnArray[i] !== _util.OPS.dependency) { continue; } for (const obj of argsArray[i]) { const objsPool = obj.startsWith(&quot;g_&quot;) ? this.commonObjs : this.objs; const promise = new Promise(resolve =&gt; { objsPool.get(obj, resolve); }); this.current.dependencies.push(promise); } } return Promise.all(this.current.dependencies); } transform(a, b, c, d, e, f) { const transformMatrix = [a, b, c, d, e, f]; this.transformMatrix = _util.Util.transform(this.transformMatrix, transformMatrix); this.tgrp = null; } getSVG(operatorList, viewport) { this.viewport = viewport; const svgElement = this._initialize(viewport); return this.loadDependencies(operatorList).then(() =&gt; { this.transformMatrix = _util.IDENTITY_MATRIX; this.executeOpTree(this.convertOpList(operatorList)); return svgElement; }); } convertOpList(operatorList) { const operatorIdMapping = this._operatorIdMapping; const argsArray = operatorList.argsArray; const fnArray = operatorList.fnArray; const opList = []; for (let i = 0, ii = fnArray.length; i &lt; ii; i++) { const fnId = fnArray[i]; opList.push({ fnId, fn: operatorIdMapping[fnId], args: argsArray[i] }); } return opListToTree(opList); } executeOpTree(opTree) { for (const opTreeElement of opTree) { const fn = opTreeElement.fn; const fnId = opTreeElement.fnId; const args = opTreeElement.args; switch (fnId | 0) { case _util.OPS.beginText: this.beginText(); break; case _util.OPS.dependency: break; case _util.OPS.setLeading: this.setLeading(args); break; case _util.OPS.setLeadingMoveText: this.setLeadingMoveText(args[0], args[1]); break; case _util.OPS.setFont: this.setFont(args); break; case _util.OPS.showText: this.showText(args[0]); break; case _util.OPS.showSpacedText: this.showText(args[0]); break; case _util.OPS.endText: this.endText(); break; case _util.OPS.moveText: this.moveText(args[0], args[1]); break; case _util.OPS.setCharSpacing: this.setCharSpacing(args[0]); break; case _util.OPS.setWordSpacing: this.setWordSpacing(args[0]); break; case _util.OPS.setHScale: this.setHScale(args[0]); break; case _util.OPS.setTextMatrix: this.setTextMatrix(args[0], args[1], args[2], args[3], args[4], args[5]); break; case _util.OPS.setTextRise: this.setTextRise(args[0]); break; case _util.OPS.setTextRenderingMode: this.setTextRenderingMode(args[0]); break; case _util.OPS.setLineWidth: this.setLineWidth(args[0]); break; case _util.OPS.setLineJoin: this.setLineJoin(args[0]); break; case _util.OPS.setLineCap: this.setLineCap(args[0]); break; case _util.OPS.setMiterLimit: this.setMiterLimit(args[0]); break; case _util.OPS.setFillRGBColor: this.setFillRGBColor(args[0], args[1], args[2]); break; case _util.OPS.setStrokeRGBColor: this.setStrokeRGBColor(args[0], args[1], args[2]); break; case _util.OPS.setStrokeColorN: this.setStrokeColorN(args); break; case _util.OPS.setFillColorN: this.setFillColorN(args); break; case _util.OPS.shadingFill: this.shadingFill(args[0]); break; case _util.OPS.setDash: this.setDash(args[0], args[1]); break; case _util.OPS.setRenderingIntent: this.setRenderingIntent(args[0]); break; case _util.OPS.setFlatness: this.setFlatness(args[0]); break; case _util.OPS.setGState: this.setGState(args[0]); break; case _util.OPS.fill: this.fill(); break; case _util.OPS.eoFill: this.eoFill(); break; case _util.OPS.stroke: this.stroke(); break; case _util.OPS.fillStroke: this.fillStroke(); break; case _util.OPS.eoFillStroke: this.eoFillStroke(); break; case _util.OPS.clip: this.clip(&quot;nonzero&quot;); break; case _util.OPS.eoClip: this.clip(&quot;evenodd&quot;); break; case _util.OPS.paintSolidColorImageMask: this.paintSolidColorImageMask(); break; case _util.OPS.paintImageXObject: this.paintImageXObject(args[0]); break; case _util.OPS.paintInlineImageXObject: this.paintInlineImageXObject(args[0]); break; case _util.OPS.paintImageMaskXObject: this.paintImageMaskXObject(args[0]); break; case _util.OPS.paintFormXObjectBegin: this.paintFormXObjectBegin(args[0], args[1]); break; case _util.OPS.paintFormXObjectEnd: this.paintFormXObjectEnd(); break; case _util.OPS.closePath: this.closePath(); break; case _util.OPS.closeStroke: this.closeStroke(); break; case _util.OPS.closeFillStroke: this.closeFillStroke(); break; case _util.OPS.closeEOFillStroke: this.closeEOFillStroke(); break; case _util.OPS.nextLine: this.nextLine(); break; case _util.OPS.transform: this.transform(args[0], args[1], args[2], args[3], args[4], args[5]); break; case _util.OPS.constructPath: this.constructPath(args[0], args[1]); break; case _util.OPS.endPath: this.endPath(); break; case 92: this.group(opTreeElement.items); break; default: (0, _util.warn)(`Unimplemented operator ${fn}`); break; } } } setWordSpacing(wordSpacing) { this.current.wordSpacing = wordSpacing; } setCharSpacing(charSpacing) { this.current.charSpacing = charSpacing; } nextLine() { this.moveText(0, this.current.leading); } setTextMatrix(a, b, c, d, e, f) { const current = this.current; current.textMatrix = current.lineMatrix = [a, b, c, d, e, f]; current.textMatrixScale = Math.hypot(a, b); current.x = current.lineX = 0; current.y = current.lineY = 0; current.xcoords = []; current.ycoords = []; current.tspan = this.svgFactory.createElement(&quot;svg:tspan&quot;); current.tspan.setAttributeNS(null, &quot;font-family&quot;, current.fontFamily); current.tspan.setAttributeNS(null, &quot;font-size&quot;, `${pf(current.fontSize)}px`); current.tspan.setAttributeNS(null, &quot;y&quot;, pf(-current.y)); current.txtElement = this.svgFactory.createElement(&quot;svg:text&quot;); current.txtElement.append(current.tspan); } beginText() { const current = this.current; current.x = current.lineX = 0; current.y = current.lineY = 0; current.textMatrix = _util.IDENTITY_MATRIX; current.lineMatrix = _util.IDENTITY_MATRIX; current.textMatrixScale = 1; current.tspan = this.svgFactory.createElement(&quot;svg:tspan&quot;); current.txtElement = this.svgFactory.createElement(&quot;svg:text&quot;); current.txtgrp = this.svgFactory.createElement(&quot;svg:g&quot;); current.xcoords = []; current.ycoords = []; } moveText(x, y) { const current = this.current; current.x = current.lineX += x; current.y = current.lineY += y; current.xcoords = []; current.ycoords = []; current.tspan = this.svgFactory.createElement(&quot;svg:tspan&quot;); current.tspan.setAttributeNS(null, &quot;font-family&quot;, current.fontFamily); current.tspan.setAttributeNS(null, &quot;font-size&quot;, `${pf(current.fontSize)}px`); current.tspan.setAttributeNS(null, &quot;y&quot;, pf(-current.y)); } showText(glyphs) { const current = this.current; const font = current.font; const fontSize = current.fontSize; if (fontSize === 0) { return; } const fontSizeScale = current.fontSizeScale; const charSpacing = current.charSpacing; const wordSpacing = current.wordSpacing; const fontDirection = current.fontDirection; const textHScale = current.textHScale * fontDirection; const vertical = font.vertical; const spacingDir = vertical ? 1 : -1; const defaultVMetrics = font.defaultVMetrics; const widthAdvanceScale = fontSize * current.fontMatrix[0]; let x = 0; for (const glyph of glyphs) { if (glyph === null) { x += fontDirection * wordSpacing; continue; } else if (typeof glyph === &quot;number&quot;) { x += spacingDir * glyph * fontSize / 1000; continue; } const spacing = (glyph.isSpace ? wordSpacing : 0) + charSpacing; const character = glyph.fontChar; let scaledX, scaledY; let width = glyph.width; if (vertical) { let vx; const vmetric = glyph.vmetric || defaultVMetrics; vx = glyph.vmetric ? vmetric[1] : width * 0.5; vx = -vx * widthAdvanceScale; const vy = vmetric[2] * widthAdvanceScale; width = vmetric ? -vmetric[0] : width; scaledX = vx / fontSizeScale; scaledY = (x + vy) / fontSizeScale; } else { scaledX = x / fontSizeScale; scaledY = 0; } if (glyph.isInFont || font.missingFile) { current.xcoords.push(current.x + scaledX); if (vertical) { current.ycoords.push(-current.y + scaledY); } current.tspan.textContent += character; } else {} let charWidth; if (vertical) { charWidth = width * widthAdvanceScale - spacing * fontDirection; } else { charWidth = width * widthAdvanceScale + spacing * fontDirection; } x += charWidth; } current.tspan.setAttributeNS(null, &quot;x&quot;, current.xcoords.map(pf).join(&quot; &quot;)); if (vertical) { current.tspan.setAttributeNS(null, &quot;y&quot;, current.ycoords.map(pf).join(&quot; &quot;)); } else { current.tspan.setAttributeNS(null, &quot;y&quot;, pf(-current.y)); } if (vertical) { current.y -= x; } else { current.x += x * textHScale; } current.tspan.setAttributeNS(null, &quot;font-family&quot;, current.fontFamily); current.tspan.setAttributeNS(null, &quot;font-size&quot;, `${pf(current.fontSize)}px`); if (current.fontStyle !== SVG_DEFAULTS.fontStyle) { current.tspan.setAttributeNS(null, &quot;font-style&quot;, current.fontStyle); } if (current.fontWeight !== SVG_DEFAULTS.fontWeight) { current.tspan.setAttributeNS(null, &quot;font-weight&quot;, current.fontWeight); } const fillStrokeMode = current.textRenderingMode &amp; _util.TextRenderingMode.FILL_STROKE_MASK; if (fillStrokeMode === _util.TextRenderingMode.FILL || fillStrokeMode === _util.TextRenderingMode.FILL_STROKE) { if (current.fillColor !== SVG_DEFAULTS.fillColor) { current.tspan.setAttributeNS(null, &quot;fill&quot;, current.fillColor); } if (current.fillAlpha &lt; 1) { current.tspan.setAttributeNS(null, &quot;fill-opacity&quot;, current.fillAlpha); } } else if (current.textRenderingMode === _util.TextRenderingMode.ADD_TO_PATH) { current.tspan.setAttributeNS(null, &quot;fill&quot;, &quot;transparent&quot;); } else { current.tspan.setAttributeNS(null, &quot;fill&quot;, &quot;none&quot;); } if (fillStrokeMode === _util.TextRenderingMode.STROKE || fillStrokeMode === _util.TextRenderingMode.FILL_STROKE) { const lineWidthScale = 1 / (current.textMatrixScale || 1); this._setStrokeAttributes(current.tspan, lineWidthScale); } let textMatrix = current.textMatrix; if (current.textRise !== 0) { textMatrix = textMatrix.slice(); textMatrix[5] += current.textRise; } current.txtElement.setAttributeNS(null, &quot;transform&quot;, `${pm(textMatrix)} scale(${pf(textHScale)}, -1)`); current.txtElement.setAttributeNS(XML_NS, &quot;xml:space&quot;, &quot;preserve&quot;); current.txtElement.append(current.tspan); current.txtgrp.append(current.txtElement); this._ensureTransformGroup().append(current.txtElement); } setLeadingMoveText(x, y) { this.setLeading(-y); this.moveText(x, y); } addFontStyle(fontObj) { if (!fontObj.data) { throw new Error(&quot;addFontStyle: No font data available, &quot; + &apos;ensure that the &quot;fontExtraProperties&quot; API parameter is set.&apos;); } if (!this.cssStyle) { this.cssStyle = this.svgFactory.createElement(&quot;svg:style&quot;); this.cssStyle.setAttributeNS(null, &quot;type&quot;, &quot;text/css&quot;); this.defs.append(this.cssStyle); } const url = createObjectURL(fontObj.data, fontObj.mimetype, this.forceDataSchema); this.cssStyle.textContent += `@font-face { font-family: &quot;${fontObj.loadedName}&quot;;` + ` src: url(${url}); }\\n`; } setFont(details) { const current = this.current; const fontObj = this.commonObjs.get(details[0]); let size = details[1]; current.font = fontObj; if (this.embedFonts &amp;&amp; !fontObj.missingFile &amp;&amp; !this.embeddedFonts[fontObj.loadedName]) { this.addFontStyle(fontObj); this.embeddedFonts[fontObj.loadedName] = fontObj; } current.fontMatrix = fontObj.fontMatrix || _util.FONT_IDENTITY_MATRIX; let bold = &quot;normal&quot;; if (fontObj.black) { bold = &quot;900&quot;; } else if (fontObj.bold) { bold = &quot;bold&quot;; } const italic = fontObj.italic ? &quot;italic&quot; : &quot;normal&quot;; if (size &lt; 0) { size = -size; current.fontDirection = -1; } else { current.fontDirection = 1; } current.fontSize = size; current.fontFamily = fontObj.loadedName; current.fontWeight = bold; current.fontStyle = italic; current.tspan = this.svgFactory.createElement(&quot;svg:tspan&quot;); current.tspan.setAttributeNS(null, &quot;y&quot;, pf(-current.y)); current.xcoords = []; current.ycoords = []; } endText() { const current = this.current; if (current.textRenderingMode &amp; _util.TextRenderingMode.ADD_TO_PATH_FLAG &amp;&amp; current.txtElement?.hasChildNodes()) { current.element = current.txtElement; this.clip(&quot;nonzero&quot;); this.endPath(); } } setLineWidth(width) { if (width &gt; 0) { this.current.lineWidth = width; } } setLineCap(style) { this.current.lineCap = LINE_CAP_STYLES[style]; } setLineJoin(style) { this.current.lineJoin = LINE_JOIN_STYLES[style]; } setMiterLimit(limit) { this.current.miterLimit = limit; } setStrokeAlpha(strokeAlpha) { this.current.strokeAlpha = strokeAlpha; } setStrokeRGBColor(r, g, b) { this.current.strokeColor = _util.Util.makeHexColor(r, g, b); } setFillAlpha(fillAlpha) { this.current.fillAlpha = fillAlpha; } setFillRGBColor(r, g, b) { this.current.fillColor = _util.Util.makeHexColor(r, g, b); this.current.tspan = this.svgFactory.createElement(&quot;svg:tspan&quot;); this.current.xcoords = []; this.current.ycoords = []; } setStrokeColorN(args) { this.current.strokeColor = this._makeColorN_Pattern(args); } setFillColorN(args) { this.current.fillColor = this._makeColorN_Pattern(args); } shadingFill(args) { const width = this.viewport.width; const height = this.viewport.height; const inv = _util.Util.inverseTransform(this.transformMatrix); const bl = _util.Util.applyTransform([0, 0], inv); const br = _util.Util.applyTransform([0, height], inv); const ul = _util.Util.applyTransform([width, 0], inv); const ur = _util.Util.applyTransform([width, height], inv); const x0 = Math.min(bl[0], br[0], ul[0], ur[0]); const y0 = Math.min(bl[1], br[1], ul[1], ur[1]); const x1 = Math.max(bl[0], br[0], ul[0], ur[0]); const y1 = Math.max(bl[1], br[1], ul[1], ur[1]); const rect = this.svgFactory.createElement(&quot;svg:rect&quot;); rect.setAttributeNS(null, &quot;x&quot;, x0); rect.setAttributeNS(null, &quot;y&quot;, y0); rect.setAttributeNS(null, &quot;width&quot;, x1 - x0); rect.setAttributeNS(null, &quot;height&quot;, y1 - y0); rect.setAttributeNS(null, &quot;fill&quot;, this._makeShadingPattern(args)); if (this.current.fillAlpha &lt; 1) { rect.setAttributeNS(null, &quot;fill-opacity&quot;, this.current.fillAlpha); } this._ensureTransformGroup().append(rect); } _makeColorN_Pattern(args) { if (args[0] === &quot;TilingPattern&quot;) { return this._makeTilingPattern(args); } return this._makeShadingPattern(args); } _makeTilingPattern(args) { const color = args[1]; const operatorList = args[2]; const matrix = args[3] || _util.IDENTITY_MATRIX; const [x0, y0, x1, y1] = args[4]; const xstep = args[5]; const ystep = args[6]; const paintType = args[7]; const tilingId = `shading${shadingCount++}`; const [tx0, ty0, tx1, ty1] = _util.Util.normalizeRect([..._util.Util.applyTransform([x0, y0], matrix), ..._util.Util.applyTransform([x1, y1], matrix)]); const [xscale, yscale] = _util.Util.singularValueDecompose2dScale(matrix); const txstep = xstep * xscale; const tystep = ystep * yscale; const tiling = this.svgFactory.createElement(&quot;svg:pattern&quot;); tiling.setAttributeNS(null, &quot;id&quot;, tilingId); tiling.setAttributeNS(null, &quot;patternUnits&quot;, &quot;userSpaceOnUse&quot;); tiling.setAttributeNS(null, &quot;width&quot;, txstep); tiling.setAttributeNS(null, &quot;height&quot;, tystep); tiling.setAttributeNS(null, &quot;x&quot;, `${tx0}`); tiling.setAttributeNS(null, &quot;y&quot;, `${ty0}`); const svg = this.svg; const transformMatrix = this.transformMatrix; const fillColor = this.current.fillColor; const strokeColor = this.current.strokeColor; const bbox = this.svgFactory.create(tx1 - tx0, ty1 - ty0); this.svg = bbox; this.transformMatrix = matrix; if (paintType === 2) { const cssColor = _util.Util.makeHexColor(...color); this.current.fillColor = cssColor; this.current.strokeColor = cssColor; } this.executeOpTree(this.convertOpList(operatorList)); this.svg = svg; this.transformMatrix = transformMatrix; this.current.fillColor = fillColor; this.current.strokeColor = strokeColor; tiling.append(bbox.childNodes[0]); this.defs.append(tiling); return `url(#${tilingId})`; } _makeShadingPattern(args) { if (typeof args === &quot;string&quot;) { args = this.objs.get(args); } switch (args[0]) { case &quot;RadialAxial&quot;: const shadingId = `shading${shadingCount++}`; const colorStops = args[3]; let gradient; switch (args[1]) { case &quot;axial&quot;: const point0 = args[4]; const point1 = args[5]; gradient = this.svgFactory.createElement(&quot;svg:linearGradient&quot;); gradient.setAttributeNS(null, &quot;id&quot;, shadingId); gradient.setAttributeNS(null, &quot;gradientUnits&quot;, &quot;userSpaceOnUse&quot;); gradient.setAttributeNS(null, &quot;x1&quot;, point0[0]); gradient.setAttributeNS(null, &quot;y1&quot;, point0[1]); gradient.setAttributeNS(null, &quot;x2&quot;, point1[0]); gradient.setAttributeNS(null, &quot;y2&quot;, point1[1]); break; case &quot;radial&quot;: const focalPoint = args[4]; const circlePoint = args[5]; const focalRadius = args[6]; const circleRadius = args[7]; gradient = this.svgFactory.createElement(&quot;svg:radialGradient&quot;); gradient.setAttributeNS(null, &quot;id&quot;, shadingId); gradient.setAttributeNS(null, &quot;gradientUnits&quot;, &quot;userSpaceOnUse&quot;); gradient.setAttributeNS(null, &quot;cx&quot;, circlePoint[0]); gradient.setAttributeNS(null, &quot;cy&quot;, circlePoint[1]); gradient.setAttributeNS(null, &quot;r&quot;, circleRadius); gradient.setAttributeNS(null, &quot;fx&quot;, focalPoint[0]); gradient.setAttributeNS(null, &quot;fy&quot;, focalPoint[1]); gradient.setAttributeNS(null, &quot;fr&quot;, focalRadius); break; default: throw new Error(`Unknown RadialAxial type: ${args[1]}`); } for (const colorStop of colorStops) { const stop = this.svgFactory.createElement(&quot;svg:stop&quot;); stop.setAttributeNS(null, &quot;offset&quot;, colorStop[0]); stop.setAttributeNS(null, &quot;stop-color&quot;, colorStop[1]); gradient.append(stop); } this.defs.append(gradient); return `url(#${shadingId})`; case &quot;Mesh&quot;: (0, _util.warn)(&quot;Unimplemented pattern Mesh&quot;); return null; case &quot;Dummy&quot;: return &quot;hotpink&quot;; default: throw new Error(`Unknown IR type: ${args[0]}`); } } setDash(dashArray, dashPhase) { this.current.dashArray = dashArray; this.current.dashPhase = dashPhase; } constructPath(ops, args) { const current = this.current; let x = current.x, y = current.y; let d = []; let j = 0; for (const op of ops) { switch (op | 0) { case _util.OPS.rectangle: x = args[j++]; y = args[j++]; const width = args[j++]; const height = args[j++]; const xw = x + width; const yh = y + height; d.push(&quot;M&quot;, pf(x), pf(y), &quot;L&quot;, pf(xw), pf(y), &quot;L&quot;, pf(xw), pf(yh), &quot;L&quot;, pf(x), pf(yh), &quot;Z&quot;); break; case _util.OPS.moveTo: x = args[j++]; y = args[j++]; d.push(&quot;M&quot;, pf(x), pf(y)); break; case _util.OPS.lineTo: x = args[j++]; y = args[j++]; d.push(&quot;L&quot;, pf(x), pf(y)); break; case _util.OPS.curveTo: x = args[j + 4]; y = args[j + 5]; d.push(&quot;C&quot;, pf(args[j]), pf(args[j + 1]), pf(args[j + 2]), pf(args[j + 3]), pf(x), pf(y)); j += 6; break; case _util.OPS.curveTo2: d.push(&quot;C&quot;, pf(x), pf(y), pf(args[j]), pf(args[j + 1]), pf(args[j + 2]), pf(args[j + 3])); x = args[j + 2]; y = args[j + 3]; j += 4; break; case _util.OPS.curveTo3: x = args[j + 2]; y = args[j + 3]; d.push(&quot;C&quot;, pf(args[j]), pf(args[j + 1]), pf(x), pf(y), pf(x), pf(y)); j += 4; break; case _util.OPS.closePath: d.push(&quot;Z&quot;); break; } } d = d.join(&quot; &quot;); if (current.path &amp;&amp; ops.length &gt; 0 &amp;&amp; ops[0] !== _util.OPS.rectangle &amp;&amp; ops[0] !== _util.OPS.moveTo) { d = current.path.getAttributeNS(null, &quot;d&quot;) + d; } else { current.path = this.svgFactory.createElement(&quot;svg:path&quot;); this._ensureTransformGroup().append(current.path); } current.path.setAttributeNS(null, &quot;d&quot;, d); current.path.setAttributeNS(null, &quot;fill&quot;, &quot;none&quot;); current.element = current.path; current.setCurrentPoint(x, y); } endPath() { const current = this.current; current.path = null; if (!this.pendingClip) { return; } if (!current.element) { this.pendingClip = null; return; } const clipId = `clippath${clipCount++}`; const clipPath = this.svgFactory.createElement(&quot;svg:clipPath&quot;); clipPath.setAttributeNS(null, &quot;id&quot;, clipId); clipPath.setAttributeNS(null, &quot;transform&quot;, pm(this.transformMatrix)); const clipElement = current.element.cloneNode(true); if (this.pendingClip === &quot;evenodd&quot;) { clipElement.setAttributeNS(null, &quot;clip-rule&quot;, &quot;evenodd&quot;); } else { clipElement.setAttributeNS(null, &quot;clip-rule&quot;, &quot;nonzero&quot;); } this.pendingClip = null; clipPath.append(clipElement); this.defs.append(clipPath); if (current.activeClipUrl) { current.clipGroup = null; for (const prev of this.extraStack) { prev.clipGroup = null; } clipPath.setAttributeNS(null, &quot;clip-path&quot;, current.activeClipUrl); } current.activeClipUrl = `url(#${clipId})`; this.tgrp = null; } clip(type) { this.pendingClip = type; } closePath() { const current = this.current; if (current.path) { const d = `${current.path.getAttributeNS(null, &quot;d&quot;)}Z`; current.path.setAttributeNS(null, &quot;d&quot;, d); } } setLeading(leading) { this.current.leading = -leading; } setTextRise(textRise) { this.current.textRise = textRise; } setTextRenderingMode(textRenderingMode) { this.current.textRenderingMode = textRenderingMode; } setHScale(scale) { this.current.textHScale = scale / 100; } setRenderingIntent(intent) {} setFlatness(flatness) {} setGState(states) { for (const [key, value] of states) { switch (key) { case &quot;LW&quot;: this.setLineWidth(value); break; case &quot;LC&quot;: this.setLineCap(value); break; case &quot;LJ&quot;: this.setLineJoin(value); break; case &quot;ML&quot;: this.setMiterLimit(value); break; case &quot;D&quot;: this.setDash(value[0], value[1]); break; case &quot;RI&quot;: this.setRenderingIntent(value); break; case &quot;FL&quot;: this.setFlatness(value); break; case &quot;Font&quot;: this.setFont(value); break; case &quot;CA&quot;: this.setStrokeAlpha(value); break; case &quot;ca&quot;: this.setFillAlpha(value); break; default: (0, _util.warn)(`Unimplemented graphic state operator ${key}`); break; } } } fill() { const current = this.current; if (current.element) { current.element.setAttributeNS(null, &quot;fill&quot;, current.fillColor); current.element.setAttributeNS(null, &quot;fill-opacity&quot;, current.fillAlpha); this.endPath(); } } stroke() { const current = this.current; if (current.element) { this._setStrokeAttributes(current.element); current.element.setAttributeNS(null, &quot;fill&quot;, &quot;none&quot;); this.endPath(); } } _setStrokeAttributes(element, lineWidthScale = 1) { const current = this.current; let dashArray = current.dashArray; if (lineWidthScale !== 1 &amp;&amp; dashArray.length &gt; 0) { dashArray = dashArray.map(function (value) { return lineWidthScale * value; }); } element.setAttributeNS(null, &quot;stroke&quot;, current.strokeColor); element.setAttributeNS(null, &quot;stroke-opacity&quot;, current.strokeAlpha); element.setAttributeNS(null, &quot;stroke-miterlimit&quot;, pf(current.miterLimit)); element.setAttributeNS(null, &quot;stroke-linecap&quot;, current.lineCap); element.setAttributeNS(null, &quot;stroke-linejoin&quot;, current.lineJoin); element.setAttributeNS(null, &quot;stroke-width&quot;, pf(lineWidthScale * current.lineWidth) + &quot;px&quot;); element.setAttributeNS(null, &quot;stroke-dasharray&quot;, dashArray.map(pf).join(&quot; &quot;)); element.setAttributeNS(null, &quot;stroke-dashoffset&quot;, pf(lineWidthScale * current.dashPhase) + &quot;px&quot;); } eoFill() { this.current.element?.setAttributeNS(null, &quot;fill-rule&quot;, &quot;evenodd&quot;); this.fill(); } fillStroke() { this.stroke(); this.fill(); } eoFillStroke() { this.current.element?.setAttributeNS(null, &quot;fill-rule&quot;, &quot;evenodd&quot;); this.fillStroke(); } closeStroke() { this.closePath(); this.stroke(); } closeFillStroke() { this.closePath(); this.fillStroke(); } closeEOFillStroke() { this.closePath(); this.eoFillStroke(); } paintSolidColorImageMask() { const rect = this.svgFactory.createElement(&quot;svg:rect&quot;); rect.setAttributeNS(null, &quot;x&quot;, &quot;0&quot;); rect.setAttributeNS(null, &quot;y&quot;, &quot;0&quot;); rect.setAttributeNS(null, &quot;width&quot;, &quot;1px&quot;); rect.setAttributeNS(null, &quot;height&quot;, &quot;1px&quot;); rect.setAttributeNS(null, &quot;fill&quot;, this.current.fillColor); this._ensureTransformGroup().append(rect); } paintImageXObject(objId) { const imgData = this.getObject(objId); if (!imgData) { (0, _util.warn)(`Dependent image with object ID ${objId} is not ready yet`); return; } this.paintInlineImageXObject(imgData); } paintInlineImageXObject(imgData, mask) { const width = imgData.width; const height = imgData.height; const imgSrc = convertImgDataToPng(imgData, this.forceDataSchema, !!mask); const cliprect = this.svgFactory.createElement(&quot;svg:rect&quot;); cliprect.setAttributeNS(null, &quot;x&quot;, &quot;0&quot;); cliprect.setAttributeNS(null, &quot;y&quot;, &quot;0&quot;); cliprect.setAttributeNS(null, &quot;width&quot;, pf(width)); cliprect.setAttributeNS(null, &quot;height&quot;, pf(height)); this.current.element = cliprect; this.clip(&quot;nonzero&quot;); const imgEl = this.svgFactory.createElement(&quot;svg:image&quot;); imgEl.setAttributeNS(XLINK_NS, &quot;xlink:href&quot;, imgSrc); imgEl.setAttributeNS(null, &quot;x&quot;, &quot;0&quot;); imgEl.setAttributeNS(null, &quot;y&quot;, pf(-height)); imgEl.setAttributeNS(null, &quot;width&quot;, pf(width) + &quot;px&quot;); imgEl.setAttributeNS(null, &quot;height&quot;, pf(height) + &quot;px&quot;); imgEl.setAttributeNS(null, &quot;transform&quot;, `scale(${pf(1 / width)} ${pf(-1 / height)})`); if (mask) { mask.append(imgEl); } else { this._ensureTransformGroup().append(imgEl); } } paintImageMaskXObject(img) { const imgData = this.getObject(img.data, img); if (imgData.bitmap) { (0, _util.warn)(&quot;paintImageMaskXObject: ImageBitmap support is not implemented, &quot; + &quot;ensure that the `isOffscreenCanvasSupported` API parameter is disabled.&quot;); return; } const current = this.current; const width = imgData.width; const height = imgData.height; const fillColor = current.fillColor; current.maskId = `mask${maskCount++}`; const mask = this.svgFactory.createElement(&quot;svg:mask&quot;); mask.setAttributeNS(null, &quot;id&quot;, current.maskId); const rect = this.svgFactory.createElement(&quot;svg:rect&quot;); rect.setAttributeNS(null, &quot;x&quot;, &quot;0&quot;); rect.setAttributeNS(null, &quot;y&quot;, &quot;0&quot;); rect.setAttributeNS(null, &quot;width&quot;, pf(width)); rect.setAttributeNS(null, &quot;height&quot;, pf(height)); rect.setAttributeNS(null, &quot;fill&quot;, fillColor); rect.setAttributeNS(null, &quot;mask&quot;, `url(#${current.maskId})`); this.defs.append(mask); this._ensureTransformGroup().append(rect); this.paintInlineImageXObject(imgData, mask); } paintFormXObjectBegin(matrix, bbox) { if (Array.isArray(matrix) &amp;&amp; matrix.length === 6) { this.transform(matrix[0], matrix[1], matrix[2], matrix[3], matrix[4], matrix[5]); } if (bbox) { const width = bbox[2] - bbox[0]; const height = bbox[3] - bbox[1]; const cliprect = this.svgFactory.createElement(&quot;svg:rect&quot;); cliprect.setAttributeNS(null, &quot;x&quot;, bbox[0]); cliprect.setAttributeNS(null, &quot;y&quot;, bbox[1]); cliprect.setAttributeNS(null, &quot;width&quot;, pf(width)); cliprect.setAttributeNS(null, &quot;height&quot;, pf(height)); this.current.element = cliprect; this.clip(&quot;nonzero&quot;); this.endPath(); } } paintFormXObjectEnd() {} _initialize(viewport) { const svg = this.svgFactory.create(viewport.width, viewport.height); const definitions = this.svgFactory.createElement(&quot;svg:defs&quot;); svg.append(definitions); this.defs = definitions; const rootGroup = this.svgFactory.createElement(&quot;svg:g&quot;); rootGroup.setAttributeNS(null, &quot;transform&quot;, pm(viewport.transform)); svg.append(rootGroup); this.svg = rootGroup; return svg; } _ensureClipGroup() { if (!this.current.clipGroup) { const clipGroup = this.svgFactory.createElement(&quot;svg:g&quot;); clipGroup.setAttributeNS(null, &quot;clip-path&quot;, this.current.activeClipUrl); this.svg.append(clipGroup); this.current.clipGroup = clipGroup; } return this.current.clipGroup; } _ensureTransformGroup() { if (!this.tgrp) { this.tgrp = this.svgFactory.createElement(&quot;svg:g&quot;); this.tgrp.setAttributeNS(null, &quot;transform&quot;, pm(this.transformMatrix)); if (this.current.activeClipUrl) { this._ensureClipGroup().append(this.tgrp); } else { this.svg.append(this.tgrp); } } return this.tgrp; } }; } /***/ }), /* 31 */ /***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) =&gt; { Object.defineProperty(exports, &quot;__esModule&quot;, ({ value: true })); exports.PDFNodeStream = void 0; var _util = __w_pdfjs_require__(1); var _network_utils = __w_pdfjs_require__(32); ; const fs = require(&quot;fs&quot;); const http = require(&quot;http&quot;); const https = require(&quot;https&quot;); const url = require(&quot;url&quot;); const fileUriRegex = /^file:\\/\\/\\/[a-zA-Z]:\\//; function parseUrl(sourceUrl) { const parsedUrl = url.parse(sourceUrl); if (parsedUrl.protocol === &quot;file:&quot; || parsedUrl.host) { return parsedUrl; } if (/^[a-z]:[/\\\\]/i.test(sourceUrl)) { return url.parse(`file:///${sourceUrl}`); } if (!parsedUrl.host) { parsedUrl.protocol = &quot;file:&quot;; } return parsedUrl; } class PDFNodeStream { constructor(source) { this.source = source; this.url = parseUrl(source.url); this.isHttp = this.url.protocol === &quot;http:&quot; || this.url.protocol === &quot;https:&quot;; this.isFsUrl = this.url.protocol === &quot;file:&quot;; this.httpHeaders = this.isHttp &amp;&amp; source.httpHeaders || {}; this._fullRequestReader = null; this._rangeRequestReaders = []; } get _progressiveDataLength() { return this._fullRequestReader?._loaded ?? 0; } getFullReader() { (0, _util.assert)(!this._fullRequestReader, &quot;PDFNodeStream.getFullReader can only be called once.&quot;); this._fullRequestReader = this.isFsUrl ? new PDFNodeStreamFsFullReader(this) : new PDFNodeStreamFullReader(this); return this._fullRequestReader; } getRangeReader(start, end) { if (end &lt;= this._progressiveDataLength) { return null; } const rangeReader = this.isFsUrl ? new PDFNodeStreamFsRangeReader(this, start, end) : new PDFNodeStreamRangeReader(this, start, end); this._rangeRequestReaders.push(rangeReader); return rangeReader; } cancelAllRequests(reason) { this._fullRequestReader?.cancel(reason); for (const reader of this._rangeRequestReaders.slice(0)) { reader.cancel(reason); } } } exports.PDFNodeStream = PDFNodeStream; class BaseFullReader { constructor(stream) { this._url = stream.url; this._done = false; this._storedError = null; this.onProgress = null; const source = stream.source; this._contentLength = source.length; this._loaded = 0; this._filename = null; this._disableRange = source.disableRange || false; this._rangeChunkSize = source.rangeChunkSize; if (!this._rangeChunkSize &amp;&amp; !this._disableRange) { this._disableRange = true; } this._isStreamingSupported = !source.disableStream; this._isRangeSupported = !source.disableRange; this._readableStream = null; this._readCapability = (0, _util.createPromiseCapability)(); this._headersCapability = (0, _util.createPromiseCapability)(); } get headersReady() { return this._headersCapability.promise; } get filename() { return this._filename; } get contentLength() { return this._contentLength; } get isRangeSupported() { return this._isRangeSupported; } get isStreamingSupported() { return this._isStreamingSupported; } async read() { await this._readCapability.promise; if (this._done) { return { value: undefined, done: true }; } if (this._storedError) { throw this._storedError; } const chunk = this._readableStream.read(); if (chunk === null) { this._readCapability = (0, _util.createPromiseCapability)(); return this.read(); } this._loaded += chunk.length; this.onProgress?.({ loaded: this._loaded, total: this._contentLength }); const buffer = new Uint8Array(chunk).buffer; return { value: buffer, done: false }; } cancel(reason) { if (!this._readableStream) { this._error(reason); return; } this._readableStream.destroy(reason); } _error(reason) { this._storedError = reason; this._readCapability.resolve(); } _setReadableStream(readableStream) { this._readableStream = readableStream; readableStream.on(&quot;readable&quot;, () =&gt; { this._readCapability.resolve(); }); readableStream.on(&quot;end&quot;, () =&gt; { readableStream.destroy(); this._done = true; this._readCapability.resolve(); }); readableStream.on(&quot;error&quot;, reason =&gt; { this._error(reason); }); if (!this._isStreamingSupported &amp;&amp; this._isRangeSupported) { this._error(new _util.AbortException(&quot;streaming is disabled&quot;)); } if (this._storedError) { this._readableStream.destroy(this._storedError); } } } class BaseRangeReader { constructor(stream) { this._url = stream.url; this._done = false; this._storedError = null; this.onProgress = null; this._loaded = 0; this._readableStream = null; this._readCapability = (0, _util.createPromiseCapability)(); const source = stream.source; this._isStreamingSupported = !source.disableStream; } get isStreamingSupported() { return this._isStreamingSupported; } async read() { await this._readCapability.promise; if (this._done) { return { value: undefined, done: true }; } if (this._storedError) { throw this._storedError; } const chunk = this._readableStream.read(); if (chunk === null) { this._readCapability = (0, _util.createPromiseCapability)(); return this.read(); } this._loaded += chunk.length; this.onProgress?.({ loaded: this._loaded }); const buffer = new Uint8Array(chunk).buffer; return { value: buffer, done: false }; } cancel(reason) { if (!this._readableStream) { this._error(reason); return; } this._readableStream.destroy(reason); } _error(reason) { this._storedError = reason; this._readCapability.resolve(); } _setReadableStream(readableStream) { this._readableStream = readableStream; readableStream.on(&quot;readable&quot;, () =&gt; { this._readCapability.resolve(); }); readableStream.on(&quot;end&quot;, () =&gt; { readableStream.destroy(); this._done = true; this._readCapability.resolve(); }); readableStream.on(&quot;error&quot;, reason =&gt; { this._error(reason); }); if (this._storedError) { this._readableStream.destroy(this._storedError); } } } function createRequestOptions(parsedUrl, headers) { return { protocol: parsedUrl.protocol, auth: parsedUrl.auth, host: parsedUrl.hostname, port: parsedUrl.port, path: parsedUrl.path, method: &quot;GET&quot;, headers }; } class PDFNodeStreamFullReader extends BaseFullReader { constructor(stream) { super(stream); const handleResponse = response =&gt; { if (response.statusCode === 404) { const error = new _util.MissingPDFException(`Missing PDF &quot;${this._url}&quot;.`); this._storedError = error; this._headersCapability.reject(error); return; } this._headersCapability.resolve(); this._setReadableStream(response); const getResponseHeader = name =&gt; { return this._readableStream.headers[name.toLowerCase()]; }; const { allowRangeRequests, suggestedLength } = (0, _network_utils.validateRangeRequestCapabilities)({ getResponseHeader, isHttp: stream.isHttp, rangeChunkSize: this._rangeChunkSize, disableRange: this._disableRange }); this._isRangeSupported = allowRangeRequests; this._contentLength = suggestedLength || this._contentLength; this._filename = (0, _network_utils.extractFilenameFromHeader)(getResponseHeader); }; this._request = null; if (this._url.protocol === &quot;http:&quot;) { this._request = http.request(createRequestOptions(this._url, stream.httpHeaders), handleResponse); } else { this._request = https.request(createRequestOptions(this._url, stream.httpHeaders), handleResponse); } this._request.on(&quot;error&quot;, reason =&gt; { this._storedError = reason; this._headersCapability.reject(reason); }); this._request.end(); } } class PDFNodeStreamRangeReader extends BaseRangeReader { constructor(stream, start, end) { super(stream); this._httpHeaders = {}; for (const property in stream.httpHeaders) { const value = stream.httpHeaders[property]; if (typeof value === &quot;undefined&quot;) { continue; } this._httpHeaders[property] = value; } this._httpHeaders.Range = `bytes=${start}-${end - 1}`; const handleResponse = response =&gt; { if (response.statusCode === 404) { const error = new _util.MissingPDFException(`Missing PDF &quot;${this._url}&quot;.`); this._storedError = error; return; } this._setReadableStream(response); }; this._request = null; if (this._url.protocol === &quot;http:&quot;) { this._request = http.request(createRequestOptions(this._url, this._httpHeaders), handleResponse); } else { this._request = https.request(createRequestOptions(this._url, this._httpHeaders), handleResponse); } this._request.on(&quot;error&quot;, reason =&gt; { this._storedError = reason; }); this._request.end(); } } class PDFNodeStreamFsFullReader extends BaseFullReader { constructor(stream) { super(stream); let path = decodeURIComponent(this._url.path); if (fileUriRegex.test(this._url.href)) { path = path.replace(/^\\//, &quot;&quot;); } fs.lstat(path, (error, stat) =&gt; { if (error) { if (error.code === &quot;ENOENT&quot;) { error = new _util.MissingPDFException(`Missing PDF &quot;${path}&quot;.`); } this._storedError = error; this._headersCapability.reject(error); return; } this._contentLength = stat.size; this._setReadableStream(fs.createReadStream(path)); this._headersCapability.resolve(); }); } } class PDFNodeStreamFsRangeReader extends BaseRangeReader { constructor(stream, start, end) { super(stream); let path = decodeURIComponent(this._url.path); if (fileUriRegex.test(this._url.href)) { path = path.replace(/^\\//, &quot;&quot;); } this._setReadableStream(fs.createReadStream(path, { start, end: end - 1 })); } } /***/ }), /* 32 */ /***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) =&gt; { Object.defineProperty(exports, &quot;__esModule&quot;, ({ value: true })); exports.createResponseStatusError = createResponseStatusError; exports.extractFilenameFromHeader = extractFilenameFromHeader; exports.validateRangeRequestCapabilities = validateRangeRequestCapabilities; exports.validateResponseStatus = validateResponseStatus; var _util = __w_pdfjs_require__(1); var _content_disposition = __w_pdfjs_require__(33); var _display_utils = __w_pdfjs_require__(6); function validateRangeRequestCapabilities({ getResponseHeader, isHttp, rangeChunkSize, disableRange }) { const returnValues = { allowRangeRequests: false, suggestedLength: undefined }; const length = parseInt(getResponseHeader(&quot;Content-Length&quot;), 10); if (!Number.isInteger(length)) { return returnValues; } returnValues.suggestedLength = length; if (length &lt;= 2 * rangeChunkSize) { return returnValues; } if (disableRange || !isHttp) { return returnValues; } if (getResponseHeader(&quot;Accept-Ranges&quot;) !== &quot;bytes&quot;) { return returnValues; } const contentEncoding = getResponseHeader(&quot;Content-Encoding&quot;) || &quot;identity&quot;; if (contentEncoding !== &quot;identity&quot;) { return returnValues; } returnValues.allowRangeRequests = true; return returnValues; } function extractFilenameFromHeader(getResponseHeader) { const contentDisposition = getResponseHeader(&quot;Content-Disposition&quot;); if (contentDisposition) { let filename = (0, _content_disposition.getFilenameFromContentDispositionHeader)(contentDisposition); if (filename.includes(&quot;%&quot;)) { try { filename = decodeURIComponent(filename); } catch (ex) {} } if ((0, _display_utils.isPdfFile)(filename)) { return filename; } } return null; } function createResponseStatusError(status, url) { if (status === 404 || status === 0 &amp;&amp; url.startsWith(&quot;file:&quot;)) { return new _util.MissingPDFException(&apos;Missing PDF &quot;&apos; + url + &apos;&quot;.&apos;); } return new _util.UnexpectedResponseException(`Unexpected server response (${status}) while retrieving PDF &quot;${url}&quot;.`, status); } function validateResponseStatus(status) { return status === 200 || status === 206; } /***/ }), /* 33 */ /***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) =&gt; { Object.defineProperty(exports, &quot;__esModule&quot;, ({ value: true })); exports.getFilenameFromContentDispositionHeader = getFilenameFromContentDispositionHeader; var _util = __w_pdfjs_require__(1); function getFilenameFromContentDispositionHeader(contentDisposition) { let needsEncodingFixup = true; let tmp = toParamRegExp(&quot;filename\\\\*&quot;, &quot;i&quot;).exec(contentDisposition); if (tmp) { tmp = tmp[1]; let filename = rfc2616unquote(tmp); filename = unescape(filename); filename = rfc5987decode(filename); filename = rfc2047decode(filename); return fixupEncoding(filename); } tmp = rfc2231getparam(contentDisposition); if (tmp) { const filename = rfc2047decode(tmp); return fixupEncoding(filename); } tmp = toParamRegExp(&quot;filename&quot;, &quot;i&quot;).exec(contentDisposition); if (tmp) { tmp = tmp[1]; let filename = rfc2616unquote(tmp); filename = rfc2047decode(filename); return fixupEncoding(filename); } function toParamRegExp(attributePattern, flags) { return new RegExp(&quot;(?:^|;)\\\\s*&quot; + attributePattern + &quot;\\\\s*=\\\\s*&quot; + &quot;(&quot; + &apos;[^&quot;;\\\\s][^;\\\\s]*&apos; + &quot;|&quot; + &apos;&quot;(?:[^&quot;\\\\\\\\]|\\\\\\\\&quot;?)+&quot;?&apos; + &quot;)&quot;, flags); } function textdecode(encoding, value) { if (encoding) { if (!/^[\\x00-\\xFF]+$/.test(value)) { return value; } try { const decoder = new TextDecoder(encoding, { fatal: true }); const buffer = (0, _util.stringToBytes)(value); value = decoder.decode(buffer); needsEncodingFixup = false; } catch (e) {} } return value; } function fixupEncoding(value) { if (needsEncodingFixup &amp;&amp; /[\\x80-\\xff]/.test(value)) { value = textdecode(&quot;utf-8&quot;, value); if (needsEncodingFixup) { value = textdecode(&quot;iso-8859-1&quot;, value); } } return value; } function rfc2231getparam(contentDispositionStr) { const matches = []; let match; const iter = toParamRegExp(&quot;filename\\\\*((?!0\\\\d)\\\\d+)(\\\\*?)&quot;, &quot;ig&quot;); while ((match = iter.exec(contentDispositionStr)) !== null) { let [, n, quot, part] = match; n = parseInt(n, 10); if (n in matches) { if (n === 0) { break; } continue; } matches[n] = [quot, part]; } const parts = []; for (let n = 0; n &lt; matches.length; ++n) { if (!(n in matches)) { break; } let [quot, part] = matches[n]; part = rfc2616unquote(part); if (quot) { part = unescape(part); if (n === 0) { part = rfc5987decode(part); } } parts.push(part); } return parts.join(&quot;&quot;); } function rfc2616unquote(value) { if (value.startsWith(&apos;&quot;&apos;)) { const parts = value.slice(1).split(&apos;\\\\&quot;&apos;); for (let i = 0; i &lt; parts.length; ++i) { const quotindex = parts[i].indexOf(&apos;&quot;&apos;); if (quotindex !== -1) { parts[i] = parts[i].slice(0, quotindex); parts.length = i + 1; } parts[i] = parts[i].replace(/\\\\(.)/g, &quot;$1&quot;); } value = parts.join(&apos;&quot;&apos;); } return value; } function rfc5987decode(extvalue) { const encodingend = extvalue.indexOf(&quot;&apos;&quot;); if (encodingend === -1) { return extvalue; } const encoding = extvalue.slice(0, encodingend); const langvalue = extvalue.slice(encodingend + 1); const value = langvalue.replace(/^[^&apos;]*&apos;/, &quot;&quot;); return textdecode(encoding, value); } function rfc2047decode(value) { if (!value.startsWith(&quot;=?&quot;) || /[\\x00-\\x19\\x80-\\xff]/.test(value)) { return value; } return value.replace(/=\\?([\\w-]*)\\?([QqBb])\\?((?:[^?]|\\?(?!=))*)\\?=/g, function (matches, charset, encoding, text) { if (encoding === &quot;q&quot; || encoding === &quot;Q&quot;) { text = text.replace(/_/g, &quot; &quot;); text = text.replace(/=([0-9a-fA-F]{2})/g, function (match, hex) { return String.fromCharCode(parseInt(hex, 16)); }); return textdecode(charset, text); } try { text = atob(text); } catch (e) {} return textdecode(charset, text); }); } return &quot;&quot;; } /***/ }), /* 34 */ /***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) =&gt; { Object.defineProperty(exports, &quot;__esModule&quot;, ({ value: true })); exports.PDFNetworkStream = void 0; var _util = __w_pdfjs_require__(1); var _network_utils = __w_pdfjs_require__(32); ; const OK_RESPONSE = 200; const PARTIAL_CONTENT_RESPONSE = 206; function getArrayBuffer(xhr) { const data = xhr.response; if (typeof data !== &quot;string&quot;) { return data; } const array = (0, _util.stringToBytes)(data); return array.buffer; } class NetworkManager { constructor(url, args = {}) { this.url = url; this.isHttp = /^https?:/i.test(url); this.httpHeaders = this.isHttp &amp;&amp; args.httpHeaders || Object.create(null); this.withCredentials = args.withCredentials || false; this.getXhr = args.getXhr || function NetworkManager_getXhr() { return new XMLHttpRequest(); }; this.currXhrId = 0; this.pendingRequests = Object.create(null); } requestRange(begin, end, listeners) { const args = { begin, end }; for (const prop in listeners) { args[prop] = listeners[prop]; } return this.request(args); } requestFull(listeners) { return this.request(listeners); } request(args) { const xhr = this.getXhr(); const xhrId = this.currXhrId++; const pendingRequest = this.pendingRequests[xhrId] = { xhr }; xhr.open(&quot;GET&quot;, this.url); xhr.withCredentials = this.withCredentials; for (const property in this.httpHeaders) { const value = this.httpHeaders[property]; if (typeof value === &quot;undefined&quot;) { continue; } xhr.setRequestHeader(property, value); } if (this.isHttp &amp;&amp; &quot;begin&quot; in args &amp;&amp; &quot;end&quot; in args) { xhr.setRequestHeader(&quot;Range&quot;, `bytes=${args.begin}-${args.end - 1}`); pendingRequest.expectedStatus = PARTIAL_CONTENT_RESPONSE; } else { pendingRequest.expectedStatus = OK_RESPONSE; } xhr.responseType = &quot;arraybuffer&quot;; if (args.onError) { xhr.onerror = function (evt) { args.onError(xhr.status); }; } xhr.onreadystatechange = this.onStateChange.bind(this, xhrId); xhr.onprogress = this.onProgress.bind(this, xhrId); pendingRequest.onHeadersReceived = args.onHeadersReceived; pendingRequest.onDone = args.onDone; pendingRequest.onError = args.onError; pendingRequest.onProgress = args.onProgress; xhr.send(null); return xhrId; } onProgress(xhrId, evt) { const pendingRequest = this.pendingRequests[xhrId]; if (!pendingRequest) { return; } pendingRequest.onProgress?.(evt); } onStateChange(xhrId, evt) { const pendingRequest = this.pendingRequests[xhrId]; if (!pendingRequest) { return; } const xhr = pendingRequest.xhr; if (xhr.readyState &gt;= 2 &amp;&amp; pendingRequest.onHeadersReceived) { pendingRequest.onHeadersReceived(); delete pendingRequest.onHeadersReceived; } if (xhr.readyState !== 4) { return; } if (!(xhrId in this.pendingRequests)) { return; } delete this.pendingRequests[xhrId]; if (xhr.status === 0 &amp;&amp; this.isHttp) { pendingRequest.onError?.(xhr.status); return; } const xhrStatus = xhr.status || OK_RESPONSE; const ok_response_on_range_request = xhrStatus === OK_RESPONSE &amp;&amp; pendingRequest.expectedStatus === PARTIAL_CONTENT_RESPONSE; if (!ok_response_on_range_request &amp;&amp; xhrStatus !== pendingRequest.expectedStatus) { pendingRequest.onError?.(xhr.status); return; } const chunk = getArrayBuffer(xhr); if (xhrStatus === PARTIAL_CONTENT_RESPONSE) { const rangeHeader = xhr.getResponseHeader(&quot;Content-Range&quot;); const matches = /bytes (\\d+)-(\\d+)\\/(\\d+)/.exec(rangeHeader); pendingRequest.onDone({ begin: parseInt(matches[1], 10), chunk }); } else if (chunk) { pendingRequest.onDone({ begin: 0, chunk }); } else { pendingRequest.onError?.(xhr.status); } } getRequestXhr(xhrId) { return this.pendingRequests[xhrId].xhr; } isPendingRequest(xhrId) { return xhrId in this.pendingRequests; } abortRequest(xhrId) { const xhr = this.pendingRequests[xhrId].xhr; delete this.pendingRequests[xhrId]; xhr.abort(); } } class PDFNetworkStream { constructor(source) { this._source = source; this._manager = new NetworkManager(source.url, { httpHeaders: source.httpHeaders, withCredentials: source.withCredentials }); this._rangeChunkSize = source.rangeChunkSize; this._fullRequestReader = null; this._rangeRequestReaders = []; } _onRangeRequestReaderClosed(reader) { const i = this._rangeRequestReaders.indexOf(reader); if (i &gt;= 0) { this._rangeRequestReaders.splice(i, 1); } } getFullReader() { (0, _util.assert)(!this._fullRequestReader, &quot;PDFNetworkStream.getFullReader can only be called once.&quot;); this._fullRequestReader = new PDFNetworkStreamFullRequestReader(this._manager, this._source); return this._fullRequestReader; } getRangeReader(begin, end) { const reader = new PDFNetworkStreamRangeRequestReader(this._manager, begin, end); reader.onClosed = this._onRangeRequestReaderClosed.bind(this); this._rangeRequestReaders.push(reader); return reader; } cancelAllRequests(reason) { this._fullRequestReader?.cancel(reason); for (const reader of this._rangeRequestReaders.slice(0)) { reader.cancel(reason); } } } exports.PDFNetworkStream = PDFNetworkStream; class PDFNetworkStreamFullRequestReader { constructor(manager, source) { this._manager = manager; const args = { onHeadersReceived: this._onHeadersReceived.bind(this), onDone: this._onDone.bind(this), onError: this._onError.bind(this), onProgress: this._onProgress.bind(this) }; this._url = source.url; this._fullRequestId = manager.requestFull(args); this._headersReceivedCapability = (0, _util.createPromiseCapability)(); this._disableRange = source.disableRange || false; this._contentLength = source.length; this._rangeChunkSize = source.rangeChunkSize; if (!this._rangeChunkSize &amp;&amp; !this._disableRange) { this._disableRange = true; } this._isStreamingSupported = false; this._isRangeSupported = false; this._cachedChunks = []; this._requests = []; this._done = false; this._storedError = undefined; this._filename = null; this.onProgress = null; } _onHeadersReceived() { const fullRequestXhrId = this._fullRequestId; const fullRequestXhr = this._manager.getRequestXhr(fullRequestXhrId); const getResponseHeader = name =&gt; { return fullRequestXhr.getResponseHeader(name); }; const { allowRangeRequests, suggestedLength } = (0, _network_utils.validateRangeRequestCapabilities)({ getResponseHeader, isHttp: this._manager.isHttp, rangeChunkSize: this._rangeChunkSize, disableRange: this._disableRange }); if (allowRangeRequests) { this._isRangeSupported = true; } this._contentLength = suggestedLength || this._contentLength; this._filename = (0, _network_utils.extractFilenameFromHeader)(getResponseHeader); if (this._isRangeSupported) { this._manager.abortRequest(fullRequestXhrId); } this._headersReceivedCapability.resolve(); } _onDone(data) { if (data) { if (this._requests.length &gt; 0) { const requestCapability = this._requests.shift(); requestCapability.resolve({ value: data.chunk, done: false }); } else { this._cachedChunks.push(data.chunk); } } this._done = true; if (this._cachedChunks.length &gt; 0) { return; } for (const requestCapability of this._requests) { requestCapability.resolve({ value: undefined, done: true }); } this._requests.length = 0; } _onError(status) { this._storedError = (0, _network_utils.createResponseStatusError)(status, this._url); this._headersReceivedCapability.reject(this._storedError); for (const requestCapability of this._requests) { requestCapability.reject(this._storedError); } this._requests.length = 0; this._cachedChunks.length = 0; } _onProgress(evt) { this.onProgress?.({ loaded: evt.loaded, total: evt.lengthComputable ? evt.total : this._contentLength }); } get filename() { return this._filename; } get isRangeSupported() { return this._isRangeSupported; } get isStreamingSupported() { return this._isStreamingSupported; } get contentLength() { return this._contentLength; } get headersReady() { return this._headersReceivedCapability.promise; } async read() { if (this._storedError) { throw this._storedError; } if (this._cachedChunks.length &gt; 0) { const chunk = this._cachedChunks.shift(); return { value: chunk, done: false }; } if (this._done) { return { value: undefined, done: true }; } const requestCapability = (0, _util.createPromiseCapability)(); this._requests.push(requestCapability); return requestCapability.promise; } cancel(reason) { this._done = true; this._headersReceivedCapability.reject(reason); for (const requestCapability of this._requests) { requestCapability.resolve({ value: undefined, done: true }); } this._requests.length = 0; if (this._manager.isPendingRequest(this._fullRequestId)) { this._manager.abortRequest(this._fullRequestId); } this._fullRequestReader = null; } } class PDFNetworkStreamRangeRequestReader { constructor(manager, begin, end) { this._manager = manager; const args = { onDone: this._onDone.bind(this), onError: this._onError.bind(this), onProgress: this._onProgress.bind(this) }; this._url = manager.url; this._requestId = manager.requestRange(begin, end, args); this._requests = []; this._queuedChunk = null; this._done = false; this._storedError = undefined; this.onProgress = null; this.onClosed = null; } _close() { this.onClosed?.(this); } _onDone(data) { const chunk = data.chunk; if (this._requests.length &gt; 0) { const requestCapability = this._requests.shift(); requestCapability.resolve({ value: chunk, done: false }); } else { this._queuedChunk = chunk; } this._done = true; for (const requestCapability of this._requests) { requestCapability.resolve({ value: undefined, done: true }); } this._requests.length = 0; this._close(); } _onError(status) { this._storedError = (0, _network_utils.createResponseStatusError)(status, this._url); for (const requestCapability of this._requests) { requestCapability.reject(this._storedError); } this._requests.length = 0; this._queuedChunk = null; } _onProgress(evt) { if (!this.isStreamingSupported) { this.onProgress?.({ loaded: evt.loaded }); } } get isStreamingSupported() { return false; } async read() { if (this._storedError) { throw this._storedError; } if (this._queuedChunk !== null) { const chunk = this._queuedChunk; this._queuedChunk = null; return { value: chunk, done: false }; } if (this._done) { return { value: undefined, done: true }; } const requestCapability = (0, _util.createPromiseCapability)(); this._requests.push(requestCapability); return requestCapability.promise; } cancel(reason) { this._done = true; for (const requestCapability of this._requests) { requestCapability.resolve({ value: undefined, done: true }); } this._requests.length = 0; if (this._manager.isPendingRequest(this._requestId)) { this._manager.abortRequest(this._requestId); } this._close(); } } /***/ }), /* 35 */ /***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) =&gt; { Object.defineProperty(exports, &quot;__esModule&quot;, ({ value: true })); exports.PDFFetchStream = void 0; var _util = __w_pdfjs_require__(1); var _network_utils = __w_pdfjs_require__(32); ; function createFetchOptions(headers, withCredentials, abortController) { return { method: &quot;GET&quot;, headers, signal: abortController.signal, mode: &quot;cors&quot;, credentials: withCredentials ? &quot;include&quot; : &quot;same-origin&quot;, redirect: &quot;follow&quot; }; } function createHeaders(httpHeaders) { const headers = new Headers(); for (const property in httpHeaders) { const value = httpHeaders[property]; if (typeof value === &quot;undefined&quot;) { continue; } headers.append(property, value); } return headers; } class PDFFetchStream { constructor(source) { this.source = source; this.isHttp = /^https?:/i.test(source.url); this.httpHeaders = this.isHttp &amp;&amp; source.httpHeaders || {}; this._fullRequestReader = null; this._rangeRequestReaders = []; } get _progressiveDataLength() { return this._fullRequestReader?._loaded ?? 0; } getFullReader() { (0, _util.assert)(!this._fullRequestReader, &quot;PDFFetchStream.getFullReader can only be called once.&quot;); this._fullRequestReader = new PDFFetchStreamReader(this); return this._fullRequestReader; } getRangeReader(begin, end) { if (end &lt;= this._progressiveDataLength) { return null; } const reader = new PDFFetchStreamRangeReader(this, begin, end); this._rangeRequestReaders.push(reader); return reader; } cancelAllRequests(reason) { this._fullRequestReader?.cancel(reason); for (const reader of this._rangeRequestReaders.slice(0)) { reader.cancel(reason); } } } exports.PDFFetchStream = PDFFetchStream; class PDFFetchStreamReader { constructor(stream) { this._stream = stream; this._reader = null; this._loaded = 0; this._filename = null; const source = stream.source; this._withCredentials = source.withCredentials || false; this._contentLength = source.length; this._headersCapability = (0, _util.createPromiseCapability)(); this._disableRange = source.disableRange || false; this._rangeChunkSize = source.rangeChunkSize; if (!this._rangeChunkSize &amp;&amp; !this._disableRange) { this._disableRange = true; } this._abortController = new AbortController(); this._isStreamingSupported = !source.disableStream; this._isRangeSupported = !source.disableRange; this._headers = createHeaders(this._stream.httpHeaders); const url = source.url; fetch(url, createFetchOptions(this._headers, this._withCredentials, this._abortController)).then(response =&gt; { if (!(0, _network_utils.validateResponseStatus)(response.status)) { throw (0, _network_utils.createResponseStatusError)(response.status, url); } this._reader = response.body.getReader(); this._headersCapability.resolve(); const getResponseHeader = name =&gt; { return response.headers.get(name); }; const { allowRangeRequests, suggestedLength } = (0, _network_utils.validateRangeRequestCapabilities)({ getResponseHeader, isHttp: this._stream.isHttp, rangeChunkSize: this._rangeChunkSize, disableRange: this._disableRange }); this._isRangeSupported = allowRangeRequests; this._contentLength = suggestedLength || this._contentLength; this._filename = (0, _network_utils.extractFilenameFromHeader)(getResponseHeader); if (!this._isStreamingSupported &amp;&amp; this._isRangeSupported) { this.cancel(new _util.AbortException(&quot;Streaming is disabled.&quot;)); } }).catch(this._headersCapability.reject); this.onProgress = null; } get headersReady() { return this._headersCapability.promise; } get filename() { return this._filename; } get contentLength() { return this._contentLength; } get isRangeSupported() { return this._isRangeSupported; } get isStreamingSupported() { return this._isStreamingSupported; } async read() { await this._headersCapability.promise; const { value, done } = await this._reader.read(); if (done) { return { value, done }; } this._loaded += value.byteLength; this.onProgress?.({ loaded: this._loaded, total: this._contentLength }); const buffer = new Uint8Array(value).buffer; return { value: buffer, done: false }; } cancel(reason) { this._reader?.cancel(reason); this._abortController.abort(); } } class PDFFetchStreamRangeReader { constructor(stream, begin, end) { this._stream = stream; this._reader = null; this._loaded = 0; const source = stream.source; this._withCredentials = source.withCredentials || false; this._readCapability = (0, _util.createPromiseCapability)(); this._isStreamingSupported = !source.disableStream; this._abortController = new AbortController(); this._headers = createHeaders(this._stream.httpHeaders); this._headers.append(&quot;Range&quot;, `bytes=${begin}-${end - 1}`); const url = source.url; fetch(url, createFetchOptions(this._headers, this._withCredentials, this._abortController)).then(response =&gt; { if (!(0, _network_utils.validateResponseStatus)(response.status)) { throw (0, _network_utils.createResponseStatusError)(response.status, url); } this._readCapability.resolve(); this._reader = response.body.getReader(); }).catch(this._readCapability.reject); this.onProgress = null; } get isStreamingSupported() { return this._isStreamingSupported; } async read() { await this._readCapability.promise; const { value, done } = await this._reader.read(); if (done) { return { value, done }; } this._loaded += value.byteLength; this.onProgress?.({ loaded: this._loaded }); const buffer = new Uint8Array(value).buffer; return { value: buffer, done: false }; } cancel(reason) { this._reader?.cancel(reason); this._abortController.abort(); } } /***/ }) /******/ ]); /************************************************************************/ /******/ // The module cache /******/ var __webpack_module_cache__ = {}; /******/ /******/ // The require function /******/ function __w_pdfjs_require__(moduleId) { /******/ // Check if module is in cache /******/ var cachedModule = __webpack_module_cache__[moduleId]; /******/ if (cachedModule !== undefined) { /******/ return cachedModule.exports; /******/ } /******/ // Create a new module (and put it into the cache) /******/ var module = __webpack_module_cache__[moduleId] = { /******/ // no module.id needed /******/ // no module.loaded needed /******/ exports: {} /******/ }; /******/ /******/ // Execute the module function /******/ __webpack_modules__[moduleId](module, module.exports, __w_pdfjs_require__); /******/ /******/ // Return the exports of the module /******/ return module.exports; /******/ } /******/ /************************************************************************/ var __webpack_exports__ = {}; // This entry need to be wrapped in an IIFE because it need to be isolated against other modules in the chunk. (() =&gt; { var exports = __webpack_exports__; Object.defineProperty(exports, &quot;__esModule&quot;, ({ value: true })); Object.defineProperty(exports, &quot;AnnotationEditorLayer&quot;, ({ enumerable: true, get: function () { return _annotation_editor_layer.AnnotationEditorLayer; } })); Object.defineProperty(exports, &quot;AnnotationEditorParamsType&quot;, ({ enumerable: true, get: function () { return _util.AnnotationEditorParamsType; } })); Object.defineProperty(exports, &quot;AnnotationEditorType&quot;, ({ enumerable: true, get: function () { return _util.AnnotationEditorType; } })); Object.defineProperty(exports, &quot;AnnotationEditorUIManager&quot;, ({ enumerable: true, get: function () { return _tools.AnnotationEditorUIManager; } })); Object.defineProperty(exports, &quot;AnnotationLayer&quot;, ({ enumerable: true, get: function () { return _annotation_layer.AnnotationLayer; } })); Object.defineProperty(exports, &quot;AnnotationMode&quot;, ({ enumerable: true, get: function () { return _util.AnnotationMode; } })); Object.defineProperty(exports, &quot;CMapCompressionType&quot;, ({ enumerable: true, get: function () { return _util.CMapCompressionType; } })); Object.defineProperty(exports, &quot;GlobalWorkerOptions&quot;, ({ enumerable: true, get: function () { return _worker_options.GlobalWorkerOptions; } })); Object.defineProperty(exports, &quot;InvalidPDFException&quot;, ({ enumerable: true, get: function () { return _util.InvalidPDFException; } })); Object.defineProperty(exports, &quot;MissingPDFException&quot;, ({ enumerable: true, get: function () { return _util.MissingPDFException; } })); Object.defineProperty(exports, &quot;OPS&quot;, ({ enumerable: true, get: function () { return _util.OPS; } })); Object.defineProperty(exports, &quot;PDFDataRangeTransport&quot;, ({ enumerable: true, get: function () { return _api.PDFDataRangeTransport; } })); Object.defineProperty(exports, &quot;PDFDateString&quot;, ({ enumerable: true, get: function () { return _display_utils.PDFDateString; } })); Object.defineProperty(exports, &quot;PDFWorker&quot;, ({ enumerable: true, get: function () { return _api.PDFWorker; } })); Object.defineProperty(exports, &quot;PasswordResponses&quot;, ({ enumerable: true, get: function () { return _util.PasswordResponses; } })); Object.defineProperty(exports, &quot;PermissionFlag&quot;, ({ enumerable: true, get: function () { return _util.PermissionFlag; } })); Object.defineProperty(exports, &quot;PixelsPerInch&quot;, ({ enumerable: true, get: function () { return _display_utils.PixelsPerInch; } })); Object.defineProperty(exports, &quot;RenderingCancelledException&quot;, ({ enumerable: true, get: function () { return _display_utils.RenderingCancelledException; } })); Object.defineProperty(exports, &quot;SVGGraphics&quot;, ({ enumerable: true, get: function () { return _svg.SVGGraphics; } })); Object.defineProperty(exports, &quot;UNSUPPORTED_FEATURES&quot;, ({ enumerable: true, get: function () { return _util.UNSUPPORTED_FEATURES; } })); Object.defineProperty(exports, &quot;UnexpectedResponseException&quot;, ({ enumerable: true, get: function () { return _util.UnexpectedResponseException; } })); Object.defineProperty(exports, &quot;Util&quot;, ({ enumerable: true, get: function () { return _util.Util; } })); Object.defineProperty(exports, &quot;VerbosityLevel&quot;, ({ enumerable: true, get: function () { return _util.VerbosityLevel; } })); Object.defineProperty(exports, &quot;XfaLayer&quot;, ({ enumerable: true, get: function () { return _xfa_layer.XfaLayer; } })); Object.defineProperty(exports, &quot;build&quot;, ({ enumerable: true, get: function () { return _api.build; } })); Object.defineProperty(exports, &quot;createPromiseCapability&quot;, ({ enumerable: true, get: function () { return _util.createPromiseCapability; } })); Object.defineProperty(exports, &quot;createValidAbsoluteUrl&quot;, ({ enumerable: true, get: function () { return _util.createValidAbsoluteUrl; } })); Object.defineProperty(exports, &quot;getDocument&quot;, ({ enumerable: true, get: function () { return _api.getDocument; } })); Object.defineProperty(exports, &quot;getFilenameFromUrl&quot;, ({ enumerable: true, get: function () { return _display_utils.getFilenameFromUrl; } })); Object.defineProperty(exports, &quot;getPdfFilenameFromUrl&quot;, ({ enumerable: true, get: function () { return _display_utils.getPdfFilenameFromUrl; } })); Object.defineProperty(exports, &quot;getXfaPageViewport&quot;, ({ enumerable: true, get: function () { return _display_utils.getXfaPageViewport; } })); Object.defineProperty(exports, &quot;isPdfFile&quot;, ({ enumerable: true, get: function () { return _display_utils.isPdfFile; } })); Object.defineProperty(exports, &quot;loadScript&quot;, ({ enumerable: true, get: function () { return _display_utils.loadScript; } })); Object.defineProperty(exports, &quot;renderTextLayer&quot;, ({ enumerable: true, get: function () { return _text_layer.renderTextLayer; } })); Object.defineProperty(exports, &quot;shadow&quot;, ({ enumerable: true, get: function () { return _util.shadow; } })); Object.defineProperty(exports, &quot;version&quot;, ({ enumerable: true, get: function () { return _api.version; } })); var _util = __w_pdfjs_require__(1); var _api = __w_pdfjs_require__(2); var _display_utils = __w_pdfjs_require__(6); var _annotation_editor_layer = __w_pdfjs_require__(21); var _tools = __w_pdfjs_require__(5); var _annotation_layer = __w_pdfjs_require__(26); var _worker_options = __w_pdfjs_require__(14); var _is_node = __w_pdfjs_require__(12); var _text_layer = __w_pdfjs_require__(29); var _svg = __w_pdfjs_require__(30); var _xfa_layer = __w_pdfjs_require__(28); const pdfjsVersion = &apos;3.0.0&apos;; const pdfjsBuild = &apos;987062c&apos;; { if (_is_node.isNodeJS) { const { PDFNodeStream } = __w_pdfjs_require__(31); (0, _api.setPDFNetworkStreamFactory)(params =&gt; { return new PDFNodeStream(params); }); } else { const { PDFNetworkStream } = __w_pdfjs_require__(34); const { PDFFetchStream } = __w_pdfjs_require__(35); (0, _api.setPDFNetworkStreamFactory)(params =&gt; { if ((0, _display_utils.isValidFetchUrl)(params.url)) { return new PDFFetchStream(params); } return new PDFNetworkStream(params); }); } } })(); /******/ return __webpack_exports__; /******/ })() ; }); //# sourceMappingURL=pdf.js.map","link":"/lib/pdf/build/pdf.js"},{"title":"","text":"Thumbnails Document Outline Attachments Layers Current Outline Item Previous Next Highlight All Match Case Match Diacritics Whole Words Color Size Color Thickness Opacity Open Print Download Presentation Mode Current View Go to First Page Go to Last Page Rotate Clockwise Rotate Counterclockwise Text Selection Tool Hand Tool Page Scrolling Vertical Scrolling Horizontal Scrolling Wrapped Scrolling No Spreads Odd Spreads Even Spreads Document Properties… Toggle Sidebar Find Previous Next Open Print Download Text Draw Tools Zoom Out Zoom In Automatic Zoom Actual Size Page Fit Page Width 50% 75% 100% 125% 150% 200% 300% 400% Enter the password to open this PDF file: Cancel OK File name: - File size: - Title: - Author: - Subject: - Keywords: - Creation Date: - Modification Date: - Creator: - PDF Producer: - PDF Version: - Page Count: - Page Size: - Fast Web View: - Close Preparing document for printing… 0% Cancel","link":"/lib/pdf/web/viewer.html"},{"title":"","text":"/** * @licstart The following is the entire license notice for the * JavaScript code in this page * * Copyright 2022 Mozilla Foundation * * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. * * @licend The above is the entire license notice for the * JavaScript code in this page */ /******/ (() =&gt; { // webpackBootstrap /******/ &quot;use strict&quot;; /******/ var __webpack_modules__ = ([ /* 0 */, /* 1 */ /***/ ((__unused_webpack_module, exports) =&gt; { Object.defineProperty(exports, &quot;__esModule&quot;, ({ value: true })); exports.animationStarted = exports.VERTICAL_PADDING = exports.UNKNOWN_SCALE = exports.TextLayerMode = exports.SpreadMode = exports.SidebarView = exports.ScrollMode = exports.SCROLLBAR_PADDING = exports.RenderingStates = exports.RendererType = exports.ProgressBar = exports.PresentationModeState = exports.OutputScale = exports.MIN_SCALE = exports.MAX_SCALE = exports.MAX_AUTO_SCALE = exports.DEFAULT_SCALE_VALUE = exports.DEFAULT_SCALE_DELTA = exports.DEFAULT_SCALE = exports.AutoPrintRegExp = void 0; exports.apiPageLayoutToViewerModes = apiPageLayoutToViewerModes; exports.apiPageModeToSidebarView = apiPageModeToSidebarView; exports.approximateFraction = approximateFraction; exports.backtrackBeforeAllVisibleElements = backtrackBeforeAllVisibleElements; exports.binarySearchFirstItem = binarySearchFirstItem; exports.docStyle = void 0; exports.getActiveOrFocusedElement = getActiveOrFocusedElement; exports.getPageSizeInches = getPageSizeInches; exports.getVisibleElements = getVisibleElements; exports.isPortraitOrientation = isPortraitOrientation; exports.isValidRotation = isValidRotation; exports.isValidScrollMode = isValidScrollMode; exports.isValidSpreadMode = isValidSpreadMode; exports.noContextMenuHandler = noContextMenuHandler; exports.normalizeWheelEventDelta = normalizeWheelEventDelta; exports.normalizeWheelEventDirection = normalizeWheelEventDirection; exports.parseQueryString = parseQueryString; exports.removeNullCharacters = removeNullCharacters; exports.roundToDivide = roundToDivide; exports.scrollIntoView = scrollIntoView; exports.watchScroll = watchScroll; const DEFAULT_SCALE_VALUE = &quot;auto&quot;; exports.DEFAULT_SCALE_VALUE = DEFAULT_SCALE_VALUE; const DEFAULT_SCALE = 1.0; exports.DEFAULT_SCALE = DEFAULT_SCALE; const DEFAULT_SCALE_DELTA = 1.1; exports.DEFAULT_SCALE_DELTA = DEFAULT_SCALE_DELTA; const MIN_SCALE = 0.1; exports.MIN_SCALE = MIN_SCALE; const MAX_SCALE = 10.0; exports.MAX_SCALE = MAX_SCALE; const UNKNOWN_SCALE = 0; exports.UNKNOWN_SCALE = UNKNOWN_SCALE; const MAX_AUTO_SCALE = 1.25; exports.MAX_AUTO_SCALE = MAX_AUTO_SCALE; const SCROLLBAR_PADDING = 40; exports.SCROLLBAR_PADDING = SCROLLBAR_PADDING; const VERTICAL_PADDING = 5; exports.VERTICAL_PADDING = VERTICAL_PADDING; const RenderingStates = { INITIAL: 0, RUNNING: 1, PAUSED: 2, FINISHED: 3 }; exports.RenderingStates = RenderingStates; const PresentationModeState = { UNKNOWN: 0, NORMAL: 1, CHANGING: 2, FULLSCREEN: 3 }; exports.PresentationModeState = PresentationModeState; const SidebarView = { UNKNOWN: -1, NONE: 0, THUMBS: 1, OUTLINE: 2, ATTACHMENTS: 3, LAYERS: 4 }; exports.SidebarView = SidebarView; const RendererType = { CANVAS: &quot;canvas&quot;, SVG: &quot;svg&quot; }; exports.RendererType = RendererType; const TextLayerMode = { DISABLE: 0, ENABLE: 1 }; exports.TextLayerMode = TextLayerMode; const ScrollMode = { UNKNOWN: -1, VERTICAL: 0, HORIZONTAL: 1, WRAPPED: 2, PAGE: 3 }; exports.ScrollMode = ScrollMode; const SpreadMode = { UNKNOWN: -1, NONE: 0, ODD: 1, EVEN: 2 }; exports.SpreadMode = SpreadMode; const AutoPrintRegExp = /\\bprint\\s*\\(/; exports.AutoPrintRegExp = AutoPrintRegExp; class OutputScale { constructor() { const pixelRatio = window.devicePixelRatio || 1; this.sx = pixelRatio; this.sy = pixelRatio; } get scaled() { return this.sx !== 1 || this.sy !== 1; } } exports.OutputScale = OutputScale; function scrollIntoView(element, spot, scrollMatches = false) { let parent = element.offsetParent; if (!parent) { console.error(&quot;offsetParent is not set -- cannot scroll&quot;); return; } let offsetY = element.offsetTop + element.clientTop; let offsetX = element.offsetLeft + element.clientLeft; while (parent.clientHeight === parent.scrollHeight &amp;&amp; parent.clientWidth === parent.scrollWidth || scrollMatches &amp;&amp; (parent.classList.contains(&quot;markedContent&quot;) || getComputedStyle(parent).overflow === &quot;hidden&quot;)) { offsetY += parent.offsetTop; offsetX += parent.offsetLeft; parent = parent.offsetParent; if (!parent) { return; } } if (spot) { if (spot.top !== undefined) { offsetY += spot.top; } if (spot.left !== undefined) { offsetX += spot.left; parent.scrollLeft = offsetX; } } parent.scrollTop = offsetY; } function watchScroll(viewAreaElement, callback) { const debounceScroll = function (evt) { if (rAF) { return; } rAF = window.requestAnimationFrame(function viewAreaElementScrolled() { rAF = null; const currentX = viewAreaElement.scrollLeft; const lastX = state.lastX; if (currentX !== lastX) { state.right = currentX &gt; lastX; } state.lastX = currentX; const currentY = viewAreaElement.scrollTop; const lastY = state.lastY; if (currentY !== lastY) { state.down = currentY &gt; lastY; } state.lastY = currentY; callback(state); }); }; const state = { right: true, down: true, lastX: viewAreaElement.scrollLeft, lastY: viewAreaElement.scrollTop, _eventHandler: debounceScroll }; let rAF = null; viewAreaElement.addEventListener(&quot;scroll&quot;, debounceScroll, true); return state; } function parseQueryString(query) { const params = new Map(); for (const [key, value] of new URLSearchParams(query)) { params.set(key.toLowerCase(), value); } return params; } const NullCharactersRegExp = /\\x00/g; const InvisibleCharactersRegExp = /[\\x01-\\x1F]/g; function removeNullCharacters(str, replaceInvisible = false) { if (typeof str !== &quot;string&quot;) { console.error(`The argument must be a string.`); return str; } if (replaceInvisible) { str = str.replace(InvisibleCharactersRegExp, &quot; &quot;); } return str.replace(NullCharactersRegExp, &quot;&quot;); } function binarySearchFirstItem(items, condition, start = 0) { let minIndex = start; let maxIndex = items.length - 1; if (maxIndex &lt; 0 || !condition(items[maxIndex])) { return items.length; } if (condition(items[minIndex])) { return minIndex; } while (minIndex &lt; maxIndex) { const currentIndex = minIndex + maxIndex &gt;&gt; 1; const currentItem = items[currentIndex]; if (condition(currentItem)) { maxIndex = currentIndex; } else { minIndex = currentIndex + 1; } } return minIndex; } function approximateFraction(x) { if (Math.floor(x) === x) { return [x, 1]; } const xinv = 1 / x; const limit = 8; if (xinv &gt; limit) { return [1, limit]; } else if (Math.floor(xinv) === xinv) { return [1, xinv]; } const x_ = x &gt; 1 ? xinv : x; let a = 0, b = 1, c = 1, d = 1; while (true) { const p = a + c, q = b + d; if (q &gt; limit) { break; } if (x_ &lt;= p / q) { c = p; d = q; } else { a = p; b = q; } } let result; if (x_ - a / b &lt; c / d - x_) { result = x_ === x ? [a, b] : [b, a]; } else { result = x_ === x ? [c, d] : [d, c]; } return result; } function roundToDivide(x, div) { const r = x % div; return r === 0 ? x : Math.round(x - r + div); } function getPageSizeInches({ view, userUnit, rotate }) { const [x1, y1, x2, y2] = view; const changeOrientation = rotate % 180 !== 0; const width = (x2 - x1) / 72 * userUnit; const height = (y2 - y1) / 72 * userUnit; return { width: changeOrientation ? height : width, height: changeOrientation ? width : height }; } function backtrackBeforeAllVisibleElements(index, views, top) { if (index &lt; 2) { return index; } let elt = views[index].div; let pageTop = elt.offsetTop + elt.clientTop; if (pageTop &gt;= top) { elt = views[index - 1].div; pageTop = elt.offsetTop + elt.clientTop; } for (let i = index - 2; i &gt;= 0; --i) { elt = views[i].div; if (elt.offsetTop + elt.clientTop + elt.clientHeight &lt;= pageTop) { break; } index = i; } return index; } function getVisibleElements({ scrollEl, views, sortByVisibility = false, horizontal = false, rtl = false }) { const top = scrollEl.scrollTop, bottom = top + scrollEl.clientHeight; const left = scrollEl.scrollLeft, right = left + scrollEl.clientWidth; function isElementBottomAfterViewTop(view) { const element = view.div; const elementBottom = element.offsetTop + element.clientTop + element.clientHeight; return elementBottom &gt; top; } function isElementNextAfterViewHorizontally(view) { const element = view.div; const elementLeft = element.offsetLeft + element.clientLeft; const elementRight = elementLeft + element.clientWidth; return rtl ? elementLeft &lt; right : elementRight &gt; left; } const visible = [], ids = new Set(), numViews = views.length; let firstVisibleElementInd = binarySearchFirstItem(views, horizontal ? isElementNextAfterViewHorizontally : isElementBottomAfterViewTop); if (firstVisibleElementInd &gt; 0 &amp;&amp; firstVisibleElementInd &lt; numViews &amp;&amp; !horizontal) { firstVisibleElementInd = backtrackBeforeAllVisibleElements(firstVisibleElementInd, views, top); } let lastEdge = horizontal ? right : -1; for (let i = firstVisibleElementInd; i &lt; numViews; i++) { const view = views[i], element = view.div; const currentWidth = element.offsetLeft + element.clientLeft; const currentHeight = element.offsetTop + element.clientTop; const viewWidth = element.clientWidth, viewHeight = element.clientHeight; const viewRight = currentWidth + viewWidth; const viewBottom = currentHeight + viewHeight; if (lastEdge === -1) { if (viewBottom &gt;= bottom) { lastEdge = viewBottom; } } else if ((horizontal ? currentWidth : currentHeight) &gt; lastEdge) { break; } if (viewBottom &lt;= top || currentHeight &gt;= bottom || viewRight &lt;= left || currentWidth &gt;= right) { continue; } const hiddenHeight = Math.max(0, top - currentHeight) + Math.max(0, viewBottom - bottom); const hiddenWidth = Math.max(0, left - currentWidth) + Math.max(0, viewRight - right); const fractionHeight = (viewHeight - hiddenHeight) / viewHeight, fractionWidth = (viewWidth - hiddenWidth) / viewWidth; const percent = fractionHeight * fractionWidth * 100 | 0; visible.push({ id: view.id, x: currentWidth, y: currentHeight, view, percent, widthPercent: fractionWidth * 100 | 0 }); ids.add(view.id); } const first = visible[0], last = visible.at(-1); if (sortByVisibility) { visible.sort(function (a, b) { const pc = a.percent - b.percent; if (Math.abs(pc) &gt; 0.001) { return -pc; } return a.id - b.id; }); } return { first, last, views: visible, ids }; } function noContextMenuHandler(evt) { evt.preventDefault(); } function normalizeWheelEventDirection(evt) { let delta = Math.hypot(evt.deltaX, evt.deltaY); const angle = Math.atan2(evt.deltaY, evt.deltaX); if (-0.25 * Math.PI &lt; angle &amp;&amp; angle &lt; 0.75 * Math.PI) { delta = -delta; } return delta; } function normalizeWheelEventDelta(evt) { let delta = normalizeWheelEventDirection(evt); const MOUSE_DOM_DELTA_PIXEL_MODE = 0; const MOUSE_DOM_DELTA_LINE_MODE = 1; const MOUSE_PIXELS_PER_LINE = 30; const MOUSE_LINES_PER_PAGE = 30; if (evt.deltaMode === MOUSE_DOM_DELTA_PIXEL_MODE) { delta /= MOUSE_PIXELS_PER_LINE * MOUSE_LINES_PER_PAGE; } else if (evt.deltaMode === MOUSE_DOM_DELTA_LINE_MODE) { delta /= MOUSE_LINES_PER_PAGE; } return delta; } function isValidRotation(angle) { return Number.isInteger(angle) &amp;&amp; angle % 90 === 0; } function isValidScrollMode(mode) { return Number.isInteger(mode) &amp;&amp; Object.values(ScrollMode).includes(mode) &amp;&amp; mode !== ScrollMode.UNKNOWN; } function isValidSpreadMode(mode) { return Number.isInteger(mode) &amp;&amp; Object.values(SpreadMode).includes(mode) &amp;&amp; mode !== SpreadMode.UNKNOWN; } function isPortraitOrientation(size) { return size.width &lt;= size.height; } const animationStarted = new Promise(function (resolve) { window.requestAnimationFrame(resolve); }); exports.animationStarted = animationStarted; const docStyle = document.documentElement.style; exports.docStyle = docStyle; function clamp(v, min, max) { return Math.min(Math.max(v, min), max); } class ProgressBar { #classList = null; #percent = 0; #visible = true; constructor(id) { const bar = document.getElementById(id); this.#classList = bar.classList; } get percent() { return this.#percent; } set percent(val) { this.#percent = clamp(val, 0, 100); if (isNaN(val)) { this.#classList.add(&quot;indeterminate&quot;); return; } this.#classList.remove(&quot;indeterminate&quot;); docStyle.setProperty(&quot;--progressBar-percent&quot;, `${this.#percent}%`); } setWidth(viewer) { if (!viewer) { return; } const container = viewer.parentNode; const scrollbarWidth = container.offsetWidth - viewer.offsetWidth; if (scrollbarWidth &gt; 0) { docStyle.setProperty(&quot;--progressBar-end-offset&quot;, `${scrollbarWidth}px`); } } hide() { if (!this.#visible) { return; } this.#visible = false; this.#classList.add(&quot;hidden&quot;); } show() { if (this.#visible) { return; } this.#visible = true; this.#classList.remove(&quot;hidden&quot;); } } exports.ProgressBar = ProgressBar; function getActiveOrFocusedElement() { let curRoot = document; let curActiveOrFocused = curRoot.activeElement || curRoot.querySelector(&quot;:focus&quot;); while (curActiveOrFocused?.shadowRoot) { curRoot = curActiveOrFocused.shadowRoot; curActiveOrFocused = curRoot.activeElement || curRoot.querySelector(&quot;:focus&quot;); } return curActiveOrFocused; } function apiPageLayoutToViewerModes(layout) { let scrollMode = ScrollMode.VERTICAL, spreadMode = SpreadMode.NONE; switch (layout) { case &quot;SinglePage&quot;: scrollMode = ScrollMode.PAGE; break; case &quot;OneColumn&quot;: break; case &quot;TwoPageLeft&quot;: scrollMode = ScrollMode.PAGE; case &quot;TwoColumnLeft&quot;: spreadMode = SpreadMode.ODD; break; case &quot;TwoPageRight&quot;: scrollMode = ScrollMode.PAGE; case &quot;TwoColumnRight&quot;: spreadMode = SpreadMode.EVEN; break; } return { scrollMode, spreadMode }; } function apiPageModeToSidebarView(mode) { switch (mode) { case &quot;UseNone&quot;: return SidebarView.NONE; case &quot;UseThumbs&quot;: return SidebarView.THUMBS; case &quot;UseOutlines&quot;: return SidebarView.OUTLINE; case &quot;UseAttachments&quot;: return SidebarView.ATTACHMENTS; case &quot;UseOC&quot;: return SidebarView.LAYERS; } return SidebarView.NONE; } /***/ }), /* 2 */ /***/ ((__unused_webpack_module, exports) =&gt; { Object.defineProperty(exports, &quot;__esModule&quot;, ({ value: true })); exports.compatibilityParams = exports.OptionKind = exports.AppOptions = void 0; const compatibilityParams = Object.create(null); exports.compatibilityParams = compatibilityParams; { const userAgent = navigator.userAgent || &quot;&quot;; const platform = navigator.platform || &quot;&quot;; const maxTouchPoints = navigator.maxTouchPoints || 1; const isAndroid = /Android/.test(userAgent); const isIOS = /\\b(iPad|iPhone|iPod)(?=;)/.test(userAgent) || platform === &quot;MacIntel&quot; &amp;&amp; maxTouchPoints &gt; 1; (function checkCanvasSizeLimitation() { if (isIOS || isAndroid) { compatibilityParams.maxCanvasPixels = 5242880; } })(); } const OptionKind = { VIEWER: 0x02, API: 0x04, WORKER: 0x08, PREFERENCE: 0x80 }; exports.OptionKind = OptionKind; const defaultOptions = { annotationEditorMode: { value: 0, kind: OptionKind.VIEWER + OptionKind.PREFERENCE }, annotationMode: { value: 2, kind: OptionKind.VIEWER + OptionKind.PREFERENCE }, cursorToolOnLoad: { value: 0, kind: OptionKind.VIEWER + OptionKind.PREFERENCE }, defaultZoomValue: { value: &quot;&quot;, kind: OptionKind.VIEWER + OptionKind.PREFERENCE }, disableHistory: { value: false, kind: OptionKind.VIEWER }, disablePageLabels: { value: false, kind: OptionKind.VIEWER + OptionKind.PREFERENCE }, enablePermissions: { value: false, kind: OptionKind.VIEWER + OptionKind.PREFERENCE }, enablePrintAutoRotate: { value: true, kind: OptionKind.VIEWER + OptionKind.PREFERENCE }, enableScripting: { value: true, kind: OptionKind.VIEWER + OptionKind.PREFERENCE }, externalLinkRel: { value: &quot;noopener noreferrer nofollow&quot;, kind: OptionKind.VIEWER }, externalLinkTarget: { value: 0, kind: OptionKind.VIEWER + OptionKind.PREFERENCE }, historyUpdateUrl: { value: false, kind: OptionKind.VIEWER + OptionKind.PREFERENCE }, ignoreDestinationZoom: { value: false, kind: OptionKind.VIEWER + OptionKind.PREFERENCE }, imageResourcesPath: { value: &quot;./images/&quot;, kind: OptionKind.VIEWER }, maxCanvasPixels: { value: 16777216, kind: OptionKind.VIEWER }, forcePageColors: { value: false, kind: OptionKind.VIEWER + OptionKind.PREFERENCE }, pageColorsBackground: { value: &quot;Canvas&quot;, kind: OptionKind.VIEWER + OptionKind.PREFERENCE }, pageColorsForeground: { value: &quot;CanvasText&quot;, kind: OptionKind.VIEWER + OptionKind.PREFERENCE }, pdfBugEnabled: { value: false, kind: OptionKind.VIEWER + OptionKind.PREFERENCE }, printResolution: { value: 150, kind: OptionKind.VIEWER }, sidebarViewOnLoad: { value: -1, kind: OptionKind.VIEWER + OptionKind.PREFERENCE }, scrollModeOnLoad: { value: -1, kind: OptionKind.VIEWER + OptionKind.PREFERENCE }, spreadModeOnLoad: { value: -1, kind: OptionKind.VIEWER + OptionKind.PREFERENCE }, textLayerMode: { value: 1, kind: OptionKind.VIEWER + OptionKind.PREFERENCE }, useOnlyCssZoom: { value: false, kind: OptionKind.VIEWER + OptionKind.PREFERENCE }, viewerCssTheme: { value: 0, kind: OptionKind.VIEWER + OptionKind.PREFERENCE }, viewOnLoad: { value: 0, kind: OptionKind.VIEWER + OptionKind.PREFERENCE }, cMapPacked: { value: true, kind: OptionKind.API }, cMapUrl: { value: &quot;../web/cmaps/&quot;, kind: OptionKind.API }, disableAutoFetch: { value: false, kind: OptionKind.API + OptionKind.PREFERENCE }, disableFontFace: { value: false, kind: OptionKind.API + OptionKind.PREFERENCE }, disableRange: { value: false, kind: OptionKind.API + OptionKind.PREFERENCE }, disableStream: { value: false, kind: OptionKind.API + OptionKind.PREFERENCE }, docBaseUrl: { value: &quot;&quot;, kind: OptionKind.API }, enableXfa: { value: true, kind: OptionKind.API + OptionKind.PREFERENCE }, fontExtraProperties: { value: false, kind: OptionKind.API }, isEvalSupported: { value: true, kind: OptionKind.API }, isOffscreenCanvasSupported: { value: true, kind: OptionKind.API }, maxImageSize: { value: -1, kind: OptionKind.API }, pdfBug: { value: false, kind: OptionKind.API }, standardFontDataUrl: { value: &quot;../web/standard_fonts/&quot;, kind: OptionKind.API }, verbosity: { value: 1, kind: OptionKind.API }, workerPort: { value: null, kind: OptionKind.WORKER }, workerSrc: { value: &quot;../build/pdf.worker.js&quot;, kind: OptionKind.WORKER } }; { defaultOptions.defaultUrl = { value: &quot;compressed.tracemonkey-pldi-09.pdf&quot;, kind: OptionKind.VIEWER }; defaultOptions.disablePreferences = { value: false, kind: OptionKind.VIEWER }; defaultOptions.locale = { value: navigator.language || &quot;en-US&quot;, kind: OptionKind.VIEWER }; defaultOptions.renderer = { value: &quot;canvas&quot;, kind: OptionKind.VIEWER + OptionKind.PREFERENCE }; defaultOptions.sandboxBundleSrc = { value: &quot;../build/pdf.sandbox.js&quot;, kind: OptionKind.VIEWER }; } const userOptions = Object.create(null); class AppOptions { constructor() { throw new Error(&quot;Cannot initialize AppOptions.&quot;); } static get(name) { const userOption = userOptions[name]; if (userOption !== undefined) { return userOption; } const defaultOption = defaultOptions[name]; if (defaultOption !== undefined) { return compatibilityParams[name] ?? defaultOption.value; } return undefined; } static getAll(kind = null) { const options = Object.create(null); for (const name in defaultOptions) { const defaultOption = defaultOptions[name]; if (kind) { if ((kind &amp; defaultOption.kind) === 0) { continue; } if (kind === OptionKind.PREFERENCE) { const value = defaultOption.value, valueType = typeof value; if (valueType === &quot;boolean&quot; || valueType === &quot;string&quot; || valueType === &quot;number&quot; &amp;&amp; Number.isInteger(value)) { options[name] = value; continue; } throw new Error(`Invalid type for preference: ${name}`); } } const userOption = userOptions[name]; options[name] = userOption !== undefined ? userOption : compatibilityParams[name] ?? defaultOption.value; } return options; } static set(name, value) { userOptions[name] = value; } static setAll(options) { for (const name in options) { userOptions[name] = options[name]; } } static remove(name) { delete userOptions[name]; } static _hasUserOptions() { return Object.keys(userOptions).length &gt; 0; } } exports.AppOptions = AppOptions; /***/ }), /* 3 */ /***/ ((__unused_webpack_module, exports, __webpack_require__) =&gt; { Object.defineProperty(exports, &quot;__esModule&quot;, ({ value: true })); exports.SimpleLinkService = exports.PDFLinkService = exports.LinkTarget = void 0; var _ui_utils = __webpack_require__(1); const DEFAULT_LINK_REL = &quot;noopener noreferrer nofollow&quot;; const LinkTarget = { NONE: 0, SELF: 1, BLANK: 2, PARENT: 3, TOP: 4 }; exports.LinkTarget = LinkTarget; function addLinkAttributes(link, { url, target, rel, enabled = true } = {}) { if (!url || typeof url !== &quot;string&quot;) { throw new Error(&apos;A valid &quot;url&quot; parameter must provided.&apos;); } const urlNullRemoved = (0, _ui_utils.removeNullCharacters)(url); if (enabled) { link.href = link.title = urlNullRemoved; } else { link.href = &quot;&quot;; link.title = `Disabled: ${urlNullRemoved}`; link.onclick = () =&gt; { return false; }; } let targetStr = &quot;&quot;; switch (target) { case LinkTarget.NONE: break; case LinkTarget.SELF: targetStr = &quot;_self&quot;; break; case LinkTarget.BLANK: targetStr = &quot;_blank&quot;; break; case LinkTarget.PARENT: targetStr = &quot;_parent&quot;; break; case LinkTarget.TOP: targetStr = &quot;_top&quot;; break; } link.target = targetStr; link.rel = typeof rel === &quot;string&quot; ? rel : DEFAULT_LINK_REL; } class PDFLinkService { #pagesRefCache = new Map(); constructor({ eventBus, externalLinkTarget = null, externalLinkRel = null, ignoreDestinationZoom = false } = {}) { this.eventBus = eventBus; this.externalLinkTarget = externalLinkTarget; this.externalLinkRel = externalLinkRel; this.externalLinkEnabled = true; this._ignoreDestinationZoom = ignoreDestinationZoom; this.baseUrl = null; this.pdfDocument = null; this.pdfViewer = null; this.pdfHistory = null; } setDocument(pdfDocument, baseUrl = null) { this.baseUrl = baseUrl; this.pdfDocument = pdfDocument; this.#pagesRefCache.clear(); } setViewer(pdfViewer) { this.pdfViewer = pdfViewer; } setHistory(pdfHistory) { this.pdfHistory = pdfHistory; } get pagesCount() { return this.pdfDocument ? this.pdfDocument.numPages : 0; } get page() { return this.pdfViewer.currentPageNumber; } set page(value) { this.pdfViewer.currentPageNumber = value; } get rotation() { return this.pdfViewer.pagesRotation; } set rotation(value) { this.pdfViewer.pagesRotation = value; } #goToDestinationHelper(rawDest, namedDest = null, explicitDest) { const destRef = explicitDest[0]; let pageNumber; if (typeof destRef === &quot;object&quot; &amp;&amp; destRef !== null) { pageNumber = this._cachedPageNumber(destRef); if (!pageNumber) { this.pdfDocument.getPageIndex(destRef).then(pageIndex =&gt; { this.cachePageRef(pageIndex + 1, destRef); this.#goToDestinationHelper(rawDest, namedDest, explicitDest); }).catch(() =&gt; { console.error(`PDFLinkService.#goToDestinationHelper: &quot;${destRef}&quot; is not ` + `a valid page reference, for dest=&quot;${rawDest}&quot;.`); }); return; } } else if (Number.isInteger(destRef)) { pageNumber = destRef + 1; } else { console.error(`PDFLinkService.#goToDestinationHelper: &quot;${destRef}&quot; is not ` + `a valid destination reference, for dest=&quot;${rawDest}&quot;.`); return; } if (!pageNumber || pageNumber &lt; 1 || pageNumber &gt; this.pagesCount) { console.error(`PDFLinkService.#goToDestinationHelper: &quot;${pageNumber}&quot; is not ` + `a valid page number, for dest=&quot;${rawDest}&quot;.`); return; } if (this.pdfHistory) { this.pdfHistory.pushCurrentPosition(); this.pdfHistory.push({ namedDest, explicitDest, pageNumber }); } this.pdfViewer.scrollPageIntoView({ pageNumber, destArray: explicitDest, ignoreDestinationZoom: this._ignoreDestinationZoom }); } async goToDestination(dest) { if (!this.pdfDocument) { return; } let namedDest, explicitDest; if (typeof dest === &quot;string&quot;) { namedDest = dest; explicitDest = await this.pdfDocument.getDestination(dest); } else { namedDest = null; explicitDest = await dest; } if (!Array.isArray(explicitDest)) { console.error(`PDFLinkService.goToDestination: &quot;${explicitDest}&quot; is not ` + `a valid destination array, for dest=&quot;${dest}&quot;.`); return; } this.#goToDestinationHelper(dest, namedDest, explicitDest); } goToPage(val) { if (!this.pdfDocument) { return; } const pageNumber = typeof val === &quot;string&quot; &amp;&amp; this.pdfViewer.pageLabelToPageNumber(val) || val | 0; if (!(Number.isInteger(pageNumber) &amp;&amp; pageNumber &gt; 0 &amp;&amp; pageNumber &lt;= this.pagesCount)) { console.error(`PDFLinkService.goToPage: &quot;${val}&quot; is not a valid page.`); return; } if (this.pdfHistory) { this.pdfHistory.pushCurrentPosition(); this.pdfHistory.pushPage(pageNumber); } this.pdfViewer.scrollPageIntoView({ pageNumber }); } addLinkAttributes(link, url, newWindow = false) { addLinkAttributes(link, { url, target: newWindow ? LinkTarget.BLANK : this.externalLinkTarget, rel: this.externalLinkRel, enabled: this.externalLinkEnabled }); } getDestinationHash(dest) { if (typeof dest === &quot;string&quot;) { if (dest.length &gt; 0) { return this.getAnchorUrl(&quot;#&quot; + escape(dest)); } } else if (Array.isArray(dest)) { const str = JSON.stringify(dest); if (str.length &gt; 0) { return this.getAnchorUrl(&quot;#&quot; + escape(str)); } } return this.getAnchorUrl(&quot;&quot;); } getAnchorUrl(anchor) { return (this.baseUrl || &quot;&quot;) + anchor; } setHash(hash) { if (!this.pdfDocument) { return; } let pageNumber, dest; if (hash.includes(&quot;=&quot;)) { const params = (0, _ui_utils.parseQueryString)(hash); if (params.has(&quot;search&quot;)) { this.eventBus.dispatch(&quot;findfromurlhash&quot;, { source: this, query: params.get(&quot;search&quot;).replace(/&quot;/g, &quot;&quot;), phraseSearch: params.get(&quot;phrase&quot;) === &quot;true&quot; }); } if (params.has(&quot;page&quot;)) { pageNumber = params.get(&quot;page&quot;) | 0 || 1; } if (params.has(&quot;zoom&quot;)) { const zoomArgs = params.get(&quot;zoom&quot;).split(&quot;,&quot;); const zoomArg = zoomArgs[0]; const zoomArgNumber = parseFloat(zoomArg); if (!zoomArg.includes(&quot;Fit&quot;)) { dest = [null, { name: &quot;XYZ&quot; }, zoomArgs.length &gt; 1 ? zoomArgs[1] | 0 : null, zoomArgs.length &gt; 2 ? zoomArgs[2] | 0 : null, zoomArgNumber ? zoomArgNumber / 100 : zoomArg]; } else { if (zoomArg === &quot;Fit&quot; || zoomArg === &quot;FitB&quot;) { dest = [null, { name: zoomArg }]; } else if (zoomArg === &quot;FitH&quot; || zoomArg === &quot;FitBH&quot; || zoomArg === &quot;FitV&quot; || zoomArg === &quot;FitBV&quot;) { dest = [null, { name: zoomArg }, zoomArgs.length &gt; 1 ? zoomArgs[1] | 0 : null]; } else if (zoomArg === &quot;FitR&quot;) { if (zoomArgs.length !== 5) { console.error(&apos;PDFLinkService.setHash: Not enough parameters for &quot;FitR&quot;.&apos;); } else { dest = [null, { name: zoomArg }, zoomArgs[1] | 0, zoomArgs[2] | 0, zoomArgs[3] | 0, zoomArgs[4] | 0]; } } else { console.error(`PDFLinkService.setHash: &quot;${zoomArg}&quot; is not a valid zoom value.`); } } } if (dest) { this.pdfViewer.scrollPageIntoView({ pageNumber: pageNumber || this.page, destArray: dest, allowNegativeOffset: true }); } else if (pageNumber) { this.page = pageNumber; } if (params.has(&quot;pagemode&quot;)) { this.eventBus.dispatch(&quot;pagemode&quot;, { source: this, mode: params.get(&quot;pagemode&quot;) }); } if (params.has(&quot;nameddest&quot;)) { this.goToDestination(params.get(&quot;nameddest&quot;)); } } else { dest = unescape(hash); try { dest = JSON.parse(dest); if (!Array.isArray(dest)) { dest = dest.toString(); } } catch (ex) {} if (typeof dest === &quot;string&quot; || PDFLinkService.#isValidExplicitDestination(dest)) { this.goToDestination(dest); return; } console.error(`PDFLinkService.setHash: &quot;${unescape(hash)}&quot; is not a valid destination.`); } } executeNamedAction(action) { switch (action) { case &quot;GoBack&quot;: this.pdfHistory?.back(); break; case &quot;GoForward&quot;: this.pdfHistory?.forward(); break; case &quot;NextPage&quot;: this.pdfViewer.nextPage(); break; case &quot;PrevPage&quot;: this.pdfViewer.previousPage(); break; case &quot;LastPage&quot;: this.page = this.pagesCount; break; case &quot;FirstPage&quot;: this.page = 1; break; default: break; } this.eventBus.dispatch(&quot;namedaction&quot;, { source: this, action }); } async executeSetOCGState(action) { const pdfDocument = this.pdfDocument; const optionalContentConfig = await this.pdfViewer.optionalContentConfigPromise; if (pdfDocument !== this.pdfDocument) { return; } let operator; for (const elem of action.state) { switch (elem) { case &quot;ON&quot;: case &quot;OFF&quot;: case &quot;Toggle&quot;: operator = elem; continue; } switch (operator) { case &quot;ON&quot;: optionalContentConfig.setVisibility(elem, true); break; case &quot;OFF&quot;: optionalContentConfig.setVisibility(elem, false); break; case &quot;Toggle&quot;: const group = optionalContentConfig.getGroup(elem); if (group) { optionalContentConfig.setVisibility(elem, !group.visible); } break; } } this.pdfViewer.optionalContentConfigPromise = Promise.resolve(optionalContentConfig); } cachePageRef(pageNum, pageRef) { if (!pageRef) { return; } const refStr = pageRef.gen === 0 ? `${pageRef.num}R` : `${pageRef.num}R${pageRef.gen}`; this.#pagesRefCache.set(refStr, pageNum); } _cachedPageNumber(pageRef) { if (!pageRef) { return null; } const refStr = pageRef.gen === 0 ? `${pageRef.num}R` : `${pageRef.num}R${pageRef.gen}`; return this.#pagesRefCache.get(refStr) || null; } isPageVisible(pageNumber) { return this.pdfViewer.isPageVisible(pageNumber); } isPageCached(pageNumber) { return this.pdfViewer.isPageCached(pageNumber); } static #isValidExplicitDestination(dest) { if (!Array.isArray(dest)) { return false; } const destLength = dest.length; if (destLength &lt; 2) { return false; } const page = dest[0]; if (!(typeof page === &quot;object&quot; &amp;&amp; Number.isInteger(page.num) &amp;&amp; Number.isInteger(page.gen)) &amp;&amp; !(Number.isInteger(page) &amp;&amp; page &gt;= 0)) { return false; } const zoom = dest[1]; if (!(typeof zoom === &quot;object&quot; &amp;&amp; typeof zoom.name === &quot;string&quot;)) { return false; } let allowNull = true; switch (zoom.name) { case &quot;XYZ&quot;: if (destLength !== 5) { return false; } break; case &quot;Fit&quot;: case &quot;FitB&quot;: return destLength === 2; case &quot;FitH&quot;: case &quot;FitBH&quot;: case &quot;FitV&quot;: case &quot;FitBV&quot;: if (destLength !== 3) { return false; } break; case &quot;FitR&quot;: if (destLength !== 6) { return false; } allowNull = false; break; default: return false; } for (let i = 2; i &lt; destLength; i++) { const param = dest[i]; if (!(typeof param === &quot;number&quot; || allowNull &amp;&amp; param === null)) { return false; } } return true; } } exports.PDFLinkService = PDFLinkService; class SimpleLinkService { constructor() { this.externalLinkEnabled = true; } get pagesCount() { return 0; } get page() { return 0; } set page(value) {} get rotation() { return 0; } set rotation(value) {} async goToDestination(dest) {} goToPage(val) {} addLinkAttributes(link, url, newWindow = false) { addLinkAttributes(link, { url, enabled: this.externalLinkEnabled }); } getDestinationHash(dest) { return &quot;#&quot;; } getAnchorUrl(hash) { return &quot;#&quot;; } setHash(hash) {} executeNamedAction(action) {} executeSetOCGState(action) {} cachePageRef(pageNum, pageRef) {} isPageVisible(pageNumber) { return true; } isPageCached(pageNumber) { return true; } } exports.SimpleLinkService = SimpleLinkService; /***/ }), /* 4 */ /***/ ((__unused_webpack_module, exports, __webpack_require__) =&gt; { Object.defineProperty(exports, &quot;__esModule&quot;, ({ value: true })); exports.PDFViewerApplication = exports.PDFPrintServiceFactory = exports.DefaultExternalServices = void 0; var _ui_utils = __webpack_require__(1); var _pdfjsLib = __webpack_require__(5); var _app_options = __webpack_require__(2); var _event_utils = __webpack_require__(6); var _pdf_cursor_tools = __webpack_require__(7); var _pdf_link_service = __webpack_require__(3); var _annotation_editor_params = __webpack_require__(9); var _overlay_manager = __webpack_require__(10); var _password_prompt = __webpack_require__(11); var _pdf_attachment_viewer = __webpack_require__(12); var _pdf_document_properties = __webpack_require__(14); var _pdf_find_bar = __webpack_require__(15); var _pdf_find_controller = __webpack_require__(16); var _pdf_history = __webpack_require__(18); var _pdf_layer_viewer = __webpack_require__(19); var _pdf_outline_viewer = __webpack_require__(20); var _pdf_presentation_mode = __webpack_require__(21); var _pdf_rendering_queue = __webpack_require__(22); var _pdf_scripting_manager = __webpack_require__(23); var _pdf_sidebar = __webpack_require__(24); var _pdf_sidebar_resizer = __webpack_require__(25); var _pdf_thumbnail_viewer = __webpack_require__(26); var _pdf_viewer = __webpack_require__(28); var _secondary_toolbar = __webpack_require__(38); var _toolbar = __webpack_require__(39); var _view_history = __webpack_require__(40); const DISABLE_AUTO_FETCH_LOADING_BAR_TIMEOUT = 5000; const FORCE_PAGES_LOADED_TIMEOUT = 10000; const WHEEL_ZOOM_DISABLED_TIMEOUT = 1000; const ViewOnLoad = { UNKNOWN: -1, PREVIOUS: 0, INITIAL: 1 }; const ViewerCssTheme = { AUTOMATIC: 0, LIGHT: 1, DARK: 2 }; const KNOWN_VERSIONS = [&quot;1.0&quot;, &quot;1.1&quot;, &quot;1.2&quot;, &quot;1.3&quot;, &quot;1.4&quot;, &quot;1.5&quot;, &quot;1.6&quot;, &quot;1.7&quot;, &quot;1.8&quot;, &quot;1.9&quot;, &quot;2.0&quot;, &quot;2.1&quot;, &quot;2.2&quot;, &quot;2.3&quot;]; const KNOWN_GENERATORS = [&quot;acrobat distiller&quot;, &quot;acrobat pdfwriter&quot;, &quot;adobe livecycle&quot;, &quot;adobe pdf library&quot;, &quot;adobe photoshop&quot;, &quot;ghostscript&quot;, &quot;tcpdf&quot;, &quot;cairo&quot;, &quot;dvipdfm&quot;, &quot;dvips&quot;, &quot;pdftex&quot;, &quot;pdfkit&quot;, &quot;itext&quot;, &quot;prince&quot;, &quot;quarkxpress&quot;, &quot;mac os x&quot;, &quot;microsoft&quot;, &quot;openoffice&quot;, &quot;oracle&quot;, &quot;luradocument&quot;, &quot;pdf-xchange&quot;, &quot;antenna house&quot;, &quot;aspose.cells&quot;, &quot;fpdf&quot;]; class DefaultExternalServices { constructor() { throw new Error(&quot;Cannot initialize DefaultExternalServices.&quot;); } static updateFindControlState(data) {} static updateFindMatchesCount(data) {} static initPassiveLoading(callbacks) {} static reportTelemetry(data) {} static createDownloadManager(options) { throw new Error(&quot;Not implemented: createDownloadManager&quot;); } static createPreferences() { throw new Error(&quot;Not implemented: createPreferences&quot;); } static createL10n(options) { throw new Error(&quot;Not implemented: createL10n&quot;); } static createScripting(options) { throw new Error(&quot;Not implemented: createScripting&quot;); } static get supportsIntegratedFind() { return (0, _pdfjsLib.shadow)(this, &quot;supportsIntegratedFind&quot;, false); } static get supportsDocumentFonts() { return (0, _pdfjsLib.shadow)(this, &quot;supportsDocumentFonts&quot;, true); } static get supportedMouseWheelZoomModifierKeys() { return (0, _pdfjsLib.shadow)(this, &quot;supportedMouseWheelZoomModifierKeys&quot;, { ctrlKey: true, metaKey: true }); } static get isInAutomation() { return (0, _pdfjsLib.shadow)(this, &quot;isInAutomation&quot;, false); } static updateEditorStates(data) { throw new Error(&quot;Not implemented: updateEditorStates&quot;); } } exports.DefaultExternalServices = DefaultExternalServices; const PDFViewerApplication = { initialBookmark: document.location.hash.substring(1), _initializedCapability: (0, _pdfjsLib.createPromiseCapability)(), appConfig: null, pdfDocument: null, pdfLoadingTask: null, printService: null, pdfViewer: null, pdfThumbnailViewer: null, pdfRenderingQueue: null, pdfPresentationMode: null, pdfDocumentProperties: null, pdfLinkService: null, pdfHistory: null, pdfSidebar: null, pdfSidebarResizer: null, pdfOutlineViewer: null, pdfAttachmentViewer: null, pdfLayerViewer: null, pdfCursorTools: null, pdfScriptingManager: null, store: null, downloadManager: null, overlayManager: null, preferences: null, toolbar: null, secondaryToolbar: null, eventBus: null, l10n: null, annotationEditorParams: null, isInitialViewSet: false, downloadComplete: false, isViewerEmbedded: window.parent !== window, url: &quot;&quot;, baseUrl: &quot;&quot;, _downloadUrl: &quot;&quot;, externalServices: DefaultExternalServices, _boundEvents: Object.create(null), documentInfo: null, metadata: null, _contentDispositionFilename: null, _contentLength: null, _saveInProgress: false, _docStats: null, _wheelUnusedTicks: 0, _PDFBug: null, _hasAnnotationEditors: false, _title: document.title, _printAnnotationStoragePromise: null, async initialize(appConfig) { this.preferences = this.externalServices.createPreferences(); this.appConfig = appConfig; await this._readPreferences(); await this._parseHashParameters(); this._forceCssTheme(); await this._initializeL10n(); if (this.isViewerEmbedded &amp;&amp; _app_options.AppOptions.get(&quot;externalLinkTarget&quot;) === _pdf_link_service.LinkTarget.NONE) { _app_options.AppOptions.set(&quot;externalLinkTarget&quot;, _pdf_link_service.LinkTarget.TOP); } await this._initializeViewerComponents(); this.bindEvents(); this.bindWindowEvents(); const appContainer = appConfig.appContainer || document.documentElement; this.l10n.translate(appContainer).then(() =&gt; { this.eventBus.dispatch(&quot;localized&quot;, { source: this }); }); this._initializedCapability.resolve(); }, async _readPreferences() { if (_app_options.AppOptions.get(&quot;disablePreferences&quot;)) { return; } if (_app_options.AppOptions._hasUserOptions()) { console.warn(&quot;_readPreferences: The Preferences may override manually set AppOptions; &quot; + &apos;please use the &quot;disablePreferences&quot;-option in order to prevent that.&apos;); } try { _app_options.AppOptions.setAll(await this.preferences.getAll()); } catch (reason) { console.error(`_readPreferences: &quot;${reason?.message}&quot;.`); } }, async _parseHashParameters() { if (!_app_options.AppOptions.get(&quot;pdfBugEnabled&quot;)) { return; } const hash = document.location.hash.substring(1); if (!hash) { return; } const { mainContainer, viewerContainer } = this.appConfig, params = (0, _ui_utils.parseQueryString)(hash); if (params.get(&quot;disableworker&quot;) === &quot;true&quot;) { try { await loadFakeWorker(); } catch (ex) { console.error(`_parseHashParameters: &quot;${ex.message}&quot;.`); } } if (params.has(&quot;disablerange&quot;)) { _app_options.AppOptions.set(&quot;disableRange&quot;, params.get(&quot;disablerange&quot;) === &quot;true&quot;); } if (params.has(&quot;disablestream&quot;)) { _app_options.AppOptions.set(&quot;disableStream&quot;, params.get(&quot;disablestream&quot;) === &quot;true&quot;); } if (params.has(&quot;disableautofetch&quot;)) { _app_options.AppOptions.set(&quot;disableAutoFetch&quot;, params.get(&quot;disableautofetch&quot;) === &quot;true&quot;); } if (params.has(&quot;disablefontface&quot;)) { _app_options.AppOptions.set(&quot;disableFontFace&quot;, params.get(&quot;disablefontface&quot;) === &quot;true&quot;); } if (params.has(&quot;disablehistory&quot;)) { _app_options.AppOptions.set(&quot;disableHistory&quot;, params.get(&quot;disablehistory&quot;) === &quot;true&quot;); } if (params.has(&quot;verbosity&quot;)) { _app_options.AppOptions.set(&quot;verbosity&quot;, params.get(&quot;verbosity&quot;) | 0); } if (params.has(&quot;textlayer&quot;)) { switch (params.get(&quot;textlayer&quot;)) { case &quot;off&quot;: _app_options.AppOptions.set(&quot;textLayerMode&quot;, _ui_utils.TextLayerMode.DISABLE); break; case &quot;visible&quot;: case &quot;shadow&quot;: case &quot;hover&quot;: viewerContainer.classList.add(`textLayer-${params.get(&quot;textlayer&quot;)}`); try { await loadPDFBug(this); this._PDFBug.loadCSS(); } catch (ex) { console.error(`_parseHashParameters: &quot;${ex.message}&quot;.`); } break; } } if (params.has(&quot;pdfbug&quot;)) { _app_options.AppOptions.set(&quot;pdfBug&quot;, true); _app_options.AppOptions.set(&quot;fontExtraProperties&quot;, true); const enabled = params.get(&quot;pdfbug&quot;).split(&quot;,&quot;); try { await loadPDFBug(this); this._PDFBug.init({ OPS: _pdfjsLib.OPS }, mainContainer, enabled); } catch (ex) { console.error(`_parseHashParameters: &quot;${ex.message}&quot;.`); } } if (params.has(&quot;locale&quot;)) { _app_options.AppOptions.set(&quot;locale&quot;, params.get(&quot;locale&quot;)); } }, async _initializeL10n() { this.l10n = this.externalServices.createL10n({ locale: _app_options.AppOptions.get(&quot;locale&quot;) }); const dir = await this.l10n.getDirection(); document.getElementsByTagName(&quot;html&quot;)[0].dir = dir; }, _forceCssTheme() { const cssTheme = _app_options.AppOptions.get(&quot;viewerCssTheme&quot;); if (cssTheme === ViewerCssTheme.AUTOMATIC || !Object.values(ViewerCssTheme).includes(cssTheme)) { return; } try { const styleSheet = document.styleSheets[0]; const cssRules = styleSheet?.cssRules || []; for (let i = 0, ii = cssRules.length; i &lt; ii; i++) { const rule = cssRules[i]; if (rule instanceof CSSMediaRule &amp;&amp; rule.media?.[0] === &quot;(prefers-color-scheme: dark)&quot;) { if (cssTheme === ViewerCssTheme.LIGHT) { styleSheet.deleteRule(i); return; } const darkRules = /^@media \\(prefers-color-scheme: dark\\) {\\n\\s*([\\w\\s-.,:;/\\\\{}()]+)\\n}$/.exec(rule.cssText); if (darkRules?.[1]) { styleSheet.deleteRule(i); styleSheet.insertRule(darkRules[1], i); } return; } } } catch (reason) { console.error(`_forceCssTheme: &quot;${reason?.message}&quot;.`); } }, async _initializeViewerComponents() { const { appConfig, externalServices } = this; const eventBus = externalServices.isInAutomation ? new _event_utils.AutomationEventBus() : new _event_utils.EventBus(); this.eventBus = eventBus; this.overlayManager = new _overlay_manager.OverlayManager(); const pdfRenderingQueue = new _pdf_rendering_queue.PDFRenderingQueue(); pdfRenderingQueue.onIdle = this._cleanup.bind(this); this.pdfRenderingQueue = pdfRenderingQueue; const pdfLinkService = new _pdf_link_service.PDFLinkService({ eventBus, externalLinkTarget: _app_options.AppOptions.get(&quot;externalLinkTarget&quot;), externalLinkRel: _app_options.AppOptions.get(&quot;externalLinkRel&quot;), ignoreDestinationZoom: _app_options.AppOptions.get(&quot;ignoreDestinationZoom&quot;) }); this.pdfLinkService = pdfLinkService; const downloadManager = externalServices.createDownloadManager(); this.downloadManager = downloadManager; const findController = new _pdf_find_controller.PDFFindController({ linkService: pdfLinkService, eventBus }); this.findController = findController; const pdfScriptingManager = new _pdf_scripting_manager.PDFScriptingManager({ eventBus, sandboxBundleSrc: _app_options.AppOptions.get(&quot;sandboxBundleSrc&quot;), scriptingFactory: externalServices, docPropertiesLookup: this._scriptingDocProperties.bind(this) }); this.pdfScriptingManager = pdfScriptingManager; const container = appConfig.mainContainer, viewer = appConfig.viewerContainer; const annotationEditorMode = _app_options.AppOptions.get(&quot;annotationEditorMode&quot;); const pageColors = _app_options.AppOptions.get(&quot;forcePageColors&quot;) || window.matchMedia(&quot;(forced-colors: active)&quot;).matches ? { background: _app_options.AppOptions.get(&quot;pageColorsBackground&quot;), foreground: _app_options.AppOptions.get(&quot;pageColorsForeground&quot;) } : null; this.pdfViewer = new _pdf_viewer.PDFViewer({ container, viewer, eventBus, renderingQueue: pdfRenderingQueue, linkService: pdfLinkService, downloadManager, findController, scriptingManager: _app_options.AppOptions.get(&quot;enableScripting&quot;) &amp;&amp; pdfScriptingManager, renderer: _app_options.AppOptions.get(&quot;renderer&quot;), l10n: this.l10n, textLayerMode: _app_options.AppOptions.get(&quot;textLayerMode&quot;), annotationMode: _app_options.AppOptions.get(&quot;annotationMode&quot;), annotationEditorMode, imageResourcesPath: _app_options.AppOptions.get(&quot;imageResourcesPath&quot;), enablePrintAutoRotate: _app_options.AppOptions.get(&quot;enablePrintAutoRotate&quot;), useOnlyCssZoom: _app_options.AppOptions.get(&quot;useOnlyCssZoom&quot;), maxCanvasPixels: _app_options.AppOptions.get(&quot;maxCanvasPixels&quot;), enablePermissions: _app_options.AppOptions.get(&quot;enablePermissions&quot;), pageColors }); pdfRenderingQueue.setViewer(this.pdfViewer); pdfLinkService.setViewer(this.pdfViewer); pdfScriptingManager.setViewer(this.pdfViewer); this.pdfThumbnailViewer = new _pdf_thumbnail_viewer.PDFThumbnailViewer({ container: appConfig.sidebar.thumbnailView, eventBus, renderingQueue: pdfRenderingQueue, linkService: pdfLinkService, l10n: this.l10n, pageColors }); pdfRenderingQueue.setThumbnailViewer(this.pdfThumbnailViewer); if (!this.isViewerEmbedded &amp;&amp; !_app_options.AppOptions.get(&quot;disableHistory&quot;)) { this.pdfHistory = new _pdf_history.PDFHistory({ linkService: pdfLinkService, eventBus }); pdfLinkService.setHistory(this.pdfHistory); } if (!this.supportsIntegratedFind) { this.findBar = new _pdf_find_bar.PDFFindBar(appConfig.findBar, eventBus, this.l10n); } if (annotationEditorMode !== _pdfjsLib.AnnotationEditorType.DISABLE) { this.annotationEditorParams = new _annotation_editor_params.AnnotationEditorParams(appConfig.annotationEditorParams, eventBus); } else { for (const element of [document.getElementById(&quot;editorModeButtons&quot;), document.getElementById(&quot;editorModeSeparator&quot;)]) { element.hidden = true; } } this.pdfDocumentProperties = new _pdf_document_properties.PDFDocumentProperties(appConfig.documentProperties, this.overlayManager, eventBus, this.l10n, () =&gt; { return this._docFilename; }); this.pdfCursorTools = new _pdf_cursor_tools.PDFCursorTools({ container, eventBus, cursorToolOnLoad: _app_options.AppOptions.get(&quot;cursorToolOnLoad&quot;) }); this.toolbar = new _toolbar.Toolbar(appConfig.toolbar, eventBus, this.l10n); this.secondaryToolbar = new _secondary_toolbar.SecondaryToolbar(appConfig.secondaryToolbar, eventBus, this.externalServices); if (this.supportsFullscreen) { this.pdfPresentationMode = new _pdf_presentation_mode.PDFPresentationMode({ container, pdfViewer: this.pdfViewer, eventBus }); } this.passwordPrompt = new _password_prompt.PasswordPrompt(appConfig.passwordOverlay, this.overlayManager, this.l10n, this.isViewerEmbedded); this.pdfOutlineViewer = new _pdf_outline_viewer.PDFOutlineViewer({ container: appConfig.sidebar.outlineView, eventBus, linkService: pdfLinkService, downloadManager }); this.pdfAttachmentViewer = new _pdf_attachment_viewer.PDFAttachmentViewer({ container: appConfig.sidebar.attachmentsView, eventBus, downloadManager }); this.pdfLayerViewer = new _pdf_layer_viewer.PDFLayerViewer({ container: appConfig.sidebar.layersView, eventBus, l10n: this.l10n }); this.pdfSidebar = new _pdf_sidebar.PDFSidebar({ elements: appConfig.sidebar, pdfViewer: this.pdfViewer, pdfThumbnailViewer: this.pdfThumbnailViewer, eventBus, l10n: this.l10n }); this.pdfSidebar.onToggled = this.forceRendering.bind(this); this.pdfSidebarResizer = new _pdf_sidebar_resizer.PDFSidebarResizer(appConfig.sidebarResizer, eventBus, this.l10n); }, run(config) { this.initialize(config).then(webViewerInitialized); }, get initialized() { return this._initializedCapability.settled; }, get initializedPromise() { return this._initializedCapability.promise; }, zoomIn(steps) { if (this.pdfViewer.isInPresentationMode) { return; } this.pdfViewer.increaseScale(steps); }, zoomOut(steps) { if (this.pdfViewer.isInPresentationMode) { return; } this.pdfViewer.decreaseScale(steps); }, zoomReset() { if (this.pdfViewer.isInPresentationMode) { return; } this.pdfViewer.currentScaleValue = _ui_utils.DEFAULT_SCALE_VALUE; }, get pagesCount() { return this.pdfDocument ? this.pdfDocument.numPages : 0; }, get page() { return this.pdfViewer.currentPageNumber; }, set page(val) { this.pdfViewer.currentPageNumber = val; }, get supportsPrinting() { return PDFPrintServiceFactory.instance.supportsPrinting; }, get supportsFullscreen() { return (0, _pdfjsLib.shadow)(this, &quot;supportsFullscreen&quot;, document.fullscreenEnabled); }, get supportsIntegratedFind() { return this.externalServices.supportsIntegratedFind; }, get supportsDocumentFonts() { return this.externalServices.supportsDocumentFonts; }, get loadingBar() { const bar = new _ui_utils.ProgressBar(&quot;loadingBar&quot;); return (0, _pdfjsLib.shadow)(this, &quot;loadingBar&quot;, bar); }, get supportedMouseWheelZoomModifierKeys() { return this.externalServices.supportedMouseWheelZoomModifierKeys; }, initPassiveLoading() { throw new Error(&quot;Not implemented: initPassiveLoading&quot;); }, setTitleUsingUrl(url = &quot;&quot;, downloadUrl = null) { this.url = url; this.baseUrl = url.split(&quot;#&quot;)[0]; if (downloadUrl) { this._downloadUrl = downloadUrl === url ? this.baseUrl : downloadUrl.split(&quot;#&quot;)[0]; } let title = (0, _pdfjsLib.getPdfFilenameFromUrl)(url, &quot;&quot;); if (!title) { try { title = decodeURIComponent((0, _pdfjsLib.getFilenameFromUrl)(url)) || url; } catch (ex) { title = url; } } this.setTitle(title); }, setTitle(title = this._title) { this._title = title; if (this.isViewerEmbedded) { return; } const editorIndicator = this._hasAnnotationEditors &amp;&amp; !this.pdfRenderingQueue.printing; document.title = `${editorIndicator ? &quot;* &quot; : &quot;&quot;}${title}`; }, get _docFilename() { return this._contentDispositionFilename || (0, _pdfjsLib.getPdfFilenameFromUrl)(this.url); }, _hideViewBookmark() { this.appConfig.secondaryToolbar.viewBookmarkButton.hidden = true; }, async close() { this._unblockDocumentLoadEvent(); this._hideViewBookmark(); if (!this.pdfLoadingTask) { return; } if (this.pdfDocument?.annotationStorage.size &gt; 0 &amp;&amp; this._annotationStorageModified) { try { await this.save(); } catch (reason) {} } const promises = []; promises.push(this.pdfLoadingTask.destroy()); this.pdfLoadingTask = null; if (this.pdfDocument) { this.pdfDocument = null; this.pdfThumbnailViewer.setDocument(null); this.pdfViewer.setDocument(null); this.pdfLinkService.setDocument(null); this.pdfDocumentProperties.setDocument(null); } this.pdfLinkService.externalLinkEnabled = true; this.store = null; this.isInitialViewSet = false; this.downloadComplete = false; this.url = &quot;&quot;; this.baseUrl = &quot;&quot;; this._downloadUrl = &quot;&quot;; this.documentInfo = null; this.metadata = null; this._contentDispositionFilename = null; this._contentLength = null; this._saveInProgress = false; this._docStats = null; this._hasAnnotationEditors = false; promises.push(this.pdfScriptingManager.destroyPromise); this.setTitle(); this.pdfSidebar.reset(); this.pdfOutlineViewer.reset(); this.pdfAttachmentViewer.reset(); this.pdfLayerViewer.reset(); this.pdfHistory?.reset(); this.findBar?.reset(); this.toolbar.reset(); this.secondaryToolbar.reset(); this._PDFBug?.cleanup(); await Promise.all(promises); }, async open(file, args) { if (this.pdfLoadingTask) { await this.close(); } const workerParameters = _app_options.AppOptions.getAll(_app_options.OptionKind.WORKER); for (const key in workerParameters) { _pdfjsLib.GlobalWorkerOptions[key] = workerParameters[key]; } const parameters = Object.create(null); if (typeof file === &quot;string&quot;) { this.setTitleUsingUrl(file, file); parameters.url = file; } else if (file &amp;&amp; &quot;byteLength&quot; in file) { parameters.data = file; } else if (file.url &amp;&amp; file.originalUrl) { this.setTitleUsingUrl(file.originalUrl, file.url); parameters.url = file.url; } const apiParameters = _app_options.AppOptions.getAll(_app_options.OptionKind.API); for (const key in apiParameters) { let value = apiParameters[key]; if (key === &quot;docBaseUrl&quot; &amp;&amp; !value) {} parameters[key] = value; } if (args) { for (const key in args) { parameters[key] = args[key]; } } const loadingTask = (0, _pdfjsLib.getDocument)(parameters); this.pdfLoadingTask = loadingTask; loadingTask.onPassword = (updateCallback, reason) =&gt; { this.pdfLinkService.externalLinkEnabled = false; this.passwordPrompt.setUpdateCallback(updateCallback, reason); this.passwordPrompt.open(); }; loadingTask.onProgress = ({ loaded, total }) =&gt; { this.progress(loaded / total); }; loadingTask.onUnsupportedFeature = this.fallback.bind(this); return loadingTask.promise.then(pdfDocument =&gt; { this.load(pdfDocument); }, reason =&gt; { if (loadingTask !== this.pdfLoadingTask) { return undefined; } let key = &quot;loading_error&quot;; if (reason instanceof _pdfjsLib.InvalidPDFException) { key = &quot;invalid_file_error&quot;; } else if (reason instanceof _pdfjsLib.MissingPDFException) { key = &quot;missing_file_error&quot;; } else if (reason instanceof _pdfjsLib.UnexpectedResponseException) { key = &quot;unexpected_response_error&quot;; } return this.l10n.get(key).then(msg =&gt; { this._documentError(msg, { message: reason?.message }); throw reason; }); }); }, _ensureDownloadComplete() { if (this.pdfDocument &amp;&amp; this.downloadComplete) { return; } throw new Error(&quot;PDF document not downloaded.&quot;); }, async download() { const url = this._downloadUrl, filename = this._docFilename; try { this._ensureDownloadComplete(); const data = await this.pdfDocument.getData(); const blob = new Blob([data], { type: &quot;application/pdf&quot; }); await this.downloadManager.download(blob, url, filename); } catch (reason) { await this.downloadManager.downloadUrl(url, filename); } }, async save() { if (this._saveInProgress) { return; } this._saveInProgress = true; await this.pdfScriptingManager.dispatchWillSave(); const url = this._downloadUrl, filename = this._docFilename; try { this._ensureDownloadComplete(); const data = await this.pdfDocument.saveDocument(); const blob = new Blob([data], { type: &quot;application/pdf&quot; }); await this.downloadManager.download(blob, url, filename); } catch (reason) { console.error(`Error when saving the document: ${reason.message}`); await this.download(); } finally { await this.pdfScriptingManager.dispatchDidSave(); this._saveInProgress = false; } if (this._hasAnnotationEditors) { this.externalServices.reportTelemetry({ type: &quot;editing&quot;, data: { type: &quot;save&quot; } }); } }, downloadOrSave() { if (this.pdfDocument?.annotationStorage.size &gt; 0) { this.save(); } else { this.download(); } }, fallback(featureId) { this.externalServices.reportTelemetry({ type: &quot;unsupportedFeature&quot;, featureId }); }, _documentError(message, moreInfo = null) { this._unblockDocumentLoadEvent(); this._otherError(message, moreInfo); this.eventBus.dispatch(&quot;documenterror&quot;, { source: this, message, reason: moreInfo?.message ?? null }); }, _otherError(message, moreInfo = null) { const moreInfoText = [`PDF.js v${_pdfjsLib.version || &quot;?&quot;} (build: ${_pdfjsLib.build || &quot;?&quot;})`]; if (moreInfo) { moreInfoText.push(`Message: ${moreInfo.message}`); if (moreInfo.stack) { moreInfoText.push(`Stack: ${moreInfo.stack}`); } else { if (moreInfo.filename) { moreInfoText.push(`File: ${moreInfo.filename}`); } if (moreInfo.lineNumber) { moreInfoText.push(`Line: ${moreInfo.lineNumber}`); } } } console.error(`${message}\\n\\n${moreInfoText.join(&quot;\\n&quot;)}`); this.fallback(); }, progress(level) { if (this.downloadComplete) { return; } const percent = Math.round(level * 100); if (percent &lt;= this.loadingBar.percent) { return; } this.loadingBar.percent = percent; const disableAutoFetch = this.pdfDocument?.loadingParams.disableAutoFetch ?? _app_options.AppOptions.get(&quot;disableAutoFetch&quot;); if (!disableAutoFetch || isNaN(percent)) { return; } if (this.disableAutoFetchLoadingBarTimeout) { clearTimeout(this.disableAutoFetchLoadingBarTimeout); this.disableAutoFetchLoadingBarTimeout = null; } this.loadingBar.show(); this.disableAutoFetchLoadingBarTimeout = setTimeout(() =&gt; { this.loadingBar.hide(); this.disableAutoFetchLoadingBarTimeout = null; }, DISABLE_AUTO_FETCH_LOADING_BAR_TIMEOUT); }, load(pdfDocument) { this.pdfDocument = pdfDocument; pdfDocument.getDownloadInfo().then(({ length }) =&gt; { this._contentLength = length; this.downloadComplete = true; this.loadingBar.hide(); firstPagePromise.then(() =&gt; { this.eventBus.dispatch(&quot;documentloaded&quot;, { source: this }); }); }); const pageLayoutPromise = pdfDocument.getPageLayout().catch(function () {}); const pageModePromise = pdfDocument.getPageMode().catch(function () {}); const openActionPromise = pdfDocument.getOpenAction().catch(function () {}); this.toolbar.setPagesCount(pdfDocument.numPages, false); this.secondaryToolbar.setPagesCount(pdfDocument.numPages); let baseDocumentUrl; baseDocumentUrl = null; this.pdfLinkService.setDocument(pdfDocument, baseDocumentUrl); this.pdfDocumentProperties.setDocument(pdfDocument); const pdfViewer = this.pdfViewer; pdfViewer.setDocument(pdfDocument); const { firstPagePromise, onePageRendered, pagesPromise } = pdfViewer; const pdfThumbnailViewer = this.pdfThumbnailViewer; pdfThumbnailViewer.setDocument(pdfDocument); const storedPromise = (this.store = new _view_history.ViewHistory(pdfDocument.fingerprints[0])).getMultiple({ page: null, zoom: _ui_utils.DEFAULT_SCALE_VALUE, scrollLeft: &quot;0&quot;, scrollTop: &quot;0&quot;, rotation: null, sidebarView: _ui_utils.SidebarView.UNKNOWN, scrollMode: _ui_utils.ScrollMode.UNKNOWN, spreadMode: _ui_utils.SpreadMode.UNKNOWN }).catch(() =&gt; { return Object.create(null); }); firstPagePromise.then(pdfPage =&gt; { this.loadingBar.setWidth(this.appConfig.viewerContainer); this._initializeAnnotationStorageCallbacks(pdfDocument); Promise.all([_ui_utils.animationStarted, storedPromise, pageLayoutPromise, pageModePromise, openActionPromise]).then(async ([timeStamp, stored, pageLayout, pageMode, openAction]) =&gt; { const viewOnLoad = _app_options.AppOptions.get(&quot;viewOnLoad&quot;); this._initializePdfHistory({ fingerprint: pdfDocument.fingerprints[0], viewOnLoad, initialDest: openAction?.dest }); const initialBookmark = this.initialBookmark; const zoom = _app_options.AppOptions.get(&quot;defaultZoomValue&quot;); let hash = zoom ? `zoom=${zoom}` : null; let rotation = null; let sidebarView = _app_options.AppOptions.get(&quot;sidebarViewOnLoad&quot;); let scrollMode = _app_options.AppOptions.get(&quot;scrollModeOnLoad&quot;); let spreadMode = _app_options.AppOptions.get(&quot;spreadModeOnLoad&quot;); if (stored.page &amp;&amp; viewOnLoad !== ViewOnLoad.INITIAL) { hash = `page=${stored.page}&amp;zoom=${zoom || stored.zoom},` + `${stored.scrollLeft},${stored.scrollTop}`; rotation = parseInt(stored.rotation, 10); if (sidebarView === _ui_utils.SidebarView.UNKNOWN) { sidebarView = stored.sidebarView | 0; } if (scrollMode === _ui_utils.ScrollMode.UNKNOWN) { scrollMode = stored.scrollMode | 0; } if (spreadMode === _ui_utils.SpreadMode.UNKNOWN) { spreadMode = stored.spreadMode | 0; } } if (pageMode &amp;&amp; sidebarView === _ui_utils.SidebarView.UNKNOWN) { sidebarView = (0, _ui_utils.apiPageModeToSidebarView)(pageMode); } if (pageLayout &amp;&amp; scrollMode === _ui_utils.ScrollMode.UNKNOWN &amp;&amp; spreadMode === _ui_utils.SpreadMode.UNKNOWN) { const modes = (0, _ui_utils.apiPageLayoutToViewerModes)(pageLayout); spreadMode = modes.spreadMode; } this.setInitialView(hash, { rotation, sidebarView, scrollMode, spreadMode }); this.eventBus.dispatch(&quot;documentinit&quot;, { source: this }); if (!this.isViewerEmbedded) { pdfViewer.focus(); } await Promise.race([pagesPromise, new Promise(resolve =&gt; { setTimeout(resolve, FORCE_PAGES_LOADED_TIMEOUT); })]); if (!initialBookmark &amp;&amp; !hash) { return; } if (pdfViewer.hasEqualPageSizes) { return; } this.initialBookmark = initialBookmark; pdfViewer.currentScaleValue = pdfViewer.currentScaleValue; this.setInitialView(hash); }).catch(() =&gt; { this.setInitialView(); }).then(function () { pdfViewer.update(); }); }); pagesPromise.then(() =&gt; { this._unblockDocumentLoadEvent(); this._initializeAutoPrint(pdfDocument, openActionPromise); }, reason =&gt; { this.l10n.get(&quot;loading_error&quot;).then(msg =&gt; { this._documentError(msg, { message: reason?.message }); }); }); onePageRendered.then(data =&gt; { this.externalServices.reportTelemetry({ type: &quot;pageInfo&quot;, timestamp: data.timestamp }); pdfDocument.getOutline().then(outline =&gt; { if (pdfDocument !== this.pdfDocument) { return; } this.pdfOutlineViewer.render({ outline, pdfDocument }); }); pdfDocument.getAttachments().then(attachments =&gt; { if (pdfDocument !== this.pdfDocument) { return; } this.pdfAttachmentViewer.render({ attachments }); }); pdfViewer.optionalContentConfigPromise.then(optionalContentConfig =&gt; { if (pdfDocument !== this.pdfDocument) { return; } this.pdfLayerViewer.render({ optionalContentConfig, pdfDocument }); }); }); this._initializePageLabels(pdfDocument); this._initializeMetadata(pdfDocument); }, async _scriptingDocProperties(pdfDocument) { if (!this.documentInfo) { await new Promise(resolve =&gt; { this.eventBus._on(&quot;metadataloaded&quot;, resolve, { once: true }); }); if (pdfDocument !== this.pdfDocument) { return null; } } if (!this._contentLength) { await new Promise(resolve =&gt; { this.eventBus._on(&quot;documentloaded&quot;, resolve, { once: true }); }); if (pdfDocument !== this.pdfDocument) { return null; } } return { ...this.documentInfo, baseURL: this.baseUrl, filesize: this._contentLength, filename: this._docFilename, metadata: this.metadata?.getRaw(), authors: this.metadata?.get(&quot;dc:creator&quot;), numPages: this.pagesCount, URL: this.url }; }, async _initializeAutoPrint(pdfDocument, openActionPromise) { const [openAction, javaScript] = await Promise.all([openActionPromise, !this.pdfViewer.enableScripting ? pdfDocument.getJavaScript() : null]); if (pdfDocument !== this.pdfDocument) { return; } let triggerAutoPrint = false; if (openAction?.action === &quot;Print&quot;) { triggerAutoPrint = true; } if (javaScript) { javaScript.some(js =&gt; { if (!js) { return false; } console.warn(&quot;Warning: JavaScript support is not enabled&quot;); this.fallback(_pdfjsLib.UNSUPPORTED_FEATURES.javaScript); return true; }); if (!triggerAutoPrint) { for (const js of javaScript) { if (js &amp;&amp; _ui_utils.AutoPrintRegExp.test(js)) { triggerAutoPrint = true; break; } } } } if (triggerAutoPrint) { this.triggerPrinting(); } }, async _initializeMetadata(pdfDocument) { const { info, metadata, contentDispositionFilename, contentLength } = await pdfDocument.getMetadata(); if (pdfDocument !== this.pdfDocument) { return; } this.documentInfo = info; this.metadata = metadata; this._contentDispositionFilename ??= contentDispositionFilename; this._contentLength ??= contentLength; console.log(`PDF ${pdfDocument.fingerprints[0]} [${info.PDFFormatVersion} ` + `${(info.Producer || &quot;-&quot;).trim()} / ${(info.Creator || &quot;-&quot;).trim()}] ` + `(PDF.js: ${_pdfjsLib.version || &quot;?&quot;} [${_pdfjsLib.build || &quot;?&quot;}])`); let pdfTitle = info.Title; const metadataTitle = metadata?.get(&quot;dc:title&quot;); if (metadataTitle) { if (metadataTitle !== &quot;Untitled&quot; &amp;&amp; !/[\\uFFF0-\\uFFFF]/g.test(metadataTitle)) { pdfTitle = metadataTitle; } } if (pdfTitle) { this.setTitle(`${pdfTitle} - ${this._contentDispositionFilename || this._title}`); } else if (this._contentDispositionFilename) { this.setTitle(this._contentDispositionFilename); } if (info.IsXFAPresent &amp;&amp; !info.IsAcroFormPresent &amp;&amp; !pdfDocument.isPureXfa) { if (pdfDocument.loadingParams.enableXfa) { console.warn(&quot;Warning: XFA Foreground documents are not supported&quot;); } else { console.warn(&quot;Warning: XFA support is not enabled&quot;); } this.fallback(_pdfjsLib.UNSUPPORTED_FEATURES.forms); } else if ((info.IsAcroFormPresent || info.IsXFAPresent) &amp;&amp; !this.pdfViewer.renderForms) { console.warn(&quot;Warning: Interactive form support is not enabled&quot;); this.fallback(_pdfjsLib.UNSUPPORTED_FEATURES.forms); } if (info.IsSignaturesPresent) { console.warn(&quot;Warning: Digital signatures validation is not supported&quot;); this.fallback(_pdfjsLib.UNSUPPORTED_FEATURES.signatures); } let versionId = &quot;other&quot;; if (KNOWN_VERSIONS.includes(info.PDFFormatVersion)) { versionId = `v${info.PDFFormatVersion.replace(&quot;.&quot;, &quot;_&quot;)}`; } let generatorId = &quot;other&quot;; if (info.Producer) { const producer = info.Producer.toLowerCase(); KNOWN_GENERATORS.some(function (generator) { if (!producer.includes(generator)) { return false; } generatorId = generator.replace(/[ .-]/g, &quot;_&quot;); return true; }); } let formType = null; if (info.IsXFAPresent) { formType = &quot;xfa&quot;; } else if (info.IsAcroFormPresent) { formType = &quot;acroform&quot;; } this.externalServices.reportTelemetry({ type: &quot;documentInfo&quot;, version: versionId, generator: generatorId, formType }); this.eventBus.dispatch(&quot;metadataloaded&quot;, { source: this }); }, async _initializePageLabels(pdfDocument) { const labels = await pdfDocument.getPageLabels(); if (pdfDocument !== this.pdfDocument) { return; } if (!labels || _app_options.AppOptions.get(&quot;disablePageLabels&quot;)) { return; } const numLabels = labels.length; let standardLabels = 0, emptyLabels = 0; for (let i = 0; i &lt; numLabels; i++) { const label = labels[i]; if (label === (i + 1).toString()) { standardLabels++; } else if (label === &quot;&quot;) { emptyLabels++; } else { break; } } if (standardLabels &gt;= numLabels || emptyLabels &gt;= numLabels) { return; } const { pdfViewer, pdfThumbnailViewer, toolbar } = this; pdfViewer.setPageLabels(labels); pdfThumbnailViewer.setPageLabels(labels); toolbar.setPagesCount(numLabels, true); toolbar.setPageNumber(pdfViewer.currentPageNumber, pdfViewer.currentPageLabel); }, _initializePdfHistory({ fingerprint, viewOnLoad, initialDest = null }) { if (!this.pdfHistory) { return; } this.pdfHistory.initialize({ fingerprint, resetHistory: viewOnLoad === ViewOnLoad.INITIAL, updateUrl: _app_options.AppOptions.get(&quot;historyUpdateUrl&quot;) }); if (this.pdfHistory.initialBookmark) { this.initialBookmark = this.pdfHistory.initialBookmark; this.initialRotation = this.pdfHistory.initialRotation; } if (initialDest &amp;&amp; !this.initialBookmark &amp;&amp; viewOnLoad === ViewOnLoad.UNKNOWN) { this.initialBookmark = JSON.stringify(initialDest); this.pdfHistory.push({ explicitDest: initialDest, pageNumber: null }); } }, _initializeAnnotationStorageCallbacks(pdfDocument) { if (pdfDocument !== this.pdfDocument) { return; } const { annotationStorage } = pdfDocument; annotationStorage.onSetModified = () =&gt; { window.addEventListener(&quot;beforeunload&quot;, beforeUnload); this._annotationStorageModified = true; }; annotationStorage.onResetModified = () =&gt; { window.removeEventListener(&quot;beforeunload&quot;, beforeUnload); delete this._annotationStorageModified; }; annotationStorage.onAnnotationEditor = typeStr =&gt; { this._hasAnnotationEditors = !!typeStr; this.setTitle(); if (typeStr) { this.externalServices.reportTelemetry({ type: &quot;editing&quot;, data: { type: typeStr } }); } }; }, setInitialView(storedHash, { rotation, sidebarView, scrollMode, spreadMode } = {}) { const setRotation = angle =&gt; { if ((0, _ui_utils.isValidRotation)(angle)) { this.pdfViewer.pagesRotation = angle; } }; const setViewerModes = (scroll, spread) =&gt; { if ((0, _ui_utils.isValidScrollMode)(scroll)) { this.pdfViewer.scrollMode = scroll; } if ((0, _ui_utils.isValidSpreadMode)(spread)) { this.pdfViewer.spreadMode = spread; } }; this.isInitialViewSet = true; this.pdfSidebar.setInitialView(sidebarView); setViewerModes(scrollMode, spreadMode); if (this.initialBookmark) { setRotation(this.initialRotation); delete this.initialRotation; this.pdfLinkService.setHash(this.initialBookmark); this.initialBookmark = null; } else if (storedHash) { setRotation(rotation); this.pdfLinkService.setHash(storedHash); } this.toolbar.setPageNumber(this.pdfViewer.currentPageNumber, this.pdfViewer.currentPageLabel); this.secondaryToolbar.setPageNumber(this.pdfViewer.currentPageNumber); if (!this.pdfViewer.currentScaleValue) { this.pdfViewer.currentScaleValue = _ui_utils.DEFAULT_SCALE_VALUE; } }, _cleanup() { if (!this.pdfDocument) { return; } this.pdfViewer.cleanup(); this.pdfThumbnailViewer.cleanup(); this.pdfDocument.cleanup(this.pdfViewer.renderer === _ui_utils.RendererType.SVG); }, forceRendering() { this.pdfRenderingQueue.printing = !!this.printService; this.pdfRenderingQueue.isThumbnailViewEnabled = this.pdfSidebar.visibleView === _ui_utils.SidebarView.THUMBS; this.pdfRenderingQueue.renderHighestPriority(); }, beforePrint() { this._printAnnotationStoragePromise = this.pdfScriptingManager.dispatchWillPrint().catch(() =&gt; {}).then(() =&gt; { return this.pdfDocument?.annotationStorage.print; }); if (this.printService) { return; } if (!this.supportsPrinting) { this.l10n.get(&quot;printing_not_supported&quot;).then(msg =&gt; { this._otherError(msg); }); return; } if (!this.pdfViewer.pageViewsReady) { this.l10n.get(&quot;printing_not_ready&quot;).then(msg =&gt; { window.alert(msg); }); return; } const pagesOverview = this.pdfViewer.getPagesOverview(); const printContainer = this.appConfig.printContainer; const printResolution = _app_options.AppOptions.get(&quot;printResolution&quot;); const optionalContentConfigPromise = this.pdfViewer.optionalContentConfigPromise; const printService = PDFPrintServiceFactory.instance.createPrintService(this.pdfDocument, pagesOverview, printContainer, printResolution, optionalContentConfigPromise, this._printAnnotationStoragePromise, this.l10n); this.printService = printService; this.forceRendering(); this.setTitle(); printService.layout(); this.externalServices.reportTelemetry({ type: &quot;print&quot; }); if (this._hasAnnotationEditors) { this.externalServices.reportTelemetry({ type: &quot;editing&quot;, data: { type: &quot;print&quot; } }); } }, afterPrint() { if (this._printAnnotationStoragePromise) { this._printAnnotationStoragePromise.then(() =&gt; { this.pdfScriptingManager.dispatchDidPrint(); }); this._printAnnotationStoragePromise = null; } if (this.printService) { this.printService.destroy(); this.printService = null; this.pdfDocument?.annotationStorage.resetModified(); } this.forceRendering(); this.setTitle(); }, rotatePages(delta) { this.pdfViewer.pagesRotation += delta; }, requestPresentationMode() { this.pdfPresentationMode?.request(); }, triggerPrinting() { if (!this.supportsPrinting) { return; } window.print(); }, bindEvents() { const { eventBus, _boundEvents } = this; _boundEvents.beforePrint = this.beforePrint.bind(this); _boundEvents.afterPrint = this.afterPrint.bind(this); eventBus._on(&quot;resize&quot;, webViewerResize); eventBus._on(&quot;hashchange&quot;, webViewerHashchange); eventBus._on(&quot;beforeprint&quot;, _boundEvents.beforePrint); eventBus._on(&quot;afterprint&quot;, _boundEvents.afterPrint); eventBus._on(&quot;pagerendered&quot;, webViewerPageRendered); eventBus._on(&quot;updateviewarea&quot;, webViewerUpdateViewarea); eventBus._on(&quot;pagechanging&quot;, webViewerPageChanging); eventBus._on(&quot;scalechanging&quot;, webViewerScaleChanging); eventBus._on(&quot;rotationchanging&quot;, webViewerRotationChanging); eventBus._on(&quot;sidebarviewchanged&quot;, webViewerSidebarViewChanged); eventBus._on(&quot;pagemode&quot;, webViewerPageMode); eventBus._on(&quot;namedaction&quot;, webViewerNamedAction); eventBus._on(&quot;presentationmodechanged&quot;, webViewerPresentationModeChanged); eventBus._on(&quot;presentationmode&quot;, webViewerPresentationMode); eventBus._on(&quot;switchannotationeditormode&quot;, webViewerSwitchAnnotationEditorMode); eventBus._on(&quot;switchannotationeditorparams&quot;, webViewerSwitchAnnotationEditorParams); eventBus._on(&quot;print&quot;, webViewerPrint); eventBus._on(&quot;download&quot;, webViewerDownload); eventBus._on(&quot;firstpage&quot;, webViewerFirstPage); eventBus._on(&quot;lastpage&quot;, webViewerLastPage); eventBus._on(&quot;nextpage&quot;, webViewerNextPage); eventBus._on(&quot;previouspage&quot;, webViewerPreviousPage); eventBus._on(&quot;zoomin&quot;, webViewerZoomIn); eventBus._on(&quot;zoomout&quot;, webViewerZoomOut); eventBus._on(&quot;zoomreset&quot;, webViewerZoomReset); eventBus._on(&quot;pagenumberchanged&quot;, webViewerPageNumberChanged); eventBus._on(&quot;scalechanged&quot;, webViewerScaleChanged); eventBus._on(&quot;rotatecw&quot;, webViewerRotateCw); eventBus._on(&quot;rotateccw&quot;, webViewerRotateCcw); eventBus._on(&quot;optionalcontentconfig&quot;, webViewerOptionalContentConfig); eventBus._on(&quot;switchscrollmode&quot;, webViewerSwitchScrollMode); eventBus._on(&quot;scrollmodechanged&quot;, webViewerScrollModeChanged); eventBus._on(&quot;switchspreadmode&quot;, webViewerSwitchSpreadMode); eventBus._on(&quot;spreadmodechanged&quot;, webViewerSpreadModeChanged); eventBus._on(&quot;documentproperties&quot;, webViewerDocumentProperties); eventBus._on(&quot;findfromurlhash&quot;, webViewerFindFromUrlHash); eventBus._on(&quot;updatefindmatchescount&quot;, webViewerUpdateFindMatchesCount); eventBus._on(&quot;updatefindcontrolstate&quot;, webViewerUpdateFindControlState); if (_app_options.AppOptions.get(&quot;pdfBug&quot;)) { _boundEvents.reportPageStatsPDFBug = reportPageStatsPDFBug; eventBus._on(&quot;pagerendered&quot;, _boundEvents.reportPageStatsPDFBug); eventBus._on(&quot;pagechanging&quot;, _boundEvents.reportPageStatsPDFBug); } eventBus._on(&quot;fileinputchange&quot;, webViewerFileInputChange); eventBus._on(&quot;openfile&quot;, webViewerOpenFile); }, bindWindowEvents() { const { eventBus, _boundEvents } = this; function addWindowResolutionChange(evt = null) { if (evt) { webViewerResolutionChange(evt); } const mediaQueryList = window.matchMedia(`(resolution: ${window.devicePixelRatio || 1}dppx)`); mediaQueryList.addEventListener(&quot;change&quot;, addWindowResolutionChange, { once: true }); _boundEvents.removeWindowResolutionChange ||= function () { mediaQueryList.removeEventListener(&quot;change&quot;, addWindowResolutionChange); _boundEvents.removeWindowResolutionChange = null; }; } addWindowResolutionChange(); _boundEvents.windowResize = () =&gt; { eventBus.dispatch(&quot;resize&quot;, { source: window }); }; _boundEvents.windowHashChange = () =&gt; { eventBus.dispatch(&quot;hashchange&quot;, { source: window, hash: document.location.hash.substring(1) }); }; _boundEvents.windowBeforePrint = () =&gt; { eventBus.dispatch(&quot;beforeprint&quot;, { source: window }); }; _boundEvents.windowAfterPrint = () =&gt; { eventBus.dispatch(&quot;afterprint&quot;, { source: window }); }; _boundEvents.windowUpdateFromSandbox = event =&gt; { eventBus.dispatch(&quot;updatefromsandbox&quot;, { source: window, detail: event.detail }); }; window.addEventListener(&quot;visibilitychange&quot;, webViewerVisibilityChange); window.addEventListener(&quot;wheel&quot;, webViewerWheel, { passive: false }); window.addEventListener(&quot;touchstart&quot;, webViewerTouchStart, { passive: false }); window.addEventListener(&quot;click&quot;, webViewerClick); window.addEventListener(&quot;keydown&quot;, webViewerKeyDown); window.addEventListener(&quot;resize&quot;, _boundEvents.windowResize); window.addEventListener(&quot;hashchange&quot;, _boundEvents.windowHashChange); window.addEventListener(&quot;beforeprint&quot;, _boundEvents.windowBeforePrint); window.addEventListener(&quot;afterprint&quot;, _boundEvents.windowAfterPrint); window.addEventListener(&quot;updatefromsandbox&quot;, _boundEvents.windowUpdateFromSandbox); }, unbindEvents() { const { eventBus, _boundEvents } = this; eventBus._off(&quot;resize&quot;, webViewerResize); eventBus._off(&quot;hashchange&quot;, webViewerHashchange); eventBus._off(&quot;beforeprint&quot;, _boundEvents.beforePrint); eventBus._off(&quot;afterprint&quot;, _boundEvents.afterPrint); eventBus._off(&quot;pagerendered&quot;, webViewerPageRendered); eventBus._off(&quot;updateviewarea&quot;, webViewerUpdateViewarea); eventBus._off(&quot;pagechanging&quot;, webViewerPageChanging); eventBus._off(&quot;scalechanging&quot;, webViewerScaleChanging); eventBus._off(&quot;rotationchanging&quot;, webViewerRotationChanging); eventBus._off(&quot;sidebarviewchanged&quot;, webViewerSidebarViewChanged); eventBus._off(&quot;pagemode&quot;, webViewerPageMode); eventBus._off(&quot;namedaction&quot;, webViewerNamedAction); eventBus._off(&quot;presentationmodechanged&quot;, webViewerPresentationModeChanged); eventBus._off(&quot;presentationmode&quot;, webViewerPresentationMode); eventBus._off(&quot;print&quot;, webViewerPrint); eventBus._off(&quot;download&quot;, webViewerDownload); eventBus._off(&quot;firstpage&quot;, webViewerFirstPage); eventBus._off(&quot;lastpage&quot;, webViewerLastPage); eventBus._off(&quot;nextpage&quot;, webViewerNextPage); eventBus._off(&quot;previouspage&quot;, webViewerPreviousPage); eventBus._off(&quot;zoomin&quot;, webViewerZoomIn); eventBus._off(&quot;zoomout&quot;, webViewerZoomOut); eventBus._off(&quot;zoomreset&quot;, webViewerZoomReset); eventBus._off(&quot;pagenumberchanged&quot;, webViewerPageNumberChanged); eventBus._off(&quot;scalechanged&quot;, webViewerScaleChanged); eventBus._off(&quot;rotatecw&quot;, webViewerRotateCw); eventBus._off(&quot;rotateccw&quot;, webViewerRotateCcw); eventBus._off(&quot;optionalcontentconfig&quot;, webViewerOptionalContentConfig); eventBus._off(&quot;switchscrollmode&quot;, webViewerSwitchScrollMode); eventBus._off(&quot;scrollmodechanged&quot;, webViewerScrollModeChanged); eventBus._off(&quot;switchspreadmode&quot;, webViewerSwitchSpreadMode); eventBus._off(&quot;spreadmodechanged&quot;, webViewerSpreadModeChanged); eventBus._off(&quot;documentproperties&quot;, webViewerDocumentProperties); eventBus._off(&quot;findfromurlhash&quot;, webViewerFindFromUrlHash); eventBus._off(&quot;updatefindmatchescount&quot;, webViewerUpdateFindMatchesCount); eventBus._off(&quot;updatefindcontrolstate&quot;, webViewerUpdateFindControlState); if (_boundEvents.reportPageStatsPDFBug) { eventBus._off(&quot;pagerendered&quot;, _boundEvents.reportPageStatsPDFBug); eventBus._off(&quot;pagechanging&quot;, _boundEvents.reportPageStatsPDFBug); _boundEvents.reportPageStatsPDFBug = null; } eventBus._off(&quot;fileinputchange&quot;, webViewerFileInputChange); eventBus._off(&quot;openfile&quot;, webViewerOpenFile); _boundEvents.beforePrint = null; _boundEvents.afterPrint = null; }, unbindWindowEvents() { const { _boundEvents } = this; window.removeEventListener(&quot;visibilitychange&quot;, webViewerVisibilityChange); window.removeEventListener(&quot;wheel&quot;, webViewerWheel, { passive: false }); window.removeEventListener(&quot;touchstart&quot;, webViewerTouchStart, { passive: false }); window.removeEventListener(&quot;click&quot;, webViewerClick); window.removeEventListener(&quot;keydown&quot;, webViewerKeyDown); window.removeEventListener(&quot;resize&quot;, _boundEvents.windowResize); window.removeEventListener(&quot;hashchange&quot;, _boundEvents.windowHashChange); window.removeEventListener(&quot;beforeprint&quot;, _boundEvents.windowBeforePrint); window.removeEventListener(&quot;afterprint&quot;, _boundEvents.windowAfterPrint); window.removeEventListener(&quot;updatefromsandbox&quot;, _boundEvents.windowUpdateFromSandbox); _boundEvents.removeWindowResolutionChange?.(); _boundEvents.windowResize = null; _boundEvents.windowHashChange = null; _boundEvents.windowBeforePrint = null; _boundEvents.windowAfterPrint = null; _boundEvents.windowUpdateFromSandbox = null; }, accumulateWheelTicks(ticks) { if (this._wheelUnusedTicks &gt; 0 &amp;&amp; ticks &lt; 0 || this._wheelUnusedTicks &lt; 0 &amp;&amp; ticks &gt; 0) { this._wheelUnusedTicks = 0; } this._wheelUnusedTicks += ticks; const wholeTicks = Math.sign(this._wheelUnusedTicks) * Math.floor(Math.abs(this._wheelUnusedTicks)); this._wheelUnusedTicks -= wholeTicks; return wholeTicks; }, _unblockDocumentLoadEvent() { document.blockUnblockOnload?.(false); this._unblockDocumentLoadEvent = () =&gt; {}; }, _reportDocumentStatsTelemetry() { const { stats } = this.pdfDocument; if (stats !== this._docStats) { this._docStats = stats; this.externalServices.reportTelemetry({ type: &quot;documentStats&quot;, stats }); } }, get scriptingReady() { return this.pdfScriptingManager.ready; } }; exports.PDFViewerApplication = PDFViewerApplication; { const HOSTED_VIEWER_ORIGINS = [&quot;null&quot;, &quot;http://mozilla.github.io&quot;, &quot;https://mozilla.github.io&quot;]; var validateFileURL = function (file) { if (!file) { return; } try { const viewerOrigin = new URL(window.location.href).origin || &quot;null&quot;; if (HOSTED_VIEWER_ORIGINS.includes(viewerOrigin)) { return; } const fileOrigin = new URL(file, window.location.href).origin; if (fileOrigin !== viewerOrigin) { throw new Error(&quot;file origin does not match viewer&apos;s&quot;); } } catch (ex) { PDFViewerApplication.l10n.get(&quot;loading_error&quot;).then(msg =&gt; { PDFViewerApplication._documentError(msg, { message: ex?.message }); }); throw ex; } }; } async function loadFakeWorker() { _pdfjsLib.GlobalWorkerOptions.workerSrc ||= _app_options.AppOptions.get(&quot;workerSrc&quot;); await (0, _pdfjsLib.loadScript)(_pdfjsLib.PDFWorker.workerSrc); } async function loadPDFBug(self) { const { debuggerScriptPath } = self.appConfig; const { PDFBug } = await import(debuggerScriptPath); self._PDFBug = PDFBug; } function reportPageStatsPDFBug({ pageNumber }) { if (!globalThis.Stats?.enabled) { return; } const pageView = PDFViewerApplication.pdfViewer.getPageView(pageNumber - 1); globalThis.Stats.add(pageNumber, pageView?.pdfPage?.stats); } function webViewerInitialized() { const { appConfig, eventBus } = PDFViewerApplication; let file; const queryString = document.location.search.substring(1); const params = (0, _ui_utils.parseQueryString)(queryString); file = params.get(&quot;file&quot;) ?? _app_options.AppOptions.get(&quot;defaultUrl&quot;); validateFileURL(file); const fileInput = appConfig.openFileInput; fileInput.value = null; fileInput.addEventListener(&quot;change&quot;, function (evt) { const { files } = evt.target; if (!files || files.length === 0) { return; } eventBus.dispatch(&quot;fileinputchange&quot;, { source: this, fileInput: evt.target }); }); appConfig.mainContainer.addEventListener(&quot;dragover&quot;, function (evt) { evt.preventDefault(); evt.dataTransfer.dropEffect = evt.dataTransfer.effectAllowed === &quot;copy&quot; ? &quot;copy&quot; : &quot;move&quot;; }); appConfig.mainContainer.addEventListener(&quot;drop&quot;, function (evt) { evt.preventDefault(); const { files } = evt.dataTransfer; if (!files || files.length === 0) { return; } eventBus.dispatch(&quot;fileinputchange&quot;, { source: this, fileInput: evt.dataTransfer }); }); if (!PDFViewerApplication.supportsDocumentFonts) { _app_options.AppOptions.set(&quot;disableFontFace&quot;, true); PDFViewerApplication.l10n.get(&quot;web_fonts_disabled&quot;).then(msg =&gt; { console.warn(msg); }); } if (!PDFViewerApplication.supportsPrinting) { appConfig.toolbar.print.classList.add(&quot;hidden&quot;); appConfig.secondaryToolbar.printButton.classList.add(&quot;hidden&quot;); } if (!PDFViewerApplication.supportsFullscreen) { appConfig.secondaryToolbar.presentationModeButton.classList.add(&quot;hidden&quot;); } if (PDFViewerApplication.supportsIntegratedFind) { appConfig.toolbar.viewFind.classList.add(&quot;hidden&quot;); } appConfig.mainContainer.addEventListener(&quot;transitionend&quot;, function (evt) { if (evt.target === this) { eventBus.dispatch(&quot;resize&quot;, { source: this }); } }, true); try { if (file) { PDFViewerApplication.open(file); } else { PDFViewerApplication._hideViewBookmark(); } } catch (reason) { PDFViewerApplication.l10n.get(&quot;loading_error&quot;).then(msg =&gt; { PDFViewerApplication._documentError(msg, reason); }); } } function webViewerPageRendered({ pageNumber, error }) { if (pageNumber === PDFViewerApplication.page) { PDFViewerApplication.toolbar.updateLoadingIndicatorState(false); } if (PDFViewerApplication.pdfSidebar.visibleView === _ui_utils.SidebarView.THUMBS) { const pageView = PDFViewerApplication.pdfViewer.getPageView(pageNumber - 1); const thumbnailView = PDFViewerApplication.pdfThumbnailViewer.getThumbnail(pageNumber - 1); if (pageView &amp;&amp; thumbnailView) { thumbnailView.setImage(pageView); } } if (error) { PDFViewerApplication.l10n.get(&quot;rendering_error&quot;).then(msg =&gt; { PDFViewerApplication._otherError(msg, error); }); } PDFViewerApplication._reportDocumentStatsTelemetry(); } function webViewerPageMode({ mode }) { let view; switch (mode) { case &quot;thumbs&quot;: view = _ui_utils.SidebarView.THUMBS; break; case &quot;bookmarks&quot;: case &quot;outline&quot;: view = _ui_utils.SidebarView.OUTLINE; break; case &quot;attachments&quot;: view = _ui_utils.SidebarView.ATTACHMENTS; break; case &quot;layers&quot;: view = _ui_utils.SidebarView.LAYERS; break; case &quot;none&quot;: view = _ui_utils.SidebarView.NONE; break; default: console.error(&apos;Invalid &quot;pagemode&quot; hash parameter: &apos; + mode); return; } PDFViewerApplication.pdfSidebar.switchView(view, true); } function webViewerNamedAction(evt) { switch (evt.action) { case &quot;GoToPage&quot;: PDFViewerApplication.appConfig.toolbar.pageNumber.select(); break; case &quot;Find&quot;: if (!PDFViewerApplication.supportsIntegratedFind) { PDFViewerApplication.findBar.toggle(); } break; case &quot;Print&quot;: PDFViewerApplication.triggerPrinting(); break; case &quot;SaveAs&quot;: PDFViewerApplication.downloadOrSave(); break; } } function webViewerPresentationModeChanged(evt) { PDFViewerApplication.pdfViewer.presentationModeState = evt.state; } function webViewerSidebarViewChanged({ view }) { PDFViewerApplication.pdfRenderingQueue.isThumbnailViewEnabled = view === _ui_utils.SidebarView.THUMBS; if (PDFViewerApplication.isInitialViewSet) { PDFViewerApplication.store?.set(&quot;sidebarView&quot;, view).catch(() =&gt; {}); } } function webViewerUpdateViewarea({ location }) { if (PDFViewerApplication.isInitialViewSet) { PDFViewerApplication.store?.setMultiple({ page: location.pageNumber, zoom: location.scale, scrollLeft: location.left, scrollTop: location.top, rotation: location.rotation }).catch(() =&gt; {}); } const href = PDFViewerApplication.pdfLinkService.getAnchorUrl(location.pdfOpenParams); PDFViewerApplication.appConfig.secondaryToolbar.viewBookmarkButton.href = href; const currentPage = PDFViewerApplication.pdfViewer.getPageView(PDFViewerApplication.page - 1); const loading = currentPage?.renderingState !== _ui_utils.RenderingStates.FINISHED; PDFViewerApplication.toolbar.updateLoadingIndicatorState(loading); } function webViewerScrollModeChanged(evt) { if (PDFViewerApplication.isInitialViewSet &amp;&amp; !PDFViewerApplication.pdfViewer.isInPresentationMode) { PDFViewerApplication.store?.set(&quot;scrollMode&quot;, evt.mode).catch(() =&gt; {}); } } function webViewerSpreadModeChanged(evt) { if (PDFViewerApplication.isInitialViewSet &amp;&amp; !PDFViewerApplication.pdfViewer.isInPresentationMode) { PDFViewerApplication.store?.set(&quot;spreadMode&quot;, evt.mode).catch(() =&gt; {}); } } function webViewerResize() { const { pdfDocument, pdfViewer, pdfRenderingQueue } = PDFViewerApplication; if (pdfRenderingQueue.printing &amp;&amp; window.matchMedia(&quot;print&quot;).matches) { return; } pdfViewer.updateContainerHeightCss(); if (!pdfDocument) { return; } const currentScaleValue = pdfViewer.currentScaleValue; if (currentScaleValue === &quot;auto&quot; || currentScaleValue === &quot;page-fit&quot; || currentScaleValue === &quot;page-width&quot;) { pdfViewer.currentScaleValue = currentScaleValue; } pdfViewer.update(); } function webViewerHashchange(evt) { const hash = evt.hash; if (!hash) { return; } if (!PDFViewerApplication.isInitialViewSet) { PDFViewerApplication.initialBookmark = hash; } else if (!PDFViewerApplication.pdfHistory?.popStateInProgress) { PDFViewerApplication.pdfLinkService.setHash(hash); } } { var webViewerFileInputChange = function (evt) { if (PDFViewerApplication.pdfViewer?.isInPresentationMode) { return; } const file = evt.fileInput.files[0]; let url = URL.createObjectURL(file); if (file.name) { url = { url, originalUrl: file.name }; } PDFViewerApplication.open(url); }; var webViewerOpenFile = function (evt) { const fileInput = PDFViewerApplication.appConfig.openFileInput; fileInput.click(); }; } function webViewerPresentationMode() { PDFViewerApplication.requestPresentationMode(); } function webViewerSwitchAnnotationEditorMode(evt) { PDFViewerApplication.pdfViewer.annotationEditorMode = evt.mode; } function webViewerSwitchAnnotationEditorParams(evt) { PDFViewerApplication.pdfViewer.annotationEditorParams = evt; } function webViewerPrint() { PDFViewerApplication.triggerPrinting(); } function webViewerDownload() { PDFViewerApplication.downloadOrSave(); } function webViewerFirstPage() { if (PDFViewerApplication.pdfDocument) { PDFViewerApplication.page = 1; } } function webViewerLastPage() { if (PDFViewerApplication.pdfDocument) { PDFViewerApplication.page = PDFViewerApplication.pagesCount; } } function webViewerNextPage() { PDFViewerApplication.pdfViewer.nextPage(); } function webViewerPreviousPage() { PDFViewerApplication.pdfViewer.previousPage(); } function webViewerZoomIn() { PDFViewerApplication.zoomIn(); } function webViewerZoomOut() { PDFViewerApplication.zoomOut(); } function webViewerZoomReset() { PDFViewerApplication.zoomReset(); } function webViewerPageNumberChanged(evt) { const pdfViewer = PDFViewerApplication.pdfViewer; if (evt.value !== &quot;&quot;) { PDFViewerApplication.pdfLinkService.goToPage(evt.value); } if (evt.value !== pdfViewer.currentPageNumber.toString() &amp;&amp; evt.value !== pdfViewer.currentPageLabel) { PDFViewerApplication.toolbar.setPageNumber(pdfViewer.currentPageNumber, pdfViewer.currentPageLabel); } } function webViewerScaleChanged(evt) { PDFViewerApplication.pdfViewer.currentScaleValue = evt.value; } function webViewerRotateCw() { PDFViewerApplication.rotatePages(90); } function webViewerRotateCcw() { PDFViewerApplication.rotatePages(-90); } function webViewerOptionalContentConfig(evt) { PDFViewerApplication.pdfViewer.optionalContentConfigPromise = evt.promise; } function webViewerSwitchScrollMode(evt) { PDFViewerApplication.pdfViewer.scrollMode = evt.mode; } function webViewerSwitchSpreadMode(evt) { PDFViewerApplication.pdfViewer.spreadMode = evt.mode; } function webViewerDocumentProperties() { PDFViewerApplication.pdfDocumentProperties.open(); } function webViewerFindFromUrlHash(evt) { PDFViewerApplication.eventBus.dispatch(&quot;find&quot;, { source: evt.source, type: &quot;&quot;, query: evt.query, phraseSearch: evt.phraseSearch, caseSensitive: false, entireWord: false, highlightAll: true, findPrevious: false, matchDiacritics: true }); } function webViewerUpdateFindMatchesCount({ matchesCount }) { if (PDFViewerApplication.supportsIntegratedFind) { PDFViewerApplication.externalServices.updateFindMatchesCount(matchesCount); } else { PDFViewerApplication.findBar.updateResultsCount(matchesCount); } } function webViewerUpdateFindControlState({ state, previous, matchesCount, rawQuery }) { if (PDFViewerApplication.supportsIntegratedFind) { PDFViewerApplication.externalServices.updateFindControlState({ result: state, findPrevious: previous, matchesCount, rawQuery }); } else { PDFViewerApplication.findBar.updateUIState(state, previous, matchesCount); } } function webViewerScaleChanging(evt) { PDFViewerApplication.toolbar.setPageScale(evt.presetValue, evt.scale); PDFViewerApplication.pdfViewer.update(); } function webViewerRotationChanging(evt) { PDFViewerApplication.pdfThumbnailViewer.pagesRotation = evt.pagesRotation; PDFViewerApplication.forceRendering(); PDFViewerApplication.pdfViewer.currentPageNumber = evt.pageNumber; } function webViewerPageChanging({ pageNumber, pageLabel }) { PDFViewerApplication.toolbar.setPageNumber(pageNumber, pageLabel); PDFViewerApplication.secondaryToolbar.setPageNumber(pageNumber); if (PDFViewerApplication.pdfSidebar.visibleView === _ui_utils.SidebarView.THUMBS) { PDFViewerApplication.pdfThumbnailViewer.scrollThumbnailIntoView(pageNumber); } } function webViewerResolutionChange(evt) { PDFViewerApplication.pdfViewer.refresh(); } function webViewerVisibilityChange(evt) { if (document.visibilityState === &quot;visible&quot;) { setZoomDisabledTimeout(); } } let zoomDisabledTimeout = null; function setZoomDisabledTimeout() { if (zoomDisabledTimeout) { clearTimeout(zoomDisabledTimeout); } zoomDisabledTimeout = setTimeout(function () { zoomDisabledTimeout = null; }, WHEEL_ZOOM_DISABLED_TIMEOUT); } function webViewerWheel(evt) { const { pdfViewer, supportedMouseWheelZoomModifierKeys } = PDFViewerApplication; if (pdfViewer.isInPresentationMode) { return; } if (evt.ctrlKey &amp;&amp; supportedMouseWheelZoomModifierKeys.ctrlKey || evt.metaKey &amp;&amp; supportedMouseWheelZoomModifierKeys.metaKey) { evt.preventDefault(); if (zoomDisabledTimeout || document.visibilityState === &quot;hidden&quot;) { return; } const deltaMode = evt.deltaMode; const delta = (0, _ui_utils.normalizeWheelEventDirection)(evt); const previousScale = pdfViewer.currentScale; let ticks = 0; if (deltaMode === WheelEvent.DOM_DELTA_LINE || deltaMode === WheelEvent.DOM_DELTA_PAGE) { if (Math.abs(delta) &gt;= 1) { ticks = Math.sign(delta); } else { ticks = PDFViewerApplication.accumulateWheelTicks(delta); } } else { const PIXELS_PER_LINE_SCALE = 30; ticks = PDFViewerApplication.accumulateWheelTicks(delta / PIXELS_PER_LINE_SCALE); } if (ticks &lt; 0) { PDFViewerApplication.zoomOut(-ticks); } else if (ticks &gt; 0) { PDFViewerApplication.zoomIn(ticks); } const currentScale = pdfViewer.currentScale; if (previousScale !== currentScale) { const scaleCorrectionFactor = currentScale / previousScale - 1; const rect = pdfViewer.container.getBoundingClientRect(); const dx = evt.clientX - rect.left; const dy = evt.clientY - rect.top; pdfViewer.container.scrollLeft += dx * scaleCorrectionFactor; pdfViewer.container.scrollTop += dy * scaleCorrectionFactor; } } else { setZoomDisabledTimeout(); } } function webViewerTouchStart(evt) { if (evt.touches.length &gt; 1) { evt.preventDefault(); } } function webViewerClick(evt) { if (!PDFViewerApplication.secondaryToolbar.isOpen) { return; } const appConfig = PDFViewerApplication.appConfig; if (PDFViewerApplication.pdfViewer.containsElement(evt.target) || appConfig.toolbar.container.contains(evt.target) &amp;&amp; evt.target !== appConfig.secondaryToolbar.toggleButton) { PDFViewerApplication.secondaryToolbar.close(); } } function webViewerKeyDown(evt) { if (PDFViewerApplication.overlayManager.active) { return; } const { eventBus, pdfViewer } = PDFViewerApplication; const isViewerInPresentationMode = pdfViewer.isInPresentationMode; let handled = false, ensureViewerFocused = false; const cmd = (evt.ctrlKey ? 1 : 0) | (evt.altKey ? 2 : 0) | (evt.shiftKey ? 4 : 0) | (evt.metaKey ? 8 : 0); if (cmd === 1 || cmd === 8 || cmd === 5 || cmd === 12) { switch (evt.keyCode) { case 70: if (!PDFViewerApplication.supportsIntegratedFind &amp;&amp; !evt.shiftKey) { PDFViewerApplication.findBar.open(); handled = true; } break; case 71: if (!PDFViewerApplication.supportsIntegratedFind) { const { state } = PDFViewerApplication.findController; if (state) { const eventState = Object.assign(Object.create(null), state, { source: window, type: &quot;again&quot;, findPrevious: cmd === 5 || cmd === 12 }); eventBus.dispatch(&quot;find&quot;, eventState); } handled = true; } break; case 61: case 107: case 187: case 171: if (!isViewerInPresentationMode) { PDFViewerApplication.zoomIn(); } handled = true; break; case 173: case 109: case 189: if (!isViewerInPresentationMode) { PDFViewerApplication.zoomOut(); } handled = true; break; case 48: case 96: if (!isViewerInPresentationMode) { setTimeout(function () { PDFViewerApplication.zoomReset(); }); handled = false; } break; case 38: if (isViewerInPresentationMode || PDFViewerApplication.page &gt; 1) { PDFViewerApplication.page = 1; handled = true; ensureViewerFocused = true; } break; case 40: if (isViewerInPresentationMode || PDFViewerApplication.page &lt; PDFViewerApplication.pagesCount) { PDFViewerApplication.page = PDFViewerApplication.pagesCount; handled = true; ensureViewerFocused = true; } break; } } if (cmd === 1 || cmd === 8) { switch (evt.keyCode) { case 83: eventBus.dispatch(&quot;download&quot;, { source: window }); handled = true; break; case 79: { eventBus.dispatch(&quot;openfile&quot;, { source: window }); handled = true; } break; } } if (cmd === 3 || cmd === 10) { switch (evt.keyCode) { case 80: PDFViewerApplication.requestPresentationMode(); handled = true; PDFViewerApplication.externalServices.reportTelemetry({ type: &quot;buttons&quot;, data: { id: &quot;presentationModeKeyboard&quot; } }); break; case 71: PDFViewerApplication.appConfig.toolbar.pageNumber.select(); handled = true; break; } } if (handled) { if (ensureViewerFocused &amp;&amp; !isViewerInPresentationMode) { pdfViewer.focus(); } evt.preventDefault(); return; } const curElement = (0, _ui_utils.getActiveOrFocusedElement)(); const curElementTagName = curElement?.tagName.toUpperCase(); if (curElementTagName === &quot;INPUT&quot; || curElementTagName === &quot;TEXTAREA&quot; || curElementTagName === &quot;SELECT&quot; || curElement?.isContentEditable) { if (evt.keyCode !== 27) { return; } } if (cmd === 0) { let turnPage = 0, turnOnlyIfPageFit = false; switch (evt.keyCode) { case 38: case 33: if (pdfViewer.isVerticalScrollbarEnabled) { turnOnlyIfPageFit = true; } turnPage = -1; break; case 8: if (!isViewerInPresentationMode) { turnOnlyIfPageFit = true; } turnPage = -1; break; case 37: if (pdfViewer.isHorizontalScrollbarEnabled) { turnOnlyIfPageFit = true; } case 75: case 80: turnPage = -1; break; case 27: if (PDFViewerApplication.secondaryToolbar.isOpen) { PDFViewerApplication.secondaryToolbar.close(); handled = true; } if (!PDFViewerApplication.supportsIntegratedFind &amp;&amp; PDFViewerApplication.findBar.opened) { PDFViewerApplication.findBar.close(); handled = true; } break; case 40: case 34: if (pdfViewer.isVerticalScrollbarEnabled) { turnOnlyIfPageFit = true; } turnPage = 1; break; case 13: case 32: if (!isViewerInPresentationMode) { turnOnlyIfPageFit = true; } turnPage = 1; break; case 39: if (pdfViewer.isHorizontalScrollbarEnabled) { turnOnlyIfPageFit = true; } case 74: case 78: turnPage = 1; break; case 36: if (isViewerInPresentationMode || PDFViewerApplication.page &gt; 1) { PDFViewerApplication.page = 1; handled = true; ensureViewerFocused = true; } break; case 35: if (isViewerInPresentationMode || PDFViewerApplication.page &lt; PDFViewerApplication.pagesCount) { PDFViewerApplication.page = PDFViewerApplication.pagesCount; handled = true; ensureViewerFocused = true; } break; case 83: PDFViewerApplication.pdfCursorTools.switchTool(_pdf_cursor_tools.CursorTool.SELECT); break; case 72: PDFViewerApplication.pdfCursorTools.switchTool(_pdf_cursor_tools.CursorTool.HAND); break; case 82: PDFViewerApplication.rotatePages(90); break; case 115: PDFViewerApplication.pdfSidebar.toggle(); break; } if (turnPage !== 0 &amp;&amp; (!turnOnlyIfPageFit || pdfViewer.currentScaleValue === &quot;page-fit&quot;)) { if (turnPage &gt; 0) { pdfViewer.nextPage(); } else { pdfViewer.previousPage(); } handled = true; } } if (cmd === 4) { switch (evt.keyCode) { case 13: case 32: if (!isViewerInPresentationMode &amp;&amp; pdfViewer.currentScaleValue !== &quot;page-fit&quot;) { break; } pdfViewer.previousPage(); handled = true; break; case 82: PDFViewerApplication.rotatePages(-90); break; } } if (!handled &amp;&amp; !isViewerInPresentationMode) { if (evt.keyCode &gt;= 33 &amp;&amp; evt.keyCode &lt;= 40 || evt.keyCode === 32 &amp;&amp; curElementTagName !== &quot;BUTTON&quot;) { ensureViewerFocused = true; } } if (ensureViewerFocused &amp;&amp; !pdfViewer.containsElement(curElement)) { pdfViewer.focus(); } if (handled) { evt.preventDefault(); } } function beforeUnload(evt) { evt.preventDefault(); evt.returnValue = &quot;&quot;; return false; } function webViewerAnnotationEditorStatesChanged(data) { PDFViewerApplication.externalServices.updateEditorStates(data); } const PDFPrintServiceFactory = { instance: { supportsPrinting: false, createPrintService() { throw new Error(&quot;Not implemented: createPrintService&quot;); } } }; exports.PDFPrintServiceFactory = PDFPrintServiceFactory; /***/ }), /* 5 */ /***/ ((module) =&gt; { let pdfjsLib; if (typeof window !== &quot;undefined&quot; &amp;&amp; window[&quot;pdfjs-dist/build/pdf&quot;]) { pdfjsLib = window[&quot;pdfjs-dist/build/pdf&quot;]; } else { pdfjsLib = require(&quot;../build/pdf.js&quot;); } module.exports = pdfjsLib; /***/ }), /* 6 */ /***/ ((__unused_webpack_module, exports) =&gt; { Object.defineProperty(exports, &quot;__esModule&quot;, ({ value: true })); exports.WaitOnType = exports.EventBus = exports.AutomationEventBus = void 0; exports.waitOnEventOrTimeout = waitOnEventOrTimeout; const WaitOnType = { EVENT: &quot;event&quot;, TIMEOUT: &quot;timeout&quot; }; exports.WaitOnType = WaitOnType; function waitOnEventOrTimeout({ target, name, delay = 0 }) { return new Promise(function (resolve, reject) { if (typeof target !== &quot;object&quot; || !(name &amp;&amp; typeof name === &quot;string&quot;) || !(Number.isInteger(delay) &amp;&amp; delay &gt;= 0)) { throw new Error(&quot;waitOnEventOrTimeout - invalid parameters.&quot;); } function handler(type) { if (target instanceof EventBus) { target._off(name, eventHandler); } else { target.removeEventListener(name, eventHandler); } if (timeout) { clearTimeout(timeout); } resolve(type); } const eventHandler = handler.bind(null, WaitOnType.EVENT); if (target instanceof EventBus) { target._on(name, eventHandler); } else { target.addEventListener(name, eventHandler); } const timeoutHandler = handler.bind(null, WaitOnType.TIMEOUT); const timeout = setTimeout(timeoutHandler, delay); }); } class EventBus { constructor() { this._listeners = Object.create(null); } on(eventName, listener, options = null) { this._on(eventName, listener, { external: true, once: options?.once }); } off(eventName, listener, options = null) { this._off(eventName, listener, { external: true, once: options?.once }); } dispatch(eventName, data) { const eventListeners = this._listeners[eventName]; if (!eventListeners || eventListeners.length === 0) { return; } let externalListeners; for (const { listener, external, once } of eventListeners.slice(0)) { if (once) { this._off(eventName, listener); } if (external) { (externalListeners ||= []).push(listener); continue; } listener(data); } if (externalListeners) { for (const listener of externalListeners) { listener(data); } externalListeners = null; } } _on(eventName, listener, options = null) { const eventListeners = this._listeners[eventName] ||= []; eventListeners.push({ listener, external: options?.external === true, once: options?.once === true }); } _off(eventName, listener, options = null) { const eventListeners = this._listeners[eventName]; if (!eventListeners) { return; } for (let i = 0, ii = eventListeners.length; i &lt; ii; i++) { if (eventListeners[i].listener === listener) { eventListeners.splice(i, 1); return; } } } } exports.EventBus = EventBus; class AutomationEventBus extends EventBus { dispatch(eventName, data) { throw new Error(&quot;Not implemented: AutomationEventBus.dispatch&quot;); } } exports.AutomationEventBus = AutomationEventBus; /***/ }), /* 7 */ /***/ ((__unused_webpack_module, exports, __webpack_require__) =&gt; { Object.defineProperty(exports, &quot;__esModule&quot;, ({ value: true })); exports.PDFCursorTools = exports.CursorTool = void 0; var _pdfjsLib = __webpack_require__(5); var _grab_to_pan = __webpack_require__(8); var _ui_utils = __webpack_require__(1); const CursorTool = { SELECT: 0, HAND: 1, ZOOM: 2 }; exports.CursorTool = CursorTool; class PDFCursorTools { constructor({ container, eventBus, cursorToolOnLoad = CursorTool.SELECT }) { this.container = container; this.eventBus = eventBus; this.active = CursorTool.SELECT; this.previouslyActive = null; this.handTool = new _grab_to_pan.GrabToPan({ element: this.container }); this.#addEventListeners(); Promise.resolve().then(() =&gt; { this.switchTool(cursorToolOnLoad); }); } get activeTool() { return this.active; } switchTool(tool) { if (this.previouslyActive !== null) { return; } if (tool === this.active) { return; } const disableActiveTool = () =&gt; { switch (this.active) { case CursorTool.SELECT: break; case CursorTool.HAND: this.handTool.deactivate(); break; case CursorTool.ZOOM: } }; switch (tool) { case CursorTool.SELECT: disableActiveTool(); break; case CursorTool.HAND: disableActiveTool(); this.handTool.activate(); break; case CursorTool.ZOOM: default: console.error(`switchTool: &quot;${tool}&quot; is an unsupported value.`); return; } this.active = tool; this.#dispatchEvent(); } #dispatchEvent() { this.eventBus.dispatch(&quot;cursortoolchanged&quot;, { source: this, tool: this.active }); } #addEventListeners() { this.eventBus._on(&quot;switchcursortool&quot;, evt =&gt; { this.switchTool(evt.tool); }); let annotationEditorMode = _pdfjsLib.AnnotationEditorType.NONE, presentationModeState = _ui_utils.PresentationModeState.NORMAL; const disableActive = () =&gt; { const previouslyActive = this.active; this.switchTool(CursorTool.SELECT); this.previouslyActive ??= previouslyActive; }; const enableActive = () =&gt; { const previouslyActive = this.previouslyActive; if (previouslyActive !== null &amp;&amp; annotationEditorMode === _pdfjsLib.AnnotationEditorType.NONE &amp;&amp; presentationModeState === _ui_utils.PresentationModeState.NORMAL) { this.previouslyActive = null; this.switchTool(previouslyActive); } }; this.eventBus._on(&quot;secondarytoolbarreset&quot;, evt =&gt; { if (this.previouslyActive !== null) { annotationEditorMode = _pdfjsLib.AnnotationEditorType.NONE; presentationModeState = _ui_utils.PresentationModeState.NORMAL; enableActive(); } }); this.eventBus._on(&quot;annotationeditormodechanged&quot;, ({ mode }) =&gt; { annotationEditorMode = mode; if (mode === _pdfjsLib.AnnotationEditorType.NONE) { enableActive(); } else { disableActive(); } }); this.eventBus._on(&quot;presentationmodechanged&quot;, ({ state }) =&gt; { presentationModeState = state; if (state === _ui_utils.PresentationModeState.NORMAL) { enableActive(); } else if (state === _ui_utils.PresentationModeState.FULLSCREEN) { disableActive(); } }); } } exports.PDFCursorTools = PDFCursorTools; /***/ }), /* 8 */ /***/ ((__unused_webpack_module, exports) =&gt; { Object.defineProperty(exports, &quot;__esModule&quot;, ({ value: true })); exports.GrabToPan = void 0; const CSS_CLASS_GRAB = &quot;grab-to-pan-grab&quot;; class GrabToPan { constructor(options) { this.element = options.element; this.document = options.element.ownerDocument; if (typeof options.ignoreTarget === &quot;function&quot;) { this.ignoreTarget = options.ignoreTarget; } this.onActiveChanged = options.onActiveChanged; this.activate = this.activate.bind(this); this.deactivate = this.deactivate.bind(this); this.toggle = this.toggle.bind(this); this._onMouseDown = this.#onMouseDown.bind(this); this._onMouseMove = this.#onMouseMove.bind(this); this._endPan = this.#endPan.bind(this); const overlay = this.overlay = document.createElement(&quot;div&quot;); overlay.className = &quot;grab-to-pan-grabbing&quot;; } activate() { if (!this.active) { this.active = true; this.element.addEventListener(&quot;mousedown&quot;, this._onMouseDown, true); this.element.classList.add(CSS_CLASS_GRAB); this.onActiveChanged?.(true); } } deactivate() { if (this.active) { this.active = false; this.element.removeEventListener(&quot;mousedown&quot;, this._onMouseDown, true); this._endPan(); this.element.classList.remove(CSS_CLASS_GRAB); this.onActiveChanged?.(false); } } toggle() { if (this.active) { this.deactivate(); } else { this.activate(); } } ignoreTarget(node) { return node.matches(&quot;a[href], a[href] *, input, textarea, button, button *, select, option&quot;); } #onMouseDown(event) { if (event.button !== 0 || this.ignoreTarget(event.target)) { return; } if (event.originalTarget) { try { event.originalTarget.tagName; } catch (e) { return; } } this.scrollLeftStart = this.element.scrollLeft; this.scrollTopStart = this.element.scrollTop; this.clientXStart = event.clientX; this.clientYStart = event.clientY; this.document.addEventListener(&quot;mousemove&quot;, this._onMouseMove, true); this.document.addEventListener(&quot;mouseup&quot;, this._endPan, true); this.element.addEventListener(&quot;scroll&quot;, this._endPan, true); event.preventDefault(); event.stopPropagation(); const focusedElement = document.activeElement; if (focusedElement &amp;&amp; !focusedElement.contains(event.target)) { focusedElement.blur(); } } #onMouseMove(event) { this.element.removeEventListener(&quot;scroll&quot;, this._endPan, true); if (!(event.buttons &amp; 1)) { this._endPan(); return; } const xDiff = event.clientX - this.clientXStart; const yDiff = event.clientY - this.clientYStart; const scrollTop = this.scrollTopStart - yDiff; const scrollLeft = this.scrollLeftStart - xDiff; if (this.element.scrollTo) { this.element.scrollTo({ top: scrollTop, left: scrollLeft, behavior: &quot;instant&quot; }); } else { this.element.scrollTop = scrollTop; this.element.scrollLeft = scrollLeft; } if (!this.overlay.parentNode) { document.body.append(this.overlay); } } #endPan() { this.element.removeEventListener(&quot;scroll&quot;, this._endPan, true); this.document.removeEventListener(&quot;mousemove&quot;, this._onMouseMove, true); this.document.removeEventListener(&quot;mouseup&quot;, this._endPan, true); this.overlay.remove(); } } exports.GrabToPan = GrabToPan; /***/ }), /* 9 */ /***/ ((__unused_webpack_module, exports, __webpack_require__) =&gt; { Object.defineProperty(exports, &quot;__esModule&quot;, ({ value: true })); exports.AnnotationEditorParams = void 0; var _pdfjsLib = __webpack_require__(5); class AnnotationEditorParams { constructor(options, eventBus) { this.eventBus = eventBus; this.#bindListeners(options); } #bindListeners({ editorFreeTextFontSize, editorFreeTextColor, editorInkColor, editorInkThickness, editorInkOpacity }) { editorFreeTextFontSize.addEventListener(&quot;input&quot;, evt =&gt; { this.eventBus.dispatch(&quot;switchannotationeditorparams&quot;, { source: this, type: _pdfjsLib.AnnotationEditorParamsType.FREETEXT_SIZE, value: editorFreeTextFontSize.valueAsNumber }); }); editorFreeTextColor.addEventListener(&quot;input&quot;, evt =&gt; { this.eventBus.dispatch(&quot;switchannotationeditorparams&quot;, { source: this, type: _pdfjsLib.AnnotationEditorParamsType.FREETEXT_COLOR, value: editorFreeTextColor.value }); }); editorInkColor.addEventListener(&quot;input&quot;, evt =&gt; { this.eventBus.dispatch(&quot;switchannotationeditorparams&quot;, { source: this, type: _pdfjsLib.AnnotationEditorParamsType.INK_COLOR, value: editorInkColor.value }); }); editorInkThickness.addEventListener(&quot;input&quot;, evt =&gt; { this.eventBus.dispatch(&quot;switchannotationeditorparams&quot;, { source: this, type: _pdfjsLib.AnnotationEditorParamsType.INK_THICKNESS, value: editorInkThickness.valueAsNumber }); }); editorInkOpacity.addEventListener(&quot;input&quot;, evt =&gt; { this.eventBus.dispatch(&quot;switchannotationeditorparams&quot;, { source: this, type: _pdfjsLib.AnnotationEditorParamsType.INK_OPACITY, value: editorInkOpacity.valueAsNumber }); }); this.eventBus._on(&quot;annotationeditorparamschanged&quot;, evt =&gt; { for (const [type, value] of evt.details) { switch (type) { case _pdfjsLib.AnnotationEditorParamsType.FREETEXT_SIZE: editorFreeTextFontSize.value = value; break; case _pdfjsLib.AnnotationEditorParamsType.FREETEXT_COLOR: editorFreeTextColor.value = value; break; case _pdfjsLib.AnnotationEditorParamsType.INK_COLOR: editorInkColor.value = value; break; case _pdfjsLib.AnnotationEditorParamsType.INK_THICKNESS: editorInkThickness.value = value; break; case _pdfjsLib.AnnotationEditorParamsType.INK_OPACITY: editorInkOpacity.value = value; break; } } }); } } exports.AnnotationEditorParams = AnnotationEditorParams; /***/ }), /* 10 */ /***/ ((__unused_webpack_module, exports) =&gt; { Object.defineProperty(exports, &quot;__esModule&quot;, ({ value: true })); exports.OverlayManager = void 0; class OverlayManager { #overlays = new WeakMap(); #active = null; get active() { return this.#active; } async register(dialog, canForceClose = false) { if (typeof dialog !== &quot;object&quot;) { throw new Error(&quot;Not enough parameters.&quot;); } else if (this.#overlays.has(dialog)) { throw new Error(&quot;The overlay is already registered.&quot;); } this.#overlays.set(dialog, { canForceClose }); dialog.addEventListener(&quot;cancel&quot;, evt =&gt; { this.#active = null; }); } async unregister(dialog) { if (!this.#overlays.has(dialog)) { throw new Error(&quot;The overlay does not exist.&quot;); } else if (this.#active === dialog) { throw new Error(&quot;The overlay cannot be removed while it is active.&quot;); } this.#overlays.delete(dialog); } async open(dialog) { if (!this.#overlays.has(dialog)) { throw new Error(&quot;The overlay does not exist.&quot;); } else if (this.#active) { if (this.#active === dialog) { throw new Error(&quot;The overlay is already active.&quot;); } else if (this.#overlays.get(dialog).canForceClose) { await this.close(); } else { throw new Error(&quot;Another overlay is currently active.&quot;); } } this.#active = dialog; dialog.showModal(); } async close(dialog = this.#active) { if (!this.#overlays.has(dialog)) { throw new Error(&quot;The overlay does not exist.&quot;); } else if (!this.#active) { throw new Error(&quot;The overlay is currently not active.&quot;); } else if (this.#active !== dialog) { throw new Error(&quot;Another overlay is currently active.&quot;); } dialog.close(); this.#active = null; } } exports.OverlayManager = OverlayManager; /***/ }), /* 11 */ /***/ ((__unused_webpack_module, exports, __webpack_require__) =&gt; { Object.defineProperty(exports, &quot;__esModule&quot;, ({ value: true })); exports.PasswordPrompt = void 0; var _pdfjsLib = __webpack_require__(5); class PasswordPrompt { #activeCapability = null; #updateCallback = null; #reason = null; constructor(options, overlayManager, l10n, isViewerEmbedded = false) { this.dialog = options.dialog; this.label = options.label; this.input = options.input; this.submitButton = options.submitButton; this.cancelButton = options.cancelButton; this.overlayManager = overlayManager; this.l10n = l10n; this._isViewerEmbedded = isViewerEmbedded; this.submitButton.addEventListener(&quot;click&quot;, this.#verify.bind(this)); this.cancelButton.addEventListener(&quot;click&quot;, this.close.bind(this)); this.input.addEventListener(&quot;keydown&quot;, e =&gt; { if (e.keyCode === 13) { this.#verify(); } }); this.overlayManager.register(this.dialog, true); this.dialog.addEventListener(&quot;close&quot;, this.#cancel.bind(this)); } async open() { if (this.#activeCapability) { await this.#activeCapability.promise; } this.#activeCapability = (0, _pdfjsLib.createPromiseCapability)(); try { await this.overlayManager.open(this.dialog); } catch (ex) { this.#activeCapability = null; throw ex; } const passwordIncorrect = this.#reason === _pdfjsLib.PasswordResponses.INCORRECT_PASSWORD; if (!this._isViewerEmbedded || passwordIncorrect) { this.input.focus(); } this.label.textContent = await this.l10n.get(`password_${passwordIncorrect ? &quot;invalid&quot; : &quot;label&quot;}`); } async close() { if (this.overlayManager.active === this.dialog) { this.overlayManager.close(this.dialog); } } #verify() { const password = this.input.value; if (password?.length &gt; 0) { this.#invokeCallback(password); } } #cancel() { this.#invokeCallback(new Error(&quot;PasswordPrompt cancelled.&quot;)); this.#activeCapability.resolve(); } #invokeCallback(password) { if (!this.#updateCallback) { return; } this.close(); this.input.value = &quot;&quot;; this.#updateCallback(password); this.#updateCallback = null; } async setUpdateCallback(updateCallback, reason) { if (this.#activeCapability) { await this.#activeCapability.promise; } this.#updateCallback = updateCallback; this.#reason = reason; } } exports.PasswordPrompt = PasswordPrompt; /***/ }), /* 12 */ /***/ ((__unused_webpack_module, exports, __webpack_require__) =&gt; { Object.defineProperty(exports, &quot;__esModule&quot;, ({ value: true })); exports.PDFAttachmentViewer = void 0; var _pdfjsLib = __webpack_require__(5); var _base_tree_viewer = __webpack_require__(13); var _event_utils = __webpack_require__(6); class PDFAttachmentViewer extends _base_tree_viewer.BaseTreeViewer { constructor(options) { super(options); this.downloadManager = options.downloadManager; this.eventBus._on(&quot;fileattachmentannotation&quot;, this.#appendAttachment.bind(this)); } reset(keepRenderedCapability = false) { super.reset(); this._attachments = null; if (!keepRenderedCapability) { this._renderedCapability = (0, _pdfjsLib.createPromiseCapability)(); } this._pendingDispatchEvent = false; } async _dispatchEvent(attachmentsCount) { this._renderedCapability.resolve(); if (attachmentsCount === 0 &amp;&amp; !this._pendingDispatchEvent) { this._pendingDispatchEvent = true; await (0, _event_utils.waitOnEventOrTimeout)({ target: this.eventBus, name: &quot;annotationlayerrendered&quot;, delay: 1000 }); if (!this._pendingDispatchEvent) { return; } } this._pendingDispatchEvent = false; this.eventBus.dispatch(&quot;attachmentsloaded&quot;, { source: this, attachmentsCount }); } _bindLink(element, { content, filename }) { element.onclick = () =&gt; { this.downloadManager.openOrDownloadData(element, content, filename); return false; }; } render({ attachments, keepRenderedCapability = false }) { if (this._attachments) { this.reset(keepRenderedCapability); } this._attachments = attachments || null; if (!attachments) { this._dispatchEvent(0); return; } const names = Object.keys(attachments).sort(function (a, b) { return a.toLowerCase().localeCompare(b.toLowerCase()); }); const fragment = document.createDocumentFragment(); let attachmentsCount = 0; for (const name of names) { const item = attachments[name]; const content = item.content, filename = (0, _pdfjsLib.getFilenameFromUrl)(item.filename); const div = document.createElement(&quot;div&quot;); div.className = &quot;treeItem&quot;; const element = document.createElement(&quot;a&quot;); this._bindLink(element, { content, filename }); element.textContent = this._normalizeTextContent(filename); div.append(element); fragment.append(div); attachmentsCount++; } this._finishRendering(fragment, attachmentsCount); } #appendAttachment({ filename, content }) { const renderedPromise = this._renderedCapability.promise; renderedPromise.then(() =&gt; { if (renderedPromise !== this._renderedCapability.promise) { return; } const attachments = this._attachments || Object.create(null); for (const name in attachments) { if (filename === name) { return; } } attachments[filename] = { filename, content }; this.render({ attachments, keepRenderedCapability: true }); }); } } exports.PDFAttachmentViewer = PDFAttachmentViewer; /***/ }), /* 13 */ /***/ ((__unused_webpack_module, exports, __webpack_require__) =&gt; { Object.defineProperty(exports, &quot;__esModule&quot;, ({ value: true })); exports.BaseTreeViewer = void 0; var _ui_utils = __webpack_require__(1); const TREEITEM_OFFSET_TOP = -100; const TREEITEM_SELECTED_CLASS = &quot;selected&quot;; class BaseTreeViewer { constructor(options) { if (this.constructor === BaseTreeViewer) { throw new Error(&quot;Cannot initialize BaseTreeViewer.&quot;); } this.container = options.container; this.eventBus = options.eventBus; this.reset(); } reset() { this._pdfDocument = null; this._lastToggleIsShow = true; this._currentTreeItem = null; this.container.textContent = &quot;&quot;; this.container.classList.remove(&quot;treeWithDeepNesting&quot;); } _dispatchEvent(count) { throw new Error(&quot;Not implemented: _dispatchEvent&quot;); } _bindLink(element, params) { throw new Error(&quot;Not implemented: _bindLink&quot;); } _normalizeTextContent(str) { return (0, _ui_utils.removeNullCharacters)(str, true) || &quot;\\u2013&quot;; } _addToggleButton(div, hidden = false) { const toggler = document.createElement(&quot;div&quot;); toggler.className = &quot;treeItemToggler&quot;; if (hidden) { toggler.classList.add(&quot;treeItemsHidden&quot;); } toggler.onclick = evt =&gt; { evt.stopPropagation(); toggler.classList.toggle(&quot;treeItemsHidden&quot;); if (evt.shiftKey) { const shouldShowAll = !toggler.classList.contains(&quot;treeItemsHidden&quot;); this._toggleTreeItem(div, shouldShowAll); } }; div.prepend(toggler); } _toggleTreeItem(root, show = false) { this._lastToggleIsShow = show; for (const toggler of root.querySelectorAll(&quot;.treeItemToggler&quot;)) { toggler.classList.toggle(&quot;treeItemsHidden&quot;, !show); } } _toggleAllTreeItems() { this._toggleTreeItem(this.container, !this._lastToggleIsShow); } _finishRendering(fragment, count, hasAnyNesting = false) { if (hasAnyNesting) { this.container.classList.add(&quot;treeWithDeepNesting&quot;); this._lastToggleIsShow = !fragment.querySelector(&quot;.treeItemsHidden&quot;); } this.container.append(fragment); this._dispatchEvent(count); } render(params) { throw new Error(&quot;Not implemented: render&quot;); } _updateCurrentTreeItem(treeItem = null) { if (this._currentTreeItem) { this._currentTreeItem.classList.remove(TREEITEM_SELECTED_CLASS); this._currentTreeItem = null; } if (treeItem) { treeItem.classList.add(TREEITEM_SELECTED_CLASS); this._currentTreeItem = treeItem; } } _scrollToCurrentTreeItem(treeItem) { if (!treeItem) { return; } let currentNode = treeItem.parentNode; while (currentNode &amp;&amp; currentNode !== this.container) { if (currentNode.classList.contains(&quot;treeItem&quot;)) { const toggler = currentNode.firstElementChild; toggler?.classList.remove(&quot;treeItemsHidden&quot;); } currentNode = currentNode.parentNode; } this._updateCurrentTreeItem(treeItem); this.container.scrollTo(treeItem.offsetLeft, treeItem.offsetTop + TREEITEM_OFFSET_TOP); } } exports.BaseTreeViewer = BaseTreeViewer; /***/ }), /* 14 */ /***/ ((__unused_webpack_module, exports, __webpack_require__) =&gt; { Object.defineProperty(exports, &quot;__esModule&quot;, ({ value: true })); exports.PDFDocumentProperties = void 0; var _pdfjsLib = __webpack_require__(5); var _ui_utils = __webpack_require__(1); const DEFAULT_FIELD_CONTENT = &quot;-&quot;; const NON_METRIC_LOCALES = [&quot;en-us&quot;, &quot;en-lr&quot;, &quot;my&quot;]; const US_PAGE_NAMES = { &quot;8.5x11&quot;: &quot;Letter&quot;, &quot;8.5x14&quot;: &quot;Legal&quot; }; const METRIC_PAGE_NAMES = { &quot;297x420&quot;: &quot;A3&quot;, &quot;210x297&quot;: &quot;A4&quot; }; function getPageName(size, isPortrait, pageNames) { const width = isPortrait ? size.width : size.height; const height = isPortrait ? size.height : size.width; return pageNames[`${width}x${height}`]; } class PDFDocumentProperties { #fieldData = null; constructor({ dialog, fields, closeButton }, overlayManager, eventBus, l10n, fileNameLookup) { this.dialog = dialog; this.fields = fields; this.overlayManager = overlayManager; this.l10n = l10n; this._fileNameLookup = fileNameLookup; this.#reset(); closeButton.addEventListener(&quot;click&quot;, this.close.bind(this)); this.overlayManager.register(this.dialog); eventBus._on(&quot;pagechanging&quot;, evt =&gt; { this._currentPageNumber = evt.pageNumber; }); eventBus._on(&quot;rotationchanging&quot;, evt =&gt; { this._pagesRotation = evt.pagesRotation; }); this._isNonMetricLocale = true; l10n.getLanguage().then(locale =&gt; { this._isNonMetricLocale = NON_METRIC_LOCALES.includes(locale); }); } async open() { await Promise.all([this.overlayManager.open(this.dialog), this._dataAvailableCapability.promise]); const currentPageNumber = this._currentPageNumber; const pagesRotation = this._pagesRotation; if (this.#fieldData &amp;&amp; currentPageNumber === this.#fieldData._currentPageNumber &amp;&amp; pagesRotation === this.#fieldData._pagesRotation) { this.#updateUI(); return; } const { info, contentLength } = await this.pdfDocument.getMetadata(); const [fileName, fileSize, creationDate, modificationDate, pageSize, isLinearized] = await Promise.all([this._fileNameLookup(), this.#parseFileSize(contentLength), this.#parseDate(info.CreationDate), this.#parseDate(info.ModDate), this.pdfDocument.getPage(currentPageNumber).then(pdfPage =&gt; { return this.#parsePageSize((0, _ui_utils.getPageSizeInches)(pdfPage), pagesRotation); }), this.#parseLinearization(info.IsLinearized)]); this.#fieldData = Object.freeze({ fileName, fileSize, title: info.Title, author: info.Author, subject: info.Subject, keywords: info.Keywords, creationDate, modificationDate, creator: info.Creator, producer: info.Producer, version: info.PDFFormatVersion, pageCount: this.pdfDocument.numPages, pageSize, linearized: isLinearized, _currentPageNumber: currentPageNumber, _pagesRotation: pagesRotation }); this.#updateUI(); const { length } = await this.pdfDocument.getDownloadInfo(); if (contentLength === length) { return; } const data = Object.assign(Object.create(null), this.#fieldData); data.fileSize = await this.#parseFileSize(length); this.#fieldData = Object.freeze(data); this.#updateUI(); } async close() { this.overlayManager.close(this.dialog); } setDocument(pdfDocument) { if (this.pdfDocument) { this.#reset(); this.#updateUI(true); } if (!pdfDocument) { return; } this.pdfDocument = pdfDocument; this._dataAvailableCapability.resolve(); } #reset() { this.pdfDocument = null; this.#fieldData = null; this._dataAvailableCapability = (0, _pdfjsLib.createPromiseCapability)(); this._currentPageNumber = 1; this._pagesRotation = 0; } #updateUI(reset = false) { if (reset || !this.#fieldData) { for (const id in this.fields) { this.fields[id].textContent = DEFAULT_FIELD_CONTENT; } return; } if (this.overlayManager.active !== this.dialog) { return; } for (const id in this.fields) { const content = this.#fieldData[id]; this.fields[id].textContent = content || content === 0 ? content : DEFAULT_FIELD_CONTENT; } } async #parseFileSize(fileSize = 0) { const kb = fileSize / 1024, mb = kb / 1024; if (!kb) { return undefined; } return this.l10n.get(`document_properties_${mb &gt;= 1 ? &quot;mb&quot; : &quot;kb&quot;}`, { size_mb: mb &gt;= 1 &amp;&amp; (+mb.toPrecision(3)).toLocaleString(), size_kb: mb &lt; 1 &amp;&amp; (+kb.toPrecision(3)).toLocaleString(), size_b: fileSize.toLocaleString() }); } async #parsePageSize(pageSizeInches, pagesRotation) { if (!pageSizeInches) { return undefined; } if (pagesRotation % 180 !== 0) { pageSizeInches = { width: pageSizeInches.height, height: pageSizeInches.width }; } const isPortrait = (0, _ui_utils.isPortraitOrientation)(pageSizeInches); let sizeInches = { width: Math.round(pageSizeInches.width * 100) / 100, height: Math.round(pageSizeInches.height * 100) / 100 }; let sizeMillimeters = { width: Math.round(pageSizeInches.width * 25.4 * 10) / 10, height: Math.round(pageSizeInches.height * 25.4 * 10) / 10 }; let rawName = getPageName(sizeInches, isPortrait, US_PAGE_NAMES) || getPageName(sizeMillimeters, isPortrait, METRIC_PAGE_NAMES); if (!rawName &amp;&amp; !(Number.isInteger(sizeMillimeters.width) &amp;&amp; Number.isInteger(sizeMillimeters.height))) { const exactMillimeters = { width: pageSizeInches.width * 25.4, height: pageSizeInches.height * 25.4 }; const intMillimeters = { width: Math.round(sizeMillimeters.width), height: Math.round(sizeMillimeters.height) }; if (Math.abs(exactMillimeters.width - intMillimeters.width) &lt; 0.1 &amp;&amp; Math.abs(exactMillimeters.height - intMillimeters.height) &lt; 0.1) { rawName = getPageName(intMillimeters, isPortrait, METRIC_PAGE_NAMES); if (rawName) { sizeInches = { width: Math.round(intMillimeters.width / 25.4 * 100) / 100, height: Math.round(intMillimeters.height / 25.4 * 100) / 100 }; sizeMillimeters = intMillimeters; } } } const [{ width, height }, unit, name, orientation] = await Promise.all([this._isNonMetricLocale ? sizeInches : sizeMillimeters, this.l10n.get(`document_properties_page_size_unit_${this._isNonMetricLocale ? &quot;inches&quot; : &quot;millimeters&quot;}`), rawName &amp;&amp; this.l10n.get(`document_properties_page_size_name_${rawName.toLowerCase()}`), this.l10n.get(`document_properties_page_size_orientation_${isPortrait ? &quot;portrait&quot; : &quot;landscape&quot;}`)]); return this.l10n.get(`document_properties_page_size_dimension_${name ? &quot;name_&quot; : &quot;&quot;}string`, { width: width.toLocaleString(), height: height.toLocaleString(), unit, name, orientation }); } async #parseDate(inputDate) { const dateObject = _pdfjsLib.PDFDateString.toDateObject(inputDate); if (!dateObject) { return undefined; } return this.l10n.get(&quot;document_properties_date_string&quot;, { date: dateObject.toLocaleDateString(), time: dateObject.toLocaleTimeString() }); } #parseLinearization(isLinearized) { return this.l10n.get(`document_properties_linearized_${isLinearized ? &quot;yes&quot; : &quot;no&quot;}`); } } exports.PDFDocumentProperties = PDFDocumentProperties; /***/ }), /* 15 */ /***/ ((__unused_webpack_module, exports, __webpack_require__) =&gt; { Object.defineProperty(exports, &quot;__esModule&quot;, ({ value: true })); exports.PDFFindBar = void 0; var _pdf_find_controller = __webpack_require__(16); const MATCHES_COUNT_LIMIT = 1000; class PDFFindBar { constructor(options, eventBus, l10n) { this.opened = false; this.bar = options.bar; this.toggleButton = options.toggleButton; this.findField = options.findField; this.highlightAll = options.highlightAllCheckbox; this.caseSensitive = options.caseSensitiveCheckbox; this.matchDiacritics = options.matchDiacriticsCheckbox; this.entireWord = options.entireWordCheckbox; this.findMsg = options.findMsg; this.findResultsCount = options.findResultsCount; this.findPreviousButton = options.findPreviousButton; this.findNextButton = options.findNextButton; this.eventBus = eventBus; this.l10n = l10n; this.toggleButton.addEventListener(&quot;click&quot;, () =&gt; { this.toggle(); }); this.findField.addEventListener(&quot;input&quot;, () =&gt; { this.dispatchEvent(&quot;&quot;); }); this.bar.addEventListener(&quot;keydown&quot;, e =&gt; { switch (e.keyCode) { case 13: if (e.target === this.findField) { this.dispatchEvent(&quot;again&quot;, e.shiftKey); } break; case 27: this.close(); break; } }); this.findPreviousButton.addEventListener(&quot;click&quot;, () =&gt; { this.dispatchEvent(&quot;again&quot;, true); }); this.findNextButton.addEventListener(&quot;click&quot;, () =&gt; { this.dispatchEvent(&quot;again&quot;, false); }); this.highlightAll.addEventListener(&quot;click&quot;, () =&gt; { this.dispatchEvent(&quot;highlightallchange&quot;); }); this.caseSensitive.addEventListener(&quot;click&quot;, () =&gt; { this.dispatchEvent(&quot;casesensitivitychange&quot;); }); this.entireWord.addEventListener(&quot;click&quot;, () =&gt; { this.dispatchEvent(&quot;entirewordchange&quot;); }); this.matchDiacritics.addEventListener(&quot;click&quot;, () =&gt; { this.dispatchEvent(&quot;diacriticmatchingchange&quot;); }); this.eventBus._on(&quot;resize&quot;, this.#adjustWidth.bind(this)); } reset() { this.updateUIState(); } dispatchEvent(type, findPrev = false) { this.eventBus.dispatch(&quot;find&quot;, { source: this, type, query: this.findField.value, phraseSearch: true, caseSensitive: this.caseSensitive.checked, entireWord: this.entireWord.checked, highlightAll: this.highlightAll.checked, findPrevious: findPrev, matchDiacritics: this.matchDiacritics.checked }); } updateUIState(state, previous, matchesCount) { let findMsg = Promise.resolve(&quot;&quot;); let status = &quot;&quot;; switch (state) { case _pdf_find_controller.FindState.FOUND: break; case _pdf_find_controller.FindState.PENDING: status = &quot;pending&quot;; break; case _pdf_find_controller.FindState.NOT_FOUND: findMsg = this.l10n.get(&quot;find_not_found&quot;); status = &quot;notFound&quot;; break; case _pdf_find_controller.FindState.WRAPPED: findMsg = this.l10n.get(`find_reached_${previous ? &quot;top&quot; : &quot;bottom&quot;}`); break; } this.findField.setAttribute(&quot;data-status&quot;, status); this.findField.setAttribute(&quot;aria-invalid&quot;, state === _pdf_find_controller.FindState.NOT_FOUND); findMsg.then(msg =&gt; { this.findMsg.textContent = msg; this.#adjustWidth(); }); this.updateResultsCount(matchesCount); } updateResultsCount({ current = 0, total = 0 } = {}) { const limit = MATCHES_COUNT_LIMIT; let matchCountMsg = Promise.resolve(&quot;&quot;); if (total &gt; 0) { if (total &gt; limit) { let key = &quot;find_match_count_limit&quot;; matchCountMsg = this.l10n.get(key, { limit }); } else { let key = &quot;find_match_count&quot;; matchCountMsg = this.l10n.get(key, { current, total }); } } matchCountMsg.then(msg =&gt; { this.findResultsCount.textContent = msg; this.#adjustWidth(); }); } open() { if (!this.opened) { this.opened = true; this.toggleButton.classList.add(&quot;toggled&quot;); this.toggleButton.setAttribute(&quot;aria-expanded&quot;, &quot;true&quot;); this.bar.classList.remove(&quot;hidden&quot;); } this.findField.select(); this.findField.focus(); this.#adjustWidth(); } close() { if (!this.opened) { return; } this.opened = false; this.toggleButton.classList.remove(&quot;toggled&quot;); this.toggleButton.setAttribute(&quot;aria-expanded&quot;, &quot;false&quot;); this.bar.classList.add(&quot;hidden&quot;); this.eventBus.dispatch(&quot;findbarclose&quot;, { source: this }); } toggle() { if (this.opened) { this.close(); } else { this.open(); } } #adjustWidth() { if (!this.opened) { return; } this.bar.classList.remove(&quot;wrapContainers&quot;); const findbarHeight = this.bar.clientHeight; const inputContainerHeight = this.bar.firstElementChild.clientHeight; if (findbarHeight &gt; inputContainerHeight) { this.bar.classList.add(&quot;wrapContainers&quot;); } } } exports.PDFFindBar = PDFFindBar; /***/ }), /* 16 */ /***/ ((__unused_webpack_module, exports, __webpack_require__) =&gt; { Object.defineProperty(exports, &quot;__esModule&quot;, ({ value: true })); exports.PDFFindController = exports.FindState = void 0; var _ui_utils = __webpack_require__(1); var _pdfjsLib = __webpack_require__(5); var _pdf_find_utils = __webpack_require__(17); const FindState = { FOUND: 0, NOT_FOUND: 1, WRAPPED: 2, PENDING: 3 }; exports.FindState = FindState; const FIND_TIMEOUT = 250; const MATCH_SCROLL_OFFSET_TOP = -50; const MATCH_SCROLL_OFFSET_LEFT = -400; const CHARACTERS_TO_NORMALIZE = { &quot;\\u2010&quot;: &quot;-&quot;, &quot;\\u2018&quot;: &quot;&apos;&quot;, &quot;\\u2019&quot;: &quot;&apos;&quot;, &quot;\\u201A&quot;: &quot;&apos;&quot;, &quot;\\u201B&quot;: &quot;&apos;&quot;, &quot;\\u201C&quot;: &apos;&quot;&apos;, &quot;\\u201D&quot;: &apos;&quot;&apos;, &quot;\\u201E&quot;: &apos;&quot;&apos;, &quot;\\u201F&quot;: &apos;&quot;&apos;, &quot;\\u00BC&quot;: &quot;1/4&quot;, &quot;\\u00BD&quot;: &quot;1/2&quot;, &quot;\\u00BE&quot;: &quot;3/4&quot; }; const DIACRITICS_EXCEPTION = new Set([0x3099, 0x309a, 0x094d, 0x09cd, 0x0a4d, 0x0acd, 0x0b4d, 0x0bcd, 0x0c4d, 0x0ccd, 0x0d3b, 0x0d3c, 0x0d4d, 0x0dca, 0x0e3a, 0x0eba, 0x0f84, 0x1039, 0x103a, 0x1714, 0x1734, 0x17d2, 0x1a60, 0x1b44, 0x1baa, 0x1bab, 0x1bf2, 0x1bf3, 0x2d7f, 0xa806, 0xa82c, 0xa8c4, 0xa953, 0xa9c0, 0xaaf6, 0xabed, 0x0c56, 0x0f71, 0x0f72, 0x0f7a, 0x0f7b, 0x0f7c, 0x0f7d, 0x0f80, 0x0f74]); const DIACRITICS_EXCEPTION_STR = [...DIACRITICS_EXCEPTION.values()].map(x =&gt; String.fromCharCode(x)).join(&quot;&quot;); const DIACRITICS_REG_EXP = /\\p{M}+/gu; const SPECIAL_CHARS_REG_EXP = /([.*+?^${}()|[\\]\\\\])|(\\p{P})|(\\s+)|(\\p{M})|(\\p{L})/gu; const NOT_DIACRITIC_FROM_END_REG_EXP = /([^\\p{M}])\\p{M}*$/u; const NOT_DIACRITIC_FROM_START_REG_EXP = /^\\p{M}*([^\\p{M}])/u; const SYLLABLES_REG_EXP = /[\\uAC00-\\uD7AF\\uFA6C\\uFACF-\\uFAD1\\uFAD5-\\uFAD7]+/g; const SYLLABLES_LENGTHS = new Map(); const FIRST_CHAR_SYLLABLES_REG_EXP = &quot;[\\\\u1100-\\\\u1112\\\\ud7a4-\\\\ud7af\\\\ud84a\\\\ud84c\\\\ud850\\\\ud854\\\\ud857\\\\ud85f]&quot;; let noSyllablesRegExp = null; let withSyllablesRegExp = null; function normalize(text) { const syllablePositions = []; let m; while ((m = SYLLABLES_REG_EXP.exec(text)) !== null) { let { index } = m; for (const char of m[0]) { let len = SYLLABLES_LENGTHS.get(char); if (!len) { len = char.normalize(&quot;NFD&quot;).length; SYLLABLES_LENGTHS.set(char, len); } syllablePositions.push([len, index++]); } } let normalizationRegex; if (syllablePositions.length === 0 &amp;&amp; noSyllablesRegExp) { normalizationRegex = noSyllablesRegExp; } else if (syllablePositions.length &gt; 0 &amp;&amp; withSyllablesRegExp) { normalizationRegex = withSyllablesRegExp; } else { const replace = Object.keys(CHARACTERS_TO_NORMALIZE).join(&quot;&quot;); const regexp = `([${replace}])|(\\\\p{M}+(?:-\\\\n)?)|(\\\\S-\\\\n)|(\\\\p{Ideographic}\\\\n)|(\\\\n)`; if (syllablePositions.length === 0) { normalizationRegex = noSyllablesRegExp = new RegExp(regexp + &quot;|(\\\\u0000)&quot;, &quot;gum&quot;); } else { normalizationRegex = withSyllablesRegExp = new RegExp(regexp + `|(${FIRST_CHAR_SYLLABLES_REG_EXP})`, &quot;gum&quot;); } } const rawDiacriticsPositions = []; while ((m = DIACRITICS_REG_EXP.exec(text)) !== null) { rawDiacriticsPositions.push([m[0].length, m.index]); } let normalized = text.normalize(&quot;NFD&quot;); const positions = [[0, 0]]; let rawDiacriticsIndex = 0; let syllableIndex = 0; let shift = 0; let shiftOrigin = 0; let eol = 0; let hasDiacritics = false; normalized = normalized.replace(normalizationRegex, (match, p1, p2, p3, p4, p5, p6, i) =&gt; { i -= shiftOrigin; if (p1) { const replacement = CHARACTERS_TO_NORMALIZE[match]; const jj = replacement.length; for (let j = 1; j &lt; jj; j++) { positions.push([i - shift + j, shift - j]); } shift -= jj - 1; return replacement; } if (p2) { const hasTrailingDashEOL = p2.endsWith(&quot;\\n&quot;); const len = hasTrailingDashEOL ? p2.length - 2 : p2.length; hasDiacritics = true; let jj = len; if (i + eol === rawDiacriticsPositions[rawDiacriticsIndex]?.[1]) { jj -= rawDiacriticsPositions[rawDiacriticsIndex][0]; ++rawDiacriticsIndex; } for (let j = 1; j &lt;= jj; j++) { positions.push([i - 1 - shift + j, shift - j]); } shift -= jj; shiftOrigin += jj; if (hasTrailingDashEOL) { i += len - 1; positions.push([i - shift + 1, 1 + shift]); shift += 1; shiftOrigin += 1; eol += 1; return p2.slice(0, len); } return p2; } if (p3) { positions.push([i - shift + 1, 1 + shift]); shift += 1; shiftOrigin += 1; eol += 1; return p3.charAt(0); } if (p4) { positions.push([i - shift + 1, shift]); shiftOrigin += 1; eol += 1; return p4.charAt(0); } if (p5) { positions.push([i - shift + 1, shift - 1]); shift -= 1; shiftOrigin += 1; eol += 1; return &quot; &quot;; } if (i + eol === syllablePositions[syllableIndex]?.[1]) { const newCharLen = syllablePositions[syllableIndex][0] - 1; ++syllableIndex; for (let j = 1; j &lt;= newCharLen; j++) { positions.push([i - (shift - j), shift - j]); } shift -= newCharLen; shiftOrigin += newCharLen; } return p6; }); positions.push([normalized.length, shift]); return [normalized, positions, hasDiacritics]; } function getOriginalIndex(diffs, pos, len) { if (!diffs) { return [pos, len]; } const start = pos; const end = pos + len; let i = (0, _ui_utils.binarySearchFirstItem)(diffs, x =&gt; x[0] &gt;= start); if (diffs[i][0] &gt; start) { --i; } let j = (0, _ui_utils.binarySearchFirstItem)(diffs, x =&gt; x[0] &gt;= end, i); if (diffs[j][0] &gt; end) { --j; } return [start + diffs[i][1], len + diffs[j][1] - diffs[i][1]]; } class PDFFindController { constructor({ linkService, eventBus }) { this._linkService = linkService; this._eventBus = eventBus; this.#reset(); eventBus._on(&quot;find&quot;, this.#onFind.bind(this)); eventBus._on(&quot;findbarclose&quot;, this.#onFindBarClose.bind(this)); } get highlightMatches() { return this._highlightMatches; } get pageMatches() { return this._pageMatches; } get pageMatchesLength() { return this._pageMatchesLength; } get selected() { return this._selected; } get state() { return this._state; } setDocument(pdfDocument) { if (this._pdfDocument) { this.#reset(); } if (!pdfDocument) { return; } this._pdfDocument = pdfDocument; this._firstPageCapability.resolve(); } #onFind(state) { if (!state) { return; } const pdfDocument = this._pdfDocument; const { type } = state; if (this._state === null || this.#shouldDirtyMatch(state)) { this._dirtyMatch = true; } this._state = state; if (type !== &quot;highlightallchange&quot;) { this.#updateUIState(FindState.PENDING); } this._firstPageCapability.promise.then(() =&gt; { if (!this._pdfDocument || pdfDocument &amp;&amp; this._pdfDocument !== pdfDocument) { return; } this.#extractText(); const findbarClosed = !this._highlightMatches; const pendingTimeout = !!this._findTimeout; if (this._findTimeout) { clearTimeout(this._findTimeout); this._findTimeout = null; } if (!type) { this._findTimeout = setTimeout(() =&gt; { this.#nextMatch(); this._findTimeout = null; }, FIND_TIMEOUT); } else if (this._dirtyMatch) { this.#nextMatch(); } else if (type === &quot;again&quot;) { this.#nextMatch(); if (findbarClosed &amp;&amp; this._state.highlightAll) { this.#updateAllPages(); } } else if (type === &quot;highlightallchange&quot;) { if (pendingTimeout) { this.#nextMatch(); } else { this._highlightMatches = true; } this.#updateAllPages(); } else { this.#nextMatch(); } }); } scrollMatchIntoView({ element = null, selectedLeft = 0, pageIndex = -1, matchIndex = -1 }) { if (!this._scrollMatches || !element) { return; } else if (matchIndex === -1 || matchIndex !== this._selected.matchIdx) { return; } else if (pageIndex === -1 || pageIndex !== this._selected.pageIdx) { return; } this._scrollMatches = false; const spot = { top: MATCH_SCROLL_OFFSET_TOP, left: selectedLeft + MATCH_SCROLL_OFFSET_LEFT }; (0, _ui_utils.scrollIntoView)(element, spot, true); } #reset() { this._highlightMatches = false; this._scrollMatches = false; this._pdfDocument = null; this._pageMatches = []; this._pageMatchesLength = []; this._state = null; this._selected = { pageIdx: -1, matchIdx: -1 }; this._offset = { pageIdx: null, matchIdx: null, wrapped: false }; this._extractTextPromises = []; this._pageContents = []; this._pageDiffs = []; this._hasDiacritics = []; this._matchesCountTotal = 0; this._pagesToSearch = null; this._pendingFindMatches = new Set(); this._resumePageIdx = null; this._dirtyMatch = false; clearTimeout(this._findTimeout); this._findTimeout = null; this._firstPageCapability = (0, _pdfjsLib.createPromiseCapability)(); } get #query() { if (this._state.query !== this._rawQuery) { this._rawQuery = this._state.query; [this._normalizedQuery] = normalize(this._state.query); } return this._normalizedQuery; } #shouldDirtyMatch(state) { if (state.query !== this._state.query) { return true; } switch (state.type) { case &quot;again&quot;: const pageNumber = this._selected.pageIdx + 1; const linkService = this._linkService; if (pageNumber &gt;= 1 &amp;&amp; pageNumber &lt;= linkService.pagesCount &amp;&amp; pageNumber !== linkService.page &amp;&amp; !linkService.isPageVisible(pageNumber)) { return true; } return false; case &quot;highlightallchange&quot;: return false; } return true; } #isEntireWord(content, startIdx, length) { let match = content.slice(0, startIdx).match(NOT_DIACRITIC_FROM_END_REG_EXP); if (match) { const first = content.charCodeAt(startIdx); const limit = match[1].charCodeAt(0); if ((0, _pdf_find_utils.getCharacterType)(first) === (0, _pdf_find_utils.getCharacterType)(limit)) { return false; } } match = content.slice(startIdx + length).match(NOT_DIACRITIC_FROM_START_REG_EXP); if (match) { const last = content.charCodeAt(startIdx + length - 1); const limit = match[1].charCodeAt(0); if ((0, _pdf_find_utils.getCharacterType)(last) === (0, _pdf_find_utils.getCharacterType)(limit)) { return false; } } return true; } #calculateRegExpMatch(query, entireWord, pageIndex, pageContent) { const matches = [], matchesLength = []; const diffs = this._pageDiffs[pageIndex]; let match; while ((match = query.exec(pageContent)) !== null) { if (entireWord &amp;&amp; !this.#isEntireWord(pageContent, match.index, match[0].length)) { continue; } const [matchPos, matchLen] = getOriginalIndex(diffs, match.index, match[0].length); if (matchLen) { matches.push(matchPos); matchesLength.push(matchLen); } } this._pageMatches[pageIndex] = matches; this._pageMatchesLength[pageIndex] = matchesLength; } #convertToRegExpString(query, hasDiacritics) { const { matchDiacritics } = this._state; let isUnicode = false; query = query.replace(SPECIAL_CHARS_REG_EXP, (match, p1, p2, p3, p4, p5) =&gt; { if (p1) { return `[ ]*\\\\${p1}[ ]*`; } if (p2) { return `[ ]*${p2}[ ]*`; } if (p3) { return &quot;[ ]+&quot;; } if (matchDiacritics) { return p4 || p5; } if (p4) { return DIACRITICS_EXCEPTION.has(p4.charCodeAt(0)) ? p4 : &quot;&quot;; } if (hasDiacritics) { isUnicode = true; return `${p5}\\\\p{M}*`; } return p5; }); const trailingSpaces = &quot;[ ]*&quot;; if (query.endsWith(trailingSpaces)) { query = query.slice(0, query.length - trailingSpaces.length); } if (matchDiacritics) { if (hasDiacritics) { isUnicode = true; query = `${query}(?=[${DIACRITICS_EXCEPTION_STR}]|[^\\\\p{M}]|$)`; } } return [isUnicode, query]; } #calculateMatch(pageIndex) { let query = this.#query; if (query.length === 0) { return; } const { caseSensitive, entireWord, phraseSearch } = this._state; const pageContent = this._pageContents[pageIndex]; const hasDiacritics = this._hasDiacritics[pageIndex]; let isUnicode = false; if (phraseSearch) { [isUnicode, query] = this.#convertToRegExpString(query, hasDiacritics); } else { const match = query.match(/\\S+/g); if (match) { query = match.sort().reverse().map(q =&gt; { const [isUnicodePart, queryPart] = this.#convertToRegExpString(q, hasDiacritics); isUnicode ||= isUnicodePart; return `(${queryPart})`; }).join(&quot;|&quot;); } } const flags = `g${isUnicode ? &quot;u&quot; : &quot;&quot;}${caseSensitive ? &quot;&quot; : &quot;i&quot;}`; query = new RegExp(query, flags); this.#calculateRegExpMatch(query, entireWord, pageIndex, pageContent); if (this._state.highlightAll) { this.#updatePage(pageIndex); } if (this._resumePageIdx === pageIndex) { this._resumePageIdx = null; this.#nextPageMatch(); } const pageMatchesCount = this._pageMatches[pageIndex].length; if (pageMatchesCount &gt; 0) { this._matchesCountTotal += pageMatchesCount; this.#updateUIResultsCount(); } } #extractText() { if (this._extractTextPromises.length &gt; 0) { return; } let promise = Promise.resolve(); for (let i = 0, ii = this._linkService.pagesCount; i &lt; ii; i++) { const extractTextCapability = (0, _pdfjsLib.createPromiseCapability)(); this._extractTextPromises[i] = extractTextCapability.promise; promise = promise.then(() =&gt; { return this._pdfDocument.getPage(i + 1).then(pdfPage =&gt; { return pdfPage.getTextContent(); }).then(textContent =&gt; { const strBuf = []; for (const textItem of textContent.items) { strBuf.push(textItem.str); if (textItem.hasEOL) { strBuf.push(&quot;\\n&quot;); } } [this._pageContents[i], this._pageDiffs[i], this._hasDiacritics[i]] = normalize(strBuf.join(&quot;&quot;)); extractTextCapability.resolve(); }, reason =&gt; { console.error(`Unable to get text content for page ${i + 1}`, reason); this._pageContents[i] = &quot;&quot;; this._pageDiffs[i] = null; this._hasDiacritics[i] = false; extractTextCapability.resolve(); }); }); } } #updatePage(index) { if (this._scrollMatches &amp;&amp; this._selected.pageIdx === index) { this._linkService.page = index + 1; } this._eventBus.dispatch(&quot;updatetextlayermatches&quot;, { source: this, pageIndex: index }); } #updateAllPages() { this._eventBus.dispatch(&quot;updatetextlayermatches&quot;, { source: this, pageIndex: -1 }); } #nextMatch() { const previous = this._state.findPrevious; const currentPageIndex = this._linkService.page - 1; const numPages = this._linkService.pagesCount; this._highlightMatches = true; if (this._dirtyMatch) { this._dirtyMatch = false; this._selected.pageIdx = this._selected.matchIdx = -1; this._offset.pageIdx = currentPageIndex; this._offset.matchIdx = null; this._offset.wrapped = false; this._resumePageIdx = null; this._pageMatches.length = 0; this._pageMatchesLength.length = 0; this._matchesCountTotal = 0; this.#updateAllPages(); for (let i = 0; i &lt; numPages; i++) { if (this._pendingFindMatches.has(i)) { continue; } this._pendingFindMatches.add(i); this._extractTextPromises[i].then(() =&gt; { this._pendingFindMatches.delete(i); this.#calculateMatch(i); }); } } if (this.#query === &quot;&quot;) { this.#updateUIState(FindState.FOUND); return; } if (this._resumePageIdx) { return; } const offset = this._offset; this._pagesToSearch = numPages; if (offset.matchIdx !== null) { const numPageMatches = this._pageMatches[offset.pageIdx].length; if (!previous &amp;&amp; offset.matchIdx + 1 &lt; numPageMatches || previous &amp;&amp; offset.matchIdx &gt; 0) { offset.matchIdx = previous ? offset.matchIdx - 1 : offset.matchIdx + 1; this.#updateMatch(true); return; } this.#advanceOffsetPage(previous); } this.#nextPageMatch(); } #matchesReady(matches) { const offset = this._offset; const numMatches = matches.length; const previous = this._state.findPrevious; if (numMatches) { offset.matchIdx = previous ? numMatches - 1 : 0; this.#updateMatch(true); return true; } this.#advanceOffsetPage(previous); if (offset.wrapped) { offset.matchIdx = null; if (this._pagesToSearch &lt; 0) { this.#updateMatch(false); return true; } } return false; } #nextPageMatch() { if (this._resumePageIdx !== null) { console.error(&quot;There can only be one pending page.&quot;); } let matches = null; do { const pageIdx = this._offset.pageIdx; matches = this._pageMatches[pageIdx]; if (!matches) { this._resumePageIdx = pageIdx; break; } } while (!this.#matchesReady(matches)); } #advanceOffsetPage(previous) { const offset = this._offset; const numPages = this._linkService.pagesCount; offset.pageIdx = previous ? offset.pageIdx - 1 : offset.pageIdx + 1; offset.matchIdx = null; this._pagesToSearch--; if (offset.pageIdx &gt;= numPages || offset.pageIdx &lt; 0) { offset.pageIdx = previous ? numPages - 1 : 0; offset.wrapped = true; } } #updateMatch(found = false) { let state = FindState.NOT_FOUND; const wrapped = this._offset.wrapped; this._offset.wrapped = false; if (found) { const previousPage = this._selected.pageIdx; this._selected.pageIdx = this._offset.pageIdx; this._selected.matchIdx = this._offset.matchIdx; state = wrapped ? FindState.WRAPPED : FindState.FOUND; if (previousPage !== -1 &amp;&amp; previousPage !== this._selected.pageIdx) { this.#updatePage(previousPage); } } this.#updateUIState(state, this._state.findPrevious); if (this._selected.pageIdx !== -1) { this._scrollMatches = true; this.#updatePage(this._selected.pageIdx); } } #onFindBarClose(evt) { const pdfDocument = this._pdfDocument; this._firstPageCapability.promise.then(() =&gt; { if (!this._pdfDocument || pdfDocument &amp;&amp; this._pdfDocument !== pdfDocument) { return; } if (this._findTimeout) { clearTimeout(this._findTimeout); this._findTimeout = null; } if (this._resumePageIdx) { this._resumePageIdx = null; this._dirtyMatch = true; } this.#updateUIState(FindState.FOUND); this._highlightMatches = false; this.#updateAllPages(); }); } #requestMatchesCount() { const { pageIdx, matchIdx } = this._selected; let current = 0, total = this._matchesCountTotal; if (matchIdx !== -1) { for (let i = 0; i &lt; pageIdx; i++) { current += this._pageMatches[i]?.length || 0; } current += matchIdx + 1; } if (current &lt; 1 || current &gt; total) { current = total = 0; } return { current, total }; } #updateUIResultsCount() { this._eventBus.dispatch(&quot;updatefindmatchescount&quot;, { source: this, matchesCount: this.#requestMatchesCount() }); } #updateUIState(state, previous = false) { this._eventBus.dispatch(&quot;updatefindcontrolstate&quot;, { source: this, state, previous, matchesCount: this.#requestMatchesCount(), rawQuery: this._state?.query ?? null }); } } exports.PDFFindController = PDFFindController; /***/ }), /* 17 */ /***/ ((__unused_webpack_module, exports) =&gt; { Object.defineProperty(exports, &quot;__esModule&quot;, ({ value: true })); exports.CharacterType = void 0; exports.getCharacterType = getCharacterType; const CharacterType = { SPACE: 0, ALPHA_LETTER: 1, PUNCT: 2, HAN_LETTER: 3, KATAKANA_LETTER: 4, HIRAGANA_LETTER: 5, HALFWIDTH_KATAKANA_LETTER: 6, THAI_LETTER: 7 }; exports.CharacterType = CharacterType; function isAlphabeticalScript(charCode) { return charCode &lt; 0x2e80; } function isAscii(charCode) { return (charCode &amp; 0xff80) === 0; } function isAsciiAlpha(charCode) { return charCode &gt;= 0x61 &amp;&amp; charCode &lt;= 0x7a || charCode &gt;= 0x41 &amp;&amp; charCode &lt;= 0x5a; } function isAsciiDigit(charCode) { return charCode &gt;= 0x30 &amp;&amp; charCode &lt;= 0x39; } function isAsciiSpace(charCode) { return charCode === 0x20 || charCode === 0x09 || charCode === 0x0d || charCode === 0x0a; } function isHan(charCode) { return charCode &gt;= 0x3400 &amp;&amp; charCode &lt;= 0x9fff || charCode &gt;= 0xf900 &amp;&amp; charCode &lt;= 0xfaff; } function isKatakana(charCode) { return charCode &gt;= 0x30a0 &amp;&amp; charCode &lt;= 0x30ff; } function isHiragana(charCode) { return charCode &gt;= 0x3040 &amp;&amp; charCode &lt;= 0x309f; } function isHalfwidthKatakana(charCode) { return charCode &gt;= 0xff60 &amp;&amp; charCode &lt;= 0xff9f; } function isThai(charCode) { return (charCode &amp; 0xff80) === 0x0e00; } function getCharacterType(charCode) { if (isAlphabeticalScript(charCode)) { if (isAscii(charCode)) { if (isAsciiSpace(charCode)) { return CharacterType.SPACE; } else if (isAsciiAlpha(charCode) || isAsciiDigit(charCode) || charCode === 0x5f) { return CharacterType.ALPHA_LETTER; } return CharacterType.PUNCT; } else if (isThai(charCode)) { return CharacterType.THAI_LETTER; } else if (charCode === 0xa0) { return CharacterType.SPACE; } return CharacterType.ALPHA_LETTER; } if (isHan(charCode)) { return CharacterType.HAN_LETTER; } else if (isKatakana(charCode)) { return CharacterType.KATAKANA_LETTER; } else if (isHiragana(charCode)) { return CharacterType.HIRAGANA_LETTER; } else if (isHalfwidthKatakana(charCode)) { return CharacterType.HALFWIDTH_KATAKANA_LETTER; } return CharacterType.ALPHA_LETTER; } /***/ }), /* 18 */ /***/ ((__unused_webpack_module, exports, __webpack_require__) =&gt; { Object.defineProperty(exports, &quot;__esModule&quot;, ({ value: true })); exports.PDFHistory = void 0; exports.isDestArraysEqual = isDestArraysEqual; exports.isDestHashesEqual = isDestHashesEqual; var _ui_utils = __webpack_require__(1); var _event_utils = __webpack_require__(6); const HASH_CHANGE_TIMEOUT = 1000; const POSITION_UPDATED_THRESHOLD = 50; const UPDATE_VIEWAREA_TIMEOUT = 1000; function getCurrentHash() { return document.location.hash; } class PDFHistory { constructor({ linkService, eventBus }) { this.linkService = linkService; this.eventBus = eventBus; this._initialized = false; this._fingerprint = &quot;&quot;; this.reset(); this._boundEvents = null; this.eventBus._on(&quot;pagesinit&quot;, () =&gt; { this._isPagesLoaded = false; this.eventBus._on(&quot;pagesloaded&quot;, evt =&gt; { this._isPagesLoaded = !!evt.pagesCount; }, { once: true }); }); } initialize({ fingerprint, resetHistory = false, updateUrl = false }) { if (!fingerprint || typeof fingerprint !== &quot;string&quot;) { console.error(&apos;PDFHistory.initialize: The &quot;fingerprint&quot; must be a non-empty string.&apos;); return; } if (this._initialized) { this.reset(); } const reInitialized = this._fingerprint !== &quot;&quot; &amp;&amp; this._fingerprint !== fingerprint; this._fingerprint = fingerprint; this._updateUrl = updateUrl === true; this._initialized = true; this._bindEvents(); const state = window.history.state; this._popStateInProgress = false; this._blockHashChange = 0; this._currentHash = getCurrentHash(); this._numPositionUpdates = 0; this._uid = this._maxUid = 0; this._destination = null; this._position = null; if (!this._isValidState(state, true) || resetHistory) { const { hash, page, rotation } = this._parseCurrentHash(true); if (!hash || reInitialized || resetHistory) { this._pushOrReplaceState(null, true); return; } this._pushOrReplaceState({ hash, page, rotation }, true); return; } const destination = state.destination; this._updateInternalState(destination, state.uid, true); if (destination.rotation !== undefined) { this._initialRotation = destination.rotation; } if (destination.dest) { this._initialBookmark = JSON.stringify(destination.dest); this._destination.page = null; } else if (destination.hash) { this._initialBookmark = destination.hash; } else if (destination.page) { this._initialBookmark = `page=${destination.page}`; } } reset() { if (this._initialized) { this._pageHide(); this._initialized = false; this._unbindEvents(); } if (this._updateViewareaTimeout) { clearTimeout(this._updateViewareaTimeout); this._updateViewareaTimeout = null; } this._initialBookmark = null; this._initialRotation = null; } push({ namedDest = null, explicitDest, pageNumber }) { if (!this._initialized) { return; } if (namedDest &amp;&amp; typeof namedDest !== &quot;string&quot;) { console.error(&quot;PDFHistory.push: &quot; + `&quot;${namedDest}&quot; is not a valid namedDest parameter.`); return; } else if (!Array.isArray(explicitDest)) { console.error(&quot;PDFHistory.push: &quot; + `&quot;${explicitDest}&quot; is not a valid explicitDest parameter.`); return; } else if (!this._isValidPage(pageNumber)) { if (pageNumber !== null || this._destination) { console.error(&quot;PDFHistory.push: &quot; + `&quot;${pageNumber}&quot; is not a valid pageNumber parameter.`); return; } } const hash = namedDest || JSON.stringify(explicitDest); if (!hash) { return; } let forceReplace = false; if (this._destination &amp;&amp; (isDestHashesEqual(this._destination.hash, hash) || isDestArraysEqual(this._destination.dest, explicitDest))) { if (this._destination.page) { return; } forceReplace = true; } if (this._popStateInProgress &amp;&amp; !forceReplace) { return; } this._pushOrReplaceState({ dest: explicitDest, hash, page: pageNumber, rotation: this.linkService.rotation }, forceReplace); if (!this._popStateInProgress) { this._popStateInProgress = true; Promise.resolve().then(() =&gt; { this._popStateInProgress = false; }); } } pushPage(pageNumber) { if (!this._initialized) { return; } if (!this._isValidPage(pageNumber)) { console.error(`PDFHistory.pushPage: &quot;${pageNumber}&quot; is not a valid page number.`); return; } if (this._destination?.page === pageNumber) { return; } if (this._popStateInProgress) { return; } this._pushOrReplaceState({ dest: null, hash: `page=${pageNumber}`, page: pageNumber, rotation: this.linkService.rotation }); if (!this._popStateInProgress) { this._popStateInProgress = true; Promise.resolve().then(() =&gt; { this._popStateInProgress = false; }); } } pushCurrentPosition() { if (!this._initialized || this._popStateInProgress) { return; } this._tryPushCurrentPosition(); } back() { if (!this._initialized || this._popStateInProgress) { return; } const state = window.history.state; if (this._isValidState(state) &amp;&amp; state.uid &gt; 0) { window.history.back(); } } forward() { if (!this._initialized || this._popStateInProgress) { return; } const state = window.history.state; if (this._isValidState(state) &amp;&amp; state.uid &lt; this._maxUid) { window.history.forward(); } } get popStateInProgress() { return this._initialized &amp;&amp; (this._popStateInProgress || this._blockHashChange &gt; 0); } get initialBookmark() { return this._initialized ? this._initialBookmark : null; } get initialRotation() { return this._initialized ? this._initialRotation : null; } _pushOrReplaceState(destination, forceReplace = false) { const shouldReplace = forceReplace || !this._destination; const newState = { fingerprint: this._fingerprint, uid: shouldReplace ? this._uid : this._uid + 1, destination }; this._updateInternalState(destination, newState.uid); let newUrl; if (this._updateUrl &amp;&amp; destination?.hash) { const baseUrl = document.location.href.split(&quot;#&quot;)[0]; if (!baseUrl.startsWith(&quot;file://&quot;)) { newUrl = `${baseUrl}#${destination.hash}`; } } if (shouldReplace) { window.history.replaceState(newState, &quot;&quot;, newUrl); } else { window.history.pushState(newState, &quot;&quot;, newUrl); } } _tryPushCurrentPosition(temporary = false) { if (!this._position) { return; } let position = this._position; if (temporary) { position = Object.assign(Object.create(null), this._position); position.temporary = true; } if (!this._destination) { this._pushOrReplaceState(position); return; } if (this._destination.temporary) { this._pushOrReplaceState(position, true); return; } if (this._destination.hash === position.hash) { return; } if (!this._destination.page &amp;&amp; (POSITION_UPDATED_THRESHOLD &lt;= 0 || this._numPositionUpdates &lt;= POSITION_UPDATED_THRESHOLD)) { return; } let forceReplace = false; if (this._destination.page &gt;= position.first &amp;&amp; this._destination.page &lt;= position.page) { if (this._destination.dest !== undefined || !this._destination.first) { return; } forceReplace = true; } this._pushOrReplaceState(position, forceReplace); } _isValidPage(val) { return Number.isInteger(val) &amp;&amp; val &gt; 0 &amp;&amp; val &lt;= this.linkService.pagesCount; } _isValidState(state, checkReload = false) { if (!state) { return false; } if (state.fingerprint !== this._fingerprint) { if (checkReload) { if (typeof state.fingerprint !== &quot;string&quot; || state.fingerprint.length !== this._fingerprint.length) { return false; } const [perfEntry] = performance.getEntriesByType(&quot;navigation&quot;); if (perfEntry?.type !== &quot;reload&quot;) { return false; } } else { return false; } } if (!Number.isInteger(state.uid) || state.uid &lt; 0) { return false; } if (state.destination === null || typeof state.destination !== &quot;object&quot;) { return false; } return true; } _updateInternalState(destination, uid, removeTemporary = false) { if (this._updateViewareaTimeout) { clearTimeout(this._updateViewareaTimeout); this._updateViewareaTimeout = null; } if (removeTemporary &amp;&amp; destination?.temporary) { delete destination.temporary; } this._destination = destination; this._uid = uid; this._maxUid = Math.max(this._maxUid, uid); this._numPositionUpdates = 0; } _parseCurrentHash(checkNameddest = false) { const hash = unescape(getCurrentHash()).substring(1); const params = (0, _ui_utils.parseQueryString)(hash); const nameddest = params.get(&quot;nameddest&quot;) || &quot;&quot;; let page = params.get(&quot;page&quot;) | 0; if (!this._isValidPage(page) || checkNameddest &amp;&amp; nameddest.length &gt; 0) { page = null; } return { hash, page, rotation: this.linkService.rotation }; } _updateViewarea({ location }) { if (this._updateViewareaTimeout) { clearTimeout(this._updateViewareaTimeout); this._updateViewareaTimeout = null; } this._position = { hash: location.pdfOpenParams.substring(1), page: this.linkService.page, first: location.pageNumber, rotation: location.rotation }; if (this._popStateInProgress) { return; } if (POSITION_UPDATED_THRESHOLD &gt; 0 &amp;&amp; this._isPagesLoaded &amp;&amp; this._destination &amp;&amp; !this._destination.page) { this._numPositionUpdates++; } if (UPDATE_VIEWAREA_TIMEOUT &gt; 0) { this._updateViewareaTimeout = setTimeout(() =&gt; { if (!this._popStateInProgress) { this._tryPushCurrentPosition(true); } this._updateViewareaTimeout = null; }, UPDATE_VIEWAREA_TIMEOUT); } } _popState({ state }) { const newHash = getCurrentHash(), hashChanged = this._currentHash !== newHash; this._currentHash = newHash; if (!state) { this._uid++; const { hash, page, rotation } = this._parseCurrentHash(); this._pushOrReplaceState({ hash, page, rotation }, true); return; } if (!this._isValidState(state)) { return; } this._popStateInProgress = true; if (hashChanged) { this._blockHashChange++; (0, _event_utils.waitOnEventOrTimeout)({ target: window, name: &quot;hashchange&quot;, delay: HASH_CHANGE_TIMEOUT }).then(() =&gt; { this._blockHashChange--; }); } const destination = state.destination; this._updateInternalState(destination, state.uid, true); if ((0, _ui_utils.isValidRotation)(destination.rotation)) { this.linkService.rotation = destination.rotation; } if (destination.dest) { this.linkService.goToDestination(destination.dest); } else if (destination.hash) { this.linkService.setHash(destination.hash); } else if (destination.page) { this.linkService.page = destination.page; } Promise.resolve().then(() =&gt; { this._popStateInProgress = false; }); } _pageHide() { if (!this._destination || this._destination.temporary) { this._tryPushCurrentPosition(); } } _bindEvents() { if (this._boundEvents) { return; } this._boundEvents = { updateViewarea: this._updateViewarea.bind(this), popState: this._popState.bind(this), pageHide: this._pageHide.bind(this) }; this.eventBus._on(&quot;updateviewarea&quot;, this._boundEvents.updateViewarea); window.addEventListener(&quot;popstate&quot;, this._boundEvents.popState); window.addEventListener(&quot;pagehide&quot;, this._boundEvents.pageHide); } _unbindEvents() { if (!this._boundEvents) { return; } this.eventBus._off(&quot;updateviewarea&quot;, this._boundEvents.updateViewarea); window.removeEventListener(&quot;popstate&quot;, this._boundEvents.popState); window.removeEventListener(&quot;pagehide&quot;, this._boundEvents.pageHide); this._boundEvents = null; } } exports.PDFHistory = PDFHistory; function isDestHashesEqual(destHash, pushHash) { if (typeof destHash !== &quot;string&quot; || typeof pushHash !== &quot;string&quot;) { return false; } if (destHash === pushHash) { return true; } const nameddest = (0, _ui_utils.parseQueryString)(destHash).get(&quot;nameddest&quot;); if (nameddest === pushHash) { return true; } return false; } function isDestArraysEqual(firstDest, secondDest) { function isEntryEqual(first, second) { if (typeof first !== typeof second) { return false; } if (Array.isArray(first) || Array.isArray(second)) { return false; } if (first !== null &amp;&amp; typeof first === &quot;object&quot; &amp;&amp; second !== null) { if (Object.keys(first).length !== Object.keys(second).length) { return false; } for (const key in first) { if (!isEntryEqual(first[key], second[key])) { return false; } } return true; } return first === second || Number.isNaN(first) &amp;&amp; Number.isNaN(second); } if (!(Array.isArray(firstDest) &amp;&amp; Array.isArray(secondDest))) { return false; } if (firstDest.length !== secondDest.length) { return false; } for (let i = 0, ii = firstDest.length; i &lt; ii; i++) { if (!isEntryEqual(firstDest[i], secondDest[i])) { return false; } } return true; } /***/ }), /* 19 */ /***/ ((__unused_webpack_module, exports, __webpack_require__) =&gt; { Object.defineProperty(exports, &quot;__esModule&quot;, ({ value: true })); exports.PDFLayerViewer = void 0; var _base_tree_viewer = __webpack_require__(13); class PDFLayerViewer extends _base_tree_viewer.BaseTreeViewer { constructor(options) { super(options); this.l10n = options.l10n; this.eventBus._on(&quot;optionalcontentconfigchanged&quot;, evt =&gt; { this.#updateLayers(evt.promise); }); this.eventBus._on(&quot;resetlayers&quot;, () =&gt; { this.#updateLayers(); }); this.eventBus._on(&quot;togglelayerstree&quot;, this._toggleAllTreeItems.bind(this)); } reset() { super.reset(); this._optionalContentConfig = null; this._optionalContentHash = null; } _dispatchEvent(layersCount) { this.eventBus.dispatch(&quot;layersloaded&quot;, { source: this, layersCount }); } _bindLink(element, { groupId, input }) { const setVisibility = () =&gt; { this._optionalContentConfig.setVisibility(groupId, input.checked); this._optionalContentHash = this._optionalContentConfig.getHash(); this.eventBus.dispatch(&quot;optionalcontentconfig&quot;, { source: this, promise: Promise.resolve(this._optionalContentConfig) }); }; element.onclick = evt =&gt; { if (evt.target === input) { setVisibility(); return true; } else if (evt.target !== element) { return true; } input.checked = !input.checked; setVisibility(); return false; }; } async _setNestedName(element, { name = null }) { if (typeof name === &quot;string&quot;) { element.textContent = this._normalizeTextContent(name); return; } element.textContent = await this.l10n.get(&quot;additional_layers&quot;); element.style.fontStyle = &quot;italic&quot;; } _addToggleButton(div, { name = null }) { super._addToggleButton(div, name === null); } _toggleAllTreeItems() { if (!this._optionalContentConfig) { return; } super._toggleAllTreeItems(); } render({ optionalContentConfig, pdfDocument }) { if (this._optionalContentConfig) { this.reset(); } this._optionalContentConfig = optionalContentConfig || null; this._pdfDocument = pdfDocument || null; const groups = optionalContentConfig?.getOrder(); if (!groups) { this._dispatchEvent(0); return; } this._optionalContentHash = optionalContentConfig.getHash(); const fragment = document.createDocumentFragment(), queue = [{ parent: fragment, groups }]; let layersCount = 0, hasAnyNesting = false; while (queue.length &gt; 0) { const levelData = queue.shift(); for (const groupId of levelData.groups) { const div = document.createElement(&quot;div&quot;); div.className = &quot;treeItem&quot;; const element = document.createElement(&quot;a&quot;); div.append(element); if (typeof groupId === &quot;object&quot;) { hasAnyNesting = true; this._addToggleButton(div, groupId); this._setNestedName(element, groupId); const itemsDiv = document.createElement(&quot;div&quot;); itemsDiv.className = &quot;treeItems&quot;; div.append(itemsDiv); queue.push({ parent: itemsDiv, groups: groupId.order }); } else { const group = optionalContentConfig.getGroup(groupId); const input = document.createElement(&quot;input&quot;); this._bindLink(element, { groupId, input }); input.type = &quot;checkbox&quot;; input.checked = group.visible; const label = document.createElement(&quot;label&quot;); label.textContent = this._normalizeTextContent(group.name); label.append(input); element.append(label); layersCount++; } levelData.parent.append(div); } } this._finishRendering(fragment, layersCount, hasAnyNesting); } async #updateLayers(promise = null) { if (!this._optionalContentConfig) { return; } const pdfDocument = this._pdfDocument; const optionalContentConfig = await (promise || pdfDocument.getOptionalContentConfig()); if (pdfDocument !== this._pdfDocument) { return; } if (promise) { if (optionalContentConfig.getHash() === this._optionalContentHash) { return; } } else { this.eventBus.dispatch(&quot;optionalcontentconfig&quot;, { source: this, promise: Promise.resolve(optionalContentConfig) }); } this.render({ optionalContentConfig, pdfDocument: this._pdfDocument }); } } exports.PDFLayerViewer = PDFLayerViewer; /***/ }), /* 20 */ /***/ ((__unused_webpack_module, exports, __webpack_require__) =&gt; { Object.defineProperty(exports, &quot;__esModule&quot;, ({ value: true })); exports.PDFOutlineViewer = void 0; var _base_tree_viewer = __webpack_require__(13); var _pdfjsLib = __webpack_require__(5); var _ui_utils = __webpack_require__(1); class PDFOutlineViewer extends _base_tree_viewer.BaseTreeViewer { constructor(options) { super(options); this.linkService = options.linkService; this.downloadManager = options.downloadManager; this.eventBus._on(&quot;toggleoutlinetree&quot;, this._toggleAllTreeItems.bind(this)); this.eventBus._on(&quot;currentoutlineitem&quot;, this._currentOutlineItem.bind(this)); this.eventBus._on(&quot;pagechanging&quot;, evt =&gt; { this._currentPageNumber = evt.pageNumber; }); this.eventBus._on(&quot;pagesloaded&quot;, evt =&gt; { this._isPagesLoaded = !!evt.pagesCount; if (this._currentOutlineItemCapability &amp;&amp; !this._currentOutlineItemCapability.settled) { this._currentOutlineItemCapability.resolve(this._isPagesLoaded); } }); this.eventBus._on(&quot;sidebarviewchanged&quot;, evt =&gt; { this._sidebarView = evt.view; }); } reset() { super.reset(); this._outline = null; this._pageNumberToDestHashCapability = null; this._currentPageNumber = 1; this._isPagesLoaded = null; if (this._currentOutlineItemCapability &amp;&amp; !this._currentOutlineItemCapability.settled) { this._currentOutlineItemCapability.resolve(false); } this._currentOutlineItemCapability = null; } _dispatchEvent(outlineCount) { this._currentOutlineItemCapability = (0, _pdfjsLib.createPromiseCapability)(); if (outlineCount === 0 || this._pdfDocument?.loadingParams.disableAutoFetch) { this._currentOutlineItemCapability.resolve(false); } else if (this._isPagesLoaded !== null) { this._currentOutlineItemCapability.resolve(this._isPagesLoaded); } this.eventBus.dispatch(&quot;outlineloaded&quot;, { source: this, outlineCount, currentOutlineItemPromise: this._currentOutlineItemCapability.promise }); } _bindLink(element, { url, newWindow, action, attachment, dest, setOCGState }) { const { linkService } = this; if (url) { linkService.addLinkAttributes(element, url, newWindow); return; } if (action) { element.href = linkService.getAnchorUrl(&quot;&quot;); element.onclick = () =&gt; { linkService.executeNamedAction(action); return false; }; return; } if (attachment) { element.href = linkService.getAnchorUrl(&quot;&quot;); element.onclick = () =&gt; { this.downloadManager.openOrDownloadData(element, attachment.content, attachment.filename); return false; }; return; } if (setOCGState) { element.href = linkService.getAnchorUrl(&quot;&quot;); element.onclick = () =&gt; { linkService.executeSetOCGState(setOCGState); return false; }; return; } element.href = linkService.getDestinationHash(dest); element.onclick = evt =&gt; { this._updateCurrentTreeItem(evt.target.parentNode); if (dest) { linkService.goToDestination(dest); } return false; }; } _setStyles(element, { bold, italic }) { if (bold) { element.style.fontWeight = &quot;bold&quot;; } if (italic) { element.style.fontStyle = &quot;italic&quot;; } } _addToggleButton(div, { count, items }) { let hidden = false; if (count &lt; 0) { let totalCount = items.length; if (totalCount &gt; 0) { const queue = [...items]; while (queue.length &gt; 0) { const { count: nestedCount, items: nestedItems } = queue.shift(); if (nestedCount &gt; 0 &amp;&amp; nestedItems.length &gt; 0) { totalCount += nestedItems.length; queue.push(...nestedItems); } } } if (Math.abs(count) === totalCount) { hidden = true; } } super._addToggleButton(div, hidden); } _toggleAllTreeItems() { if (!this._outline) { return; } super._toggleAllTreeItems(); } render({ outline, pdfDocument }) { if (this._outline) { this.reset(); } this._outline = outline || null; this._pdfDocument = pdfDocument || null; if (!outline) { this._dispatchEvent(0); return; } const fragment = document.createDocumentFragment(); const queue = [{ parent: fragment, items: outline }]; let outlineCount = 0, hasAnyNesting = false; while (queue.length &gt; 0) { const levelData = queue.shift(); for (const item of levelData.items) { const div = document.createElement(&quot;div&quot;); div.className = &quot;treeItem&quot;; const element = document.createElement(&quot;a&quot;); this._bindLink(element, item); this._setStyles(element, item); element.textContent = this._normalizeTextContent(item.title); div.append(element); if (item.items.length &gt; 0) { hasAnyNesting = true; this._addToggleButton(div, item); const itemsDiv = document.createElement(&quot;div&quot;); itemsDiv.className = &quot;treeItems&quot;; div.append(itemsDiv); queue.push({ parent: itemsDiv, items: item.items }); } levelData.parent.append(div); outlineCount++; } } this._finishRendering(fragment, outlineCount, hasAnyNesting); } async _currentOutlineItem() { if (!this._isPagesLoaded) { throw new Error(&quot;_currentOutlineItem: All pages have not been loaded.&quot;); } if (!this._outline || !this._pdfDocument) { return; } const pageNumberToDestHash = await this._getPageNumberToDestHash(this._pdfDocument); if (!pageNumberToDestHash) { return; } this._updateCurrentTreeItem(null); if (this._sidebarView !== _ui_utils.SidebarView.OUTLINE) { return; } for (let i = this._currentPageNumber; i &gt; 0; i--) { const destHash = pageNumberToDestHash.get(i); if (!destHash) { continue; } const linkElement = this.container.querySelector(`a[href=&quot;${destHash}&quot;]`); if (!linkElement) { continue; } this._scrollToCurrentTreeItem(linkElement.parentNode); break; } } async _getPageNumberToDestHash(pdfDocument) { if (this._pageNumberToDestHashCapability) { return this._pageNumberToDestHashCapability.promise; } this._pageNumberToDestHashCapability = (0, _pdfjsLib.createPromiseCapability)(); const pageNumberToDestHash = new Map(), pageNumberNesting = new Map(); const queue = [{ nesting: 0, items: this._outline }]; while (queue.length &gt; 0) { const levelData = queue.shift(), currentNesting = levelData.nesting; for (const { dest, items } of levelData.items) { let explicitDest, pageNumber; if (typeof dest === &quot;string&quot;) { explicitDest = await pdfDocument.getDestination(dest); if (pdfDocument !== this._pdfDocument) { return null; } } else { explicitDest = dest; } if (Array.isArray(explicitDest)) { const [destRef] = explicitDest; if (typeof destRef === &quot;object&quot; &amp;&amp; destRef !== null) { pageNumber = this.linkService._cachedPageNumber(destRef); if (!pageNumber) { try { pageNumber = (await pdfDocument.getPageIndex(destRef)) + 1; if (pdfDocument !== this._pdfDocument) { return null; } this.linkService.cachePageRef(pageNumber, destRef); } catch (ex) {} } } else if (Number.isInteger(destRef)) { pageNumber = destRef + 1; } if (Number.isInteger(pageNumber) &amp;&amp; (!pageNumberToDestHash.has(pageNumber) || currentNesting &gt; pageNumberNesting.get(pageNumber))) { const destHash = this.linkService.getDestinationHash(dest); pageNumberToDestHash.set(pageNumber, destHash); pageNumberNesting.set(pageNumber, currentNesting); } } if (items.length &gt; 0) { queue.push({ nesting: currentNesting + 1, items }); } } } this._pageNumberToDestHashCapability.resolve(pageNumberToDestHash.size &gt; 0 ? pageNumberToDestHash : null); return this._pageNumberToDestHashCapability.promise; } } exports.PDFOutlineViewer = PDFOutlineViewer; /***/ }), /* 21 */ /***/ ((__unused_webpack_module, exports, __webpack_require__) =&gt; { Object.defineProperty(exports, &quot;__esModule&quot;, ({ value: true })); exports.PDFPresentationMode = void 0; var _ui_utils = __webpack_require__(1); var _pdfjsLib = __webpack_require__(5); const DELAY_BEFORE_HIDING_CONTROLS = 3000; const ACTIVE_SELECTOR = &quot;pdfPresentationMode&quot;; const CONTROLS_SELECTOR = &quot;pdfPresentationModeControls&quot;; const MOUSE_SCROLL_COOLDOWN_TIME = 50; const PAGE_SWITCH_THRESHOLD = 0.1; const SWIPE_MIN_DISTANCE_THRESHOLD = 50; const SWIPE_ANGLE_THRESHOLD = Math.PI / 6; class PDFPresentationMode { #state = _ui_utils.PresentationModeState.UNKNOWN; #args = null; constructor({ container, pdfViewer, eventBus }) { this.container = container; this.pdfViewer = pdfViewer; this.eventBus = eventBus; this.contextMenuOpen = false; this.mouseScrollTimeStamp = 0; this.mouseScrollDelta = 0; this.touchSwipeState = null; } async request() { const { container, pdfViewer } = this; if (this.active || !pdfViewer.pagesCount || !container.requestFullscreen) { return false; } this.#addFullscreenChangeListeners(); this.#notifyStateChange(_ui_utils.PresentationModeState.CHANGING); const promise = container.requestFullscreen(); this.#args = { pageNumber: pdfViewer.currentPageNumber, scaleValue: pdfViewer.currentScaleValue, scrollMode: pdfViewer.scrollMode, spreadMode: null, annotationEditorMode: null }; if (pdfViewer.spreadMode !== _ui_utils.SpreadMode.NONE &amp;&amp; !(pdfViewer.pageViewsReady &amp;&amp; pdfViewer.hasEqualPageSizes)) { console.warn(&quot;Ignoring Spread modes when entering PresentationMode, &quot; + &quot;since the document may contain varying page sizes.&quot;); this.#args.spreadMode = pdfViewer.spreadMode; } if (pdfViewer.annotationEditorMode !== _pdfjsLib.AnnotationEditorType.DISABLE) { this.#args.annotationEditorMode = pdfViewer.annotationEditorMode; } try { await promise; pdfViewer.focus(); return true; } catch (reason) { this.#removeFullscreenChangeListeners(); this.#notifyStateChange(_ui_utils.PresentationModeState.NORMAL); } return false; } get active() { return this.#state === _ui_utils.PresentationModeState.CHANGING || this.#state === _ui_utils.PresentationModeState.FULLSCREEN; } #mouseWheel(evt) { if (!this.active) { return; } evt.preventDefault(); const delta = (0, _ui_utils.normalizeWheelEventDelta)(evt); const currentTime = Date.now(); const storedTime = this.mouseScrollTimeStamp; if (currentTime &gt; storedTime &amp;&amp; currentTime - storedTime &lt; MOUSE_SCROLL_COOLDOWN_TIME) { return; } if (this.mouseScrollDelta &gt; 0 &amp;&amp; delta &lt; 0 || this.mouseScrollDelta &lt; 0 &amp;&amp; delta &gt; 0) { this.#resetMouseScrollState(); } this.mouseScrollDelta += delta; if (Math.abs(this.mouseScrollDelta) &gt;= PAGE_SWITCH_THRESHOLD) { const totalDelta = this.mouseScrollDelta; this.#resetMouseScrollState(); const success = totalDelta &gt; 0 ? this.pdfViewer.previousPage() : this.pdfViewer.nextPage(); if (success) { this.mouseScrollTimeStamp = currentTime; } } } #notifyStateChange(state) { this.#state = state; this.eventBus.dispatch(&quot;presentationmodechanged&quot;, { source: this, state }); } #enter() { this.#notifyStateChange(_ui_utils.PresentationModeState.FULLSCREEN); this.container.classList.add(ACTIVE_SELECTOR); setTimeout(() =&gt; { this.pdfViewer.scrollMode = _ui_utils.ScrollMode.PAGE; if (this.#args.spreadMode !== null) { this.pdfViewer.spreadMode = _ui_utils.SpreadMode.NONE; } this.pdfViewer.currentPageNumber = this.#args.pageNumber; this.pdfViewer.currentScaleValue = &quot;page-fit&quot;; if (this.#args.annotationEditorMode !== null) { this.pdfViewer.annotationEditorMode = _pdfjsLib.AnnotationEditorType.NONE; } }, 0); this.#addWindowListeners(); this.#showControls(); this.contextMenuOpen = false; window.getSelection().removeAllRanges(); } #exit() { const pageNumber = this.pdfViewer.currentPageNumber; this.container.classList.remove(ACTIVE_SELECTOR); setTimeout(() =&gt; { this.#removeFullscreenChangeListeners(); this.#notifyStateChange(_ui_utils.PresentationModeState.NORMAL); this.pdfViewer.scrollMode = this.#args.scrollMode; if (this.#args.spreadMode !== null) { this.pdfViewer.spreadMode = this.#args.spreadMode; } this.pdfViewer.currentScaleValue = this.#args.scaleValue; this.pdfViewer.currentPageNumber = pageNumber; if (this.#args.annotationEditorMode !== null) { this.pdfViewer.annotationEditorMode = this.#args.annotationEditorMode; } this.#args = null; }, 0); this.#removeWindowListeners(); this.#hideControls(); this.#resetMouseScrollState(); this.contextMenuOpen = false; } #mouseDown(evt) { if (this.contextMenuOpen) { this.contextMenuOpen = false; evt.preventDefault(); return; } if (evt.button === 0) { const isInternalLink = evt.target.href &amp;&amp; evt.target.classList.contains(&quot;internalLink&quot;); if (!isInternalLink) { evt.preventDefault(); if (evt.shiftKey) { this.pdfViewer.previousPage(); } else { this.pdfViewer.nextPage(); } } } } #contextMenu() { this.contextMenuOpen = true; } #showControls() { if (this.controlsTimeout) { clearTimeout(this.controlsTimeout); } else { this.container.classList.add(CONTROLS_SELECTOR); } this.controlsTimeout = setTimeout(() =&gt; { this.container.classList.remove(CONTROLS_SELECTOR); delete this.controlsTimeout; }, DELAY_BEFORE_HIDING_CONTROLS); } #hideControls() { if (!this.controlsTimeout) { return; } clearTimeout(this.controlsTimeout); this.container.classList.remove(CONTROLS_SELECTOR); delete this.controlsTimeout; } #resetMouseScrollState() { this.mouseScrollTimeStamp = 0; this.mouseScrollDelta = 0; } #touchSwipe(evt) { if (!this.active) { return; } if (evt.touches.length &gt; 1) { this.touchSwipeState = null; return; } switch (evt.type) { case &quot;touchstart&quot;: this.touchSwipeState = { startX: evt.touches[0].pageX, startY: evt.touches[0].pageY, endX: evt.touches[0].pageX, endY: evt.touches[0].pageY }; break; case &quot;touchmove&quot;: if (this.touchSwipeState === null) { return; } this.touchSwipeState.endX = evt.touches[0].pageX; this.touchSwipeState.endY = evt.touches[0].pageY; evt.preventDefault(); break; case &quot;touchend&quot;: if (this.touchSwipeState === null) { return; } let delta = 0; const dx = this.touchSwipeState.endX - this.touchSwipeState.startX; const dy = this.touchSwipeState.endY - this.touchSwipeState.startY; const absAngle = Math.abs(Math.atan2(dy, dx)); if (Math.abs(dx) &gt; SWIPE_MIN_DISTANCE_THRESHOLD &amp;&amp; (absAngle &lt;= SWIPE_ANGLE_THRESHOLD || absAngle &gt;= Math.PI - SWIPE_ANGLE_THRESHOLD)) { delta = dx; } else if (Math.abs(dy) &gt; SWIPE_MIN_DISTANCE_THRESHOLD &amp;&amp; Math.abs(absAngle - Math.PI / 2) &lt;= SWIPE_ANGLE_THRESHOLD) { delta = dy; } if (delta &gt; 0) { this.pdfViewer.previousPage(); } else if (delta &lt; 0) { this.pdfViewer.nextPage(); } break; } } #addWindowListeners() { this.showControlsBind = this.#showControls.bind(this); this.mouseDownBind = this.#mouseDown.bind(this); this.mouseWheelBind = this.#mouseWheel.bind(this); this.resetMouseScrollStateBind = this.#resetMouseScrollState.bind(this); this.contextMenuBind = this.#contextMenu.bind(this); this.touchSwipeBind = this.#touchSwipe.bind(this); window.addEventListener(&quot;mousemove&quot;, this.showControlsBind); window.addEventListener(&quot;mousedown&quot;, this.mouseDownBind); window.addEventListener(&quot;wheel&quot;, this.mouseWheelBind, { passive: false }); window.addEventListener(&quot;keydown&quot;, this.resetMouseScrollStateBind); window.addEventListener(&quot;contextmenu&quot;, this.contextMenuBind); window.addEventListener(&quot;touchstart&quot;, this.touchSwipeBind); window.addEventListener(&quot;touchmove&quot;, this.touchSwipeBind); window.addEventListener(&quot;touchend&quot;, this.touchSwipeBind); } #removeWindowListeners() { window.removeEventListener(&quot;mousemove&quot;, this.showControlsBind); window.removeEventListener(&quot;mousedown&quot;, this.mouseDownBind); window.removeEventListener(&quot;wheel&quot;, this.mouseWheelBind, { passive: false }); window.removeEventListener(&quot;keydown&quot;, this.resetMouseScrollStateBind); window.removeEventListener(&quot;contextmenu&quot;, this.contextMenuBind); window.removeEventListener(&quot;touchstart&quot;, this.touchSwipeBind); window.removeEventListener(&quot;touchmove&quot;, this.touchSwipeBind); window.removeEventListener(&quot;touchend&quot;, this.touchSwipeBind); delete this.showControlsBind; delete this.mouseDownBind; delete this.mouseWheelBind; delete this.resetMouseScrollStateBind; delete this.contextMenuBind; delete this.touchSwipeBind; } #fullscreenChange() { if (document.fullscreenElement) { this.#enter(); } else { this.#exit(); } } #addFullscreenChangeListeners() { this.fullscreenChangeBind = this.#fullscreenChange.bind(this); window.addEventListener(&quot;fullscreenchange&quot;, this.fullscreenChangeBind); } #removeFullscreenChangeListeners() { window.removeEventListener(&quot;fullscreenchange&quot;, this.fullscreenChangeBind); delete this.fullscreenChangeBind; } } exports.PDFPresentationMode = PDFPresentationMode; /***/ }), /* 22 */ /***/ ((__unused_webpack_module, exports, __webpack_require__) =&gt; { Object.defineProperty(exports, &quot;__esModule&quot;, ({ value: true })); exports.PDFRenderingQueue = void 0; var _pdfjsLib = __webpack_require__(5); var _ui_utils = __webpack_require__(1); const CLEANUP_TIMEOUT = 30000; class PDFRenderingQueue { constructor() { this.pdfViewer = null; this.pdfThumbnailViewer = null; this.onIdle = null; this.highestPriorityPage = null; this.idleTimeout = null; this.printing = false; this.isThumbnailViewEnabled = false; } setViewer(pdfViewer) { this.pdfViewer = pdfViewer; } setThumbnailViewer(pdfThumbnailViewer) { this.pdfThumbnailViewer = pdfThumbnailViewer; } isHighestPriority(view) { return this.highestPriorityPage === view.renderingId; } hasViewer() { return !!this.pdfViewer; } renderHighestPriority(currentlyVisiblePages) { if (this.idleTimeout) { clearTimeout(this.idleTimeout); this.idleTimeout = null; } if (this.pdfViewer.forceRendering(currentlyVisiblePages)) { return; } if (this.isThumbnailViewEnabled &amp;&amp; this.pdfThumbnailViewer?.forceRendering()) { return; } if (this.printing) { return; } if (this.onIdle) { this.idleTimeout = setTimeout(this.onIdle.bind(this), CLEANUP_TIMEOUT); } } getHighestPriority(visible, views, scrolledDown, preRenderExtra = false) { const visibleViews = visible.views, numVisible = visibleViews.length; if (numVisible === 0) { return null; } for (let i = 0; i &lt; numVisible; i++) { const view = visibleViews[i].view; if (!this.isViewFinished(view)) { return view; } } const firstId = visible.first.id, lastId = visible.last.id; if (lastId - firstId + 1 &gt; numVisible) { const visibleIds = visible.ids; for (let i = 1, ii = lastId - firstId; i &lt; ii; i++) { const holeId = scrolledDown ? firstId + i : lastId - i; if (visibleIds.has(holeId)) { continue; } const holeView = views[holeId - 1]; if (!this.isViewFinished(holeView)) { return holeView; } } } let preRenderIndex = scrolledDown ? lastId : firstId - 2; let preRenderView = views[preRenderIndex]; if (preRenderView &amp;&amp; !this.isViewFinished(preRenderView)) { return preRenderView; } if (preRenderExtra) { preRenderIndex += scrolledDown ? 1 : -1; preRenderView = views[preRenderIndex]; if (preRenderView &amp;&amp; !this.isViewFinished(preRenderView)) { return preRenderView; } } return null; } isViewFinished(view) { return view.renderingState === _ui_utils.RenderingStates.FINISHED; } renderView(view) { switch (view.renderingState) { case _ui_utils.RenderingStates.FINISHED: return false; case _ui_utils.RenderingStates.PAUSED: this.highestPriorityPage = view.renderingId; view.resume(); break; case _ui_utils.RenderingStates.RUNNING: this.highestPriorityPage = view.renderingId; break; case _ui_utils.RenderingStates.INITIAL: this.highestPriorityPage = view.renderingId; view.draw().finally(() =&gt; { this.renderHighestPriority(); }).catch(reason =&gt; { if (reason instanceof _pdfjsLib.RenderingCancelledException) { return; } console.error(`renderView: &quot;${reason}&quot;`); }); break; } return true; } } exports.PDFRenderingQueue = PDFRenderingQueue; /***/ }), /* 23 */ /***/ ((__unused_webpack_module, exports, __webpack_require__) =&gt; { Object.defineProperty(exports, &quot;__esModule&quot;, ({ value: true })); exports.PDFScriptingManager = void 0; var _ui_utils = __webpack_require__(1); var _pdfjsLib = __webpack_require__(5); class PDFScriptingManager { constructor({ eventBus, sandboxBundleSrc = null, scriptingFactory = null, docPropertiesLookup = null }) { this._pdfDocument = null; this._pdfViewer = null; this._closeCapability = null; this._destroyCapability = null; this._scripting = null; this._mouseState = Object.create(null); this._ready = false; this._eventBus = eventBus; this._sandboxBundleSrc = sandboxBundleSrc; this._scriptingFactory = scriptingFactory; this._docPropertiesLookup = docPropertiesLookup; } setViewer(pdfViewer) { this._pdfViewer = pdfViewer; } async setDocument(pdfDocument) { if (this._pdfDocument) { await this._destroyScripting(); } this._pdfDocument = pdfDocument; if (!pdfDocument) { return; } const [objects, calculationOrder, docActions] = await Promise.all([pdfDocument.getFieldObjects(), pdfDocument.getCalculationOrderIds(), pdfDocument.getJSActions()]); if (!objects &amp;&amp; !docActions) { await this._destroyScripting(); return; } if (pdfDocument !== this._pdfDocument) { return; } try { this._scripting = this._createScripting(); } catch (error) { console.error(`PDFScriptingManager.setDocument: &quot;${error?.message}&quot;.`); await this._destroyScripting(); return; } this._internalEvents.set(&quot;updatefromsandbox&quot;, event =&gt; { if (event?.source !== window) { return; } this._updateFromSandbox(event.detail); }); this._internalEvents.set(&quot;dispatcheventinsandbox&quot;, event =&gt; { this._scripting?.dispatchEventInSandbox(event.detail); }); this._internalEvents.set(&quot;pagechanging&quot;, ({ pageNumber, previous }) =&gt; { if (pageNumber === previous) { return; } this._dispatchPageClose(previous); this._dispatchPageOpen(pageNumber); }); this._internalEvents.set(&quot;pagerendered&quot;, ({ pageNumber }) =&gt; { if (!this._pageOpenPending.has(pageNumber)) { return; } if (pageNumber !== this._pdfViewer.currentPageNumber) { return; } this._dispatchPageOpen(pageNumber); }); this._internalEvents.set(&quot;pagesdestroy&quot;, async event =&gt; { await this._dispatchPageClose(this._pdfViewer.currentPageNumber); await this._scripting?.dispatchEventInSandbox({ id: &quot;doc&quot;, name: &quot;WillClose&quot; }); this._closeCapability?.resolve(); }); this._domEvents.set(&quot;mousedown&quot;, event =&gt; { this._mouseState.isDown = true; }); this._domEvents.set(&quot;mouseup&quot;, event =&gt; { this._mouseState.isDown = false; }); for (const [name, listener] of this._internalEvents) { this._eventBus._on(name, listener); } for (const [name, listener] of this._domEvents) { window.addEventListener(name, listener, true); } try { const docProperties = await this._getDocProperties(); if (pdfDocument !== this._pdfDocument) { return; } await this._scripting.createSandbox({ objects, calculationOrder, appInfo: { platform: navigator.platform, language: navigator.language }, docInfo: { ...docProperties, actions: docActions } }); this._eventBus.dispatch(&quot;sandboxcreated&quot;, { source: this }); } catch (error) { console.error(`PDFScriptingManager.setDocument: &quot;${error?.message}&quot;.`); await this._destroyScripting(); return; } await this._scripting?.dispatchEventInSandbox({ id: &quot;doc&quot;, name: &quot;Open&quot; }); await this._dispatchPageOpen(this._pdfViewer.currentPageNumber, true); Promise.resolve().then(() =&gt; { if (pdfDocument === this._pdfDocument) { this._ready = true; } }); } async dispatchWillSave(detail) { return this._scripting?.dispatchEventInSandbox({ id: &quot;doc&quot;, name: &quot;WillSave&quot; }); } async dispatchDidSave(detail) { return this._scripting?.dispatchEventInSandbox({ id: &quot;doc&quot;, name: &quot;DidSave&quot; }); } async dispatchWillPrint(detail) { return this._scripting?.dispatchEventInSandbox({ id: &quot;doc&quot;, name: &quot;WillPrint&quot; }); } async dispatchDidPrint(detail) { return this._scripting?.dispatchEventInSandbox({ id: &quot;doc&quot;, name: &quot;DidPrint&quot; }); } get mouseState() { return this._mouseState; } get destroyPromise() { return this._destroyCapability?.promise || null; } get ready() { return this._ready; } get _internalEvents() { return (0, _pdfjsLib.shadow)(this, &quot;_internalEvents&quot;, new Map()); } get _domEvents() { return (0, _pdfjsLib.shadow)(this, &quot;_domEvents&quot;, new Map()); } get _pageOpenPending() { return (0, _pdfjsLib.shadow)(this, &quot;_pageOpenPending&quot;, new Set()); } get _visitedPages() { return (0, _pdfjsLib.shadow)(this, &quot;_visitedPages&quot;, new Map()); } async _updateFromSandbox(detail) { const isInPresentationMode = this._pdfViewer.isInPresentationMode || this._pdfViewer.isChangingPresentationMode; const { id, siblings, command, value } = detail; if (!id) { switch (command) { case &quot;clear&quot;: console.clear(); break; case &quot;error&quot;: console.error(value); break; case &quot;layout&quot;: if (isInPresentationMode) { return; } const modes = (0, _ui_utils.apiPageLayoutToViewerModes)(value); this._pdfViewer.spreadMode = modes.spreadMode; break; case &quot;page-num&quot;: this._pdfViewer.currentPageNumber = value + 1; break; case &quot;print&quot;: await this._pdfViewer.pagesPromise; this._eventBus.dispatch(&quot;print&quot;, { source: this }); break; case &quot;println&quot;: console.log(value); break; case &quot;zoom&quot;: if (isInPresentationMode) { return; } this._pdfViewer.currentScaleValue = value; break; case &quot;SaveAs&quot;: this._eventBus.dispatch(&quot;download&quot;, { source: this }); break; case &quot;FirstPage&quot;: this._pdfViewer.currentPageNumber = 1; break; case &quot;LastPage&quot;: this._pdfViewer.currentPageNumber = this._pdfViewer.pagesCount; break; case &quot;NextPage&quot;: this._pdfViewer.nextPage(); break; case &quot;PrevPage&quot;: this._pdfViewer.previousPage(); break; case &quot;ZoomViewIn&quot;: if (isInPresentationMode) { return; } this._pdfViewer.increaseScale(); break; case &quot;ZoomViewOut&quot;: if (isInPresentationMode) { return; } this._pdfViewer.decreaseScale(); break; } return; } if (isInPresentationMode) { if (detail.focus) { return; } } delete detail.id; delete detail.siblings; const ids = siblings ? [id, ...siblings] : [id]; for (const elementId of ids) { const element = document.querySelector(`[data-element-id=&quot;${elementId}&quot;]`); if (element) { element.dispatchEvent(new CustomEvent(&quot;updatefromsandbox&quot;, { detail })); } else { this._pdfDocument?.annotationStorage.setValue(elementId, detail); } } } async _dispatchPageOpen(pageNumber, initialize = false) { const pdfDocument = this._pdfDocument, visitedPages = this._visitedPages; if (initialize) { this._closeCapability = (0, _pdfjsLib.createPromiseCapability)(); } if (!this._closeCapability) { return; } const pageView = this._pdfViewer.getPageView(pageNumber - 1); if (pageView?.renderingState !== _ui_utils.RenderingStates.FINISHED) { this._pageOpenPending.add(pageNumber); return; } this._pageOpenPending.delete(pageNumber); const actionsPromise = (async () =&gt; { const actions = await (!visitedPages.has(pageNumber) ? pageView.pdfPage?.getJSActions() : null); if (pdfDocument !== this._pdfDocument) { return; } await this._scripting?.dispatchEventInSandbox({ id: &quot;page&quot;, name: &quot;PageOpen&quot;, pageNumber, actions }); })(); visitedPages.set(pageNumber, actionsPromise); } async _dispatchPageClose(pageNumber) { const pdfDocument = this._pdfDocument, visitedPages = this._visitedPages; if (!this._closeCapability) { return; } if (this._pageOpenPending.has(pageNumber)) { return; } const actionsPromise = visitedPages.get(pageNumber); if (!actionsPromise) { return; } visitedPages.set(pageNumber, null); await actionsPromise; if (pdfDocument !== this._pdfDocument) { return; } await this._scripting?.dispatchEventInSandbox({ id: &quot;page&quot;, name: &quot;PageClose&quot;, pageNumber }); } async _getDocProperties() { if (this._docPropertiesLookup) { return this._docPropertiesLookup(this._pdfDocument); } throw new Error(&quot;_getDocProperties: Unable to lookup properties.&quot;); } _createScripting() { this._destroyCapability = (0, _pdfjsLib.createPromiseCapability)(); if (this._scripting) { throw new Error(&quot;_createScripting: Scripting already exists.&quot;); } if (this._scriptingFactory) { return this._scriptingFactory.createScripting({ sandboxBundleSrc: this._sandboxBundleSrc }); } throw new Error(&quot;_createScripting: Cannot create scripting.&quot;); } async _destroyScripting() { if (!this._scripting) { this._pdfDocument = null; this._destroyCapability?.resolve(); return; } if (this._closeCapability) { await Promise.race([this._closeCapability.promise, new Promise(resolve =&gt; { setTimeout(resolve, 1000); })]).catch(reason =&gt; {}); this._closeCapability = null; } this._pdfDocument = null; try { await this._scripting.destroySandbox(); } catch (ex) {} for (const [name, listener] of this._internalEvents) { this._eventBus._off(name, listener); } this._internalEvents.clear(); for (const [name, listener] of this._domEvents) { window.removeEventListener(name, listener, true); } this._domEvents.clear(); this._pageOpenPending.clear(); this._visitedPages.clear(); this._scripting = null; delete this._mouseState.isDown; this._ready = false; this._destroyCapability?.resolve(); } } exports.PDFScriptingManager = PDFScriptingManager; /***/ }), /* 24 */ /***/ ((__unused_webpack_module, exports, __webpack_require__) =&gt; { Object.defineProperty(exports, &quot;__esModule&quot;, ({ value: true })); exports.PDFSidebar = void 0; var _ui_utils = __webpack_require__(1); const UI_NOTIFICATION_CLASS = &quot;pdfSidebarNotification&quot;; class PDFSidebar { constructor({ elements, pdfViewer, pdfThumbnailViewer, eventBus, l10n }) { this.isOpen = false; this.active = _ui_utils.SidebarView.THUMBS; this.isInitialViewSet = false; this.isInitialEventDispatched = false; this.onToggled = null; this.pdfViewer = pdfViewer; this.pdfThumbnailViewer = pdfThumbnailViewer; this.outerContainer = elements.outerContainer; this.sidebarContainer = elements.sidebarContainer; this.toggleButton = elements.toggleButton; this.thumbnailButton = elements.thumbnailButton; this.outlineButton = elements.outlineButton; this.attachmentsButton = elements.attachmentsButton; this.layersButton = elements.layersButton; this.thumbnailView = elements.thumbnailView; this.outlineView = elements.outlineView; this.attachmentsView = elements.attachmentsView; this.layersView = elements.layersView; this._outlineOptionsContainer = elements.outlineOptionsContainer; this._currentOutlineItemButton = elements.currentOutlineItemButton; this.eventBus = eventBus; this.l10n = l10n; this.#addEventListeners(); } reset() { this.isInitialViewSet = false; this.isInitialEventDispatched = false; this.#hideUINotification(true); this.switchView(_ui_utils.SidebarView.THUMBS); this.outlineButton.disabled = false; this.attachmentsButton.disabled = false; this.layersButton.disabled = false; this._currentOutlineItemButton.disabled = true; } get visibleView() { return this.isOpen ? this.active : _ui_utils.SidebarView.NONE; } setInitialView(view = _ui_utils.SidebarView.NONE) { if (this.isInitialViewSet) { return; } this.isInitialViewSet = true; if (view === _ui_utils.SidebarView.NONE || view === _ui_utils.SidebarView.UNKNOWN) { this.#dispatchEvent(); return; } this.switchView(view, true); if (!this.isInitialEventDispatched) { this.#dispatchEvent(); } } switchView(view, forceOpen = false) { const isViewChanged = view !== this.active; let shouldForceRendering = false; switch (view) { case _ui_utils.SidebarView.NONE: if (this.isOpen) { this.close(); } return; case _ui_utils.SidebarView.THUMBS: if (this.isOpen &amp;&amp; isViewChanged) { shouldForceRendering = true; } break; case _ui_utils.SidebarView.OUTLINE: if (this.outlineButton.disabled) { return; } break; case _ui_utils.SidebarView.ATTACHMENTS: if (this.attachmentsButton.disabled) { return; } break; case _ui_utils.SidebarView.LAYERS: if (this.layersButton.disabled) { return; } break; default: console.error(`PDFSidebar.switchView: &quot;${view}&quot; is not a valid view.`); return; } this.active = view; const isThumbs = view === _ui_utils.SidebarView.THUMBS, isOutline = view === _ui_utils.SidebarView.OUTLINE, isAttachments = view === _ui_utils.SidebarView.ATTACHMENTS, isLayers = view === _ui_utils.SidebarView.LAYERS; this.thumbnailButton.classList.toggle(&quot;toggled&quot;, isThumbs); this.outlineButton.classList.toggle(&quot;toggled&quot;, isOutline); this.attachmentsButton.classList.toggle(&quot;toggled&quot;, isAttachments); this.layersButton.classList.toggle(&quot;toggled&quot;, isLayers); this.thumbnailButton.setAttribute(&quot;aria-checked&quot;, isThumbs); this.outlineButton.setAttribute(&quot;aria-checked&quot;, isOutline); this.attachmentsButton.setAttribute(&quot;aria-checked&quot;, isAttachments); this.layersButton.setAttribute(&quot;aria-checked&quot;, isLayers); this.thumbnailView.classList.toggle(&quot;hidden&quot;, !isThumbs); this.outlineView.classList.toggle(&quot;hidden&quot;, !isOutline); this.attachmentsView.classList.toggle(&quot;hidden&quot;, !isAttachments); this.layersView.classList.toggle(&quot;hidden&quot;, !isLayers); this._outlineOptionsContainer.classList.toggle(&quot;hidden&quot;, !isOutline); if (forceOpen &amp;&amp; !this.isOpen) { this.open(); return; } if (shouldForceRendering) { this.#updateThumbnailViewer(); this.#forceRendering(); } if (isViewChanged) { this.#dispatchEvent(); } } open() { if (this.isOpen) { return; } this.isOpen = true; this.toggleButton.classList.add(&quot;toggled&quot;); this.toggleButton.setAttribute(&quot;aria-expanded&quot;, &quot;true&quot;); this.outerContainer.classList.add(&quot;sidebarMoving&quot;, &quot;sidebarOpen&quot;); if (this.active === _ui_utils.SidebarView.THUMBS) { this.#updateThumbnailViewer(); } this.#forceRendering(); this.#dispatchEvent(); this.#hideUINotification(); } close() { if (!this.isOpen) { return; } this.isOpen = false; this.toggleButton.classList.remove(&quot;toggled&quot;); this.toggleButton.setAttribute(&quot;aria-expanded&quot;, &quot;false&quot;); this.outerContainer.classList.add(&quot;sidebarMoving&quot;); this.outerContainer.classList.remove(&quot;sidebarOpen&quot;); this.#forceRendering(); this.#dispatchEvent(); } toggle() { if (this.isOpen) { this.close(); } else { this.open(); } } #dispatchEvent() { if (this.isInitialViewSet &amp;&amp; !this.isInitialEventDispatched) { this.isInitialEventDispatched = true; } this.eventBus.dispatch(&quot;sidebarviewchanged&quot;, { source: this, view: this.visibleView }); } #forceRendering() { if (this.onToggled) { this.onToggled(); } else { this.pdfViewer.forceRendering(); this.pdfThumbnailViewer.forceRendering(); } } #updateThumbnailViewer() { const { pdfViewer, pdfThumbnailViewer } = this; const pagesCount = pdfViewer.pagesCount; for (let pageIndex = 0; pageIndex &lt; pagesCount; pageIndex++) { const pageView = pdfViewer.getPageView(pageIndex); if (pageView?.renderingState === _ui_utils.RenderingStates.FINISHED) { const thumbnailView = pdfThumbnailViewer.getThumbnail(pageIndex); thumbnailView.setImage(pageView); } } pdfThumbnailViewer.scrollThumbnailIntoView(pdfViewer.currentPageNumber); } #showUINotification() { this.toggleButton.setAttribute(&quot;data-l10n-id&quot;, &quot;toggle_sidebar_notification2&quot;); this.l10n.translate(this.toggleButton); if (!this.isOpen) { this.toggleButton.classList.add(UI_NOTIFICATION_CLASS); } } #hideUINotification(reset = false) { if (this.isOpen || reset) { this.toggleButton.classList.remove(UI_NOTIFICATION_CLASS); } if (reset) { this.toggleButton.setAttribute(&quot;data-l10n-id&quot;, &quot;toggle_sidebar&quot;); this.l10n.translate(this.toggleButton); } } #addEventListeners() { this.sidebarContainer.addEventListener(&quot;transitionend&quot;, evt =&gt; { if (evt.target === this.sidebarContainer) { this.outerContainer.classList.remove(&quot;sidebarMoving&quot;); } }); this.toggleButton.addEventListener(&quot;click&quot;, () =&gt; { this.toggle(); }); this.thumbnailButton.addEventListener(&quot;click&quot;, () =&gt; { this.switchView(_ui_utils.SidebarView.THUMBS); }); this.outlineButton.addEventListener(&quot;click&quot;, () =&gt; { this.switchView(_ui_utils.SidebarView.OUTLINE); }); this.outlineButton.addEventListener(&quot;dblclick&quot;, () =&gt; { this.eventBus.dispatch(&quot;toggleoutlinetree&quot;, { source: this }); }); this.attachmentsButton.addEventListener(&quot;click&quot;, () =&gt; { this.switchView(_ui_utils.SidebarView.ATTACHMENTS); }); this.layersButton.addEventListener(&quot;click&quot;, () =&gt; { this.switchView(_ui_utils.SidebarView.LAYERS); }); this.layersButton.addEventListener(&quot;dblclick&quot;, () =&gt; { this.eventBus.dispatch(&quot;resetlayers&quot;, { source: this }); }); this._currentOutlineItemButton.addEventListener(&quot;click&quot;, () =&gt; { this.eventBus.dispatch(&quot;currentoutlineitem&quot;, { source: this }); }); const onTreeLoaded = (count, button, view) =&gt; { button.disabled = !count; if (count) { this.#showUINotification(); } else if (this.active === view) { this.switchView(_ui_utils.SidebarView.THUMBS); } }; this.eventBus._on(&quot;outlineloaded&quot;, evt =&gt; { onTreeLoaded(evt.outlineCount, this.outlineButton, _ui_utils.SidebarView.OUTLINE); evt.currentOutlineItemPromise.then(enabled =&gt; { if (!this.isInitialViewSet) { return; } this._currentOutlineItemButton.disabled = !enabled; }); }); this.eventBus._on(&quot;attachmentsloaded&quot;, evt =&gt; { onTreeLoaded(evt.attachmentsCount, this.attachmentsButton, _ui_utils.SidebarView.ATTACHMENTS); }); this.eventBus._on(&quot;layersloaded&quot;, evt =&gt; { onTreeLoaded(evt.layersCount, this.layersButton, _ui_utils.SidebarView.LAYERS); }); this.eventBus._on(&quot;presentationmodechanged&quot;, evt =&gt; { if (evt.state === _ui_utils.PresentationModeState.NORMAL &amp;&amp; this.visibleView === _ui_utils.SidebarView.THUMBS) { this.#updateThumbnailViewer(); } }); } } exports.PDFSidebar = PDFSidebar; /***/ }), /* 25 */ /***/ ((__unused_webpack_module, exports, __webpack_require__) =&gt; { Object.defineProperty(exports, &quot;__esModule&quot;, ({ value: true })); exports.PDFSidebarResizer = void 0; var _ui_utils = __webpack_require__(1); const SIDEBAR_WIDTH_VAR = &quot;--sidebar-width&quot;; const SIDEBAR_MIN_WIDTH = 200; const SIDEBAR_RESIZING_CLASS = &quot;sidebarResizing&quot;; class PDFSidebarResizer { constructor(options, eventBus, l10n) { this.isRTL = false; this.sidebarOpen = false; this._width = null; this._outerContainerWidth = null; this._boundEvents = Object.create(null); this.outerContainer = options.outerContainer; this.resizer = options.resizer; this.eventBus = eventBus; l10n.getDirection().then(dir =&gt; { this.isRTL = dir === &quot;rtl&quot;; }); this._addEventListeners(); } get outerContainerWidth() { return this._outerContainerWidth ||= this.outerContainer.clientWidth; } _updateWidth(width = 0) { const maxWidth = Math.floor(this.outerContainerWidth / 2); if (width &gt; maxWidth) { width = maxWidth; } if (width &lt; SIDEBAR_MIN_WIDTH) { width = SIDEBAR_MIN_WIDTH; } if (width === this._width) { return false; } this._width = width; _ui_utils.docStyle.setProperty(SIDEBAR_WIDTH_VAR, `${width}px`); return true; } _mouseMove(evt) { let width = evt.clientX; if (this.isRTL) { width = this.outerContainerWidth - width; } this._updateWidth(width); } _mouseUp(evt) { this.outerContainer.classList.remove(SIDEBAR_RESIZING_CLASS); this.eventBus.dispatch(&quot;resize&quot;, { source: this }); const _boundEvents = this._boundEvents; window.removeEventListener(&quot;mousemove&quot;, _boundEvents.mouseMove); window.removeEventListener(&quot;mouseup&quot;, _boundEvents.mouseUp); } _addEventListeners() { const _boundEvents = this._boundEvents; _boundEvents.mouseMove = this._mouseMove.bind(this); _boundEvents.mouseUp = this._mouseUp.bind(this); this.resizer.addEventListener(&quot;mousedown&quot;, evt =&gt; { if (evt.button !== 0) { return; } this.outerContainer.classList.add(SIDEBAR_RESIZING_CLASS); window.addEventListener(&quot;mousemove&quot;, _boundEvents.mouseMove); window.addEventListener(&quot;mouseup&quot;, _boundEvents.mouseUp); }); this.eventBus._on(&quot;sidebarviewchanged&quot;, evt =&gt; { this.sidebarOpen = !!evt?.view; }); this.eventBus._on(&quot;resize&quot;, evt =&gt; { if (evt?.source !== window) { return; } this._outerContainerWidth = null; if (!this._width) { return; } if (!this.sidebarOpen) { this._updateWidth(this._width); return; } this.outerContainer.classList.add(SIDEBAR_RESIZING_CLASS); const updated = this._updateWidth(this._width); Promise.resolve().then(() =&gt; { this.outerContainer.classList.remove(SIDEBAR_RESIZING_CLASS); if (updated) { this.eventBus.dispatch(&quot;resize&quot;, { source: this }); } }); }); } } exports.PDFSidebarResizer = PDFSidebarResizer; /***/ }), /* 26 */ /***/ ((__unused_webpack_module, exports, __webpack_require__) =&gt; { Object.defineProperty(exports, &quot;__esModule&quot;, ({ value: true })); exports.PDFThumbnailViewer = void 0; var _ui_utils = __webpack_require__(1); var _pdf_thumbnail_view = __webpack_require__(27); const THUMBNAIL_SCROLL_MARGIN = -19; const THUMBNAIL_SELECTED_CLASS = &quot;selected&quot;; class PDFThumbnailViewer { constructor({ container, eventBus, linkService, renderingQueue, l10n, pageColors }) { this.container = container; this.linkService = linkService; this.renderingQueue = renderingQueue; this.l10n = l10n; this.pageColors = pageColors || null; if (this.pageColors &amp;&amp; !(CSS.supports(&quot;color&quot;, this.pageColors.background) &amp;&amp; CSS.supports(&quot;color&quot;, this.pageColors.foreground))) { if (this.pageColors.background || this.pageColors.foreground) { console.warn(&quot;PDFThumbnailViewer: Ignoring `pageColors`-option, since the browser doesn&apos;t support the values used.&quot;); } this.pageColors = null; } this.scroll = (0, _ui_utils.watchScroll)(this.container, this._scrollUpdated.bind(this)); this._resetView(); } _scrollUpdated() { this.renderingQueue.renderHighestPriority(); } getThumbnail(index) { return this._thumbnails[index]; } _getVisibleThumbs() { return (0, _ui_utils.getVisibleElements)({ scrollEl: this.container, views: this._thumbnails }); } scrollThumbnailIntoView(pageNumber) { if (!this.pdfDocument) { return; } const thumbnailView = this._thumbnails[pageNumber - 1]; if (!thumbnailView) { console.error(&apos;scrollThumbnailIntoView: Invalid &quot;pageNumber&quot; parameter.&apos;); return; } if (pageNumber !== this._currentPageNumber) { const prevThumbnailView = this._thumbnails[this._currentPageNumber - 1]; prevThumbnailView.div.classList.remove(THUMBNAIL_SELECTED_CLASS); thumbnailView.div.classList.add(THUMBNAIL_SELECTED_CLASS); } const { first, last, views } = this._getVisibleThumbs(); if (views.length &gt; 0) { let shouldScroll = false; if (pageNumber &lt;= first.id || pageNumber &gt;= last.id) { shouldScroll = true; } else { for (const { id, percent } of views) { if (id !== pageNumber) { continue; } shouldScroll = percent &lt; 100; break; } } if (shouldScroll) { (0, _ui_utils.scrollIntoView)(thumbnailView.div, { top: THUMBNAIL_SCROLL_MARGIN }); } } this._currentPageNumber = pageNumber; } get pagesRotation() { return this._pagesRotation; } set pagesRotation(rotation) { if (!(0, _ui_utils.isValidRotation)(rotation)) { throw new Error(&quot;Invalid thumbnails rotation angle.&quot;); } if (!this.pdfDocument) { return; } if (this._pagesRotation === rotation) { return; } this._pagesRotation = rotation; const updateArgs = { rotation }; for (const thumbnail of this._thumbnails) { thumbnail.update(updateArgs); } } cleanup() { for (const thumbnail of this._thumbnails) { if (thumbnail.renderingState !== _ui_utils.RenderingStates.FINISHED) { thumbnail.reset(); } } _pdf_thumbnail_view.TempImageFactory.destroyCanvas(); } _resetView() { this._thumbnails = []; this._currentPageNumber = 1; this._pageLabels = null; this._pagesRotation = 0; this.container.textContent = &quot;&quot;; } setDocument(pdfDocument) { if (this.pdfDocument) { this._cancelRendering(); this._resetView(); } this.pdfDocument = pdfDocument; if (!pdfDocument) { return; } const firstPagePromise = pdfDocument.getPage(1); const optionalContentConfigPromise = pdfDocument.getOptionalContentConfig(); firstPagePromise.then(firstPdfPage =&gt; { const pagesCount = pdfDocument.numPages; const viewport = firstPdfPage.getViewport({ scale: 1 }); for (let pageNum = 1; pageNum &lt;= pagesCount; ++pageNum) { const thumbnail = new _pdf_thumbnail_view.PDFThumbnailView({ container: this.container, id: pageNum, defaultViewport: viewport.clone(), optionalContentConfigPromise, linkService: this.linkService, renderingQueue: this.renderingQueue, l10n: this.l10n, pageColors: this.pageColors }); this._thumbnails.push(thumbnail); } this._thumbnails[0]?.setPdfPage(firstPdfPage); const thumbnailView = this._thumbnails[this._currentPageNumber - 1]; thumbnailView.div.classList.add(THUMBNAIL_SELECTED_CLASS); }).catch(reason =&gt; { console.error(&quot;Unable to initialize thumbnail viewer&quot;, reason); }); } _cancelRendering() { for (const thumbnail of this._thumbnails) { thumbnail.cancelRendering(); } } setPageLabels(labels) { if (!this.pdfDocument) { return; } if (!labels) { this._pageLabels = null; } else if (!(Array.isArray(labels) &amp;&amp; this.pdfDocument.numPages === labels.length)) { this._pageLabels = null; console.error(&quot;PDFThumbnailViewer_setPageLabels: Invalid page labels.&quot;); } else { this._pageLabels = labels; } for (let i = 0, ii = this._thumbnails.length; i &lt; ii; i++) { this._thumbnails[i].setPageLabel(this._pageLabels?.[i] ?? null); } } async #ensurePdfPageLoaded(thumbView) { if (thumbView.pdfPage) { return thumbView.pdfPage; } try { const pdfPage = await this.pdfDocument.getPage(thumbView.id); if (!thumbView.pdfPage) { thumbView.setPdfPage(pdfPage); } return pdfPage; } catch (reason) { console.error(&quot;Unable to get page for thumb view&quot;, reason); return null; } } #getScrollAhead(visible) { if (visible.first?.id === 1) { return true; } else if (visible.last?.id === this._thumbnails.length) { return false; } return this.scroll.down; } forceRendering() { const visibleThumbs = this._getVisibleThumbs(); const scrollAhead = this.#getScrollAhead(visibleThumbs); const thumbView = this.renderingQueue.getHighestPriority(visibleThumbs, this._thumbnails, scrollAhead); if (thumbView) { this.#ensurePdfPageLoaded(thumbView).then(() =&gt; { this.renderingQueue.renderView(thumbView); }); return true; } return false; } } exports.PDFThumbnailViewer = PDFThumbnailViewer; /***/ }), /* 27 */ /***/ ((__unused_webpack_module, exports, __webpack_require__) =&gt; { Object.defineProperty(exports, &quot;__esModule&quot;, ({ value: true })); exports.TempImageFactory = exports.PDFThumbnailView = void 0; var _ui_utils = __webpack_require__(1); var _pdfjsLib = __webpack_require__(5); const DRAW_UPSCALE_FACTOR = 2; const MAX_NUM_SCALING_STEPS = 3; const THUMBNAIL_CANVAS_BORDER_WIDTH = 1; const THUMBNAIL_WIDTH = 98; class TempImageFactory { static #tempCanvas = null; static getCanvas(width, height) { const tempCanvas = this.#tempCanvas ||= document.createElement(&quot;canvas&quot;); tempCanvas.width = width; tempCanvas.height = height; const ctx = tempCanvas.getContext(&quot;2d&quot;, { alpha: false }); ctx.save(); ctx.fillStyle = &quot;rgb(255, 255, 255)&quot;; ctx.fillRect(0, 0, width, height); ctx.restore(); return [tempCanvas, tempCanvas.getContext(&quot;2d&quot;)]; } static destroyCanvas() { const tempCanvas = this.#tempCanvas; if (tempCanvas) { tempCanvas.width = 0; tempCanvas.height = 0; } this.#tempCanvas = null; } } exports.TempImageFactory = TempImageFactory; class PDFThumbnailView { constructor({ container, id, defaultViewport, optionalContentConfigPromise, linkService, renderingQueue, l10n, pageColors }) { this.id = id; this.renderingId = &quot;thumbnail&quot; + id; this.pageLabel = null; this.pdfPage = null; this.rotation = 0; this.viewport = defaultViewport; this.pdfPageRotate = defaultViewport.rotation; this._optionalContentConfigPromise = optionalContentConfigPromise || null; this.pageColors = pageColors || null; this.linkService = linkService; this.renderingQueue = renderingQueue; this.renderTask = null; this.renderingState = _ui_utils.RenderingStates.INITIAL; this.resume = null; const pageWidth = this.viewport.width, pageHeight = this.viewport.height, pageRatio = pageWidth / pageHeight; this.canvasWidth = THUMBNAIL_WIDTH; this.canvasHeight = this.canvasWidth / pageRatio | 0; this.scale = this.canvasWidth / pageWidth; this.l10n = l10n; const anchor = document.createElement(&quot;a&quot;); anchor.href = linkService.getAnchorUrl(&quot;#page=&quot; + id); this._thumbPageTitle.then(msg =&gt; { anchor.title = msg; }); anchor.onclick = function () { linkService.goToPage(id); return false; }; this.anchor = anchor; const div = document.createElement(&quot;div&quot;); div.className = &quot;thumbnail&quot;; div.setAttribute(&quot;data-page-number&quot;, this.id); this.div = div; const ring = document.createElement(&quot;div&quot;); ring.className = &quot;thumbnailSelectionRing&quot;; const borderAdjustment = 2 * THUMBNAIL_CANVAS_BORDER_WIDTH; ring.style.width = this.canvasWidth + borderAdjustment + &quot;px&quot;; ring.style.height = this.canvasHeight + borderAdjustment + &quot;px&quot;; this.ring = ring; div.append(ring); anchor.append(div); container.append(anchor); } setPdfPage(pdfPage) { this.pdfPage = pdfPage; this.pdfPageRotate = pdfPage.rotate; const totalRotation = (this.rotation + this.pdfPageRotate) % 360; this.viewport = pdfPage.getViewport({ scale: 1, rotation: totalRotation }); this.reset(); } reset() { this.cancelRendering(); this.renderingState = _ui_utils.RenderingStates.INITIAL; const pageWidth = this.viewport.width, pageHeight = this.viewport.height, pageRatio = pageWidth / pageHeight; this.canvasHeight = this.canvasWidth / pageRatio | 0; this.scale = this.canvasWidth / pageWidth; this.div.removeAttribute(&quot;data-loaded&quot;); const ring = this.ring; ring.textContent = &quot;&quot;; const borderAdjustment = 2 * THUMBNAIL_CANVAS_BORDER_WIDTH; ring.style.width = this.canvasWidth + borderAdjustment + &quot;px&quot;; ring.style.height = this.canvasHeight + borderAdjustment + &quot;px&quot;; if (this.canvas) { this.canvas.width = 0; this.canvas.height = 0; delete this.canvas; } if (this.image) { this.image.removeAttribute(&quot;src&quot;); delete this.image; } } update({ rotation = null }) { if (typeof rotation === &quot;number&quot;) { this.rotation = rotation; } const totalRotation = (this.rotation + this.pdfPageRotate) % 360; this.viewport = this.viewport.clone({ scale: 1, rotation: totalRotation }); this.reset(); } cancelRendering() { if (this.renderTask) { this.renderTask.cancel(); this.renderTask = null; } this.resume = null; } _getPageDrawContext(upscaleFactor = 1) { const canvas = document.createElement(&quot;canvas&quot;); const ctx = canvas.getContext(&quot;2d&quot;, { alpha: false }); const outputScale = new _ui_utils.OutputScale(); canvas.width = upscaleFactor * this.canvasWidth * outputScale.sx | 0; canvas.height = upscaleFactor * this.canvasHeight * outputScale.sy | 0; const transform = outputScale.scaled ? [outputScale.sx, 0, 0, outputScale.sy, 0, 0] : null; return { ctx, canvas, transform }; } _convertCanvasToImage(canvas) { if (this.renderingState !== _ui_utils.RenderingStates.FINISHED) { throw new Error(&quot;_convertCanvasToImage: Rendering has not finished.&quot;); } const reducedCanvas = this._reduceImage(canvas); const image = document.createElement(&quot;img&quot;); image.className = &quot;thumbnailImage&quot;; this._thumbPageCanvas.then(msg =&gt; { image.setAttribute(&quot;aria-label&quot;, msg); }); image.style.width = this.canvasWidth + &quot;px&quot;; image.style.height = this.canvasHeight + &quot;px&quot;; image.src = reducedCanvas.toDataURL(); this.image = image; this.div.setAttribute(&quot;data-loaded&quot;, true); this.ring.append(image); reducedCanvas.width = 0; reducedCanvas.height = 0; } draw() { if (this.renderingState !== _ui_utils.RenderingStates.INITIAL) { console.error(&quot;Must be in new state before drawing&quot;); return Promise.resolve(); } const { pdfPage } = this; if (!pdfPage) { this.renderingState = _ui_utils.RenderingStates.FINISHED; return Promise.reject(new Error(&quot;pdfPage is not loaded&quot;)); } this.renderingState = _ui_utils.RenderingStates.RUNNING; const finishRenderTask = async (error = null) =&gt; { if (renderTask === this.renderTask) { this.renderTask = null; } if (error instanceof _pdfjsLib.RenderingCancelledException) { return; } this.renderingState = _ui_utils.RenderingStates.FINISHED; this._convertCanvasToImage(canvas); if (error) { throw error; } }; const { ctx, canvas, transform } = this._getPageDrawContext(DRAW_UPSCALE_FACTOR); const drawViewport = this.viewport.clone({ scale: DRAW_UPSCALE_FACTOR * this.scale }); const renderContinueCallback = cont =&gt; { if (!this.renderingQueue.isHighestPriority(this)) { this.renderingState = _ui_utils.RenderingStates.PAUSED; this.resume = () =&gt; { this.renderingState = _ui_utils.RenderingStates.RUNNING; cont(); }; return; } cont(); }; const renderContext = { canvasContext: ctx, transform, viewport: drawViewport, optionalContentConfigPromise: this._optionalContentConfigPromise, pageColors: this.pageColors }; const renderTask = this.renderTask = pdfPage.render(renderContext); renderTask.onContinue = renderContinueCallback; const resultPromise = renderTask.promise.then(function () { return finishRenderTask(null); }, function (error) { return finishRenderTask(error); }); resultPromise.finally(() =&gt; { canvas.width = 0; canvas.height = 0; const pageCached = this.linkService.isPageCached(this.id); if (!pageCached) { this.pdfPage?.cleanup(); } }); return resultPromise; } setImage(pageView) { if (this.renderingState !== _ui_utils.RenderingStates.INITIAL) { return; } const { thumbnailCanvas: canvas, pdfPage, scale } = pageView; if (!canvas) { return; } if (!this.pdfPage) { this.setPdfPage(pdfPage); } if (scale &lt; this.scale) { return; } this.renderingState = _ui_utils.RenderingStates.FINISHED; this._convertCanvasToImage(canvas); } _reduceImage(img) { const { ctx, canvas } = this._getPageDrawContext(); if (img.width &lt;= 2 * canvas.width) { ctx.drawImage(img, 0, 0, img.width, img.height, 0, 0, canvas.width, canvas.height); return canvas; } let reducedWidth = canvas.width &lt;&lt; MAX_NUM_SCALING_STEPS; let reducedHeight = canvas.height &lt;&lt; MAX_NUM_SCALING_STEPS; const [reducedImage, reducedImageCtx] = TempImageFactory.getCanvas(reducedWidth, reducedHeight); while (reducedWidth &gt; img.width || reducedHeight &gt; img.height) { reducedWidth &gt;&gt;= 1; reducedHeight &gt;&gt;= 1; } reducedImageCtx.drawImage(img, 0, 0, img.width, img.height, 0, 0, reducedWidth, reducedHeight); while (reducedWidth &gt; 2 * canvas.width) { reducedImageCtx.drawImage(reducedImage, 0, 0, reducedWidth, reducedHeight, 0, 0, reducedWidth &gt;&gt; 1, reducedHeight &gt;&gt; 1); reducedWidth &gt;&gt;= 1; reducedHeight &gt;&gt;= 1; } ctx.drawImage(reducedImage, 0, 0, reducedWidth, reducedHeight, 0, 0, canvas.width, canvas.height); return canvas; } get _thumbPageTitle() { return this.l10n.get(&quot;thumb_page_title&quot;, { page: this.pageLabel ?? this.id }); } get _thumbPageCanvas() { return this.l10n.get(&quot;thumb_page_canvas&quot;, { page: this.pageLabel ?? this.id }); } setPageLabel(label) { this.pageLabel = typeof label === &quot;string&quot; ? label : null; this._thumbPageTitle.then(msg =&gt; { this.anchor.title = msg; }); if (this.renderingState !== _ui_utils.RenderingStates.FINISHED) { return; } this._thumbPageCanvas.then(msg =&gt; { this.image?.setAttribute(&quot;aria-label&quot;, msg); }); } } exports.PDFThumbnailView = PDFThumbnailView; /***/ }), /* 28 */ /***/ ((__unused_webpack_module, exports, __webpack_require__) =&gt; { Object.defineProperty(exports, &quot;__esModule&quot;, ({ value: true })); exports.PagesCountLimit = exports.PDFViewer = exports.PDFPageViewBuffer = void 0; var _pdfjsLib = __webpack_require__(5); var _ui_utils = __webpack_require__(1); var _annotation_editor_layer_builder = __webpack_require__(29); var _annotation_layer_builder = __webpack_require__(31); var _l10n_utils = __webpack_require__(30); var _pdf_page_view = __webpack_require__(32); var _pdf_rendering_queue = __webpack_require__(22); var _pdf_link_service = __webpack_require__(3); var _struct_tree_layer_builder = __webpack_require__(34); var _text_highlighter = __webpack_require__(35); var _text_layer_builder = __webpack_require__(36); var _xfa_layer_builder = __webpack_require__(37); const DEFAULT_CACHE_SIZE = 10; const ENABLE_PERMISSIONS_CLASS = &quot;enablePermissions&quot;; const PagesCountLimit = { FORCE_SCROLL_MODE_PAGE: 15000, FORCE_LAZY_PAGE_INIT: 7500, PAUSE_EAGER_PAGE_INIT: 250 }; exports.PagesCountLimit = PagesCountLimit; function isValidAnnotationEditorMode(mode) { return Object.values(_pdfjsLib.AnnotationEditorType).includes(mode) &amp;&amp; mode !== _pdfjsLib.AnnotationEditorType.DISABLE; } class PDFPageViewBuffer { #buf = new Set(); #size = 0; constructor(size) { this.#size = size; } push(view) { const buf = this.#buf; if (buf.has(view)) { buf.delete(view); } buf.add(view); if (buf.size &gt; this.#size) { this.#destroyFirstView(); } } resize(newSize, idsToKeep = null) { this.#size = newSize; const buf = this.#buf; if (idsToKeep) { const ii = buf.size; let i = 1; for (const view of buf) { if (idsToKeep.has(view.id)) { buf.delete(view); buf.add(view); } if (++i &gt; ii) { break; } } } while (buf.size &gt; this.#size) { this.#destroyFirstView(); } } has(view) { return this.#buf.has(view); } [Symbol.iterator]() { return this.#buf.keys(); } #destroyFirstView() { const firstView = this.#buf.keys().next().value; firstView?.destroy(); this.#buf.delete(firstView); } } exports.PDFPageViewBuffer = PDFPageViewBuffer; class PDFViewer { #buffer = null; #annotationEditorMode = _pdfjsLib.AnnotationEditorType.NONE; #annotationEditorUIManager = null; #annotationMode = _pdfjsLib.AnnotationMode.ENABLE_FORMS; #enablePermissions = false; #previousContainerHeight = 0; #scrollModePageState = null; #onVisibilityChange = null; constructor(options) { const viewerVersion = &apos;3.0.0&apos;; if (_pdfjsLib.version !== viewerVersion) { throw new Error(`The API version &quot;${_pdfjsLib.version}&quot; does not match the Viewer version &quot;${viewerVersion}&quot;.`); } this.container = options.container; this.viewer = options.viewer || options.container.firstElementChild; if (!(this.container?.tagName.toUpperCase() === &quot;DIV&quot; &amp;&amp; this.viewer?.tagName.toUpperCase() === &quot;DIV&quot;)) { throw new Error(&quot;Invalid `container` and/or `viewer` option.&quot;); } if (this.container.offsetParent &amp;&amp; getComputedStyle(this.container).position !== &quot;absolute&quot;) { throw new Error(&quot;The `container` must be absolutely positioned.&quot;); } this.eventBus = options.eventBus; this.linkService = options.linkService || new _pdf_link_service.SimpleLinkService(); this.downloadManager = options.downloadManager || null; this.findController = options.findController || null; this._scriptingManager = options.scriptingManager || null; this.removePageBorders = options.removePageBorders || false; this.textLayerMode = options.textLayerMode ?? _ui_utils.TextLayerMode.ENABLE; this.#annotationMode = options.annotationMode ?? _pdfjsLib.AnnotationMode.ENABLE_FORMS; this.#annotationEditorMode = options.annotationEditorMode ?? _pdfjsLib.AnnotationEditorType.NONE; this.imageResourcesPath = options.imageResourcesPath || &quot;&quot;; this.enablePrintAutoRotate = options.enablePrintAutoRotate || false; this.renderer = options.renderer || _ui_utils.RendererType.CANVAS; this.useOnlyCssZoom = options.useOnlyCssZoom || false; this.maxCanvasPixels = options.maxCanvasPixels; this.l10n = options.l10n || _l10n_utils.NullL10n; this.#enablePermissions = options.enablePermissions || false; this.pageColors = options.pageColors || null; if (this.pageColors &amp;&amp; !(CSS.supports(&quot;color&quot;, this.pageColors.background) &amp;&amp; CSS.supports(&quot;color&quot;, this.pageColors.foreground))) { if (this.pageColors.background || this.pageColors.foreground) { console.warn(&quot;PDFViewer: Ignoring `pageColors`-option, since the browser doesn&apos;t support the values used.&quot;); } this.pageColors = null; } this.defaultRenderingQueue = !options.renderingQueue; if (this.defaultRenderingQueue) { this.renderingQueue = new _pdf_rendering_queue.PDFRenderingQueue(); this.renderingQueue.setViewer(this); } else { this.renderingQueue = options.renderingQueue; } this.scroll = (0, _ui_utils.watchScroll)(this.container, this._scrollUpdate.bind(this)); this.presentationModeState = _ui_utils.PresentationModeState.UNKNOWN; this._onBeforeDraw = this._onAfterDraw = null; this._resetView(); if (this.removePageBorders) { this.viewer.classList.add(&quot;removePageBorders&quot;); } this.updateContainerHeightCss(); } get pagesCount() { return this._pages.length; } getPageView(index) { return this._pages[index]; } get pageViewsReady() { if (!this._pagesCapability.settled) { return false; } return this._pages.every(function (pageView) { return pageView?.pdfPage; }); } get renderForms() { return this.#annotationMode === _pdfjsLib.AnnotationMode.ENABLE_FORMS; } get enableScripting() { return !!this._scriptingManager; } get currentPageNumber() { return this._currentPageNumber; } set currentPageNumber(val) { if (!Number.isInteger(val)) { throw new Error(&quot;Invalid page number.&quot;); } if (!this.pdfDocument) { return; } if (!this._setCurrentPageNumber(val, true)) { console.error(`currentPageNumber: &quot;${val}&quot; is not a valid page.`); } } _setCurrentPageNumber(val, resetCurrentPageView = false) { if (this._currentPageNumber === val) { if (resetCurrentPageView) { this.#resetCurrentPageView(); } return true; } if (!(0 &lt; val &amp;&amp; val &lt;= this.pagesCount)) { return false; } const previous = this._currentPageNumber; this._currentPageNumber = val; this.eventBus.dispatch(&quot;pagechanging&quot;, { source: this, pageNumber: val, pageLabel: this._pageLabels?.[val - 1] ?? null, previous }); if (resetCurrentPageView) { this.#resetCurrentPageView(); } return true; } get currentPageLabel() { return this._pageLabels?.[this._currentPageNumber - 1] ?? null; } set currentPageLabel(val) { if (!this.pdfDocument) { return; } let page = val | 0; if (this._pageLabels) { const i = this._pageLabels.indexOf(val); if (i &gt;= 0) { page = i + 1; } } if (!this._setCurrentPageNumber(page, true)) { console.error(`currentPageLabel: &quot;${val}&quot; is not a valid page.`); } } get currentScale() { return this._currentScale !== _ui_utils.UNKNOWN_SCALE ? this._currentScale : _ui_utils.DEFAULT_SCALE; } set currentScale(val) { if (isNaN(val)) { throw new Error(&quot;Invalid numeric scale.&quot;); } if (!this.pdfDocument) { return; } this._setScale(val, false); } get currentScaleValue() { return this._currentScaleValue; } set currentScaleValue(val) { if (!this.pdfDocument) { return; } this._setScale(val, false); } get pagesRotation() { return this._pagesRotation; } set pagesRotation(rotation) { if (!(0, _ui_utils.isValidRotation)(rotation)) { throw new Error(&quot;Invalid pages rotation angle.&quot;); } if (!this.pdfDocument) { return; } rotation %= 360; if (rotation &lt; 0) { rotation += 360; } if (this._pagesRotation === rotation) { return; } this._pagesRotation = rotation; const pageNumber = this._currentPageNumber; const updateArgs = { rotation }; for (const pageView of this._pages) { pageView.update(updateArgs); } if (this._currentScaleValue) { this._setScale(this._currentScaleValue, true); } this.eventBus.dispatch(&quot;rotationchanging&quot;, { source: this, pagesRotation: rotation, pageNumber }); if (this.defaultRenderingQueue) { this.update(); } } get firstPagePromise() { return this.pdfDocument ? this._firstPageCapability.promise : null; } get onePageRendered() { return this.pdfDocument ? this._onePageRenderedCapability.promise : null; } get pagesPromise() { return this.pdfDocument ? this._pagesCapability.promise : null; } #initializePermissions(permissions) { const params = { annotationEditorMode: this.#annotationEditorMode, annotationMode: this.#annotationMode, textLayerMode: this.textLayerMode }; if (!permissions) { return params; } if (!permissions.includes(_pdfjsLib.PermissionFlag.COPY)) { this.viewer.classList.add(ENABLE_PERMISSIONS_CLASS); } if (!permissions.includes(_pdfjsLib.PermissionFlag.MODIFY_CONTENTS)) { params.annotationEditorMode = _pdfjsLib.AnnotationEditorType.DISABLE; } if (!permissions.includes(_pdfjsLib.PermissionFlag.MODIFY_ANNOTATIONS) &amp;&amp; !permissions.includes(_pdfjsLib.PermissionFlag.FILL_INTERACTIVE_FORMS) &amp;&amp; this.#annotationMode === _pdfjsLib.AnnotationMode.ENABLE_FORMS) { params.annotationMode = _pdfjsLib.AnnotationMode.ENABLE; } return params; } #onePageRenderedOrForceFetch() { if (document.visibilityState === &quot;hidden&quot; || !this.container.offsetParent || this._getVisiblePages().views.length === 0) { return Promise.resolve(); } const visibilityChangePromise = new Promise(resolve =&gt; { this.#onVisibilityChange = () =&gt; { if (document.visibilityState !== &quot;hidden&quot;) { return; } resolve(); document.removeEventListener(&quot;visibilitychange&quot;, this.#onVisibilityChange); this.#onVisibilityChange = null; }; document.addEventListener(&quot;visibilitychange&quot;, this.#onVisibilityChange); }); return Promise.race([this._onePageRenderedCapability.promise, visibilityChangePromise]); } setDocument(pdfDocument) { if (this.pdfDocument) { this.eventBus.dispatch(&quot;pagesdestroy&quot;, { source: this }); this._cancelRendering(); this._resetView(); this.findController?.setDocument(null); this._scriptingManager?.setDocument(null); if (this.#annotationEditorUIManager) { this.#annotationEditorUIManager.destroy(); this.#annotationEditorUIManager = null; } } this.pdfDocument = pdfDocument; if (!pdfDocument) { return; } const isPureXfa = pdfDocument.isPureXfa; const pagesCount = pdfDocument.numPages; const firstPagePromise = pdfDocument.getPage(1); const optionalContentConfigPromise = pdfDocument.getOptionalContentConfig(); const permissionsPromise = this.#enablePermissions ? pdfDocument.getPermissions() : Promise.resolve(); if (pagesCount &gt; PagesCountLimit.FORCE_SCROLL_MODE_PAGE) { console.warn(&quot;Forcing PAGE-scrolling for performance reasons, given the length of the document.&quot;); const mode = this._scrollMode = _ui_utils.ScrollMode.PAGE; this.eventBus.dispatch(&quot;scrollmodechanged&quot;, { source: this, mode }); } this._pagesCapability.promise.then(() =&gt; { this.eventBus.dispatch(&quot;pagesloaded&quot;, { source: this, pagesCount }); }, () =&gt; {}); this._onBeforeDraw = evt =&gt; { const pageView = this._pages[evt.pageNumber - 1]; if (!pageView) { return; } this.#buffer.push(pageView); }; this.eventBus._on(&quot;pagerender&quot;, this._onBeforeDraw); this._onAfterDraw = evt =&gt; { if (evt.cssTransform || this._onePageRenderedCapability.settled) { return; } this._onePageRenderedCapability.resolve({ timestamp: evt.timestamp }); this.eventBus._off(&quot;pagerendered&quot;, this._onAfterDraw); this._onAfterDraw = null; if (this.#onVisibilityChange) { document.removeEventListener(&quot;visibilitychange&quot;, this.#onVisibilityChange); this.#onVisibilityChange = null; } }; this.eventBus._on(&quot;pagerendered&quot;, this._onAfterDraw); Promise.all([firstPagePromise, permissionsPromise]).then(([firstPdfPage, permissions]) =&gt; { if (pdfDocument !== this.pdfDocument) { return; } this._firstPageCapability.resolve(firstPdfPage); this._optionalContentConfigPromise = optionalContentConfigPromise; const { annotationEditorMode, annotationMode, textLayerMode } = this.#initializePermissions(permissions); if (annotationEditorMode !== _pdfjsLib.AnnotationEditorType.DISABLE) { const mode = annotationEditorMode; if (isPureXfa) { console.warn(&quot;Warning: XFA-editing is not implemented.&quot;); } else if (isValidAnnotationEditorMode(mode)) { this.#annotationEditorUIManager = new _pdfjsLib.AnnotationEditorUIManager(this.container, this.eventBus); if (mode !== _pdfjsLib.AnnotationEditorType.NONE) { this.#annotationEditorUIManager.updateMode(mode); } } else { console.error(`Invalid AnnotationEditor mode: ${mode}`); } } const viewerElement = this._scrollMode === _ui_utils.ScrollMode.PAGE ? null : this.viewer; const scale = this.currentScale; const viewport = firstPdfPage.getViewport({ scale: scale * _pdfjsLib.PixelsPerInch.PDF_TO_CSS_UNITS }); const textLayerFactory = textLayerMode !== _ui_utils.TextLayerMode.DISABLE &amp;&amp; !isPureXfa ? this : null; const annotationLayerFactory = annotationMode !== _pdfjsLib.AnnotationMode.DISABLE ? this : null; const xfaLayerFactory = isPureXfa ? this : null; const annotationEditorLayerFactory = this.#annotationEditorUIManager ? this : null; for (let pageNum = 1; pageNum &lt;= pagesCount; ++pageNum) { const pageView = new _pdf_page_view.PDFPageView({ container: viewerElement, eventBus: this.eventBus, id: pageNum, scale, defaultViewport: viewport.clone(), optionalContentConfigPromise, renderingQueue: this.renderingQueue, textLayerFactory, textLayerMode, annotationLayerFactory, annotationMode, xfaLayerFactory, annotationEditorLayerFactory, textHighlighterFactory: this, structTreeLayerFactory: this, imageResourcesPath: this.imageResourcesPath, renderer: this.renderer, useOnlyCssZoom: this.useOnlyCssZoom, maxCanvasPixels: this.maxCanvasPixels, pageColors: this.pageColors, l10n: this.l10n }); this._pages.push(pageView); } const firstPageView = this._pages[0]; if (firstPageView) { firstPageView.setPdfPage(firstPdfPage); this.linkService.cachePageRef(1, firstPdfPage.ref); } if (this._scrollMode === _ui_utils.ScrollMode.PAGE) { this.#ensurePageViewVisible(); } else if (this._spreadMode !== _ui_utils.SpreadMode.NONE) { this._updateSpreadMode(); } this.#onePageRenderedOrForceFetch().then(async () =&gt; { this.findController?.setDocument(pdfDocument); this._scriptingManager?.setDocument(pdfDocument); if (this.#annotationEditorUIManager) { this.eventBus.dispatch(&quot;annotationeditormodechanged&quot;, { source: this, mode: this.#annotationEditorMode }); } if (pdfDocument.loadingParams.disableAutoFetch || pagesCount &gt; PagesCountLimit.FORCE_LAZY_PAGE_INIT) { this._pagesCapability.resolve(); return; } let getPagesLeft = pagesCount - 1; if (getPagesLeft &lt;= 0) { this._pagesCapability.resolve(); return; } for (let pageNum = 2; pageNum &lt;= pagesCount; ++pageNum) { const promise = pdfDocument.getPage(pageNum).then(pdfPage =&gt; { const pageView = this._pages[pageNum - 1]; if (!pageView.pdfPage) { pageView.setPdfPage(pdfPage); } this.linkService.cachePageRef(pageNum, pdfPage.ref); if (--getPagesLeft === 0) { this._pagesCapability.resolve(); } }, reason =&gt; { console.error(`Unable to get page ${pageNum} to initialize viewer`, reason); if (--getPagesLeft === 0) { this._pagesCapability.resolve(); } }); if (pageNum % PagesCountLimit.PAUSE_EAGER_PAGE_INIT === 0) { await promise; } } }); this.eventBus.dispatch(&quot;pagesinit&quot;, { source: this }); pdfDocument.getMetadata().then(({ info }) =&gt; { if (pdfDocument !== this.pdfDocument) { return; } if (info.Language) { this.viewer.lang = info.Language; } }); if (this.defaultRenderingQueue) { this.update(); } }).catch(reason =&gt; { console.error(&quot;Unable to initialize viewer&quot;, reason); this._pagesCapability.reject(reason); }); } setPageLabels(labels) { if (!this.pdfDocument) { return; } if (!labels) { this._pageLabels = null; } else if (!(Array.isArray(labels) &amp;&amp; this.pdfDocument.numPages === labels.length)) { this._pageLabels = null; console.error(`setPageLabels: Invalid page labels.`); } else { this._pageLabels = labels; } for (let i = 0, ii = this._pages.length; i &lt; ii; i++) { this._pages[i].setPageLabel(this._pageLabels?.[i] ?? null); } } _resetView() { this._pages = []; this._currentPageNumber = 1; this._currentScale = _ui_utils.UNKNOWN_SCALE; this._currentScaleValue = null; this._pageLabels = null; this.#buffer = new PDFPageViewBuffer(DEFAULT_CACHE_SIZE); this._location = null; this._pagesRotation = 0; this._optionalContentConfigPromise = null; this._firstPageCapability = (0, _pdfjsLib.createPromiseCapability)(); this._onePageRenderedCapability = (0, _pdfjsLib.createPromiseCapability)(); this._pagesCapability = (0, _pdfjsLib.createPromiseCapability)(); this._scrollMode = _ui_utils.ScrollMode.VERTICAL; this._previousScrollMode = _ui_utils.ScrollMode.UNKNOWN; this._spreadMode = _ui_utils.SpreadMode.NONE; this.#scrollModePageState = { previousPageNumber: 1, scrollDown: true, pages: [] }; if (this._onBeforeDraw) { this.eventBus._off(&quot;pagerender&quot;, this._onBeforeDraw); this._onBeforeDraw = null; } if (this._onAfterDraw) { this.eventBus._off(&quot;pagerendered&quot;, this._onAfterDraw); this._onAfterDraw = null; } if (this.#onVisibilityChange) { document.removeEventListener(&quot;visibilitychange&quot;, this.#onVisibilityChange); this.#onVisibilityChange = null; } this.viewer.textContent = &quot;&quot;; this._updateScrollMode(); this.viewer.removeAttribute(&quot;lang&quot;); this.viewer.classList.remove(ENABLE_PERMISSIONS_CLASS); } #ensurePageViewVisible() { if (this._scrollMode !== _ui_utils.ScrollMode.PAGE) { throw new Error(&quot;#ensurePageViewVisible: Invalid scrollMode value.&quot;); } const pageNumber = this._currentPageNumber, state = this.#scrollModePageState, viewer = this.viewer; viewer.textContent = &quot;&quot;; state.pages.length = 0; if (this._spreadMode === _ui_utils.SpreadMode.NONE &amp;&amp; !this.isInPresentationMode) { const pageView = this._pages[pageNumber - 1]; viewer.append(pageView.div); state.pages.push(pageView); } else { const pageIndexSet = new Set(), parity = this._spreadMode - 1; if (parity === -1) { pageIndexSet.add(pageNumber - 1); } else if (pageNumber % 2 !== parity) { pageIndexSet.add(pageNumber - 1); pageIndexSet.add(pageNumber); } else { pageIndexSet.add(pageNumber - 2); pageIndexSet.add(pageNumber - 1); } const spread = document.createElement(&quot;div&quot;); spread.className = &quot;spread&quot;; if (this.isInPresentationMode) { const dummyPage = document.createElement(&quot;div&quot;); dummyPage.className = &quot;dummyPage&quot;; spread.append(dummyPage); } for (const i of pageIndexSet) { const pageView = this._pages[i]; if (!pageView) { continue; } spread.append(pageView.div); state.pages.push(pageView); } viewer.append(spread); } state.scrollDown = pageNumber &gt;= state.previousPageNumber; state.previousPageNumber = pageNumber; } _scrollUpdate() { if (this.pagesCount === 0) { return; } this.update(); } #scrollIntoView(pageView, pageSpot = null) { const { div, id } = pageView; if (this._scrollMode === _ui_utils.ScrollMode.PAGE) { this._setCurrentPageNumber(id); this.#ensurePageViewVisible(); this.update(); } if (!pageSpot &amp;&amp; !this.isInPresentationMode) { const left = div.offsetLeft + div.clientLeft, right = left + div.clientWidth; const { scrollLeft, clientWidth } = this.container; if (this._scrollMode === _ui_utils.ScrollMode.HORIZONTAL || left &lt; scrollLeft || right &gt; scrollLeft + clientWidth) { pageSpot = { left: 0, top: 0 }; } } (0, _ui_utils.scrollIntoView)(div, pageSpot); } #isSameScale(newScale) { return newScale === this._currentScale || Math.abs(newScale - this._currentScale) &lt; 1e-15; } _setScaleUpdatePages(newScale, newValue, noScroll = false, preset = false) { this._currentScaleValue = newValue.toString(); if (this.#isSameScale(newScale)) { if (preset) { this.eventBus.dispatch(&quot;scalechanging&quot;, { source: this, scale: newScale, presetValue: newValue }); } return; } _ui_utils.docStyle.setProperty(&quot;--scale-factor&quot;, newScale * _pdfjsLib.PixelsPerInch.PDF_TO_CSS_UNITS); const updateArgs = { scale: newScale }; for (const pageView of this._pages) { pageView.update(updateArgs); } this._currentScale = newScale; if (!noScroll) { let page = this._currentPageNumber, dest; if (this._location &amp;&amp; !(this.isInPresentationMode || this.isChangingPresentationMode)) { page = this._location.pageNumber; dest = [null, { name: &quot;XYZ&quot; }, this._location.left, this._location.top, null]; } this.scrollPageIntoView({ pageNumber: page, destArray: dest, allowNegativeOffset: true }); } this.eventBus.dispatch(&quot;scalechanging&quot;, { source: this, scale: newScale, presetValue: preset ? newValue : undefined }); if (this.defaultRenderingQueue) { this.update(); } this.updateContainerHeightCss(); } get _pageWidthScaleFactor() { if (this._spreadMode !== _ui_utils.SpreadMode.NONE &amp;&amp; this._scrollMode !== _ui_utils.ScrollMode.HORIZONTAL) { return 2; } return 1; } _setScale(value, noScroll = false) { let scale = parseFloat(value); if (scale &gt; 0) { this._setScaleUpdatePages(scale, value, noScroll, false); } else { const currentPage = this._pages[this._currentPageNumber - 1]; if (!currentPage) { return; } let hPadding = _ui_utils.SCROLLBAR_PADDING, vPadding = _ui_utils.VERTICAL_PADDING; if (this.isInPresentationMode) { hPadding = vPadding = 4; } else if (this.removePageBorders) { hPadding = vPadding = 0; } else if (this._scrollMode === _ui_utils.ScrollMode.HORIZONTAL) { [hPadding, vPadding] = [vPadding, hPadding]; } const pageWidthScale = (this.container.clientWidth - hPadding) / currentPage.width * currentPage.scale / this._pageWidthScaleFactor; const pageHeightScale = (this.container.clientHeight - vPadding) / currentPage.height * currentPage.scale; switch (value) { case &quot;page-actual&quot;: scale = 1; break; case &quot;page-width&quot;: scale = pageWidthScale; break; case &quot;page-height&quot;: scale = pageHeightScale; break; case &quot;page-fit&quot;: scale = Math.min(pageWidthScale, pageHeightScale); break; case &quot;auto&quot;: const horizontalScale = (0, _ui_utils.isPortraitOrientation)(currentPage) ? pageWidthScale : Math.min(pageHeightScale, pageWidthScale); scale = Math.min(_ui_utils.MAX_AUTO_SCALE, horizontalScale); break; default: console.error(`_setScale: &quot;${value}&quot; is an unknown zoom value.`); return; } this._setScaleUpdatePages(scale, value, noScroll, true); } } #resetCurrentPageView() { const pageView = this._pages[this._currentPageNumber - 1]; if (this.isInPresentationMode) { this._setScale(this._currentScaleValue, true); } this.#scrollIntoView(pageView); } pageLabelToPageNumber(label) { if (!this._pageLabels) { return null; } const i = this._pageLabels.indexOf(label); if (i &lt; 0) { return null; } return i + 1; } scrollPageIntoView({ pageNumber, destArray = null, allowNegativeOffset = false, ignoreDestinationZoom = false }) { if (!this.pdfDocument) { return; } const pageView = Number.isInteger(pageNumber) &amp;&amp; this._pages[pageNumber - 1]; if (!pageView) { console.error(`scrollPageIntoView: &quot;${pageNumber}&quot; is not a valid pageNumber parameter.`); return; } if (this.isInPresentationMode || !destArray) { this._setCurrentPageNumber(pageNumber, true); return; } let x = 0, y = 0; let width = 0, height = 0, widthScale, heightScale; const changeOrientation = pageView.rotation % 180 !== 0; const pageWidth = (changeOrientation ? pageView.height : pageView.width) / pageView.scale / _pdfjsLib.PixelsPerInch.PDF_TO_CSS_UNITS; const pageHeight = (changeOrientation ? pageView.width : pageView.height) / pageView.scale / _pdfjsLib.PixelsPerInch.PDF_TO_CSS_UNITS; let scale = 0; switch (destArray[1].name) { case &quot;XYZ&quot;: x = destArray[2]; y = destArray[3]; scale = destArray[4]; x = x !== null ? x : 0; y = y !== null ? y : pageHeight; break; case &quot;Fit&quot;: case &quot;FitB&quot;: scale = &quot;page-fit&quot;; break; case &quot;FitH&quot;: case &quot;FitBH&quot;: y = destArray[2]; scale = &quot;page-width&quot;; if (y === null &amp;&amp; this._location) { x = this._location.left; y = this._location.top; } else if (typeof y !== &quot;number&quot; || y &lt; 0) { y = pageHeight; } break; case &quot;FitV&quot;: case &quot;FitBV&quot;: x = destArray[2]; width = pageWidth; height = pageHeight; scale = &quot;page-height&quot;; break; case &quot;FitR&quot;: x = destArray[2]; y = destArray[3]; width = destArray[4] - x; height = destArray[5] - y; const hPadding = this.removePageBorders ? 0 : _ui_utils.SCROLLBAR_PADDING; const vPadding = this.removePageBorders ? 0 : _ui_utils.VERTICAL_PADDING; widthScale = (this.container.clientWidth - hPadding) / width / _pdfjsLib.PixelsPerInch.PDF_TO_CSS_UNITS; heightScale = (this.container.clientHeight - vPadding) / height / _pdfjsLib.PixelsPerInch.PDF_TO_CSS_UNITS; scale = Math.min(Math.abs(widthScale), Math.abs(heightScale)); break; default: console.error(`scrollPageIntoView: &quot;${destArray[1].name}&quot; is not a valid destination type.`); return; } if (!ignoreDestinationZoom) { if (scale &amp;&amp; scale !== this._currentScale) { this.currentScaleValue = scale; } else if (this._currentScale === _ui_utils.UNKNOWN_SCALE) { this.currentScaleValue = _ui_utils.DEFAULT_SCALE_VALUE; } } if (scale === &quot;page-fit&quot; &amp;&amp; !destArray[4]) { this.#scrollIntoView(pageView); return; } const boundingRect = [pageView.viewport.convertToViewportPoint(x, y), pageView.viewport.convertToViewportPoint(x + width, y + height)]; let left = Math.min(boundingRect[0][0], boundingRect[1][0]); let top = Math.min(boundingRect[0][1], boundingRect[1][1]); if (!allowNegativeOffset) { left = Math.max(left, 0); top = Math.max(top, 0); } this.#scrollIntoView(pageView, { left, top }); } _updateLocation(firstPage) { const currentScale = this._currentScale; const currentScaleValue = this._currentScaleValue; const normalizedScaleValue = parseFloat(currentScaleValue) === currentScale ? Math.round(currentScale * 10000) / 100 : currentScaleValue; const pageNumber = firstPage.id; const currentPageView = this._pages[pageNumber - 1]; const container = this.container; const topLeft = currentPageView.getPagePoint(container.scrollLeft - firstPage.x, container.scrollTop - firstPage.y); const intLeft = Math.round(topLeft[0]); const intTop = Math.round(topLeft[1]); let pdfOpenParams = `#page=${pageNumber}`; if (!this.isInPresentationMode) { pdfOpenParams += `&amp;zoom=${normalizedScaleValue},${intLeft},${intTop}`; } this._location = { pageNumber, scale: normalizedScaleValue, top: intTop, left: intLeft, rotation: this._pagesRotation, pdfOpenParams }; } update() { const visible = this._getVisiblePages(); const visiblePages = visible.views, numVisiblePages = visiblePages.length; if (numVisiblePages === 0) { return; } const newCacheSize = Math.max(DEFAULT_CACHE_SIZE, 2 * numVisiblePages + 1); this.#buffer.resize(newCacheSize, visible.ids); this.renderingQueue.renderHighestPriority(visible); const isSimpleLayout = this._spreadMode === _ui_utils.SpreadMode.NONE &amp;&amp; (this._scrollMode === _ui_utils.ScrollMode.PAGE || this._scrollMode === _ui_utils.ScrollMode.VERTICAL); const currentId = this._currentPageNumber; let stillFullyVisible = false; for (const page of visiblePages) { if (page.percent &lt; 100) { break; } if (page.id === currentId &amp;&amp; isSimpleLayout) { stillFullyVisible = true; break; } } this._setCurrentPageNumber(stillFullyVisible ? currentId : visiblePages[0].id); this._updateLocation(visible.first); this.eventBus.dispatch(&quot;updateviewarea&quot;, { source: this, location: this._location }); } containsElement(element) { return this.container.contains(element); } focus() { this.container.focus(); } get _isContainerRtl() { return getComputedStyle(this.container).direction === &quot;rtl&quot;; } get isInPresentationMode() { return this.presentationModeState === _ui_utils.PresentationModeState.FULLSCREEN; } get isChangingPresentationMode() { return this.presentationModeState === _ui_utils.PresentationModeState.CHANGING; } get isHorizontalScrollbarEnabled() { return this.isInPresentationMode ? false : this.container.scrollWidth &gt; this.container.clientWidth; } get isVerticalScrollbarEnabled() { return this.isInPresentationMode ? false : this.container.scrollHeight &gt; this.container.clientHeight; } _getVisiblePages() { const views = this._scrollMode === _ui_utils.ScrollMode.PAGE ? this.#scrollModePageState.pages : this._pages, horizontal = this._scrollMode === _ui_utils.ScrollMode.HORIZONTAL, rtl = horizontal &amp;&amp; this._isContainerRtl; return (0, _ui_utils.getVisibleElements)({ scrollEl: this.container, views, sortByVisibility: true, horizontal, rtl }); } isPageVisible(pageNumber) { if (!this.pdfDocument) { return false; } if (!(Number.isInteger(pageNumber) &amp;&amp; pageNumber &gt; 0 &amp;&amp; pageNumber &lt;= this.pagesCount)) { console.error(`isPageVisible: &quot;${pageNumber}&quot; is not a valid page.`); return false; } return this._getVisiblePages().ids.has(pageNumber); } isPageCached(pageNumber) { if (!this.pdfDocument) { return false; } if (!(Number.isInteger(pageNumber) &amp;&amp; pageNumber &gt; 0 &amp;&amp; pageNumber &lt;= this.pagesCount)) { console.error(`isPageCached: &quot;${pageNumber}&quot; is not a valid page.`); return false; } const pageView = this._pages[pageNumber - 1]; return this.#buffer.has(pageView); } cleanup() { for (const pageView of this._pages) { if (pageView.renderingState !== _ui_utils.RenderingStates.FINISHED) { pageView.reset(); } } } _cancelRendering() { for (const pageView of this._pages) { pageView.cancelRendering(); } } async #ensurePdfPageLoaded(pageView) { if (pageView.pdfPage) { return pageView.pdfPage; } try { const pdfPage = await this.pdfDocument.getPage(pageView.id); if (!pageView.pdfPage) { pageView.setPdfPage(pdfPage); } if (!this.linkService._cachedPageNumber?.(pdfPage.ref)) { this.linkService.cachePageRef(pageView.id, pdfPage.ref); } return pdfPage; } catch (reason) { console.error(&quot;Unable to get page for page view&quot;, reason); return null; } } #getScrollAhead(visible) { if (visible.first?.id === 1) { return true; } else if (visible.last?.id === this.pagesCount) { return false; } switch (this._scrollMode) { case _ui_utils.ScrollMode.PAGE: return this.#scrollModePageState.scrollDown; case _ui_utils.ScrollMode.HORIZONTAL: return this.scroll.right; } return this.scroll.down; } #toggleLoadingIconSpinner(visibleIds) { for (const id of visibleIds) { const pageView = this._pages[id - 1]; pageView?.toggleLoadingIconSpinner(true); } for (const pageView of this.#buffer) { if (visibleIds.has(pageView.id)) { continue; } pageView.toggleLoadingIconSpinner(false); } } forceRendering(currentlyVisiblePages) { const visiblePages = currentlyVisiblePages || this._getVisiblePages(); const scrollAhead = this.#getScrollAhead(visiblePages); const preRenderExtra = this._spreadMode !== _ui_utils.SpreadMode.NONE &amp;&amp; this._scrollMode !== _ui_utils.ScrollMode.HORIZONTAL; const pageView = this.renderingQueue.getHighestPriority(visiblePages, this._pages, scrollAhead, preRenderExtra); this.#toggleLoadingIconSpinner(visiblePages.ids); if (pageView) { this.#ensurePdfPageLoaded(pageView).then(() =&gt; { this.renderingQueue.renderView(pageView); }); return true; } return false; } createTextLayerBuilder({ textLayerDiv, pageIndex, viewport, eventBus, highlighter, accessibilityManager = null }) { return new _text_layer_builder.TextLayerBuilder({ textLayerDiv, eventBus, pageIndex, viewport, highlighter, accessibilityManager }); } createTextHighlighter({ pageIndex, eventBus }) { return new _text_highlighter.TextHighlighter({ eventBus, pageIndex, findController: this.isInPresentationMode ? null : this.findController }); } createAnnotationLayerBuilder({ pageDiv, pdfPage, annotationStorage = this.pdfDocument?.annotationStorage, imageResourcesPath = &quot;&quot;, renderForms = true, l10n = _l10n_utils.NullL10n, enableScripting = this.enableScripting, hasJSActionsPromise = this.pdfDocument?.hasJSActions(), mouseState = this._scriptingManager?.mouseState, fieldObjectsPromise = this.pdfDocument?.getFieldObjects(), annotationCanvasMap = null, accessibilityManager = null }) { return new _annotation_layer_builder.AnnotationLayerBuilder({ pageDiv, pdfPage, annotationStorage, imageResourcesPath, renderForms, linkService: this.linkService, downloadManager: this.downloadManager, l10n, enableScripting, hasJSActionsPromise, mouseState, fieldObjectsPromise, annotationCanvasMap, accessibilityManager }); } createAnnotationEditorLayerBuilder({ uiManager = this.#annotationEditorUIManager, pageDiv, pdfPage, accessibilityManager = null, l10n, annotationStorage = this.pdfDocument?.annotationStorage }) { return new _annotation_editor_layer_builder.AnnotationEditorLayerBuilder({ uiManager, pageDiv, pdfPage, annotationStorage, accessibilityManager, l10n }); } createXfaLayerBuilder({ pageDiv, pdfPage, annotationStorage = this.pdfDocument?.annotationStorage }) { return new _xfa_layer_builder.XfaLayerBuilder({ pageDiv, pdfPage, annotationStorage, linkService: this.linkService }); } createStructTreeLayerBuilder({ pdfPage }) { return new _struct_tree_layer_builder.StructTreeLayerBuilder({ pdfPage }); } get hasEqualPageSizes() { const firstPageView = this._pages[0]; for (let i = 1, ii = this._pages.length; i &lt; ii; ++i) { const pageView = this._pages[i]; if (pageView.width !== firstPageView.width || pageView.height !== firstPageView.height) { return false; } } return true; } getPagesOverview() { return this._pages.map(pageView =&gt; { const viewport = pageView.pdfPage.getViewport({ scale: 1 }); if (!this.enablePrintAutoRotate || (0, _ui_utils.isPortraitOrientation)(viewport)) { return { width: viewport.width, height: viewport.height, rotation: viewport.rotation }; } return { width: viewport.height, height: viewport.width, rotation: (viewport.rotation - 90) % 360 }; }); } get optionalContentConfigPromise() { if (!this.pdfDocument) { return Promise.resolve(null); } if (!this._optionalContentConfigPromise) { console.error(&quot;optionalContentConfigPromise: Not initialized yet.&quot;); return this.pdfDocument.getOptionalContentConfig(); } return this._optionalContentConfigPromise; } set optionalContentConfigPromise(promise) { if (!(promise instanceof Promise)) { throw new Error(`Invalid optionalContentConfigPromise: ${promise}`); } if (!this.pdfDocument) { return; } if (!this._optionalContentConfigPromise) { return; } this._optionalContentConfigPromise = promise; const updateArgs = { optionalContentConfigPromise: promise }; for (const pageView of this._pages) { pageView.update(updateArgs); } this.update(); this.eventBus.dispatch(&quot;optionalcontentconfigchanged&quot;, { source: this, promise }); } get scrollMode() { return this._scrollMode; } set scrollMode(mode) { if (this._scrollMode === mode) { return; } if (!(0, _ui_utils.isValidScrollMode)(mode)) { throw new Error(`Invalid scroll mode: ${mode}`); } if (this.pagesCount &gt; PagesCountLimit.FORCE_SCROLL_MODE_PAGE) { return; } this._previousScrollMode = this._scrollMode; this._scrollMode = mode; this.eventBus.dispatch(&quot;scrollmodechanged&quot;, { source: this, mode }); this._updateScrollMode(this._currentPageNumber); } _updateScrollMode(pageNumber = null) { const scrollMode = this._scrollMode, viewer = this.viewer; viewer.classList.toggle(&quot;scrollHorizontal&quot;, scrollMode === _ui_utils.ScrollMode.HORIZONTAL); viewer.classList.toggle(&quot;scrollWrapped&quot;, scrollMode === _ui_utils.ScrollMode.WRAPPED); if (!this.pdfDocument || !pageNumber) { return; } if (scrollMode === _ui_utils.ScrollMode.PAGE) { this.#ensurePageViewVisible(); } else if (this._previousScrollMode === _ui_utils.ScrollMode.PAGE) { this._updateSpreadMode(); } if (this._currentScaleValue &amp;&amp; isNaN(this._currentScaleValue)) { this._setScale(this._currentScaleValue, true); } this._setCurrentPageNumber(pageNumber, true); this.update(); } get spreadMode() { return this._spreadMode; } set spreadMode(mode) { if (this._spreadMode === mode) { return; } if (!(0, _ui_utils.isValidSpreadMode)(mode)) { throw new Error(`Invalid spread mode: ${mode}`); } this._spreadMode = mode; this.eventBus.dispatch(&quot;spreadmodechanged&quot;, { source: this, mode }); this._updateSpreadMode(this._currentPageNumber); } _updateSpreadMode(pageNumber = null) { if (!this.pdfDocument) { return; } const viewer = this.viewer, pages = this._pages; if (this._scrollMode === _ui_utils.ScrollMode.PAGE) { this.#ensurePageViewVisible(); } else { viewer.textContent = &quot;&quot;; if (this._spreadMode === _ui_utils.SpreadMode.NONE) { for (const pageView of this._pages) { viewer.append(pageView.div); } } else { const parity = this._spreadMode - 1; let spread = null; for (let i = 0, ii = pages.length; i &lt; ii; ++i) { if (spread === null) { spread = document.createElement(&quot;div&quot;); spread.className = &quot;spread&quot;; viewer.append(spread); } else if (i % 2 === parity) { spread = spread.cloneNode(false); viewer.append(spread); } spread.append(pages[i].div); } } } if (!pageNumber) { return; } if (this._currentScaleValue &amp;&amp; isNaN(this._currentScaleValue)) { this._setScale(this._currentScaleValue, true); } this._setCurrentPageNumber(pageNumber, true); this.update(); } _getPageAdvance(currentPageNumber, previous = false) { switch (this._scrollMode) { case _ui_utils.ScrollMode.WRAPPED: { const { views } = this._getVisiblePages(), pageLayout = new Map(); for (const { id, y, percent, widthPercent } of views) { if (percent === 0 || widthPercent &lt; 100) { continue; } let yArray = pageLayout.get(y); if (!yArray) { pageLayout.set(y, yArray ||= []); } yArray.push(id); } for (const yArray of pageLayout.values()) { const currentIndex = yArray.indexOf(currentPageNumber); if (currentIndex === -1) { continue; } const numPages = yArray.length; if (numPages === 1) { break; } if (previous) { for (let i = currentIndex - 1, ii = 0; i &gt;= ii; i--) { const currentId = yArray[i], expectedId = yArray[i + 1] - 1; if (currentId &lt; expectedId) { return currentPageNumber - expectedId; } } } else { for (let i = currentIndex + 1, ii = numPages; i &lt; ii; i++) { const currentId = yArray[i], expectedId = yArray[i - 1] + 1; if (currentId &gt; expectedId) { return expectedId - currentPageNumber; } } } if (previous) { const firstId = yArray[0]; if (firstId &lt; currentPageNumber) { return currentPageNumber - firstId + 1; } } else { const lastId = yArray[numPages - 1]; if (lastId &gt; currentPageNumber) { return lastId - currentPageNumber + 1; } } break; } break; } case _ui_utils.ScrollMode.HORIZONTAL: { break; } case _ui_utils.ScrollMode.PAGE: case _ui_utils.ScrollMode.VERTICAL: { if (this._spreadMode === _ui_utils.SpreadMode.NONE) { break; } const parity = this._spreadMode - 1; if (previous &amp;&amp; currentPageNumber % 2 !== parity) { break; } else if (!previous &amp;&amp; currentPageNumber % 2 === parity) { break; } const { views } = this._getVisiblePages(), expectedId = previous ? currentPageNumber - 1 : currentPageNumber + 1; for (const { id, percent, widthPercent } of views) { if (id !== expectedId) { continue; } if (percent &gt; 0 &amp;&amp; widthPercent === 100) { return 2; } break; } break; } } return 1; } nextPage() { const currentPageNumber = this._currentPageNumber, pagesCount = this.pagesCount; if (currentPageNumber &gt;= pagesCount) { return false; } const advance = this._getPageAdvance(currentPageNumber, false) || 1; this.currentPageNumber = Math.min(currentPageNumber + advance, pagesCount); return true; } previousPage() { const currentPageNumber = this._currentPageNumber; if (currentPageNumber &lt;= 1) { return false; } const advance = this._getPageAdvance(currentPageNumber, true) || 1; this.currentPageNumber = Math.max(currentPageNumber - advance, 1); return true; } increaseScale(steps = 1) { let newScale = this._currentScale; do { newScale = (newScale * _ui_utils.DEFAULT_SCALE_DELTA).toFixed(2); newScale = Math.ceil(newScale * 10) / 10; newScale = Math.min(_ui_utils.MAX_SCALE, newScale); } while (--steps &gt; 0 &amp;&amp; newScale &lt; _ui_utils.MAX_SCALE); this.currentScaleValue = newScale; } decreaseScale(steps = 1) { let newScale = this._currentScale; do { newScale = (newScale / _ui_utils.DEFAULT_SCALE_DELTA).toFixed(2); newScale = Math.floor(newScale * 10) / 10; newScale = Math.max(_ui_utils.MIN_SCALE, newScale); } while (--steps &gt; 0 &amp;&amp; newScale &gt; _ui_utils.MIN_SCALE); this.currentScaleValue = newScale; } updateContainerHeightCss() { const height = this.container.clientHeight; if (height !== this.#previousContainerHeight) { this.#previousContainerHeight = height; _ui_utils.docStyle.setProperty(&quot;--viewer-container-height&quot;, `${height}px`); } } get annotationEditorMode() { return this.#annotationEditorUIManager ? this.#annotationEditorMode : _pdfjsLib.AnnotationEditorType.DISABLE; } set annotationEditorMode(mode) { if (!this.#annotationEditorUIManager) { throw new Error(`The AnnotationEditor is not enabled.`); } if (this.#annotationEditorMode === mode) { return; } if (!isValidAnnotationEditorMode(mode)) { throw new Error(`Invalid AnnotationEditor mode: ${mode}`); } if (!this.pdfDocument) { return; } this.#annotationEditorMode = mode; this.eventBus.dispatch(&quot;annotationeditormodechanged&quot;, { source: this, mode }); this.#annotationEditorUIManager.updateMode(mode); } set annotationEditorParams({ type, value }) { if (!this.#annotationEditorUIManager) { throw new Error(`The AnnotationEditor is not enabled.`); } this.#annotationEditorUIManager.updateParams(type, value); } refresh() { if (!this.pdfDocument) { return; } const updateArgs = {}; for (const pageView of this._pages) { pageView.update(updateArgs); } this.update(); } } exports.PDFViewer = PDFViewer; /***/ }), /* 29 */ /***/ ((__unused_webpack_module, exports, __webpack_require__) =&gt; { Object.defineProperty(exports, &quot;__esModule&quot;, ({ value: true })); exports.AnnotationEditorLayerBuilder = void 0; var _pdfjsLib = __webpack_require__(5); var _l10n_utils = __webpack_require__(30); class AnnotationEditorLayerBuilder { #uiManager; constructor(options) { this.pageDiv = options.pageDiv; this.pdfPage = options.pdfPage; this.annotationStorage = options.annotationStorage || null; this.accessibilityManager = options.accessibilityManager; this.l10n = options.l10n || _l10n_utils.NullL10n; this.annotationEditorLayer = null; this.div = null; this._cancelled = false; this.#uiManager = options.uiManager; } async render(viewport, intent = &quot;display&quot;) { if (intent !== &quot;display&quot;) { return; } if (this._cancelled) { return; } const clonedViewport = viewport.clone({ dontFlip: true }); if (this.div) { this.annotationEditorLayer.update({ viewport: clonedViewport }); this.show(); return; } this.div = document.createElement(&quot;div&quot;); this.div.className = &quot;annotationEditorLayer&quot;; this.div.tabIndex = 0; this.pageDiv.append(this.div); this.annotationEditorLayer = new _pdfjsLib.AnnotationEditorLayer({ uiManager: this.#uiManager, div: this.div, annotationStorage: this.annotationStorage, accessibilityManager: this.accessibilityManager, pageIndex: this.pdfPage._pageIndex, l10n: this.l10n, viewport: clonedViewport }); const parameters = { viewport: clonedViewport, div: this.div, annotations: null, intent }; this.annotationEditorLayer.render(parameters); } cancel() { this._cancelled = true; this.destroy(); } hide() { if (!this.div) { return; } this.div.hidden = true; } show() { if (!this.div) { return; } this.div.hidden = false; } destroy() { if (!this.div) { return; } this.pageDiv = null; this.annotationEditorLayer.destroy(); this.div.remove(); } } exports.AnnotationEditorLayerBuilder = AnnotationEditorLayerBuilder; /***/ }), /* 30 */ /***/ ((__unused_webpack_module, exports) =&gt; { Object.defineProperty(exports, &quot;__esModule&quot;, ({ value: true })); exports.NullL10n = void 0; exports.fixupLangCode = fixupLangCode; exports.getL10nFallback = getL10nFallback; const DEFAULT_L10N_STRINGS = { of_pages: &quot;of &quot;, page_of_pages: &quot;( of )&quot;, document_properties_kb: &quot; KB ( bytes)&quot;, document_properties_mb: &quot; MB ( bytes)&quot;, document_properties_date_string: &quot;1667031860459, &quot;, document_properties_page_size_unit_inches: &quot;in&quot;, document_properties_page_size_unit_millimeters: &quot;mm&quot;, document_properties_page_size_orientation_portrait: &quot;portrait&quot;, document_properties_page_size_orientation_landscape: &quot;landscape&quot;, document_properties_page_size_name_a3: &quot;A3&quot;, document_properties_page_size_name_a4: &quot;A4&quot;, document_properties_page_size_name_letter: &quot;Letter&quot;, document_properties_page_size_name_legal: &quot;Legal&quot;, document_properties_page_size_dimension_string: &quot; × ()&quot;, document_properties_page_size_dimension_name_string: &quot; × (, )&quot;, document_properties_linearized_yes: &quot;Yes&quot;, document_properties_linearized_no: &quot;No&quot;, additional_layers: &quot;Additional Layers&quot;, page_landmark: &quot;Page &quot;, thumb_page_title: &quot;Page &quot;, thumb_page_canvas: &quot;Thumbnail of Page &quot;, find_reached_top: &quot;Reached top of document, continued from bottom&quot;, find_reached_bottom: &quot;Reached end of document, continued from top&quot;, &quot;find_match_count[one]&quot;: &quot; of match&quot;, &quot;find_match_count[other]&quot;: &quot; of matches&quot;, &quot;find_match_count_limit[one]&quot;: &quot;More than match&quot;, &quot;find_match_count_limit[other]&quot;: &quot;More than matches&quot;, find_not_found: &quot;Phrase not found&quot;, page_scale_width: &quot;Page Width&quot;, page_scale_fit: &quot;Page Fit&quot;, page_scale_auto: &quot;Automatic Zoom&quot;, page_scale_actual: &quot;Actual Size&quot;, page_scale_percent: &quot;%&quot;, loading: &quot;Loading…&quot;, loading_error: &quot;An error occurred while loading the PDF.&quot;, invalid_file_error: &quot;Invalid or corrupted PDF file.&quot;, missing_file_error: &quot;Missing PDF file.&quot;, unexpected_response_error: &quot;Unexpected server response.&quot;, rendering_error: &quot;An error occurred while rendering the page.&quot;, printing_not_supported: &quot;Warning: Printing is not fully supported by this browser.&quot;, printing_not_ready: &quot;Warning: The PDF is not fully loaded for printing.&quot;, web_fonts_disabled: &quot;Web fonts are disabled: unable to use embedded PDF fonts.&quot;, free_text2_default_content: &quot;Start typing…&quot;, editor_free_text2_aria_label: &quot;Text Editor&quot;, editor_ink2_aria_label: &quot;Draw Editor&quot;, editor_ink_canvas_aria_label: &quot;User-created image&quot; }; { DEFAULT_L10N_STRINGS.print_progress_percent = &quot;%&quot;; } function getL10nFallback(key, args) { switch (key) { case &quot;find_match_count&quot;: key = `find_match_count[${args.total === 1 ? &quot;one&quot; : &quot;other&quot;}]`; break; case &quot;find_match_count_limit&quot;: key = `find_match_count_limit[${args.limit === 1 ? &quot;one&quot; : &quot;other&quot;}]`; break; } return DEFAULT_L10N_STRINGS[key] || &quot;&quot;; } const PARTIAL_LANG_CODES = { en: &quot;en-US&quot;, es: &quot;es-ES&quot;, fy: &quot;fy-NL&quot;, ga: &quot;ga-IE&quot;, gu: &quot;gu-IN&quot;, hi: &quot;hi-IN&quot;, hy: &quot;hy-AM&quot;, nb: &quot;nb-NO&quot;, ne: &quot;ne-NP&quot;, nn: &quot;nn-NO&quot;, pa: &quot;pa-IN&quot;, pt: &quot;pt-PT&quot;, sv: &quot;sv-SE&quot;, zh: &quot;zh-CN&quot; }; function fixupLangCode(langCode) { return PARTIAL_LANG_CODES[langCode?.toLowerCase()] || langCode; } function formatL10nValue(text, args) { if (!args) { return text; } return text.replace(/\\{\\{\\s*(\\w+)\\s*\\}\\}/g, (all, name) =&gt; { return name in args ? args[name] : &quot; + name + &quot;; }); } const NullL10n = { async getLanguage() { return &quot;en-us&quot;; }, async getDirection() { return &quot;ltr&quot;; }, async get(key, args = null, fallback = getL10nFallback(key, args)) { return formatL10nValue(fallback, args); }, async translate(element) {} }; exports.NullL10n = NullL10n; /***/ }), /* 31 */ /***/ ((__unused_webpack_module, exports, __webpack_require__) =&gt; { Object.defineProperty(exports, &quot;__esModule&quot;, ({ value: true })); exports.AnnotationLayerBuilder = void 0; var _pdfjsLib = __webpack_require__(5); var _l10n_utils = __webpack_require__(30); class AnnotationLayerBuilder { constructor({ pageDiv, pdfPage, linkService, downloadManager, annotationStorage = null, imageResourcesPath = &quot;&quot;, renderForms = true, l10n = _l10n_utils.NullL10n, enableScripting = false, hasJSActionsPromise = null, fieldObjectsPromise = null, mouseState = null, annotationCanvasMap = null, accessibilityManager = null }) { this.pageDiv = pageDiv; this.pdfPage = pdfPage; this.linkService = linkService; this.downloadManager = downloadManager; this.imageResourcesPath = imageResourcesPath; this.renderForms = renderForms; this.l10n = l10n; this.annotationStorage = annotationStorage; this.enableScripting = enableScripting; this._hasJSActionsPromise = hasJSActionsPromise; this._fieldObjectsPromise = fieldObjectsPromise; this._mouseState = mouseState; this._annotationCanvasMap = annotationCanvasMap; this._accessibilityManager = accessibilityManager; this.div = null; this._cancelled = false; } async render(viewport, intent = &quot;display&quot;) { const [annotations, hasJSActions = false, fieldObjects = null] = await Promise.all([this.pdfPage.getAnnotations({ intent }), this._hasJSActionsPromise, this._fieldObjectsPromise]); if (this._cancelled || annotations.length === 0) { return; } const parameters = { viewport: viewport.clone({ dontFlip: true }), div: this.div, annotations, page: this.pdfPage, imageResourcesPath: this.imageResourcesPath, renderForms: this.renderForms, linkService: this.linkService, downloadManager: this.downloadManager, annotationStorage: this.annotationStorage, enableScripting: this.enableScripting, hasJSActions, fieldObjects, mouseState: this._mouseState, annotationCanvasMap: this._annotationCanvasMap, accessibilityManager: this._accessibilityManager }; if (this.div) { _pdfjsLib.AnnotationLayer.update(parameters); } else { this.div = document.createElement(&quot;div&quot;); this.div.className = &quot;annotationLayer&quot;; this.pageDiv.append(this.div); parameters.div = this.div; _pdfjsLib.AnnotationLayer.render(parameters); this.l10n.translate(this.div); } } cancel() { this._cancelled = true; } hide() { if (!this.div) { return; } this.div.hidden = true; } } exports.AnnotationLayerBuilder = AnnotationLayerBuilder; /***/ }), /* 32 */ /***/ ((__unused_webpack_module, exports, __webpack_require__) =&gt; { Object.defineProperty(exports, &quot;__esModule&quot;, ({ value: true })); exports.PDFPageView = void 0; var _pdfjsLib = __webpack_require__(5); var _ui_utils = __webpack_require__(1); var _app_options = __webpack_require__(2); var _l10n_utils = __webpack_require__(30); var _text_accessibility = __webpack_require__(33); const MAX_CANVAS_PIXELS = _app_options.compatibilityParams.maxCanvasPixels || 16777216; class PDFPageView { #annotationMode = _pdfjsLib.AnnotationMode.ENABLE_FORMS; #useThumbnailCanvas = { initialOptionalContent: true, regularAnnotations: true }; constructor(options) { const container = options.container; const defaultViewport = options.defaultViewport; this.id = options.id; this.renderingId = &quot;page&quot; + this.id; this.pdfPage = null; this.pageLabel = null; this.rotation = 0; this.scale = options.scale || _ui_utils.DEFAULT_SCALE; this.viewport = defaultViewport; this.pdfPageRotate = defaultViewport.rotation; this._optionalContentConfigPromise = options.optionalContentConfigPromise || null; this.hasRestrictedScaling = false; this.textLayerMode = options.textLayerMode ?? _ui_utils.TextLayerMode.ENABLE; this.#annotationMode = options.annotationMode ?? _pdfjsLib.AnnotationMode.ENABLE_FORMS; this.imageResourcesPath = options.imageResourcesPath || &quot;&quot;; this.useOnlyCssZoom = options.useOnlyCssZoom || false; this.maxCanvasPixels = options.maxCanvasPixels || MAX_CANVAS_PIXELS; this.pageColors = options.pageColors || null; this.eventBus = options.eventBus; this.renderingQueue = options.renderingQueue; this.textLayerFactory = options.textLayerFactory; this.annotationLayerFactory = options.annotationLayerFactory; this.annotationEditorLayerFactory = options.annotationEditorLayerFactory; this.xfaLayerFactory = options.xfaLayerFactory; this.textHighlighter = options.textHighlighterFactory?.createTextHighlighter({ pageIndex: this.id - 1, eventBus: this.eventBus }); this.structTreeLayerFactory = options.structTreeLayerFactory; this.renderer = options.renderer || _ui_utils.RendererType.CANVAS; this.l10n = options.l10n || _l10n_utils.NullL10n; this.paintTask = null; this.paintedViewportMap = new WeakMap(); this.renderingState = _ui_utils.RenderingStates.INITIAL; this.resume = null; this._renderError = null; this._isStandalone = !this.renderingQueue?.hasViewer(); this._annotationCanvasMap = null; this.annotationLayer = null; this.annotationEditorLayer = null; this.textLayer = null; this.zoomLayer = null; this.xfaLayer = null; this.structTreeLayer = null; const div = document.createElement(&quot;div&quot;); div.className = &quot;page&quot;; div.style.width = Math.floor(this.viewport.width) + &quot;px&quot;; div.style.height = Math.floor(this.viewport.height) + &quot;px&quot;; div.setAttribute(&quot;data-page-number&quot;, this.id); div.setAttribute(&quot;role&quot;, &quot;region&quot;); this.l10n.get(&quot;page_landmark&quot;, { page: this.id }).then(msg =&gt; { div.setAttribute(&quot;aria-label&quot;, msg); }); this.div = div; container?.append(div); if (this._isStandalone) { const { optionalContentConfigPromise } = options; if (optionalContentConfigPromise) { optionalContentConfigPromise.then(optionalContentConfig =&gt; { if (optionalContentConfigPromise !== this._optionalContentConfigPromise) { return; } this.#useThumbnailCanvas.initialOptionalContent = optionalContentConfig.hasInitialVisibility; }); } } } setPdfPage(pdfPage) { this.pdfPage = pdfPage; this.pdfPageRotate = pdfPage.rotate; const totalRotation = (this.rotation + this.pdfPageRotate) % 360; this.viewport = pdfPage.getViewport({ scale: this.scale * _pdfjsLib.PixelsPerInch.PDF_TO_CSS_UNITS, rotation: totalRotation }); this.reset(); } destroy() { this.reset(); this.pdfPage?.cleanup(); } async _renderAnnotationLayer() { let error = null; try { await this.annotationLayer.render(this.viewport, &quot;display&quot;); } catch (ex) { console.error(`_renderAnnotationLayer: &quot;${ex}&quot;.`); error = ex; } finally { this.eventBus.dispatch(&quot;annotationlayerrendered&quot;, { source: this, pageNumber: this.id, error }); } } async _renderAnnotationEditorLayer() { let error = null; try { await this.annotationEditorLayer.render(this.viewport, &quot;display&quot;); } catch (ex) { console.error(`_renderAnnotationEditorLayer: &quot;${ex}&quot;.`); error = ex; } finally { this.eventBus.dispatch(&quot;annotationeditorlayerrendered&quot;, { source: this, pageNumber: this.id, error }); } } async _renderXfaLayer() { let error = null; try { const result = await this.xfaLayer.render(this.viewport, &quot;display&quot;); if (result?.textDivs &amp;&amp; this.textHighlighter) { this._buildXfaTextContentItems(result.textDivs); } } catch (ex) { console.error(`_renderXfaLayer: &quot;${ex}&quot;.`); error = ex; } finally { this.eventBus.dispatch(&quot;xfalayerrendered&quot;, { source: this, pageNumber: this.id, error }); } } async _buildXfaTextContentItems(textDivs) { const text = await this.pdfPage.getTextContent(); const items = []; for (const item of text.items) { items.push(item.str); } this.textHighlighter.setTextMapping(textDivs, items); this.textHighlighter.enable(); } _resetZoomLayer(removeFromDOM = false) { if (!this.zoomLayer) { return; } const zoomLayerCanvas = this.zoomLayer.firstChild; this.paintedViewportMap.delete(zoomLayerCanvas); zoomLayerCanvas.width = 0; zoomLayerCanvas.height = 0; if (removeFromDOM) { this.zoomLayer.remove(); } this.zoomLayer = null; } reset({ keepZoomLayer = false, keepAnnotationLayer = false, keepAnnotationEditorLayer = false, keepXfaLayer = false } = {}) { this.cancelRendering({ keepAnnotationLayer, keepAnnotationEditorLayer, keepXfaLayer }); this.renderingState = _ui_utils.RenderingStates.INITIAL; const div = this.div; div.style.width = Math.floor(this.viewport.width) + &quot;px&quot;; div.style.height = Math.floor(this.viewport.height) + &quot;px&quot;; const childNodes = div.childNodes, zoomLayerNode = keepZoomLayer &amp;&amp; this.zoomLayer || null, annotationLayerNode = keepAnnotationLayer &amp;&amp; this.annotationLayer?.div || null, annotationEditorLayerNode = keepAnnotationEditorLayer &amp;&amp; this.annotationEditorLayer?.div || null, xfaLayerNode = keepXfaLayer &amp;&amp; this.xfaLayer?.div || null; for (let i = childNodes.length - 1; i &gt;= 0; i--) { const node = childNodes[i]; switch (node) { case zoomLayerNode: case annotationLayerNode: case annotationEditorLayerNode: case xfaLayerNode: continue; } node.remove(); } div.removeAttribute(&quot;data-loaded&quot;); if (annotationLayerNode) { this.annotationLayer.hide(); } if (annotationEditorLayerNode) { this.annotationEditorLayer.hide(); } else { this.annotationEditorLayer?.destroy(); } if (xfaLayerNode) { this.xfaLayer.hide(); } if (!zoomLayerNode) { if (this.canvas) { this.paintedViewportMap.delete(this.canvas); this.canvas.width = 0; this.canvas.height = 0; delete this.canvas; } this._resetZoomLayer(); } if (this.svg) { this.paintedViewportMap.delete(this.svg); delete this.svg; } this.loadingIconDiv = document.createElement(&quot;div&quot;); this.loadingIconDiv.className = &quot;loadingIcon notVisible&quot;; if (this._isStandalone) { this.toggleLoadingIconSpinner(true); } this.loadingIconDiv.setAttribute(&quot;role&quot;, &quot;img&quot;); this.l10n.get(&quot;loading&quot;).then(msg =&gt; { this.loadingIconDiv?.setAttribute(&quot;aria-label&quot;, msg); }); div.append(this.loadingIconDiv); } update({ scale = 0, rotation = null, optionalContentConfigPromise = null }) { this.scale = scale || this.scale; if (typeof rotation === &quot;number&quot;) { this.rotation = rotation; } if (optionalContentConfigPromise instanceof Promise) { this._optionalContentConfigPromise = optionalContentConfigPromise; optionalContentConfigPromise.then(optionalContentConfig =&gt; { if (optionalContentConfigPromise !== this._optionalContentConfigPromise) { return; } this.#useThumbnailCanvas.initialOptionalContent = optionalContentConfig.hasInitialVisibility; }); } const totalRotation = (this.rotation + this.pdfPageRotate) % 360; this.viewport = this.viewport.clone({ scale: this.scale * _pdfjsLib.PixelsPerInch.PDF_TO_CSS_UNITS, rotation: totalRotation }); if (this._isStandalone) { _ui_utils.docStyle.setProperty(&quot;--scale-factor&quot;, this.viewport.scale); } if (this.svg) { this.cssTransform({ target: this.svg, redrawAnnotationLayer: true, redrawAnnotationEditorLayer: true, redrawXfaLayer: true }); this.eventBus.dispatch(&quot;pagerendered&quot;, { source: this, pageNumber: this.id, cssTransform: true, timestamp: performance.now(), error: this._renderError }); return; } let isScalingRestricted = false; if (this.canvas &amp;&amp; this.maxCanvasPixels &gt; 0) { const outputScale = this.outputScale; if ((Math.floor(this.viewport.width) * outputScale.sx | 0) * (Math.floor(this.viewport.height) * outputScale.sy | 0) &gt; this.maxCanvasPixels) { isScalingRestricted = true; } } if (this.canvas) { if (this.useOnlyCssZoom || this.hasRestrictedScaling &amp;&amp; isScalingRestricted) { this.cssTransform({ target: this.canvas, redrawAnnotationLayer: true, redrawAnnotationEditorLayer: true, redrawXfaLayer: true }); this.eventBus.dispatch(&quot;pagerendered&quot;, { source: this, pageNumber: this.id, cssTransform: true, timestamp: performance.now(), error: this._renderError }); return; } if (!this.zoomLayer &amp;&amp; !this.canvas.hidden) { this.zoomLayer = this.canvas.parentNode; this.zoomLayer.style.position = &quot;absolute&quot;; } } if (this.zoomLayer) { this.cssTransform({ target: this.zoomLayer.firstChild }); } this.reset({ keepZoomLayer: true, keepAnnotationLayer: true, keepAnnotationEditorLayer: true, keepXfaLayer: true }); } cancelRendering({ keepAnnotationLayer = false, keepAnnotationEditorLayer = false, keepXfaLayer = false } = {}) { if (this.paintTask) { this.paintTask.cancel(); this.paintTask = null; } this.resume = null; if (this.textLayer) { this.textLayer.cancel(); this.textLayer = null; } if (this.annotationLayer &amp;&amp; (!keepAnnotationLayer || !this.annotationLayer.div)) { this.annotationLayer.cancel(); this.annotationLayer = null; this._annotationCanvasMap = null; } if (this.annotationEditorLayer &amp;&amp; (!keepAnnotationEditorLayer || !this.annotationEditorLayer.div)) { this.annotationEditorLayer.cancel(); this.annotationEditorLayer = null; } if (this.xfaLayer &amp;&amp; (!keepXfaLayer || !this.xfaLayer.div)) { this.xfaLayer.cancel(); this.xfaLayer = null; this.textHighlighter?.disable(); } if (this._onTextLayerRendered) { this.eventBus._off(&quot;textlayerrendered&quot;, this._onTextLayerRendered); this._onTextLayerRendered = null; } } cssTransform({ target, redrawAnnotationLayer = false, redrawAnnotationEditorLayer = false, redrawXfaLayer = false }) { const width = this.viewport.width; const height = this.viewport.height; const div = this.div; target.style.width = target.parentNode.style.width = div.style.width = Math.floor(width) + &quot;px&quot;; target.style.height = target.parentNode.style.height = div.style.height = Math.floor(height) + &quot;px&quot;; const relativeRotation = this.viewport.rotation - this.paintedViewportMap.get(target).rotation; const absRotation = Math.abs(relativeRotation); let scaleX = 1, scaleY = 1; if (absRotation === 90 || absRotation === 270) { scaleX = height / width; scaleY = width / height; } target.style.transform = `rotate(${relativeRotation}deg) scale(${scaleX}, ${scaleY})`; if (this.textLayer) { const textLayerViewport = this.textLayer.viewport; const textRelativeRotation = this.viewport.rotation - textLayerViewport.rotation; const textAbsRotation = Math.abs(textRelativeRotation); let scale = width / textLayerViewport.width; if (textAbsRotation === 90 || textAbsRotation === 270) { scale = width / textLayerViewport.height; } const textLayerDiv = this.textLayer.textLayerDiv; let transX, transY; switch (textAbsRotation) { case 0: transX = transY = 0; break; case 90: transX = 0; transY = &quot;-&quot; + textLayerDiv.style.height; break; case 180: transX = &quot;-&quot; + textLayerDiv.style.width; transY = &quot;-&quot; + textLayerDiv.style.height; break; case 270: transX = &quot;-&quot; + textLayerDiv.style.width; transY = 0; break; default: console.error(&quot;Bad rotation value.&quot;); break; } textLayerDiv.style.transform = `rotate(${textAbsRotation}deg) ` + `scale(${scale}) ` + `translate(${transX}, ${transY})`; textLayerDiv.style.transformOrigin = &quot;0% 0%&quot;; } if (redrawAnnotationLayer &amp;&amp; this.annotationLayer) { this._renderAnnotationLayer(); } if (redrawAnnotationEditorLayer &amp;&amp; this.annotationEditorLayer) { this._renderAnnotationEditorLayer(); } if (redrawXfaLayer &amp;&amp; this.xfaLayer) { this._renderXfaLayer(); } } get width() { return this.viewport.width; } get height() { return this.viewport.height; } getPagePoint(x, y) { return this.viewport.convertToPdfPoint(x, y); } toggleLoadingIconSpinner(viewVisible = false) { this.loadingIconDiv?.classList.toggle(&quot;notVisible&quot;, !viewVisible); } draw() { if (this.renderingState !== _ui_utils.RenderingStates.INITIAL) { console.error(&quot;Must be in new state before drawing&quot;); this.reset(); } const { div, pdfPage } = this; if (!pdfPage) { this.renderingState = _ui_utils.RenderingStates.FINISHED; if (this.loadingIconDiv) { this.loadingIconDiv.remove(); delete this.loadingIconDiv; } return Promise.reject(new Error(&quot;pdfPage is not loaded&quot;)); } this.renderingState = _ui_utils.RenderingStates.RUNNING; const canvasWrapper = document.createElement(&quot;div&quot;); canvasWrapper.style.width = div.style.width; canvasWrapper.style.height = div.style.height; canvasWrapper.classList.add(&quot;canvasWrapper&quot;); const lastDivBeforeTextDiv = this.annotationLayer?.div || this.annotationEditorLayer?.div; if (lastDivBeforeTextDiv) { lastDivBeforeTextDiv.before(canvasWrapper); } else { div.append(canvasWrapper); } let textLayer = null; if (this.textLayerMode !== _ui_utils.TextLayerMode.DISABLE &amp;&amp; this.textLayerFactory) { this._accessibilityManager ||= new _text_accessibility.TextAccessibilityManager(); const textLayerDiv = document.createElement(&quot;div&quot;); textLayerDiv.className = &quot;textLayer&quot;; textLayerDiv.style.width = canvasWrapper.style.width; textLayerDiv.style.height = canvasWrapper.style.height; if (lastDivBeforeTextDiv) { lastDivBeforeTextDiv.before(textLayerDiv); } else { div.append(textLayerDiv); } textLayer = this.textLayerFactory.createTextLayerBuilder({ textLayerDiv, pageIndex: this.id - 1, viewport: this.viewport, eventBus: this.eventBus, highlighter: this.textHighlighter, accessibilityManager: this._accessibilityManager }); } this.textLayer = textLayer; if (this.#annotationMode !== _pdfjsLib.AnnotationMode.DISABLE &amp;&amp; this.annotationLayerFactory) { this._annotationCanvasMap ||= new Map(); this.annotationLayer ||= this.annotationLayerFactory.createAnnotationLayerBuilder({ pageDiv: div, pdfPage, imageResourcesPath: this.imageResourcesPath, renderForms: this.#annotationMode === _pdfjsLib.AnnotationMode.ENABLE_FORMS, l10n: this.l10n, annotationCanvasMap: this._annotationCanvasMap, accessibilityManager: this._accessibilityManager }); } if (this.xfaLayer?.div) { div.append(this.xfaLayer.div); } let renderContinueCallback = null; if (this.renderingQueue) { renderContinueCallback = cont =&gt; { if (!this.renderingQueue.isHighestPriority(this)) { this.renderingState = _ui_utils.RenderingStates.PAUSED; this.resume = () =&gt; { this.renderingState = _ui_utils.RenderingStates.RUNNING; cont(); }; return; } cont(); }; } const finishPaintTask = async (error = null) =&gt; { if (paintTask === this.paintTask) { this.paintTask = null; } if (error instanceof _pdfjsLib.RenderingCancelledException) { this._renderError = null; return; } this._renderError = error; this.renderingState = _ui_utils.RenderingStates.FINISHED; if (this.loadingIconDiv) { this.loadingIconDiv.remove(); delete this.loadingIconDiv; } this._resetZoomLayer(true); this.#useThumbnailCanvas.regularAnnotations = !paintTask.separateAnnots; this.eventBus.dispatch(&quot;pagerendered&quot;, { source: this, pageNumber: this.id, cssTransform: false, timestamp: performance.now(), error: this._renderError }); if (error) { throw error; } }; const paintTask = this.renderer === _ui_utils.RendererType.SVG ? this.paintOnSvg(canvasWrapper) : this.paintOnCanvas(canvasWrapper); paintTask.onRenderContinue = renderContinueCallback; this.paintTask = paintTask; const resultPromise = paintTask.promise.then(() =&gt; { return finishPaintTask(null).then(() =&gt; { if (textLayer) { const readableStream = pdfPage.streamTextContent({ includeMarkedContent: true }); textLayer.setTextContentStream(readableStream); textLayer.render(); } if (this.annotationLayer) { this._renderAnnotationLayer().then(() =&gt; { if (this.annotationEditorLayerFactory) { this.annotationEditorLayer ||= this.annotationEditorLayerFactory.createAnnotationEditorLayerBuilder({ pageDiv: div, pdfPage, l10n: this.l10n, accessibilityManager: this._accessibilityManager }); this._renderAnnotationEditorLayer(); } }); } }); }, function (reason) { return finishPaintTask(reason); }); if (this.xfaLayerFactory) { this.xfaLayer ||= this.xfaLayerFactory.createXfaLayerBuilder({ pageDiv: div, pdfPage }); this._renderXfaLayer(); } if (this.structTreeLayerFactory &amp;&amp; this.textLayer &amp;&amp; this.canvas) { this._onTextLayerRendered = event =&gt; { if (event.pageNumber !== this.id) { return; } this.eventBus._off(&quot;textlayerrendered&quot;, this._onTextLayerRendered); this._onTextLayerRendered = null; if (!this.canvas) { return; } this.pdfPage.getStructTree().then(tree =&gt; { if (!tree) { return; } if (!this.canvas) { return; } const treeDom = this.structTreeLayer.render(tree); treeDom.classList.add(&quot;structTree&quot;); this.canvas.append(treeDom); }); }; this.eventBus._on(&quot;textlayerrendered&quot;, this._onTextLayerRendered); this.structTreeLayer = this.structTreeLayerFactory.createStructTreeLayerBuilder({ pdfPage }); } div.setAttribute(&quot;data-loaded&quot;, true); this.eventBus.dispatch(&quot;pagerender&quot;, { source: this, pageNumber: this.id }); return resultPromise; } paintOnCanvas(canvasWrapper) { const renderCapability = (0, _pdfjsLib.createPromiseCapability)(); const result = { promise: renderCapability.promise, onRenderContinue(cont) { cont(); }, cancel() { renderTask.cancel(); }, get separateAnnots() { return renderTask.separateAnnots; } }; const viewport = this.viewport; const canvas = document.createElement(&quot;canvas&quot;); canvas.setAttribute(&quot;role&quot;, &quot;presentation&quot;); canvas.hidden = true; let isCanvasHidden = true; const showCanvas = function () { if (isCanvasHidden) { canvas.hidden = false; isCanvasHidden = false; } }; canvasWrapper.append(canvas); this.canvas = canvas; const ctx = canvas.getContext(&quot;2d&quot;, { alpha: false }); const outputScale = this.outputScale = new _ui_utils.OutputScale(); if (this.useOnlyCssZoom) { const actualSizeViewport = viewport.clone({ scale: _pdfjsLib.PixelsPerInch.PDF_TO_CSS_UNITS }); outputScale.sx *= actualSizeViewport.width / viewport.width; outputScale.sy *= actualSizeViewport.height / viewport.height; } if (this.maxCanvasPixels &gt; 0) { const pixelsInViewport = viewport.width * viewport.height; const maxScale = Math.sqrt(this.maxCanvasPixels / pixelsInViewport); if (outputScale.sx &gt; maxScale || outputScale.sy &gt; maxScale) { outputScale.sx = maxScale; outputScale.sy = maxScale; this.hasRestrictedScaling = true; } else { this.hasRestrictedScaling = false; } } const sfx = (0, _ui_utils.approximateFraction)(outputScale.sx); const sfy = (0, _ui_utils.approximateFraction)(outputScale.sy); canvas.width = (0, _ui_utils.roundToDivide)(viewport.width * outputScale.sx, sfx[0]); canvas.height = (0, _ui_utils.roundToDivide)(viewport.height * outputScale.sy, sfy[0]); canvas.style.width = (0, _ui_utils.roundToDivide)(viewport.width, sfx[1]) + &quot;px&quot;; canvas.style.height = (0, _ui_utils.roundToDivide)(viewport.height, sfy[1]) + &quot;px&quot;; this.paintedViewportMap.set(canvas, viewport); const transform = outputScale.scaled ? [outputScale.sx, 0, 0, outputScale.sy, 0, 0] : null; const renderContext = { canvasContext: ctx, transform, viewport: this.viewport, annotationMode: this.#annotationMode, optionalContentConfigPromise: this._optionalContentConfigPromise, annotationCanvasMap: this._annotationCanvasMap, pageColors: this.pageColors }; const renderTask = this.pdfPage.render(renderContext); renderTask.onContinue = function (cont) { showCanvas(); if (result.onRenderContinue) { result.onRenderContinue(cont); } else { cont(); } }; renderTask.promise.then(function () { showCanvas(); renderCapability.resolve(); }, function (error) { showCanvas(); renderCapability.reject(error); }); return result; } paintOnSvg(wrapper) { let cancelled = false; const ensureNotCancelled = () =&gt; { if (cancelled) { throw new _pdfjsLib.RenderingCancelledException(`Rendering cancelled, page ${this.id}`, &quot;svg&quot;); } }; const pdfPage = this.pdfPage; const actualSizeViewport = this.viewport.clone({ scale: _pdfjsLib.PixelsPerInch.PDF_TO_CSS_UNITS }); const promise = pdfPage.getOperatorList({ annotationMode: this.#annotationMode }).then(opList =&gt; { ensureNotCancelled(); const svgGfx = new _pdfjsLib.SVGGraphics(pdfPage.commonObjs, pdfPage.objs); return svgGfx.getSVG(opList, actualSizeViewport).then(svg =&gt; { ensureNotCancelled(); this.svg = svg; this.paintedViewportMap.set(svg, actualSizeViewport); svg.style.width = wrapper.style.width; svg.style.height = wrapper.style.height; this.renderingState = _ui_utils.RenderingStates.FINISHED; wrapper.append(svg); }); }); return { promise, onRenderContinue(cont) { cont(); }, cancel() { cancelled = true; }, get separateAnnots() { return false; } }; } setPageLabel(label) { this.pageLabel = typeof label === &quot;string&quot; ? label : null; if (this.pageLabel !== null) { this.div.setAttribute(&quot;data-page-label&quot;, this.pageLabel); } else { this.div.removeAttribute(&quot;data-page-label&quot;); } } get thumbnailCanvas() { const { initialOptionalContent, regularAnnotations } = this.#useThumbnailCanvas; return initialOptionalContent &amp;&amp; regularAnnotations ? this.canvas : null; } } exports.PDFPageView = PDFPageView; /***/ }), /* 33 */ /***/ ((__unused_webpack_module, exports, __webpack_require__) =&gt; { Object.defineProperty(exports, &quot;__esModule&quot;, ({ value: true })); exports.TextAccessibilityManager = void 0; var _ui_utils = __webpack_require__(1); class TextAccessibilityManager { #enabled = false; #textChildren = null; #textNodes = new Map(); #waitingElements = new Map(); setTextMapping(textDivs) { this.#textChildren = textDivs; } static #compareElementPositions(e1, e2) { const rect1 = e1.getBoundingClientRect(); const rect2 = e2.getBoundingClientRect(); if (rect1.width === 0 &amp;&amp; rect1.height === 0) { return +1; } if (rect2.width === 0 &amp;&amp; rect2.height === 0) { return -1; } const top1 = rect1.y; const bot1 = rect1.y + rect1.height; const mid1 = rect1.y + rect1.height / 2; const top2 = rect2.y; const bot2 = rect2.y + rect2.height; const mid2 = rect2.y + rect2.height / 2; if (mid1 &lt;= top2 &amp;&amp; mid2 &gt;= bot1) { return -1; } if (mid2 &lt;= top1 &amp;&amp; mid1 &gt;= bot2) { return +1; } const centerX1 = rect1.x + rect1.width / 2; const centerX2 = rect2.x + rect2.width / 2; return centerX1 - centerX2; } enable() { if (this.#enabled) { throw new Error(&quot;TextAccessibilityManager is already enabled.&quot;); } if (!this.#textChildren) { throw new Error(&quot;Text divs and strings have not been set.&quot;); } this.#enabled = true; this.#textChildren = this.#textChildren.slice(); this.#textChildren.sort(TextAccessibilityManager.#compareElementPositions); if (this.#textNodes.size &gt; 0) { const textChildren = this.#textChildren; for (const [id, nodeIndex] of this.#textNodes) { const element = document.getElementById(id); if (!element) { this.#textNodes.delete(id); continue; } this.#addIdToAriaOwns(id, textChildren[nodeIndex]); } } for (const [element, isRemovable] of this.#waitingElements) { this.addPointerInTextLayer(element, isRemovable); } this.#waitingElements.clear(); } disable() { if (!this.#enabled) { return; } this.#waitingElements.clear(); this.#textChildren = null; this.#enabled = false; } removePointerInTextLayer(element) { if (!this.#enabled) { this.#waitingElements.delete(element); return; } const children = this.#textChildren; if (!children || children.length === 0) { return; } const { id } = element; const nodeIndex = this.#textNodes.get(id); if (nodeIndex === undefined) { return; } const node = children[nodeIndex]; this.#textNodes.delete(id); let owns = node.getAttribute(&quot;aria-owns&quot;); if (owns?.includes(id)) { owns = owns.split(&quot; &quot;).filter(x =&gt; x !== id).join(&quot; &quot;); if (owns) { node.setAttribute(&quot;aria-owns&quot;, owns); } else { node.removeAttribute(&quot;aria-owns&quot;); node.setAttribute(&quot;role&quot;, &quot;presentation&quot;); } } } #addIdToAriaOwns(id, node) { const owns = node.getAttribute(&quot;aria-owns&quot;); if (!owns?.includes(id)) { node.setAttribute(&quot;aria-owns&quot;, owns ? `${owns} ${id}` : id); } node.removeAttribute(&quot;role&quot;); } addPointerInTextLayer(element, isRemovable) { const { id } = element; if (!id) { return; } if (!this.#enabled) { this.#waitingElements.set(element, isRemovable); return; } if (isRemovable) { this.removePointerInTextLayer(element); } const children = this.#textChildren; if (!children || children.length === 0) { return; } const index = (0, _ui_utils.binarySearchFirstItem)(children, node =&gt; TextAccessibilityManager.#compareElementPositions(element, node) &lt; 0); const nodeIndex = Math.max(0, index - 1); this.#addIdToAriaOwns(id, children[nodeIndex]); this.#textNodes.set(id, nodeIndex); } moveElementInDOM(container, element, contentElement, isRemovable) { this.addPointerInTextLayer(contentElement, isRemovable); if (!container.hasChildNodes()) { container.append(element); return; } const children = Array.from(container.childNodes).filter(node =&gt; node !== element); if (children.length === 0) { return; } const elementToCompare = contentElement || element; const index = (0, _ui_utils.binarySearchFirstItem)(children, node =&gt; TextAccessibilityManager.#compareElementPositions(elementToCompare, node) &lt; 0); if (index === 0) { children[0].before(element); } else { children[index - 1].after(element); } } } exports.TextAccessibilityManager = TextAccessibilityManager; /***/ }), /* 34 */ /***/ ((__unused_webpack_module, exports) =&gt; { Object.defineProperty(exports, &quot;__esModule&quot;, ({ value: true })); exports.StructTreeLayerBuilder = void 0; const PDF_ROLE_TO_HTML_ROLE = { Document: null, DocumentFragment: null, Part: &quot;group&quot;, Sect: &quot;group&quot;, Div: &quot;group&quot;, Aside: &quot;note&quot;, NonStruct: &quot;none&quot;, P: null, H: &quot;heading&quot;, Title: null, FENote: &quot;note&quot;, Sub: &quot;group&quot;, Lbl: null, Span: null, Em: null, Strong: null, Link: &quot;link&quot;, Annot: &quot;note&quot;, Form: &quot;form&quot;, Ruby: null, RB: null, RT: null, RP: null, Warichu: null, WT: null, WP: null, L: &quot;list&quot;, LI: &quot;listitem&quot;, LBody: null, Table: &quot;table&quot;, TR: &quot;row&quot;, TH: &quot;columnheader&quot;, TD: &quot;cell&quot;, THead: &quot;columnheader&quot;, TBody: null, TFoot: null, Caption: null, Figure: &quot;figure&quot;, Formula: null, Artifact: null }; const HEADING_PATTERN = /^H(\\d+)$/; class StructTreeLayerBuilder { constructor({ pdfPage }) { this.pdfPage = pdfPage; } render(structTree) { return this._walk(structTree); } _setAttributes(structElement, htmlElement) { if (structElement.alt !== undefined) { htmlElement.setAttribute(&quot;aria-label&quot;, structElement.alt); } if (structElement.id !== undefined) { htmlElement.setAttribute(&quot;aria-owns&quot;, structElement.id); } if (structElement.lang !== undefined) { htmlElement.setAttribute(&quot;lang&quot;, structElement.lang); } } _walk(node) { if (!node) { return null; } const element = document.createElement(&quot;span&quot;); if (&quot;role&quot; in node) { const { role } = node; const match = role.match(HEADING_PATTERN); if (match) { element.setAttribute(&quot;role&quot;, &quot;heading&quot;); element.setAttribute(&quot;aria-level&quot;, match[1]); } else if (PDF_ROLE_TO_HTML_ROLE[role]) { element.setAttribute(&quot;role&quot;, PDF_ROLE_TO_HTML_ROLE[role]); } } this._setAttributes(node, element); if (node.children) { if (node.children.length === 1 &amp;&amp; &quot;id&quot; in node.children[0]) { this._setAttributes(node.children[0], element); } else { for (const kid of node.children) { element.append(this._walk(kid)); } } } return element; } } exports.StructTreeLayerBuilder = StructTreeLayerBuilder; /***/ }), /* 35 */ /***/ ((__unused_webpack_module, exports) =&gt; { Object.defineProperty(exports, &quot;__esModule&quot;, ({ value: true })); exports.TextHighlighter = void 0; class TextHighlighter { constructor({ findController, eventBus, pageIndex }) { this.findController = findController; this.matches = []; this.eventBus = eventBus; this.pageIdx = pageIndex; this._onUpdateTextLayerMatches = null; this.textDivs = null; this.textContentItemsStr = null; this.enabled = false; } setTextMapping(divs, texts) { this.textDivs = divs; this.textContentItemsStr = texts; } enable() { if (!this.textDivs || !this.textContentItemsStr) { throw new Error(&quot;Text divs and strings have not been set.&quot;); } if (this.enabled) { throw new Error(&quot;TextHighlighter is already enabled.&quot;); } this.enabled = true; if (!this._onUpdateTextLayerMatches) { this._onUpdateTextLayerMatches = evt =&gt; { if (evt.pageIndex === this.pageIdx || evt.pageIndex === -1) { this._updateMatches(); } }; this.eventBus._on(&quot;updatetextlayermatches&quot;, this._onUpdateTextLayerMatches); } this._updateMatches(); } disable() { if (!this.enabled) { return; } this.enabled = false; if (this._onUpdateTextLayerMatches) { this.eventBus._off(&quot;updatetextlayermatches&quot;, this._onUpdateTextLayerMatches); this._onUpdateTextLayerMatches = null; } } _convertMatches(matches, matchesLength) { if (!matches) { return []; } const { textContentItemsStr } = this; let i = 0, iIndex = 0; const end = textContentItemsStr.length - 1; const result = []; for (let m = 0, mm = matches.length; m &lt; mm; m++) { let matchIdx = matches[m]; while (i !== end &amp;&amp; matchIdx &gt;= iIndex + textContentItemsStr[i].length) { iIndex += textContentItemsStr[i].length; i++; } if (i === textContentItemsStr.length) { console.error(&quot;Could not find a matching mapping&quot;); } const match = { begin: { divIdx: i, offset: matchIdx - iIndex } }; matchIdx += matchesLength[m]; while (i !== end &amp;&amp; matchIdx &gt; iIndex + textContentItemsStr[i].length) { iIndex += textContentItemsStr[i].length; i++; } match.end = { divIdx: i, offset: matchIdx - iIndex }; result.push(match); } return result; } _renderMatches(matches) { if (matches.length === 0) { return; } const { findController, pageIdx } = this; const { textContentItemsStr, textDivs } = this; const isSelectedPage = pageIdx === findController.selected.pageIdx; const selectedMatchIdx = findController.selected.matchIdx; const highlightAll = findController.state.highlightAll; let prevEnd = null; const infinity = { divIdx: -1, offset: undefined }; function beginText(begin, className) { const divIdx = begin.divIdx; textDivs[divIdx].textContent = &quot;&quot;; return appendTextToDiv(divIdx, 0, begin.offset, className); } function appendTextToDiv(divIdx, fromOffset, toOffset, className) { let div = textDivs[divIdx]; if (div.nodeType === Node.TEXT_NODE) { const span = document.createElement(&quot;span&quot;); div.before(span); span.append(div); textDivs[divIdx] = span; div = span; } const content = textContentItemsStr[divIdx].substring(fromOffset, toOffset); const node = document.createTextNode(content); if (className) { const span = document.createElement(&quot;span&quot;); span.className = `${className} appended`; span.append(node); div.append(span); return className.includes(&quot;selected&quot;) ? span.offsetLeft : 0; } div.append(node); return 0; } let i0 = selectedMatchIdx, i1 = i0 + 1; if (highlightAll) { i0 = 0; i1 = matches.length; } else if (!isSelectedPage) { return; } for (let i = i0; i &lt; i1; i++) { const match = matches[i]; const begin = match.begin; const end = match.end; const isSelected = isSelectedPage &amp;&amp; i === selectedMatchIdx; const highlightSuffix = isSelected ? &quot; selected&quot; : &quot;&quot;; let selectedLeft = 0; if (!prevEnd || begin.divIdx !== prevEnd.divIdx) { if (prevEnd !== null) { appendTextToDiv(prevEnd.divIdx, prevEnd.offset, infinity.offset); } beginText(begin); } else { appendTextToDiv(prevEnd.divIdx, prevEnd.offset, begin.offset); } if (begin.divIdx === end.divIdx) { selectedLeft = appendTextToDiv(begin.divIdx, begin.offset, end.offset, &quot;highlight&quot; + highlightSuffix); } else { selectedLeft = appendTextToDiv(begin.divIdx, begin.offset, infinity.offset, &quot;highlight begin&quot; + highlightSuffix); for (let n0 = begin.divIdx + 1, n1 = end.divIdx; n0 &lt; n1; n0++) { textDivs[n0].className = &quot;highlight middle&quot; + highlightSuffix; } beginText(end, &quot;highlight end&quot; + highlightSuffix); } prevEnd = end; if (isSelected) { findController.scrollMatchIntoView({ element: textDivs[begin.divIdx], selectedLeft, pageIndex: pageIdx, matchIndex: selectedMatchIdx }); } } if (prevEnd) { appendTextToDiv(prevEnd.divIdx, prevEnd.offset, infinity.offset); } } _updateMatches() { if (!this.enabled) { return; } const { findController, matches, pageIdx } = this; const { textContentItemsStr, textDivs } = this; let clearedUntilDivIdx = -1; for (const match of matches) { const begin = Math.max(clearedUntilDivIdx, match.begin.divIdx); for (let n = begin, end = match.end.divIdx; n &lt;= end; n++) { const div = textDivs[n]; div.textContent = textContentItemsStr[n]; div.className = &quot;&quot;; } clearedUntilDivIdx = match.end.divIdx + 1; } if (!findController?.highlightMatches) { return; } const pageMatches = findController.pageMatches[pageIdx] || null; const pageMatchesLength = findController.pageMatchesLength[pageIdx] || null; this.matches = this._convertMatches(pageMatches, pageMatchesLength); this._renderMatches(this.matches); } } exports.TextHighlighter = TextHighlighter; /***/ }), /* 36 */ /***/ ((__unused_webpack_module, exports, __webpack_require__) =&gt; { Object.defineProperty(exports, &quot;__esModule&quot;, ({ value: true })); exports.TextLayerBuilder = void 0; var _pdfjsLib = __webpack_require__(5); class TextLayerBuilder { constructor({ textLayerDiv, eventBus, pageIndex, viewport, highlighter = null, accessibilityManager = null }) { this.textLayerDiv = textLayerDiv; this.eventBus = eventBus; this.textContent = null; this.textContentItemsStr = []; this.textContentStream = null; this.renderingDone = false; this.pageNumber = pageIndex + 1; this.viewport = viewport; this.textDivs = []; this.textLayerRenderTask = null; this.highlighter = highlighter; this.accessibilityManager = accessibilityManager; this.#bindMouse(); } #finishRendering() { this.renderingDone = true; const endOfContent = document.createElement(&quot;div&quot;); endOfContent.className = &quot;endOfContent&quot;; this.textLayerDiv.append(endOfContent); this.eventBus.dispatch(&quot;textlayerrendered&quot;, { source: this, pageNumber: this.pageNumber, numTextDivs: this.textDivs.length }); } render(timeout = 0) { if (!(this.textContent || this.textContentStream) || this.renderingDone) { return; } this.cancel(); this.textDivs.length = 0; this.highlighter?.setTextMapping(this.textDivs, this.textContentItemsStr); this.accessibilityManager?.setTextMapping(this.textDivs); const textLayerFrag = document.createDocumentFragment(); this.textLayerRenderTask = (0, _pdfjsLib.renderTextLayer)({ textContent: this.textContent, textContentStream: this.textContentStream, container: textLayerFrag, viewport: this.viewport, textDivs: this.textDivs, textContentItemsStr: this.textContentItemsStr, timeout }); this.textLayerRenderTask.promise.then(() =&gt; { this.textLayerDiv.append(textLayerFrag); this.#finishRendering(); this.highlighter?.enable(); this.accessibilityManager?.enable(); }, function (reason) {}); } cancel() { if (this.textLayerRenderTask) { this.textLayerRenderTask.cancel(); this.textLayerRenderTask = null; } this.highlighter?.disable(); this.accessibilityManager?.disable(); } setTextContentStream(readableStream) { this.cancel(); this.textContentStream = readableStream; } setTextContent(textContent) { this.cancel(); this.textContent = textContent; } #bindMouse() { const div = this.textLayerDiv; div.addEventListener(&quot;mousedown&quot;, evt =&gt; { const end = div.querySelector(&quot;.endOfContent&quot;); if (!end) { return; } let adjustTop = evt.target !== div; adjustTop &amp;&amp;= getComputedStyle(end).getPropertyValue(&quot;-moz-user-select&quot;) !== &quot;none&quot;; if (adjustTop) { const divBounds = div.getBoundingClientRect(); const r = Math.max(0, (evt.pageY - divBounds.top) / divBounds.height); end.style.top = (r * 100).toFixed(2) + &quot;%&quot;; } end.classList.add(&quot;active&quot;); }); div.addEventListener(&quot;mouseup&quot;, () =&gt; { const end = div.querySelector(&quot;.endOfContent&quot;); if (!end) { return; } end.style.top = &quot;&quot;; end.classList.remove(&quot;active&quot;); }); } } exports.TextLayerBuilder = TextLayerBuilder; /***/ }), /* 37 */ /***/ ((__unused_webpack_module, exports, __webpack_require__) =&gt; { Object.defineProperty(exports, &quot;__esModule&quot;, ({ value: true })); exports.XfaLayerBuilder = void 0; var _pdfjsLib = __webpack_require__(5); class XfaLayerBuilder { constructor({ pageDiv, pdfPage, annotationStorage = null, linkService, xfaHtml = null }) { this.pageDiv = pageDiv; this.pdfPage = pdfPage; this.annotationStorage = annotationStorage; this.linkService = linkService; this.xfaHtml = xfaHtml; this.div = null; this._cancelled = false; } render(viewport, intent = &quot;display&quot;) { if (intent === &quot;print&quot;) { const parameters = { viewport: viewport.clone({ dontFlip: true }), div: this.div, xfaHtml: this.xfaHtml, annotationStorage: this.annotationStorage, linkService: this.linkService, intent }; const div = document.createElement(&quot;div&quot;); this.pageDiv.append(div); parameters.div = div; const result = _pdfjsLib.XfaLayer.render(parameters); return Promise.resolve(result); } return this.pdfPage.getXfa().then(xfaHtml =&gt; { if (this._cancelled || !xfaHtml) { return { textDivs: [] }; } const parameters = { viewport: viewport.clone({ dontFlip: true }), div: this.div, xfaHtml, annotationStorage: this.annotationStorage, linkService: this.linkService, intent }; if (this.div) { return _pdfjsLib.XfaLayer.update(parameters); } this.div = document.createElement(&quot;div&quot;); this.pageDiv.append(this.div); parameters.div = this.div; return _pdfjsLib.XfaLayer.render(parameters); }).catch(error =&gt; { console.error(error); }); } cancel() { this._cancelled = true; } hide() { if (!this.div) { return; } this.div.hidden = true; } } exports.XfaLayerBuilder = XfaLayerBuilder; /***/ }), /* 38 */ /***/ ((__unused_webpack_module, exports, __webpack_require__) =&gt; { Object.defineProperty(exports, &quot;__esModule&quot;, ({ value: true })); exports.SecondaryToolbar = void 0; var _ui_utils = __webpack_require__(1); var _pdf_cursor_tools = __webpack_require__(7); var _pdf_viewer = __webpack_require__(28); class SecondaryToolbar { constructor(options, eventBus, externalServices) { this.toolbar = options.toolbar; this.toggleButton = options.toggleButton; this.buttons = [{ element: options.presentationModeButton, eventName: &quot;presentationmode&quot;, close: true }, { element: options.printButton, eventName: &quot;print&quot;, close: true }, { element: options.downloadButton, eventName: &quot;download&quot;, close: true }, { element: options.viewBookmarkButton, eventName: null, close: true }, { element: options.firstPageButton, eventName: &quot;firstpage&quot;, close: true }, { element: options.lastPageButton, eventName: &quot;lastpage&quot;, close: true }, { element: options.pageRotateCwButton, eventName: &quot;rotatecw&quot;, close: false }, { element: options.pageRotateCcwButton, eventName: &quot;rotateccw&quot;, close: false }, { element: options.cursorSelectToolButton, eventName: &quot;switchcursortool&quot;, eventDetails: { tool: _pdf_cursor_tools.CursorTool.SELECT }, close: true }, { element: options.cursorHandToolButton, eventName: &quot;switchcursortool&quot;, eventDetails: { tool: _pdf_cursor_tools.CursorTool.HAND }, close: true }, { element: options.scrollPageButton, eventName: &quot;switchscrollmode&quot;, eventDetails: { mode: _ui_utils.ScrollMode.PAGE }, close: true }, { element: options.scrollVerticalButton, eventName: &quot;switchscrollmode&quot;, eventDetails: { mode: _ui_utils.ScrollMode.VERTICAL }, close: true }, { element: options.scrollHorizontalButton, eventName: &quot;switchscrollmode&quot;, eventDetails: { mode: _ui_utils.ScrollMode.HORIZONTAL }, close: true }, { element: options.scrollWrappedButton, eventName: &quot;switchscrollmode&quot;, eventDetails: { mode: _ui_utils.ScrollMode.WRAPPED }, close: true }, { element: options.spreadNoneButton, eventName: &quot;switchspreadmode&quot;, eventDetails: { mode: _ui_utils.SpreadMode.NONE }, close: true }, { element: options.spreadOddButton, eventName: &quot;switchspreadmode&quot;, eventDetails: { mode: _ui_utils.SpreadMode.ODD }, close: true }, { element: options.spreadEvenButton, eventName: &quot;switchspreadmode&quot;, eventDetails: { mode: _ui_utils.SpreadMode.EVEN }, close: true }, { element: options.documentPropertiesButton, eventName: &quot;documentproperties&quot;, close: true }]; this.buttons.push({ element: options.openFileButton, eventName: &quot;openfile&quot;, close: true }); this.items = { firstPage: options.firstPageButton, lastPage: options.lastPageButton, pageRotateCw: options.pageRotateCwButton, pageRotateCcw: options.pageRotateCcwButton }; this.eventBus = eventBus; this.externalServices = externalServices; this.opened = false; this.#bindClickListeners(); this.#bindCursorToolsListener(options); this.#bindScrollModeListener(options); this.#bindSpreadModeListener(options); this.reset(); } get isOpen() { return this.opened; } setPageNumber(pageNumber) { this.pageNumber = pageNumber; this.#updateUIState(); } setPagesCount(pagesCount) { this.pagesCount = pagesCount; this.#updateUIState(); } reset() { this.pageNumber = 0; this.pagesCount = 0; this.#updateUIState(); this.eventBus.dispatch(&quot;secondarytoolbarreset&quot;, { source: this }); } #updateUIState() { this.items.firstPage.disabled = this.pageNumber &lt;= 1; this.items.lastPage.disabled = this.pageNumber &gt;= this.pagesCount; this.items.pageRotateCw.disabled = this.pagesCount === 0; this.items.pageRotateCcw.disabled = this.pagesCount === 0; } #bindClickListeners() { this.toggleButton.addEventListener(&quot;click&quot;, this.toggle.bind(this)); for (const { element, eventName, close, eventDetails } of this.buttons) { element.addEventListener(&quot;click&quot;, evt =&gt; { if (eventName !== null) { const details = { source: this }; for (const property in eventDetails) { details[property] = eventDetails[property]; } this.eventBus.dispatch(eventName, details); } if (close) { this.close(); } this.externalServices.reportTelemetry({ type: &quot;buttons&quot;, data: { id: element.id } }); }); } } #bindCursorToolsListener({ cursorSelectToolButton, cursorHandToolButton }) { this.eventBus._on(&quot;cursortoolchanged&quot;, function ({ tool }) { const isSelect = tool === _pdf_cursor_tools.CursorTool.SELECT, isHand = tool === _pdf_cursor_tools.CursorTool.HAND; cursorSelectToolButton.classList.toggle(&quot;toggled&quot;, isSelect); cursorHandToolButton.classList.toggle(&quot;toggled&quot;, isHand); cursorSelectToolButton.setAttribute(&quot;aria-checked&quot;, isSelect); cursorHandToolButton.setAttribute(&quot;aria-checked&quot;, isHand); }); } #bindScrollModeListener({ scrollPageButton, scrollVerticalButton, scrollHorizontalButton, scrollWrappedButton, spreadNoneButton, spreadOddButton, spreadEvenButton }) { const scrollModeChanged = ({ mode }) =&gt; { const isPage = mode === _ui_utils.ScrollMode.PAGE, isVertical = mode === _ui_utils.ScrollMode.VERTICAL, isHorizontal = mode === _ui_utils.ScrollMode.HORIZONTAL, isWrapped = mode === _ui_utils.ScrollMode.WRAPPED; scrollPageButton.classList.toggle(&quot;toggled&quot;, isPage); scrollVerticalButton.classList.toggle(&quot;toggled&quot;, isVertical); scrollHorizontalButton.classList.toggle(&quot;toggled&quot;, isHorizontal); scrollWrappedButton.classList.toggle(&quot;toggled&quot;, isWrapped); scrollPageButton.setAttribute(&quot;aria-checked&quot;, isPage); scrollVerticalButton.setAttribute(&quot;aria-checked&quot;, isVertical); scrollHorizontalButton.setAttribute(&quot;aria-checked&quot;, isHorizontal); scrollWrappedButton.setAttribute(&quot;aria-checked&quot;, isWrapped); const forceScrollModePage = this.pagesCount &gt; _pdf_viewer.PagesCountLimit.FORCE_SCROLL_MODE_PAGE; scrollPageButton.disabled = forceScrollModePage; scrollVerticalButton.disabled = forceScrollModePage; scrollHorizontalButton.disabled = forceScrollModePage; scrollWrappedButton.disabled = forceScrollModePage; spreadNoneButton.disabled = isHorizontal; spreadOddButton.disabled = isHorizontal; spreadEvenButton.disabled = isHorizontal; }; this.eventBus._on(&quot;scrollmodechanged&quot;, scrollModeChanged); this.eventBus._on(&quot;secondarytoolbarreset&quot;, evt =&gt; { if (evt.source === this) { scrollModeChanged({ mode: _ui_utils.ScrollMode.VERTICAL }); } }); } #bindSpreadModeListener({ spreadNoneButton, spreadOddButton, spreadEvenButton }) { function spreadModeChanged({ mode }) { const isNone = mode === _ui_utils.SpreadMode.NONE, isOdd = mode === _ui_utils.SpreadMode.ODD, isEven = mode === _ui_utils.SpreadMode.EVEN; spreadNoneButton.classList.toggle(&quot;toggled&quot;, isNone); spreadOddButton.classList.toggle(&quot;toggled&quot;, isOdd); spreadEvenButton.classList.toggle(&quot;toggled&quot;, isEven); spreadNoneButton.setAttribute(&quot;aria-checked&quot;, isNone); spreadOddButton.setAttribute(&quot;aria-checked&quot;, isOdd); spreadEvenButton.setAttribute(&quot;aria-checked&quot;, isEven); } this.eventBus._on(&quot;spreadmodechanged&quot;, spreadModeChanged); this.eventBus._on(&quot;secondarytoolbarreset&quot;, evt =&gt; { if (evt.source === this) { spreadModeChanged({ mode: _ui_utils.SpreadMode.NONE }); } }); } open() { if (this.opened) { return; } this.opened = true; this.toggleButton.classList.add(&quot;toggled&quot;); this.toggleButton.setAttribute(&quot;aria-expanded&quot;, &quot;true&quot;); this.toolbar.classList.remove(&quot;hidden&quot;); } close() { if (!this.opened) { return; } this.opened = false; this.toolbar.classList.add(&quot;hidden&quot;); this.toggleButton.classList.remove(&quot;toggled&quot;); this.toggleButton.setAttribute(&quot;aria-expanded&quot;, &quot;false&quot;); } toggle() { if (this.opened) { this.close(); } else { this.open(); } } } exports.SecondaryToolbar = SecondaryToolbar; /***/ }), /* 39 */ /***/ ((__unused_webpack_module, exports, __webpack_require__) =&gt; { Object.defineProperty(exports, &quot;__esModule&quot;, ({ value: true })); exports.Toolbar = void 0; var _ui_utils = __webpack_require__(1); var _pdfjsLib = __webpack_require__(5); const PAGE_NUMBER_LOADING_INDICATOR = &quot;visiblePageIsLoading&quot;; class Toolbar { #wasLocalized = false; constructor(options, eventBus, l10n) { this.toolbar = options.container; this.eventBus = eventBus; this.l10n = l10n; this.buttons = [{ element: options.previous, eventName: &quot;previouspage&quot; }, { element: options.next, eventName: &quot;nextpage&quot; }, { element: options.zoomIn, eventName: &quot;zoomin&quot; }, { element: options.zoomOut, eventName: &quot;zoomout&quot; }, { element: options.print, eventName: &quot;print&quot; }, { element: options.download, eventName: &quot;download&quot; }, { element: options.editorFreeTextButton, eventName: &quot;switchannotationeditormode&quot;, eventDetails: { get mode() { const { classList } = options.editorFreeTextButton; return classList.contains(&quot;toggled&quot;) ? _pdfjsLib.AnnotationEditorType.NONE : _pdfjsLib.AnnotationEditorType.FREETEXT; } } }, { element: options.editorInkButton, eventName: &quot;switchannotationeditormode&quot;, eventDetails: { get mode() { const { classList } = options.editorInkButton; return classList.contains(&quot;toggled&quot;) ? _pdfjsLib.AnnotationEditorType.NONE : _pdfjsLib.AnnotationEditorType.INK; } } }]; this.buttons.push({ element: options.openFile, eventName: &quot;openfile&quot; }); this.items = { numPages: options.numPages, pageNumber: options.pageNumber, scaleSelect: options.scaleSelect, customScaleOption: options.customScaleOption, previous: options.previous, next: options.next, zoomIn: options.zoomIn, zoomOut: options.zoomOut }; this.#bindListeners(options); this.reset(); } setPageNumber(pageNumber, pageLabel) { this.pageNumber = pageNumber; this.pageLabel = pageLabel; this.#updateUIState(false); } setPagesCount(pagesCount, hasPageLabels) { this.pagesCount = pagesCount; this.hasPageLabels = hasPageLabels; this.#updateUIState(true); } setPageScale(pageScaleValue, pageScale) { this.pageScaleValue = (pageScaleValue || pageScale).toString(); this.pageScale = pageScale; this.#updateUIState(false); } reset() { this.pageNumber = 0; this.pageLabel = null; this.hasPageLabels = false; this.pagesCount = 0; this.pageScaleValue = _ui_utils.DEFAULT_SCALE_VALUE; this.pageScale = _ui_utils.DEFAULT_SCALE; this.#updateUIState(true); this.updateLoadingIndicatorState(); this.eventBus.dispatch(&quot;toolbarreset&quot;, { source: this }); } #bindListeners(options) { const { pageNumber, scaleSelect } = this.items; const self = this; for (const { element, eventName, eventDetails } of this.buttons) { element.addEventListener(&quot;click&quot;, evt =&gt; { if (eventName !== null) { const details = { source: this }; if (eventDetails) { for (const property in eventDetails) { details[property] = eventDetails[property]; } } this.eventBus.dispatch(eventName, details); } }); } pageNumber.addEventListener(&quot;click&quot;, function () { this.select(); }); pageNumber.addEventListener(&quot;change&quot;, function () { self.eventBus.dispatch(&quot;pagenumberchanged&quot;, { source: self, value: this.value }); }); scaleSelect.addEventListener(&quot;change&quot;, function () { if (this.value === &quot;custom&quot;) { return; } self.eventBus.dispatch(&quot;scalechanged&quot;, { source: self, value: this.value }); }); scaleSelect.addEventListener(&quot;click&quot;, function (evt) { const target = evt.target; if (this.value === self.pageScaleValue &amp;&amp; target.tagName.toUpperCase() === &quot;OPTION&quot;) { this.blur(); } }); scaleSelect.oncontextmenu = _ui_utils.noContextMenuHandler; this.eventBus._on(&quot;localized&quot;, () =&gt; { this.#wasLocalized = true; this.#adjustScaleWidth(); this.#updateUIState(true); }); this.#bindEditorToolsListener(options); } #bindEditorToolsListener({ editorFreeTextButton, editorFreeTextParamsToolbar, editorInkButton, editorInkParamsToolbar }) { const editorModeChanged = (evt, disableButtons = false) =&gt; { const editorButtons = [{ mode: _pdfjsLib.AnnotationEditorType.FREETEXT, button: editorFreeTextButton, toolbar: editorFreeTextParamsToolbar }, { mode: _pdfjsLib.AnnotationEditorType.INK, button: editorInkButton, toolbar: editorInkParamsToolbar }]; for (const { mode, button, toolbar } of editorButtons) { const checked = mode === evt.mode; button.classList.toggle(&quot;toggled&quot;, checked); button.setAttribute(&quot;aria-checked&quot;, checked); button.disabled = disableButtons; toolbar?.classList.toggle(&quot;hidden&quot;, !checked); } }; this.eventBus._on(&quot;annotationeditormodechanged&quot;, editorModeChanged); this.eventBus._on(&quot;toolbarreset&quot;, evt =&gt; { if (evt.source === this) { editorModeChanged({ mode: _pdfjsLib.AnnotationEditorType.NONE }, true); } }); } #updateUIState(resetNumPages = false) { if (!this.#wasLocalized) { return; } const { pageNumber, pagesCount, pageScaleValue, pageScale, items } = this; if (resetNumPages) { if (this.hasPageLabels) { items.pageNumber.type = &quot;text&quot;; } else { items.pageNumber.type = &quot;number&quot;; this.l10n.get(&quot;of_pages&quot;, { pagesCount }).then(msg =&gt; { items.numPages.textContent = msg; }); } items.pageNumber.max = pagesCount; } if (this.hasPageLabels) { items.pageNumber.value = this.pageLabel; this.l10n.get(&quot;page_of_pages&quot;, { pageNumber, pagesCount }).then(msg =&gt; { items.numPages.textContent = msg; }); } else { items.pageNumber.value = pageNumber; } items.previous.disabled = pageNumber &lt;= 1; items.next.disabled = pageNumber &gt;= pagesCount; items.zoomOut.disabled = pageScale &lt;= _ui_utils.MIN_SCALE; items.zoomIn.disabled = pageScale &gt;= _ui_utils.MAX_SCALE; this.l10n.get(&quot;page_scale_percent&quot;, { scale: Math.round(pageScale * 10000) / 100 }).then(msg =&gt; { let predefinedValueFound = false; for (const option of items.scaleSelect.options) { if (option.value !== pageScaleValue) { option.selected = false; continue; } option.selected = true; predefinedValueFound = true; } if (!predefinedValueFound) { items.customScaleOption.textContent = msg; items.customScaleOption.selected = true; } }); } updateLoadingIndicatorState(loading = false) { const { pageNumber } = this.items; pageNumber.classList.toggle(PAGE_NUMBER_LOADING_INDICATOR, loading); } async #adjustScaleWidth() { const { items, l10n } = this; const predefinedValuesPromise = Promise.all([l10n.get(&quot;page_scale_auto&quot;), l10n.get(&quot;page_scale_actual&quot;), l10n.get(&quot;page_scale_fit&quot;), l10n.get(&quot;page_scale_width&quot;)]); await _ui_utils.animationStarted; const style = getComputedStyle(items.scaleSelect); const scaleSelectWidth = parseFloat(style.getPropertyValue(&quot;--scale-select-width&quot;)); const canvas = document.createElement(&quot;canvas&quot;); const ctx = canvas.getContext(&quot;2d&quot;, { alpha: false }); ctx.font = `${style.fontSize} ${style.fontFamily}`; let maxWidth = 0; for (const predefinedValue of await predefinedValuesPromise) { const { width } = ctx.measureText(predefinedValue); if (width &gt; maxWidth) { maxWidth = width; } } maxWidth += 0.3 * scaleSelectWidth; if (maxWidth &gt; scaleSelectWidth) { _ui_utils.docStyle.setProperty(&quot;--scale-select-width&quot;, `${maxWidth}px`); } canvas.width = 0; canvas.height = 0; } } exports.Toolbar = Toolbar; /***/ }), /* 40 */ /***/ ((__unused_webpack_module, exports) =&gt; { Object.defineProperty(exports, &quot;__esModule&quot;, ({ value: true })); exports.ViewHistory = void 0; const DEFAULT_VIEW_HISTORY_CACHE_SIZE = 20; class ViewHistory { constructor(fingerprint, cacheSize = DEFAULT_VIEW_HISTORY_CACHE_SIZE) { this.fingerprint = fingerprint; this.cacheSize = cacheSize; this._initializedPromise = this._readFromStorage().then(databaseStr =&gt; { const database = JSON.parse(databaseStr || &quot;{}&quot;); let index = -1; if (!Array.isArray(database.files)) { database.files = []; } else { while (database.files.length &gt;= this.cacheSize) { database.files.shift(); } for (let i = 0, ii = database.files.length; i &lt; ii; i++) { const branch = database.files[i]; if (branch.fingerprint === this.fingerprint) { index = i; break; } } } if (index === -1) { index = database.files.push({ fingerprint: this.fingerprint }) - 1; } this.file = database.files[index]; this.database = database; }); } async _writeToStorage() { const databaseStr = JSON.stringify(this.database); localStorage.setItem(&quot;pdfjs.history&quot;, databaseStr); } async _readFromStorage() { return localStorage.getItem(&quot;pdfjs.history&quot;); } async set(name, val) { await this._initializedPromise; this.file[name] = val; return this._writeToStorage(); } async setMultiple(properties) { await this._initializedPromise; for (const name in properties) { this.file[name] = properties[name]; } return this._writeToStorage(); } async get(name, defaultValue) { await this._initializedPromise; const val = this.file[name]; return val !== undefined ? val : defaultValue; } async getMultiple(properties) { await this._initializedPromise; const values = Object.create(null); for (const name in properties) { const val = this.file[name]; values[name] = val !== undefined ? val : properties[name]; } return values; } } exports.ViewHistory = ViewHistory; /***/ }), /* 41 */ /***/ ((__unused_webpack_module, exports, __webpack_require__) =&gt; { Object.defineProperty(exports, &quot;__esModule&quot;, ({ value: true })); exports.GenericCom = void 0; var _app = __webpack_require__(4); var _preferences = __webpack_require__(42); var _download_manager = __webpack_require__(43); var _genericl10n = __webpack_require__(44); var _generic_scripting = __webpack_require__(46); ; const GenericCom = {}; exports.GenericCom = GenericCom; class GenericPreferences extends _preferences.BasePreferences { async _writeToStorage(prefObj) { localStorage.setItem(&quot;pdfjs.preferences&quot;, JSON.stringify(prefObj)); } async _readFromStorage(prefObj) { return JSON.parse(localStorage.getItem(&quot;pdfjs.preferences&quot;)); } } class GenericExternalServices extends _app.DefaultExternalServices { static createDownloadManager(options) { return new _download_manager.DownloadManager(); } static createPreferences() { return new GenericPreferences(); } static createL10n({ locale = &quot;en-US&quot; }) { return new _genericl10n.GenericL10n(locale); } static createScripting({ sandboxBundleSrc }) { return new _generic_scripting.GenericScripting(sandboxBundleSrc); } } _app.PDFViewerApplication.externalServices = GenericExternalServices; /***/ }), /* 42 */ /***/ ((__unused_webpack_module, exports, __webpack_require__) =&gt; { Object.defineProperty(exports, &quot;__esModule&quot;, ({ value: true })); exports.BasePreferences = void 0; var _app_options = __webpack_require__(2); class BasePreferences { #defaults = Object.freeze({ &quot;annotationEditorMode&quot;: 0, &quot;annotationMode&quot;: 2, &quot;cursorToolOnLoad&quot;: 0, &quot;defaultZoomValue&quot;: &quot;&quot;, &quot;disablePageLabels&quot;: false, &quot;enablePermissions&quot;: false, &quot;enablePrintAutoRotate&quot;: true, &quot;enableScripting&quot;: true, &quot;externalLinkTarget&quot;: 0, &quot;historyUpdateUrl&quot;: false, &quot;ignoreDestinationZoom&quot;: false, &quot;forcePageColors&quot;: false, &quot;pageColorsBackground&quot;: &quot;Canvas&quot;, &quot;pageColorsForeground&quot;: &quot;CanvasText&quot;, &quot;pdfBugEnabled&quot;: false, &quot;sidebarViewOnLoad&quot;: -1, &quot;scrollModeOnLoad&quot;: -1, &quot;spreadModeOnLoad&quot;: -1, &quot;textLayerMode&quot;: 1, &quot;useOnlyCssZoom&quot;: false, &quot;viewerCssTheme&quot;: 0, &quot;viewOnLoad&quot;: 0, &quot;disableAutoFetch&quot;: false, &quot;disableFontFace&quot;: false, &quot;disableRange&quot;: false, &quot;disableStream&quot;: false, &quot;enableXfa&quot;: true, &quot;renderer&quot;: &quot;canvas&quot; }); #prefs = Object.create(null); #initializedPromise = null; constructor() { if (this.constructor === BasePreferences) { throw new Error(&quot;Cannot initialize BasePreferences.&quot;); } this.#initializedPromise = this._readFromStorage(this.#defaults).then(prefs =&gt; { for (const name in this.#defaults) { const prefValue = prefs?.[name]; if (typeof prefValue === typeof this.#defaults[name]) { this.#prefs[name] = prefValue; } } }); } async _writeToStorage(prefObj) { throw new Error(&quot;Not implemented: _writeToStorage&quot;); } async _readFromStorage(prefObj) { throw new Error(&quot;Not implemented: _readFromStorage&quot;); } async reset() { await this.#initializedPromise; const prefs = this.#prefs; this.#prefs = Object.create(null); return this._writeToStorage(this.#defaults).catch(reason =&gt; { this.#prefs = prefs; throw reason; }); } async set(name, value) { await this.#initializedPromise; const defaultValue = this.#defaults[name], prefs = this.#prefs; if (defaultValue === undefined) { throw new Error(`Set preference: &quot;${name}&quot; is undefined.`); } else if (value === undefined) { throw new Error(&quot;Set preference: no value is specified.&quot;); } const valueType = typeof value, defaultType = typeof defaultValue; if (valueType !== defaultType) { if (valueType === &quot;number&quot; &amp;&amp; defaultType === &quot;string&quot;) { value = value.toString(); } else { throw new Error(`Set preference: &quot;${value}&quot; is a ${valueType}, expected a ${defaultType}.`); } } else { if (valueType === &quot;number&quot; &amp;&amp; !Number.isInteger(value)) { throw new Error(`Set preference: &quot;${value}&quot; must be an integer.`); } } this.#prefs[name] = value; return this._writeToStorage(this.#prefs).catch(reason =&gt; { this.#prefs = prefs; throw reason; }); } async get(name) { await this.#initializedPromise; const defaultValue = this.#defaults[name]; if (defaultValue === undefined) { throw new Error(`Get preference: &quot;${name}&quot; is undefined.`); } return this.#prefs[name] ?? defaultValue; } async getAll() { await this.#initializedPromise; const obj = Object.create(null); for (const name in this.#defaults) { obj[name] = this.#prefs[name] ?? this.#defaults[name]; } return obj; } } exports.BasePreferences = BasePreferences; /***/ }), /* 43 */ /***/ ((__unused_webpack_module, exports, __webpack_require__) =&gt; { Object.defineProperty(exports, &quot;__esModule&quot;, ({ value: true })); exports.DownloadManager = void 0; var _pdfjsLib = __webpack_require__(5); ; function download(blobUrl, filename) { const a = document.createElement(&quot;a&quot;); if (!a.click) { throw new Error(&apos;DownloadManager: &quot;a.click()&quot; is not supported.&apos;); } a.href = blobUrl; a.target = &quot;_parent&quot;; if (&quot;download&quot; in a) { a.download = filename; } (document.body || document.documentElement).append(a); a.click(); a.remove(); } class DownloadManager { constructor() { this._openBlobUrls = new WeakMap(); } downloadUrl(url, filename) { if (!(0, _pdfjsLib.createValidAbsoluteUrl)(url, &quot;http://example.com&quot;)) { console.error(`downloadUrl - not a valid URL: ${url}`); return; } download(url + &quot;#pdfjs.action=download&quot;, filename); } downloadData(data, filename, contentType) { const blobUrl = URL.createObjectURL(new Blob([data], { type: contentType })); download(blobUrl, filename); } openOrDownloadData(element, data, filename) { const isPdfData = (0, _pdfjsLib.isPdfFile)(filename); const contentType = isPdfData ? &quot;application/pdf&quot; : &quot;&quot;; if (isPdfData) { let blobUrl = this._openBlobUrls.get(element); if (!blobUrl) { blobUrl = URL.createObjectURL(new Blob([data], { type: contentType })); this._openBlobUrls.set(element, blobUrl); } let viewerUrl; viewerUrl = &quot;?file=&quot; + encodeURIComponent(blobUrl + &quot;#&quot; + filename); try { window.open(viewerUrl); return true; } catch (ex) { console.error(`openOrDownloadData: ${ex}`); URL.revokeObjectURL(blobUrl); this._openBlobUrls.delete(element); } } this.downloadData(data, filename, contentType); return false; } download(blob, url, filename) { const blobUrl = URL.createObjectURL(blob); download(blobUrl, filename); } } exports.DownloadManager = DownloadManager; /***/ }), /* 44 */ /***/ ((__unused_webpack_module, exports, __webpack_require__) =&gt; { Object.defineProperty(exports, &quot;__esModule&quot;, ({ value: true })); exports.GenericL10n = void 0; __webpack_require__(45); var _l10n_utils = __webpack_require__(30); const webL10n = document.webL10n; class GenericL10n { constructor(lang) { this._lang = lang; this._ready = new Promise((resolve, reject) =&gt; { webL10n.setLanguage((0, _l10n_utils.fixupLangCode)(lang), () =&gt; { resolve(webL10n); }); }); } async getLanguage() { const l10n = await this._ready; return l10n.getLanguage(); } async getDirection() { const l10n = await this._ready; return l10n.getDirection(); } async get(key, args = null, fallback = (0, _l10n_utils.getL10nFallback)(key, args)) { const l10n = await this._ready; return l10n.get(key, args, fallback); } async translate(element) { const l10n = await this._ready; return l10n.translate(element); } } exports.GenericL10n = GenericL10n; /***/ }), /* 45 */ /***/ (() =&gt; { document.webL10n = function (window, document, undefined) { var gL10nData = {}; var gTextData = &apos;&apos;; var gTextProp = &apos;textContent&apos;; var gLanguage = &apos;&apos;; var gMacros = {}; var gReadyState = &apos;loading&apos;; var gAsyncResourceLoading = true; function getL10nResourceLinks() { return document.querySelectorAll(&apos;link[type=&quot;application/l10n&quot;]&apos;); } function getL10nDictionary() { var script = document.querySelector(&apos;script[type=&quot;application/l10n&quot;]&apos;); return script ? JSON.parse(script.innerHTML) : null; } function getTranslatableChildren(element) { return element ? element.querySelectorAll(&apos;*[data-l10n-id]&apos;) : []; } function getL10nAttributes(element) { if (!element) return {}; var l10nId = element.getAttribute(&apos;data-l10n-id&apos;); var l10nArgs = element.getAttribute(&apos;data-l10n-args&apos;); var args = {}; if (l10nArgs) { try { args = JSON.parse(l10nArgs); } catch (e) { console.warn(&apos;could not parse arguments for #&apos; + l10nId); } } return { id: l10nId, args: args }; } function xhrLoadText(url, onSuccess, onFailure) { onSuccess = onSuccess || function _onSuccess(data) {}; onFailure = onFailure || function _onFailure() {}; var xhr = new XMLHttpRequest(); xhr.open(&apos;GET&apos;, url, gAsyncResourceLoading); if (xhr.overrideMimeType) { xhr.overrideMimeType(&apos;text/plain; charset=utf-8&apos;); } xhr.onreadystatechange = function () { if (xhr.readyState == 4) { if (xhr.status == 200 || xhr.status === 0) { onSuccess(xhr.responseText); } else { onFailure(); } } }; xhr.onerror = onFailure; xhr.ontimeout = onFailure; try { xhr.send(null); } catch (e) { onFailure(); } } function parseResource(href, lang, successCallback, failureCallback) { var baseURL = href.replace(/[^\\/]*$/, &apos;&apos;) || &apos;./&apos;; function evalString(text) { if (text.lastIndexOf(&apos;\\\\&apos;) &lt; 0) return text; return text.replace(/\\\\\\\\/g, &apos;\\\\&apos;).replace(/\\\\n/g, &apos;\\n&apos;).replace(/\\\\r/g, &apos;\\r&apos;).replace(/\\\\t/g, &apos;\\t&apos;).replace(/\\\\b/g, &apos;\\b&apos;).replace(/\\\\f/g, &apos;\\f&apos;).replace(/\\\\{/g, &apos;{&apos;).replace(/\\\\}/g, &apos;}&apos;).replace(/\\\\&quot;/g, &apos;&quot;&apos;).replace(/\\\\&apos;/g, &quot;&apos;&quot;); } function parseProperties(text, parsedPropertiesCallback) { var dictionary = {}; var reBlank = /^\\s*|\\s*$/; var reComment = /^\\s*#|^\\s*$/; var reSection = /^\\s*\\[(.*)\\]\\s*$/; var reImport = /^\\s*@import\\s+url\\((.*)\\)\\s*$/i; var reSplit = /^([^=\\s]*)\\s*=\\s*(.+)$/; function parseRawLines(rawText, extendedSyntax, parsedRawLinesCallback) { var entries = rawText.replace(reBlank, &apos;&apos;).split(/[\\r\\n]+/); var currentLang = &apos;*&apos;; var genericLang = lang.split(&apos;-&apos;, 1)[0]; var skipLang = false; var match = &apos;&apos;; function nextEntry() { while (true) { if (!entries.length) { parsedRawLinesCallback(); return; } var line = entries.shift(); if (reComment.test(line)) continue; if (extendedSyntax) { match = reSection.exec(line); if (match) { currentLang = match[1].toLowerCase(); skipLang = currentLang !== &apos;*&apos; &amp;&amp; currentLang !== lang &amp;&amp; currentLang !== genericLang; continue; } else if (skipLang) { continue; } match = reImport.exec(line); if (match) { loadImport(baseURL + match[1], nextEntry); return; } } var tmp = line.match(reSplit); if (tmp &amp;&amp; tmp.length == 3) { dictionary[tmp[1]] = evalString(tmp[2]); } } } nextEntry(); } function loadImport(url, callback) { xhrLoadText(url, function (content) { parseRawLines(content, false, callback); }, function () { console.warn(url + &apos; not found.&apos;); callback(); }); } parseRawLines(text, true, function () { parsedPropertiesCallback(dictionary); }); } xhrLoadText(href, function (response) { gTextData += response; parseProperties(response, function (data) { for (var key in data) { var id, prop, index = key.lastIndexOf(&apos;.&apos;); if (index &gt; 0) { id = key.substring(0, index); prop = key.substring(index + 1); } else { id = key; prop = gTextProp; } if (!gL10nData[id]) { gL10nData[id] = {}; } gL10nData[id][prop] = data[key]; } if (successCallback) { successCallback(); } }); }, failureCallback); } function loadLocale(lang, callback) { if (lang) { lang = lang.toLowerCase(); } callback = callback || function _callback() {}; clear(); gLanguage = lang; var langLinks = getL10nResourceLinks(); var langCount = langLinks.length; if (langCount === 0) { var dict = getL10nDictionary(); if (dict &amp;&amp; dict.locales &amp;&amp; dict.default_locale) { console.log(&apos;using the embedded JSON directory, early way out&apos;); gL10nData = dict.locales[lang]; if (!gL10nData) { var defaultLocale = dict.default_locale.toLowerCase(); for (var anyCaseLang in dict.locales) { anyCaseLang = anyCaseLang.toLowerCase(); if (anyCaseLang === lang) { gL10nData = dict.locales[lang]; break; } else if (anyCaseLang === defaultLocale) { gL10nData = dict.locales[defaultLocale]; } } } callback(); } else { console.log(&apos;no resource to load, early way out&apos;); } gReadyState = &apos;complete&apos;; return; } var onResourceLoaded = null; var gResourceCount = 0; onResourceLoaded = function () { gResourceCount++; if (gResourceCount &gt;= langCount) { callback(); gReadyState = &apos;complete&apos;; } }; function L10nResourceLink(link) { var href = link.href; this.load = function (lang, callback) { parseResource(href, lang, callback, function () { console.warn(href + &apos; not found.&apos;); console.warn(&apos;&quot;&apos; + lang + &apos;&quot; resource not found&apos;); gLanguage = &apos;&apos;; callback(); }); }; } for (var i = 0; i &lt; langCount; i++) { var resource = new L10nResourceLink(langLinks[i]); resource.load(lang, onResourceLoaded); } } function clear() { gL10nData = {}; gTextData = &apos;&apos;; gLanguage = &apos;&apos;; } function getPluralRules(lang) { var locales2rules = { &apos;af&apos;: 3, &apos;ak&apos;: 4, &apos;am&apos;: 4, &apos;ar&apos;: 1, &apos;asa&apos;: 3, &apos;az&apos;: 0, &apos;be&apos;: 11, &apos;bem&apos;: 3, &apos;bez&apos;: 3, &apos;bg&apos;: 3, &apos;bh&apos;: 4, &apos;bm&apos;: 0, &apos;bn&apos;: 3, &apos;bo&apos;: 0, &apos;br&apos;: 20, &apos;brx&apos;: 3, &apos;bs&apos;: 11, &apos;ca&apos;: 3, &apos;cgg&apos;: 3, &apos;chr&apos;: 3, &apos;cs&apos;: 12, &apos;cy&apos;: 17, &apos;da&apos;: 3, &apos;de&apos;: 3, &apos;dv&apos;: 3, &apos;dz&apos;: 0, &apos;ee&apos;: 3, &apos;el&apos;: 3, &apos;en&apos;: 3, &apos;eo&apos;: 3, &apos;es&apos;: 3, &apos;et&apos;: 3, &apos;eu&apos;: 3, &apos;fa&apos;: 0, &apos;ff&apos;: 5, &apos;fi&apos;: 3, &apos;fil&apos;: 4, &apos;fo&apos;: 3, &apos;fr&apos;: 5, &apos;fur&apos;: 3, &apos;fy&apos;: 3, &apos;ga&apos;: 8, &apos;gd&apos;: 24, &apos;gl&apos;: 3, &apos;gsw&apos;: 3, &apos;gu&apos;: 3, &apos;guw&apos;: 4, &apos;gv&apos;: 23, &apos;ha&apos;: 3, &apos;haw&apos;: 3, &apos;he&apos;: 2, &apos;hi&apos;: 4, &apos;hr&apos;: 11, &apos;hu&apos;: 0, &apos;id&apos;: 0, &apos;ig&apos;: 0, &apos;ii&apos;: 0, &apos;is&apos;: 3, &apos;it&apos;: 3, &apos;iu&apos;: 7, &apos;ja&apos;: 0, &apos;jmc&apos;: 3, &apos;jv&apos;: 0, &apos;ka&apos;: 0, &apos;kab&apos;: 5, &apos;kaj&apos;: 3, &apos;kcg&apos;: 3, &apos;kde&apos;: 0, &apos;kea&apos;: 0, &apos;kk&apos;: 3, &apos;kl&apos;: 3, &apos;km&apos;: 0, &apos;kn&apos;: 0, &apos;ko&apos;: 0, &apos;ksb&apos;: 3, &apos;ksh&apos;: 21, &apos;ku&apos;: 3, &apos;kw&apos;: 7, &apos;lag&apos;: 18, &apos;lb&apos;: 3, &apos;lg&apos;: 3, &apos;ln&apos;: 4, &apos;lo&apos;: 0, &apos;lt&apos;: 10, &apos;lv&apos;: 6, &apos;mas&apos;: 3, &apos;mg&apos;: 4, &apos;mk&apos;: 16, &apos;ml&apos;: 3, &apos;mn&apos;: 3, &apos;mo&apos;: 9, &apos;mr&apos;: 3, &apos;ms&apos;: 0, &apos;mt&apos;: 15, &apos;my&apos;: 0, &apos;nah&apos;: 3, &apos;naq&apos;: 7, &apos;nb&apos;: 3, &apos;nd&apos;: 3, &apos;ne&apos;: 3, &apos;nl&apos;: 3, &apos;nn&apos;: 3, &apos;no&apos;: 3, &apos;nr&apos;: 3, &apos;nso&apos;: 4, &apos;ny&apos;: 3, &apos;nyn&apos;: 3, &apos;om&apos;: 3, &apos;or&apos;: 3, &apos;pa&apos;: 3, &apos;pap&apos;: 3, &apos;pl&apos;: 13, &apos;ps&apos;: 3, &apos;pt&apos;: 3, &apos;rm&apos;: 3, &apos;ro&apos;: 9, &apos;rof&apos;: 3, &apos;ru&apos;: 11, &apos;rwk&apos;: 3, &apos;sah&apos;: 0, &apos;saq&apos;: 3, &apos;se&apos;: 7, &apos;seh&apos;: 3, &apos;ses&apos;: 0, &apos;sg&apos;: 0, &apos;sh&apos;: 11, &apos;shi&apos;: 19, &apos;sk&apos;: 12, &apos;sl&apos;: 14, &apos;sma&apos;: 7, &apos;smi&apos;: 7, &apos;smj&apos;: 7, &apos;smn&apos;: 7, &apos;sms&apos;: 7, &apos;sn&apos;: 3, &apos;so&apos;: 3, &apos;sq&apos;: 3, &apos;sr&apos;: 11, &apos;ss&apos;: 3, &apos;ssy&apos;: 3, &apos;st&apos;: 3, &apos;sv&apos;: 3, &apos;sw&apos;: 3, &apos;syr&apos;: 3, &apos;ta&apos;: 3, &apos;te&apos;: 3, &apos;teo&apos;: 3, &apos;th&apos;: 0, &apos;ti&apos;: 4, &apos;tig&apos;: 3, &apos;tk&apos;: 3, &apos;tl&apos;: 4, &apos;tn&apos;: 3, &apos;to&apos;: 0, &apos;tr&apos;: 0, &apos;ts&apos;: 3, &apos;tzm&apos;: 22, &apos;uk&apos;: 11, &apos;ur&apos;: 3, &apos;ve&apos;: 3, &apos;vi&apos;: 0, &apos;vun&apos;: 3, &apos;wa&apos;: 4, &apos;wae&apos;: 3, &apos;wo&apos;: 0, &apos;xh&apos;: 3, &apos;xog&apos;: 3, &apos;yo&apos;: 0, &apos;zh&apos;: 0, &apos;zu&apos;: 3 }; function isIn(n, list) { return list.indexOf(n) !== -1; } function isBetween(n, start, end) { return start &lt;= n &amp;&amp; n &lt;= end; } var pluralRules = { &apos;0&apos;: function (n) { return &apos;other&apos;; }, &apos;1&apos;: function (n) { if (isBetween(n % 100, 3, 10)) return &apos;few&apos;; if (n === 0) return &apos;zero&apos;; if (isBetween(n % 100, 11, 99)) return &apos;many&apos;; if (n == 2) return &apos;two&apos;; if (n == 1) return &apos;one&apos;; return &apos;other&apos;; }, &apos;2&apos;: function (n) { if (n !== 0 &amp;&amp; n % 10 === 0) return &apos;many&apos;; if (n == 2) return &apos;two&apos;; if (n == 1) return &apos;one&apos;; return &apos;other&apos;; }, &apos;3&apos;: function (n) { if (n == 1) return &apos;one&apos;; return &apos;other&apos;; }, &apos;4&apos;: function (n) { if (isBetween(n, 0, 1)) return &apos;one&apos;; return &apos;other&apos;; }, &apos;5&apos;: function (n) { if (isBetween(n, 0, 2) &amp;&amp; n != 2) return &apos;one&apos;; return &apos;other&apos;; }, &apos;6&apos;: function (n) { if (n === 0) return &apos;zero&apos;; if (n % 10 == 1 &amp;&amp; n % 100 != 11) return &apos;one&apos;; return &apos;other&apos;; }, &apos;7&apos;: function (n) { if (n == 2) return &apos;two&apos;; if (n == 1) return &apos;one&apos;; return &apos;other&apos;; }, &apos;8&apos;: function (n) { if (isBetween(n, 3, 6)) return &apos;few&apos;; if (isBetween(n, 7, 10)) return &apos;many&apos;; if (n == 2) return &apos;two&apos;; if (n == 1) return &apos;one&apos;; return &apos;other&apos;; }, &apos;9&apos;: function (n) { if (n === 0 || n != 1 &amp;&amp; isBetween(n % 100, 1, 19)) return &apos;few&apos;; if (n == 1) return &apos;one&apos;; return &apos;other&apos;; }, &apos;10&apos;: function (n) { if (isBetween(n % 10, 2, 9) &amp;&amp; !isBetween(n % 100, 11, 19)) return &apos;few&apos;; if (n % 10 == 1 &amp;&amp; !isBetween(n % 100, 11, 19)) return &apos;one&apos;; return &apos;other&apos;; }, &apos;11&apos;: function (n) { if (isBetween(n % 10, 2, 4) &amp;&amp; !isBetween(n % 100, 12, 14)) return &apos;few&apos;; if (n % 10 === 0 || isBetween(n % 10, 5, 9) || isBetween(n % 100, 11, 14)) return &apos;many&apos;; if (n % 10 == 1 &amp;&amp; n % 100 != 11) return &apos;one&apos;; return &apos;other&apos;; }, &apos;12&apos;: function (n) { if (isBetween(n, 2, 4)) return &apos;few&apos;; if (n == 1) return &apos;one&apos;; return &apos;other&apos;; }, &apos;13&apos;: function (n) { if (isBetween(n % 10, 2, 4) &amp;&amp; !isBetween(n % 100, 12, 14)) return &apos;few&apos;; if (n != 1 &amp;&amp; isBetween(n % 10, 0, 1) || isBetween(n % 10, 5, 9) || isBetween(n % 100, 12, 14)) return &apos;many&apos;; if (n == 1) return &apos;one&apos;; return &apos;other&apos;; }, &apos;14&apos;: function (n) { if (isBetween(n % 100, 3, 4)) return &apos;few&apos;; if (n % 100 == 2) return &apos;two&apos;; if (n % 100 == 1) return &apos;one&apos;; return &apos;other&apos;; }, &apos;15&apos;: function (n) { if (n === 0 || isBetween(n % 100, 2, 10)) return &apos;few&apos;; if (isBetween(n % 100, 11, 19)) return &apos;many&apos;; if (n == 1) return &apos;one&apos;; return &apos;other&apos;; }, &apos;16&apos;: function (n) { if (n % 10 == 1 &amp;&amp; n != 11) return &apos;one&apos;; return &apos;other&apos;; }, &apos;17&apos;: function (n) { if (n == 3) return &apos;few&apos;; if (n === 0) return &apos;zero&apos;; if (n == 6) return &apos;many&apos;; if (n == 2) return &apos;two&apos;; if (n == 1) return &apos;one&apos;; return &apos;other&apos;; }, &apos;18&apos;: function (n) { if (n === 0) return &apos;zero&apos;; if (isBetween(n, 0, 2) &amp;&amp; n !== 0 &amp;&amp; n != 2) return &apos;one&apos;; return &apos;other&apos;; }, &apos;19&apos;: function (n) { if (isBetween(n, 2, 10)) return &apos;few&apos;; if (isBetween(n, 0, 1)) return &apos;one&apos;; return &apos;other&apos;; }, &apos;20&apos;: function (n) { if ((isBetween(n % 10, 3, 4) || n % 10 == 9) &amp;&amp; !(isBetween(n % 100, 10, 19) || isBetween(n % 100, 70, 79) || isBetween(n % 100, 90, 99))) return &apos;few&apos;; if (n % 1000000 === 0 &amp;&amp; n !== 0) return &apos;many&apos;; if (n % 10 == 2 &amp;&amp; !isIn(n % 100, [12, 72, 92])) return &apos;two&apos;; if (n % 10 == 1 &amp;&amp; !isIn(n % 100, [11, 71, 91])) return &apos;one&apos;; return &apos;other&apos;; }, &apos;21&apos;: function (n) { if (n === 0) return &apos;zero&apos;; if (n == 1) return &apos;one&apos;; return &apos;other&apos;; }, &apos;22&apos;: function (n) { if (isBetween(n, 0, 1) || isBetween(n, 11, 99)) return &apos;one&apos;; return &apos;other&apos;; }, &apos;23&apos;: function (n) { if (isBetween(n % 10, 1, 2) || n % 20 === 0) return &apos;one&apos;; return &apos;other&apos;; }, &apos;24&apos;: function (n) { if (isBetween(n, 3, 10) || isBetween(n, 13, 19)) return &apos;few&apos;; if (isIn(n, [2, 12])) return &apos;two&apos;; if (isIn(n, [1, 11])) return &apos;one&apos;; return &apos;other&apos;; } }; var index = locales2rules[lang.replace(/-.*$/, &apos;&apos;)]; if (!(index in pluralRules)) { console.warn(&apos;plural form unknown for [&apos; + lang + &apos;]&apos;); return function () { return &apos;other&apos;; }; } return pluralRules[index]; } gMacros.plural = function (str, param, key, prop) { var n = parseFloat(param); if (isNaN(n)) return str; if (prop != gTextProp) return str; if (!gMacros._pluralRules) { gMacros._pluralRules = getPluralRules(gLanguage); } var index = &apos;[&apos; + gMacros._pluralRules(n) + &apos;]&apos;; if (n === 0 &amp;&amp; key + &apos;[zero]&apos; in gL10nData) { str = gL10nData[key + &apos;[zero]&apos;][prop]; } else if (n == 1 &amp;&amp; key + &apos;[one]&apos; in gL10nData) { str = gL10nData[key + &apos;[one]&apos;][prop]; } else if (n == 2 &amp;&amp; key + &apos;[two]&apos; in gL10nData) { str = gL10nData[key + &apos;[two]&apos;][prop]; } else if (key + index in gL10nData) { str = gL10nData[key + index][prop]; } else if (key + &apos;[other]&apos; in gL10nData) { str = gL10nData[key + &apos;[other]&apos;][prop]; } return str; }; function getL10nData(key, args, fallback) { var data = gL10nData[key]; if (!data) { console.warn(&apos;#&apos; + key + &apos; is undefined.&apos;); if (!fallback) { return null; } data = fallback; } var rv = {}; for (var prop in data) { var str = data[prop]; str = substIndexes(str, args, key, prop); str = substArguments(str, args, key); rv[prop] = str; } return rv; } function substIndexes(str, args, key, prop) { var reIndex = /\\{\\[\\s*([a-zA-Z]+)\\(([a-zA-Z]+)\\)\\s*\\]\\}/; var reMatch = reIndex.exec(str); if (!reMatch || !reMatch.length) return str; var macroName = reMatch[1]; var paramName = reMatch[2]; var param; if (args &amp;&amp; paramName in args) { param = args[paramName]; } else if (paramName in gL10nData) { param = gL10nData[paramName]; } if (macroName in gMacros) { var macro = gMacros[macroName]; str = macro(str, param, key, prop); } return str; } function substArguments(str, args, key) { var reArgs = /\\{\\{\\s*(.+?)\\s*\\}\\}/g; return str.replace(reArgs, function (matched_text, arg) { if (args &amp;&amp; arg in args) { return args[arg]; } if (arg in gL10nData) { return gL10nData[arg]; } console.log(&apos;argument + arg + for #&apos; + key + &apos; is undefined.&apos;); return matched_text; }); } function translateElement(element) { var l10n = getL10nAttributes(element); if (!l10n.id) return; var data = getL10nData(l10n.id, l10n.args); if (!data) { console.warn(&apos;#&apos; + l10n.id + &apos; is undefined.&apos;); return; } if (data[gTextProp]) { if (getChildElementCount(element) === 0) { element[gTextProp] = data[gTextProp]; } else { var children = element.childNodes; var found = false; for (var i = 0, l = children.length; i &lt; l; i++) { if (children[i].nodeType === 3 &amp;&amp; /\\S/.test(children[i].nodeValue)) { if (found) { children[i].nodeValue = &apos;&apos;; } else { children[i].nodeValue = data[gTextProp]; found = true; } } } if (!found) { var textNode = document.createTextNode(data[gTextProp]); element.prepend(textNode); } } delete data[gTextProp]; } for (var k in data) { element[k] = data[k]; } } function getChildElementCount(element) { if (element.children) { return element.children.length; } if (typeof element.childElementCount !== &apos;undefined&apos;) { return element.childElementCount; } var count = 0; for (var i = 0; i &lt; element.childNodes.length; i++) { count += element.nodeType === 1 ? 1 : 0; } return count; } function translateFragment(element) { element = element || document.documentElement; var children = getTranslatableChildren(element); var elementCount = children.length; for (var i = 0; i &lt; elementCount; i++) { translateElement(children[i]); } translateElement(element); } return { get: function (key, args, fallbackString) { var index = key.lastIndexOf(&apos;.&apos;); var prop = gTextProp; if (index &gt; 0) { prop = key.substring(index + 1); key = key.substring(0, index); } var fallback; if (fallbackString) { fallback = {}; fallback[prop] = fallbackString; } var data = getL10nData(key, args, fallback); if (data &amp;&amp; prop in data) { return data[prop]; } return &apos; + key + &apos;; }, getData: function () { return gL10nData; }, getText: function () { return gTextData; }, getLanguage: function () { return gLanguage; }, setLanguage: function (lang, callback) { loadLocale(lang, function () { if (callback) callback(); }); }, getDirection: function () { var rtlList = [&apos;ar&apos;, &apos;he&apos;, &apos;fa&apos;, &apos;ps&apos;, &apos;ur&apos;]; var shortCode = gLanguage.split(&apos;-&apos;, 1)[0]; return rtlList.indexOf(shortCode) &gt;= 0 ? &apos;rtl&apos; : &apos;ltr&apos;; }, translate: translateFragment, getReadyState: function () { return gReadyState; }, ready: function (callback) { if (!callback) { return; } else if (gReadyState == &apos;complete&apos; || gReadyState == &apos;interactive&apos;) { window.setTimeout(function () { callback(); }); } else if (document.addEventListener) { document.addEventListener(&apos;localized&apos;, function once() { document.removeEventListener(&apos;localized&apos;, once); callback(); }); } } }; }(window, document); /***/ }), /* 46 */ /***/ ((__unused_webpack_module, exports, __webpack_require__) =&gt; { Object.defineProperty(exports, &quot;__esModule&quot;, ({ value: true })); exports.GenericScripting = void 0; exports.docPropertiesLookup = docPropertiesLookup; var _pdfjsLib = __webpack_require__(5); async function docPropertiesLookup(pdfDocument) { const url = &quot;&quot;, baseUrl = url.split(&quot;#&quot;)[0]; let { info, metadata, contentDispositionFilename, contentLength } = await pdfDocument.getMetadata(); if (!contentLength) { const { length } = await pdfDocument.getDownloadInfo(); contentLength = length; } return { ...info, baseURL: baseUrl, filesize: contentLength, filename: contentDispositionFilename || (0, _pdfjsLib.getPdfFilenameFromUrl)(url), metadata: metadata?.getRaw(), authors: metadata?.get(&quot;dc:creator&quot;), numPages: pdfDocument.numPages, URL: url }; } class GenericScripting { constructor(sandboxBundleSrc) { this._ready = (0, _pdfjsLib.loadScript)(sandboxBundleSrc, true).then(() =&gt; { return window.pdfjsSandbox.QuickJSSandbox(); }); } async createSandbox(data) { const sandbox = await this._ready; sandbox.create(data); } async dispatchEventInSandbox(event) { const sandbox = await this._ready; setTimeout(() =&gt; sandbox.dispatchEvent(event), 0); } async destroySandbox() { const sandbox = await this._ready; sandbox.nukeSandbox(); } } exports.GenericScripting = GenericScripting; /***/ }), /* 47 */ /***/ ((__unused_webpack_module, exports, __webpack_require__) =&gt; { Object.defineProperty(exports, &quot;__esModule&quot;, ({ value: true })); exports.PDFPrintService = PDFPrintService; var _pdfjsLib = __webpack_require__(5); var _app = __webpack_require__(4); var _print_utils = __webpack_require__(48); let activeService = null; let dialog = null; let overlayManager = null; function renderPage(activeServiceOnEntry, pdfDocument, pageNumber, size, printResolution, optionalContentConfigPromise, printAnnotationStoragePromise) { const scratchCanvas = activeService.scratchCanvas; const PRINT_UNITS = printResolution / _pdfjsLib.PixelsPerInch.PDF; scratchCanvas.width = Math.floor(size.width * PRINT_UNITS); scratchCanvas.height = Math.floor(size.height * PRINT_UNITS); const ctx = scratchCanvas.getContext(&quot;2d&quot;); ctx.save(); ctx.fillStyle = &quot;rgb(255, 255, 255)&quot;; ctx.fillRect(0, 0, scratchCanvas.width, scratchCanvas.height); ctx.restore(); return Promise.all([pdfDocument.getPage(pageNumber), printAnnotationStoragePromise]).then(function ([pdfPage, printAnnotationStorage]) { const renderContext = { canvasContext: ctx, transform: [PRINT_UNITS, 0, 0, PRINT_UNITS, 0, 0], viewport: pdfPage.getViewport({ scale: 1, rotation: size.rotation }), intent: &quot;print&quot;, annotationMode: _pdfjsLib.AnnotationMode.ENABLE_STORAGE, optionalContentConfigPromise, printAnnotationStorage }; return pdfPage.render(renderContext).promise; }); } function PDFPrintService(pdfDocument, pagesOverview, printContainer, printResolution, optionalContentConfigPromise = null, printAnnotationStoragePromise = null, l10n) { this.pdfDocument = pdfDocument; this.pagesOverview = pagesOverview; this.printContainer = printContainer; this._printResolution = printResolution || 150; this._optionalContentConfigPromise = optionalContentConfigPromise || pdfDocument.getOptionalContentConfig(); this._printAnnotationStoragePromise = printAnnotationStoragePromise || Promise.resolve(); this.l10n = l10n; this.currentPage = -1; this.scratchCanvas = document.createElement(&quot;canvas&quot;); } PDFPrintService.prototype = { layout() { this.throwIfInactive(); const body = document.querySelector(&quot;body&quot;); body.setAttribute(&quot;data-pdfjsprinting&quot;, true); const hasEqualPageSizes = this.pagesOverview.every(function (size) { return size.width === this.pagesOverview[0].width &amp;&amp; size.height === this.pagesOverview[0].height; }, this); if (!hasEqualPageSizes) { console.warn(&quot;Not all pages have the same size. The printed &quot; + &quot;result may be incorrect!&quot;); } this.pageStyleSheet = document.createElement(&quot;style&quot;); const pageSize = this.pagesOverview[0]; this.pageStyleSheet.textContent = &quot;@page { size: &quot; + pageSize.width + &quot;pt &quot; + pageSize.height + &quot;pt;}&quot;; body.append(this.pageStyleSheet); }, destroy() { if (activeService !== this) { return; } this.printContainer.textContent = &quot;&quot;; const body = document.querySelector(&quot;body&quot;); body.removeAttribute(&quot;data-pdfjsprinting&quot;); if (this.pageStyleSheet) { this.pageStyleSheet.remove(); this.pageStyleSheet = null; } this.scratchCanvas.width = this.scratchCanvas.height = 0; this.scratchCanvas = null; activeService = null; ensureOverlay().then(function () { if (overlayManager.active === dialog) { overlayManager.close(dialog); } }); }, renderPages() { if (this.pdfDocument.isPureXfa) { (0, _print_utils.getXfaHtmlForPrinting)(this.printContainer, this.pdfDocument); return Promise.resolve(); } const pageCount = this.pagesOverview.length; const renderNextPage = (resolve, reject) =&gt; { this.throwIfInactive(); if (++this.currentPage &gt;= pageCount) { renderProgress(pageCount, pageCount, this.l10n); resolve(); return; } const index = this.currentPage; renderProgress(index, pageCount, this.l10n); renderPage(this, this.pdfDocument, index + 1, this.pagesOverview[index], this._printResolution, this._optionalContentConfigPromise, this._printAnnotationStoragePromise).then(this.useRenderedPage.bind(this)).then(function () { renderNextPage(resolve, reject); }, reject); }; return new Promise(renderNextPage); }, useRenderedPage() { this.throwIfInactive(); const img = document.createElement(&quot;img&quot;); const scratchCanvas = this.scratchCanvas; if (&quot;toBlob&quot; in scratchCanvas) { scratchCanvas.toBlob(function (blob) { img.src = URL.createObjectURL(blob); }); } else { img.src = scratchCanvas.toDataURL(); } const wrapper = document.createElement(&quot;div&quot;); wrapper.className = &quot;printedPage&quot;; wrapper.append(img); this.printContainer.append(wrapper); return new Promise(function (resolve, reject) { img.onload = resolve; img.onerror = reject; }); }, performPrint() { this.throwIfInactive(); return new Promise(resolve =&gt; { setTimeout(() =&gt; { if (!this.active) { resolve(); return; } print.call(window); setTimeout(resolve, 20); }, 0); }); }, get active() { return this === activeService; }, throwIfInactive() { if (!this.active) { throw new Error(&quot;This print request was cancelled or completed.&quot;); } } }; const print = window.print; window.print = function () { if (activeService) { console.warn(&quot;Ignored window.print() because of a pending print job.&quot;); return; } ensureOverlay().then(function () { if (activeService) { overlayManager.open(dialog); } }); try { dispatchEvent(&quot;beforeprint&quot;); } finally { if (!activeService) { console.error(&quot;Expected print service to be initialized.&quot;); ensureOverlay().then(function () { if (overlayManager.active === dialog) { overlayManager.close(dialog); } }); return; } const activeServiceOnEntry = activeService; activeService.renderPages().then(function () { return activeServiceOnEntry.performPrint(); }).catch(function () {}).then(function () { if (activeServiceOnEntry.active) { abort(); } }); } }; function dispatchEvent(eventType) { const event = document.createEvent(&quot;CustomEvent&quot;); event.initCustomEvent(eventType, false, false, &quot;custom&quot;); window.dispatchEvent(event); } function abort() { if (activeService) { activeService.destroy(); dispatchEvent(&quot;afterprint&quot;); } } function renderProgress(index, total, l10n) { dialog ||= document.getElementById(&quot;printServiceDialog&quot;); const progress = Math.round(100 * index / total); const progressBar = dialog.querySelector(&quot;progress&quot;); const progressPerc = dialog.querySelector(&quot;.relative-progress&quot;); progressBar.value = progress; l10n.get(&quot;print_progress_percent&quot;, { progress }).then(msg =&gt; { progressPerc.textContent = msg; }); } window.addEventListener(&quot;keydown&quot;, function (event) { if (event.keyCode === 80 &amp;&amp; (event.ctrlKey || event.metaKey) &amp;&amp; !event.altKey &amp;&amp; (!event.shiftKey || window.chrome || window.opera)) { window.print(); event.preventDefault(); event.stopImmediatePropagation(); } }, true); if (&quot;onbeforeprint&quot; in window) { const stopPropagationIfNeeded = function (event) { if (event.detail !== &quot;custom&quot;) { event.stopImmediatePropagation(); } }; window.addEventListener(&quot;beforeprint&quot;, stopPropagationIfNeeded); window.addEventListener(&quot;afterprint&quot;, stopPropagationIfNeeded); } let overlayPromise; function ensureOverlay() { if (!overlayPromise) { overlayManager = _app.PDFViewerApplication.overlayManager; if (!overlayManager) { throw new Error(&quot;The overlay manager has not yet been initialized.&quot;); } dialog ||= document.getElementById(&quot;printServiceDialog&quot;); overlayPromise = overlayManager.register(dialog, true); document.getElementById(&quot;printCancel&quot;).onclick = abort; dialog.addEventListener(&quot;close&quot;, abort); } return overlayPromise; } _app.PDFPrintServiceFactory.instance = { supportsPrinting: true, createPrintService(pdfDocument, pagesOverview, printContainer, printResolution, optionalContentConfigPromise, printAnnotationStoragePromise, l10n) { if (activeService) { throw new Error(&quot;The print service is created and active.&quot;); } activeService = new PDFPrintService(pdfDocument, pagesOverview, printContainer, printResolution, optionalContentConfigPromise, printAnnotationStoragePromise, l10n); return activeService; } }; /***/ }), /* 48 */ /***/ ((__unused_webpack_module, exports, __webpack_require__) =&gt; { Object.defineProperty(exports, &quot;__esModule&quot;, ({ value: true })); exports.getXfaHtmlForPrinting = getXfaHtmlForPrinting; var _pdfjsLib = __webpack_require__(5); var _pdf_link_service = __webpack_require__(3); var _xfa_layer_builder = __webpack_require__(37); function getXfaHtmlForPrinting(printContainer, pdfDocument) { const xfaHtml = pdfDocument.allXfaHtml; const linkService = new _pdf_link_service.SimpleLinkService(); const scale = Math.round(_pdfjsLib.PixelsPerInch.PDF_TO_CSS_UNITS * 100) / 100; for (const xfaPage of xfaHtml.children) { const page = document.createElement(&quot;div&quot;); page.className = &quot;xfaPrintedPage&quot;; printContainer.append(page); const builder = new _xfa_layer_builder.XfaLayerBuilder({ pageDiv: page, pdfPage: null, annotationStorage: pdfDocument.annotationStorage, linkService, xfaHtml: xfaPage }); const viewport = (0, _pdfjsLib.getXfaPageViewport)(xfaPage, { scale }); builder.render(viewport, &quot;print&quot;); } } /***/ }) /******/ ]); /************************************************************************/ /******/ // The module cache /******/ var __webpack_module_cache__ = {}; /******/ /******/ // The require function /******/ function __webpack_require__(moduleId) { /******/ // Check if module is in cache /******/ var cachedModule = __webpack_module_cache__[moduleId]; /******/ if (cachedModule !== undefined) { /******/ return cachedModule.exports; /******/ } /******/ // Create a new module (and put it into the cache) /******/ var module = __webpack_module_cache__[moduleId] = { /******/ // no module.id needed /******/ // no module.loaded needed /******/ exports: {} /******/ }; /******/ /******/ // Execute the module function /******/ __webpack_modules__[moduleId](module, module.exports, __webpack_require__); /******/ /******/ // Return the exports of the module /******/ return module.exports; /******/ } /******/ /************************************************************************/ var __webpack_exports__ = {}; // This entry need to be wrapped in an IIFE because it need to be isolated against other modules in the chunk. (() =&gt; { var exports = __webpack_exports__; Object.defineProperty(exports, &quot;__esModule&quot;, ({ value: true })); Object.defineProperty(exports, &quot;PDFViewerApplication&quot;, ({ enumerable: true, get: function () { return _app.PDFViewerApplication; } })); exports.PDFViewerApplicationConstants = void 0; Object.defineProperty(exports, &quot;PDFViewerApplicationOptions&quot;, ({ enumerable: true, get: function () { return _app_options.AppOptions; } })); var _ui_utils = __webpack_require__(1); var _app_options = __webpack_require__(2); var _pdf_link_service = __webpack_require__(3); var _app = __webpack_require__(4); const pdfjsVersion = &apos;3.0.0&apos;; const pdfjsBuild = &apos;987062c&apos;; const AppConstants = { LinkTarget: _pdf_link_service.LinkTarget, RenderingStates: _ui_utils.RenderingStates, ScrollMode: _ui_utils.ScrollMode, SpreadMode: _ui_utils.SpreadMode }; exports.PDFViewerApplicationConstants = AppConstants; window.PDFViewerApplication = _app.PDFViewerApplication; window.PDFViewerApplicationConstants = AppConstants; window.PDFViewerApplicationOptions = _app_options.AppOptions; ; ; { __webpack_require__(41); } ; { __webpack_require__(47); } function getViewerConfiguration() { return { appContainer: document.body, mainContainer: document.getElementById(&quot;viewerContainer&quot;), viewerContainer: document.getElementById(&quot;viewer&quot;), toolbar: { container: document.getElementById(&quot;toolbarViewer&quot;), numPages: document.getElementById(&quot;numPages&quot;), pageNumber: document.getElementById(&quot;pageNumber&quot;), scaleSelect: document.getElementById(&quot;scaleSelect&quot;), customScaleOption: document.getElementById(&quot;customScaleOption&quot;), previous: document.getElementById(&quot;previous&quot;), next: document.getElementById(&quot;next&quot;), zoomIn: document.getElementById(&quot;zoomIn&quot;), zoomOut: document.getElementById(&quot;zoomOut&quot;), viewFind: document.getElementById(&quot;viewFind&quot;), openFile: document.getElementById(&quot;openFile&quot;), print: document.getElementById(&quot;print&quot;), editorFreeTextButton: document.getElementById(&quot;editorFreeText&quot;), editorFreeTextParamsToolbar: document.getElementById(&quot;editorFreeTextParamsToolbar&quot;), editorInkButton: document.getElementById(&quot;editorInk&quot;), editorInkParamsToolbar: document.getElementById(&quot;editorInkParamsToolbar&quot;), download: document.getElementById(&quot;download&quot;) }, secondaryToolbar: { toolbar: document.getElementById(&quot;secondaryToolbar&quot;), toggleButton: document.getElementById(&quot;secondaryToolbarToggle&quot;), presentationModeButton: document.getElementById(&quot;presentationMode&quot;), openFileButton: document.getElementById(&quot;secondaryOpenFile&quot;), printButton: document.getElementById(&quot;secondaryPrint&quot;), downloadButton: document.getElementById(&quot;secondaryDownload&quot;), viewBookmarkButton: document.getElementById(&quot;viewBookmark&quot;), firstPageButton: document.getElementById(&quot;firstPage&quot;), lastPageButton: document.getElementById(&quot;lastPage&quot;), pageRotateCwButton: document.getElementById(&quot;pageRotateCw&quot;), pageRotateCcwButton: document.getElementById(&quot;pageRotateCcw&quot;), cursorSelectToolButton: document.getElementById(&quot;cursorSelectTool&quot;), cursorHandToolButton: document.getElementById(&quot;cursorHandTool&quot;), scrollPageButton: document.getElementById(&quot;scrollPage&quot;), scrollVerticalButton: document.getElementById(&quot;scrollVertical&quot;), scrollHorizontalButton: document.getElementById(&quot;scrollHorizontal&quot;), scrollWrappedButton: document.getElementById(&quot;scrollWrapped&quot;), spreadNoneButton: document.getElementById(&quot;spreadNone&quot;), spreadOddButton: document.getElementById(&quot;spreadOdd&quot;), spreadEvenButton: document.getElementById(&quot;spreadEven&quot;), documentPropertiesButton: document.getElementById(&quot;documentProperties&quot;) }, sidebar: { outerContainer: document.getElementById(&quot;outerContainer&quot;), sidebarContainer: document.getElementById(&quot;sidebarContainer&quot;), toggleButton: document.getElementById(&quot;sidebarToggle&quot;), thumbnailButton: document.getElementById(&quot;viewThumbnail&quot;), outlineButton: document.getElementById(&quot;viewOutline&quot;), attachmentsButton: document.getElementById(&quot;viewAttachments&quot;), layersButton: document.getElementById(&quot;viewLayers&quot;), thumbnailView: document.getElementById(&quot;thumbnailView&quot;), outlineView: document.getElementById(&quot;outlineView&quot;), attachmentsView: document.getElementById(&quot;attachmentsView&quot;), layersView: document.getElementById(&quot;layersView&quot;), outlineOptionsContainer: document.getElementById(&quot;outlineOptionsContainer&quot;), currentOutlineItemButton: document.getElementById(&quot;currentOutlineItem&quot;) }, sidebarResizer: { outerContainer: document.getElementById(&quot;outerContainer&quot;), resizer: document.getElementById(&quot;sidebarResizer&quot;) }, findBar: { bar: document.getElementById(&quot;findbar&quot;), toggleButton: document.getElementById(&quot;viewFind&quot;), findField: document.getElementById(&quot;findInput&quot;), highlightAllCheckbox: document.getElementById(&quot;findHighlightAll&quot;), caseSensitiveCheckbox: document.getElementById(&quot;findMatchCase&quot;), matchDiacriticsCheckbox: document.getElementById(&quot;findMatchDiacritics&quot;), entireWordCheckbox: document.getElementById(&quot;findEntireWord&quot;), findMsg: document.getElementById(&quot;findMsg&quot;), findResultsCount: document.getElementById(&quot;findResultsCount&quot;), findPreviousButton: document.getElementById(&quot;findPrevious&quot;), findNextButton: document.getElementById(&quot;findNext&quot;) }, passwordOverlay: { dialog: document.getElementById(&quot;passwordDialog&quot;), label: document.getElementById(&quot;passwordText&quot;), input: document.getElementById(&quot;password&quot;), submitButton: document.getElementById(&quot;passwordSubmit&quot;), cancelButton: document.getElementById(&quot;passwordCancel&quot;) }, documentProperties: { dialog: document.getElementById(&quot;documentPropertiesDialog&quot;), closeButton: document.getElementById(&quot;documentPropertiesClose&quot;), fields: { fileName: document.getElementById(&quot;fileNameField&quot;), fileSize: document.getElementById(&quot;fileSizeField&quot;), title: document.getElementById(&quot;titleField&quot;), author: document.getElementById(&quot;authorField&quot;), subject: document.getElementById(&quot;subjectField&quot;), keywords: document.getElementById(&quot;keywordsField&quot;), creationDate: document.getElementById(&quot;creationDateField&quot;), modificationDate: document.getElementById(&quot;modificationDateField&quot;), creator: document.getElementById(&quot;creatorField&quot;), producer: document.getElementById(&quot;producerField&quot;), version: document.getElementById(&quot;versionField&quot;), pageCount: document.getElementById(&quot;pageCountField&quot;), pageSize: document.getElementById(&quot;pageSizeField&quot;), linearized: document.getElementById(&quot;linearizedField&quot;) } }, annotationEditorParams: { editorFreeTextFontSize: document.getElementById(&quot;editorFreeTextFontSize&quot;), editorFreeTextColor: document.getElementById(&quot;editorFreeTextColor&quot;), editorInkColor: document.getElementById(&quot;editorInkColor&quot;), editorInkThickness: document.getElementById(&quot;editorInkThickness&quot;), editorInkOpacity: document.getElementById(&quot;editorInkOpacity&quot;) }, printContainer: document.getElementById(&quot;printContainer&quot;), openFileInput: document.getElementById(&quot;fileInput&quot;), debuggerScriptPath: &quot;./debugger.js&quot; }; } function webViewerLoad() { const config = getViewerConfiguration(); const event = document.createEvent(&quot;CustomEvent&quot;); event.initCustomEvent(&quot;webviewerloaded&quot;, true, true, { source: window }); try { parent.document.dispatchEvent(event); } catch (ex) { console.error(`webviewerloaded: ${ex}`); document.dispatchEvent(event); } _app.PDFViewerApplication.run(config); } document.blockUnblockOnload?.(true); if (document.readyState === &quot;interactive&quot; || document.readyState === &quot;complete&quot;) { webViewerLoad(); } else { document.addEventListener(&quot;DOMContentLoaded&quot;, webViewerLoad, true); } })(); /******/ })() ; //# sourceMappingURL=viewer.js.map","link":"/lib/pdf/web/viewer.js"},{"title":"","text":"/** * @licstart The following is the entire license notice for the * JavaScript code in this page * * Copyright 2022 Mozilla Foundation * * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. * * @licend The above is the entire license notice for the * JavaScript code in this page */ (function webpackUniversalModuleDefinition(root, factory) { if(typeof exports === &apos;object&apos; &amp;&amp; typeof module === &apos;object&apos;) module.exports = factory(); else if(typeof define === &apos;function&apos; &amp;&amp; define.amd) define(&quot;pdfjs-dist/build/pdf.sandbox&quot;, [], factory); else if(typeof exports === &apos;object&apos;) exports[&quot;pdfjs-dist/build/pdf.sandbox&quot;] = factory(); else root[&quot;pdfjs-dist/build/pdf.sandbox&quot;] = root.pdfjsSandbox = factory(); })(globalThis, () =&gt; { return /******/ (() =&gt; { // webpackBootstrap /******/ &quot;use strict&quot;; /******/ var __webpack_modules__ = ([ /* 0 */, /* 1 */ /***/ ((__unused_webpack_module, exports) =&gt; { Object.defineProperty(exports, &quot;__esModule&quot;, ({value:true}));exports[&quot;default&quot;]=void 0;var Module=(()=&gt;{var _scriptDir=typeof document!==&apos;undefined&apos;&amp;&amp;document.currentScript?document.currentScript.src:undefined;return function(Module){Module=Module||{};var c;c||(c=typeof Module!==&apos;undefined&apos;?Module:{});var h,n;c.ready=new Promise(function(a,b){h=a;n=b;});var r=Object.assign({},c),t=&quot;&quot;;&quot;undefined&quot;!=typeof document&amp;&amp;document.currentScript&amp;&amp;(t=document.currentScript.src);_scriptDir&amp;&amp;(t=_scriptDir);0!==t.indexOf(&quot;blob:&quot;)?t=t.substr(0,t.replace(/[?#].*/,&quot;&quot;).lastIndexOf(&quot;/&quot;)+1):t=&quot;&quot;;var aa=c.print||console.log.bind(console),u=c.printErr||console.warn.bind(console);Object.assign(c,r);r=null;var v;c.wasmBinary&amp;&amp;(v=c.wasmBinary);var noExitRuntime=c.noExitRuntime||!0;&quot;object&quot;!=typeof WebAssembly&amp;&amp;w(&quot;no native wasm support detected&quot;);var x,y=!1;function z(a,b,d,e){var f={string:function(l){var p=0;if(null!==l&amp;&amp;void 0!==l&amp;&amp;0!==l){var S=(l.length&lt;&lt;2)+1;p=A(S);B(l,C,p,S);}return p;},array:function(l){var p=A(l.length);D.set(l,p);return p;}};a=c[&quot;_&quot;+a];var g=[],k=0;if(e)for(var m=0;m=d);)++e;if(16","link":"/lib/pdf/build/pdf.sandbox.js"},{"title":"","text":"/** * @licstart The following is the entire license notice for the * JavaScript code in this page * * Copyright 2022 Mozilla Foundation * * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. * * @licend The above is the entire license notice for the * JavaScript code in this page */ (function webpackUniversalModuleDefinition(root, factory) { if(typeof exports === &apos;object&apos; &amp;&amp; typeof module === &apos;object&apos;) module.exports = factory(); else if(typeof define === &apos;function&apos; &amp;&amp; define.amd) define(&quot;pdfjs-dist/build/pdf.worker&quot;, [], factory); else if(typeof exports === &apos;object&apos;) exports[&quot;pdfjs-dist/build/pdf.worker&quot;] = factory(); else root[&quot;pdfjs-dist/build/pdf.worker&quot;] = root.pdfjsWorker = factory(); })(globalThis, () =&gt; { return /******/ (() =&gt; { // webpackBootstrap /******/ &quot;use strict&quot;; /******/ var __webpack_modules__ = ([ /* 0 */, /* 1 */ /***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) =&gt; { Object.defineProperty(exports, &quot;__esModule&quot;, ({ value: true })); exports.WorkerTask = exports.WorkerMessageHandler = void 0; var _util = __w_pdfjs_require__(2); var _primitives = __w_pdfjs_require__(3); var _core_utils = __w_pdfjs_require__(4); var _pdf_manager = __w_pdfjs_require__(6); var _cleanup_helper = __w_pdfjs_require__(69); var _writer = __w_pdfjs_require__(63); var _is_node = __w_pdfjs_require__(100); var _message_handler = __w_pdfjs_require__(101); var _worker_stream = __w_pdfjs_require__(102); class WorkerTask { constructor(name) { this.name = name; this.terminated = false; this._capability = (0, _util.createPromiseCapability)(); } get finished() { return this._capability.promise; } finish() { this._capability.resolve(); } terminate() { this.terminated = true; } ensureNotTerminated() { if (this.terminated) { throw new Error(&quot;Worker task was terminated&quot;); } } } exports.WorkerTask = WorkerTask; class WorkerMessageHandler { static setup(handler, port) { let testMessageProcessed = false; handler.on(&quot;test&quot;, function wphSetupTest(data) { if (testMessageProcessed) { return; } testMessageProcessed = true; handler.send(&quot;test&quot;, data instanceof Uint8Array); }); handler.on(&quot;configure&quot;, function wphConfigure(data) { (0, _util.setVerbosityLevel)(data.verbosity); }); handler.on(&quot;GetDocRequest&quot;, function wphSetupDoc(data) { return WorkerMessageHandler.createDocumentHandler(data, port); }); } static createDocumentHandler(docParams, port) { let pdfManager; let terminated = false; let cancelXHRs = null; const WorkerTasks = []; const verbosity = (0, _util.getVerbosityLevel)(); const { docId, apiVersion } = docParams; const workerVersion = &apos;3.0.0&apos;; if (apiVersion !== workerVersion) { throw new Error(`The API version &quot;${apiVersion}&quot; does not match ` + `the Worker version &quot;${workerVersion}&quot;.`); } const enumerableProperties = []; for (const property in []) { enumerableProperties.push(property); } if (enumerableProperties.length) { throw new Error(&quot;The `Array.prototype` contains unexpected enumerable properties: &quot; + enumerableProperties.join(&quot;, &quot;) + &quot;; thus breaking e.g. `for...in` iteration of `Array`s.&quot;); } if (typeof ReadableStream === &quot;undefined&quot;) { const partialMsg = &quot;The browser/environment lacks native support for critical &quot; + &quot;functionality used by the PDF.js library (e.g. `ReadableStream`); &quot;; if (_is_node.isNodeJS) { throw new Error(partialMsg + &quot;please use a `legacy`-build instead.&quot;); } throw new Error(partialMsg + &quot;please update to a supported browser.&quot;); } const workerHandlerName = docId + &quot;_worker&quot;; let handler = new _message_handler.MessageHandler(workerHandlerName, docId, port); function ensureNotTerminated() { if (terminated) { throw new Error(&quot;Worker was terminated&quot;); } } function startWorkerTask(task) { WorkerTasks.push(task); } function finishWorkerTask(task) { task.finish(); const i = WorkerTasks.indexOf(task); WorkerTasks.splice(i, 1); } async function loadDocument(recoveryMode) { await pdfManager.ensureDoc(&quot;checkHeader&quot;); await pdfManager.ensureDoc(&quot;parseStartXRef&quot;); await pdfManager.ensureDoc(&quot;parse&quot;, [recoveryMode]); await pdfManager.ensureDoc(&quot;checkFirstPage&quot;, [recoveryMode]); await pdfManager.ensureDoc(&quot;checkLastPage&quot;, [recoveryMode]); const isPureXfa = await pdfManager.ensureDoc(&quot;isPureXfa&quot;); if (isPureXfa) { const task = new WorkerTask(&quot;loadXfaFonts&quot;); startWorkerTask(task); await Promise.all([pdfManager.loadXfaFonts(handler, task).catch(reason =&gt; {}).then(() =&gt; finishWorkerTask(task)), pdfManager.loadXfaImages()]); } const [numPages, fingerprints] = await Promise.all([pdfManager.ensureDoc(&quot;numPages&quot;), pdfManager.ensureDoc(&quot;fingerprints&quot;)]); const htmlForXfa = isPureXfa ? await pdfManager.ensureDoc(&quot;htmlForXfa&quot;) : null; return { numPages, fingerprints, htmlForXfa }; } function getPdfManager({ data, password, disableAutoFetch, rangeChunkSize, length, docBaseUrl, enableXfa, evaluatorOptions }) { const pdfManagerCapability = (0, _util.createPromiseCapability)(); let newPdfManager; if (data) { try { newPdfManager = new _pdf_manager.LocalPdfManager(docId, data, password, handler, evaluatorOptions, enableXfa, docBaseUrl); pdfManagerCapability.resolve(newPdfManager); } catch (ex) { pdfManagerCapability.reject(ex); } return pdfManagerCapability.promise; } let pdfStream, cachedChunks = []; try { pdfStream = new _worker_stream.PDFWorkerStream(handler); } catch (ex) { pdfManagerCapability.reject(ex); return pdfManagerCapability.promise; } const fullRequest = pdfStream.getFullReader(); fullRequest.headersReady.then(function () { if (!fullRequest.isRangeSupported) { return; } disableAutoFetch = disableAutoFetch || fullRequest.isStreamingSupported; newPdfManager = new _pdf_manager.NetworkPdfManager(docId, pdfStream, { msgHandler: handler, password, length: fullRequest.contentLength, disableAutoFetch, rangeChunkSize }, evaluatorOptions, enableXfa, docBaseUrl); for (const chunk of cachedChunks) { newPdfManager.sendProgressiveData(chunk); } cachedChunks = []; pdfManagerCapability.resolve(newPdfManager); cancelXHRs = null; }).catch(function (reason) { pdfManagerCapability.reject(reason); cancelXHRs = null; }); let loaded = 0; const flushChunks = function () { const pdfFile = (0, _util.arraysToBytes)(cachedChunks); if (length &amp;&amp; pdfFile.length !== length) { (0, _util.warn)(&quot;reported HTTP length is different from actual&quot;); } try { newPdfManager = new _pdf_manager.LocalPdfManager(docId, pdfFile, password, handler, evaluatorOptions, enableXfa, docBaseUrl); pdfManagerCapability.resolve(newPdfManager); } catch (ex) { pdfManagerCapability.reject(ex); } cachedChunks = []; }; const readPromise = new Promise(function (resolve, reject) { const readChunk = function ({ value, done }) { try { ensureNotTerminated(); if (done) { if (!newPdfManager) { flushChunks(); } cancelXHRs = null; return; } loaded += (0, _util.arrayByteLength)(value); if (!fullRequest.isStreamingSupported) { handler.send(&quot;DocProgress&quot;, { loaded, total: Math.max(loaded, fullRequest.contentLength || 0) }); } if (newPdfManager) { newPdfManager.sendProgressiveData(value); } else { cachedChunks.push(value); } fullRequest.read().then(readChunk, reject); } catch (e) { reject(e); } }; fullRequest.read().then(readChunk, reject); }); readPromise.catch(function (e) { pdfManagerCapability.reject(e); cancelXHRs = null; }); cancelXHRs = function (reason) { pdfStream.cancelAllRequests(reason); }; return pdfManagerCapability.promise; } function setupDoc(data) { function onSuccess(doc) { ensureNotTerminated(); handler.send(&quot;GetDoc&quot;, { pdfInfo: doc }); } function onFailure(ex) { ensureNotTerminated(); if (ex instanceof _util.PasswordException) { const task = new WorkerTask(`PasswordException: response ${ex.code}`); startWorkerTask(task); handler.sendWithPromise(&quot;PasswordRequest&quot;, ex).then(function ({ password }) { finishWorkerTask(task); pdfManager.updatePassword(password); pdfManagerReady(); }).catch(function () { finishWorkerTask(task); handler.send(&quot;DocException&quot;, ex); }); } else if (ex instanceof _util.InvalidPDFException || ex instanceof _util.MissingPDFException || ex instanceof _util.UnexpectedResponseException || ex instanceof _util.UnknownErrorException) { handler.send(&quot;DocException&quot;, ex); } else { handler.send(&quot;DocException&quot;, new _util.UnknownErrorException(ex.message, ex.toString())); } } function pdfManagerReady() { ensureNotTerminated(); loadDocument(false).then(onSuccess, function (reason) { ensureNotTerminated(); if (!(reason instanceof _core_utils.XRefParseException)) { onFailure(reason); return; } pdfManager.requestLoadedStream(); pdfManager.onLoadedStream().then(function () { ensureNotTerminated(); loadDocument(true).then(onSuccess, onFailure); }); }); } ensureNotTerminated(); getPdfManager(data).then(function (newPdfManager) { if (terminated) { newPdfManager.terminate(new _util.AbortException(&quot;Worker was terminated.&quot;)); throw new Error(&quot;Worker was terminated&quot;); } pdfManager = newPdfManager; pdfManager.onLoadedStream().then(function (stream) { handler.send(&quot;DataLoaded&quot;, { length: stream.bytes.byteLength }); }); }).then(pdfManagerReady, onFailure); } handler.on(&quot;GetPage&quot;, function wphSetupGetPage(data) { return pdfManager.getPage(data.pageIndex).then(function (page) { return Promise.all([pdfManager.ensure(page, &quot;rotate&quot;), pdfManager.ensure(page, &quot;ref&quot;), pdfManager.ensure(page, &quot;userUnit&quot;), pdfManager.ensure(page, &quot;view&quot;)]).then(function ([rotate, ref, userUnit, view]) { return { rotate, ref, userUnit, view }; }); }); }); handler.on(&quot;GetPageIndex&quot;, function wphSetupGetPageIndex(data) { const pageRef = _primitives.Ref.get(data.num, data.gen); return pdfManager.ensureCatalog(&quot;getPageIndex&quot;, [pageRef]); }); handler.on(&quot;GetDestinations&quot;, function wphSetupGetDestinations(data) { return pdfManager.ensureCatalog(&quot;destinations&quot;); }); handler.on(&quot;GetDestination&quot;, function wphSetupGetDestination(data) { return pdfManager.ensureCatalog(&quot;getDestination&quot;, [data.id]); }); handler.on(&quot;GetPageLabels&quot;, function wphSetupGetPageLabels(data) { return pdfManager.ensureCatalog(&quot;pageLabels&quot;); }); handler.on(&quot;GetPageLayout&quot;, function wphSetupGetPageLayout(data) { return pdfManager.ensureCatalog(&quot;pageLayout&quot;); }); handler.on(&quot;GetPageMode&quot;, function wphSetupGetPageMode(data) { return pdfManager.ensureCatalog(&quot;pageMode&quot;); }); handler.on(&quot;GetViewerPreferences&quot;, function (data) { return pdfManager.ensureCatalog(&quot;viewerPreferences&quot;); }); handler.on(&quot;GetOpenAction&quot;, function (data) { return pdfManager.ensureCatalog(&quot;openAction&quot;); }); handler.on(&quot;GetAttachments&quot;, function wphSetupGetAttachments(data) { return pdfManager.ensureCatalog(&quot;attachments&quot;); }); handler.on(&quot;GetJavaScript&quot;, function wphSetupGetJavaScript(data) { return pdfManager.ensureCatalog(&quot;javaScript&quot;); }); handler.on(&quot;GetDocJSActions&quot;, function wphSetupGetDocJSActions(data) { return pdfManager.ensureCatalog(&quot;jsActions&quot;); }); handler.on(&quot;GetPageJSActions&quot;, function ({ pageIndex }) { return pdfManager.getPage(pageIndex).then(function (page) { return pdfManager.ensure(page, &quot;jsActions&quot;); }); }); handler.on(&quot;GetOutline&quot;, function wphSetupGetOutline(data) { return pdfManager.ensureCatalog(&quot;documentOutline&quot;); }); handler.on(&quot;GetOptionalContentConfig&quot;, function (data) { return pdfManager.ensureCatalog(&quot;optionalContentConfig&quot;); }); handler.on(&quot;GetPermissions&quot;, function (data) { return pdfManager.ensureCatalog(&quot;permissions&quot;); }); handler.on(&quot;GetMetadata&quot;, function wphSetupGetMetadata(data) { return Promise.all([pdfManager.ensureDoc(&quot;documentInfo&quot;), pdfManager.ensureCatalog(&quot;metadata&quot;)]); }); handler.on(&quot;GetMarkInfo&quot;, function wphSetupGetMarkInfo(data) { return pdfManager.ensureCatalog(&quot;markInfo&quot;); }); handler.on(&quot;GetData&quot;, function wphSetupGetData(data) { pdfManager.requestLoadedStream(); return pdfManager.onLoadedStream().then(function (stream) { return stream.bytes; }); }); handler.on(&quot;GetAnnotations&quot;, function ({ pageIndex, intent }) { return pdfManager.getPage(pageIndex).then(function (page) { const task = new WorkerTask(`GetAnnotations: page ${pageIndex}`); startWorkerTask(task); return page.getAnnotationsData(handler, task, intent).then(data =&gt; { finishWorkerTask(task); return data; }, reason =&gt; { finishWorkerTask(task); }); }); }); handler.on(&quot;GetFieldObjects&quot;, function (data) { return pdfManager.ensureDoc(&quot;fieldObjects&quot;); }); handler.on(&quot;HasJSActions&quot;, function (data) { return pdfManager.ensureDoc(&quot;hasJSActions&quot;); }); handler.on(&quot;GetCalculationOrderIds&quot;, function (data) { return pdfManager.ensureDoc(&quot;calculationOrderIds&quot;); }); handler.on(&quot;SaveDocument&quot;, function ({ isPureXfa, numPages, annotationStorage, filename }) { pdfManager.requestLoadedStream(); const newAnnotationsByPage = !isPureXfa ? (0, _core_utils.getNewAnnotationsMap)(annotationStorage) : null; const promises = [pdfManager.onLoadedStream(), pdfManager.ensureCatalog(&quot;acroForm&quot;), pdfManager.ensureCatalog(&quot;acroFormRef&quot;), pdfManager.ensureDoc(&quot;xref&quot;), pdfManager.ensureDoc(&quot;startXRef&quot;)]; if (newAnnotationsByPage) { for (const [pageIndex, annotations] of newAnnotationsByPage) { promises.push(pdfManager.getPage(pageIndex).then(page =&gt; { const task = new WorkerTask(`Save (editor): page ${pageIndex}`); return page.saveNewAnnotations(handler, task, annotations).finally(function () { finishWorkerTask(task); }); })); } } if (isPureXfa) { promises.push(pdfManager.serializeXfaData(annotationStorage)); } else { for (let pageIndex = 0; pageIndex &lt; numPages; pageIndex++) { promises.push(pdfManager.getPage(pageIndex).then(function (page) { const task = new WorkerTask(`Save: page ${pageIndex}`); return page.save(handler, task, annotationStorage).finally(function () { finishWorkerTask(task); }); })); } } return Promise.all(promises).then(function ([stream, acroForm, acroFormRef, xref, startXRef, ...refs]) { let newRefs = []; let xfaData = null; if (isPureXfa) { xfaData = refs[0]; if (!xfaData) { return stream.bytes; } } else { newRefs = refs.flat(2); if (newRefs.length === 0) { return stream.bytes; } } const xfa = acroForm instanceof _primitives.Dict &amp;&amp; acroForm.get(&quot;XFA&quot;) || null; let xfaDatasetsRef = null; let hasXfaDatasetsEntry = false; if (Array.isArray(xfa)) { for (let i = 0, ii = xfa.length; i &lt; ii; i += 2) { if (xfa[i] === &quot;datasets&quot;) { xfaDatasetsRef = xfa[i + 1]; acroFormRef = null; hasXfaDatasetsEntry = true; } } if (xfaDatasetsRef === null) { xfaDatasetsRef = xref.getNewRef(); } } else if (xfa) { acroFormRef = null; (0, _util.warn)(&quot;Unsupported XFA type.&quot;); } let newXrefInfo = Object.create(null); if (xref.trailer) { const infoObj = Object.create(null); const xrefInfo = xref.trailer.get(&quot;Info&quot;) || null; if (xrefInfo instanceof _primitives.Dict) { xrefInfo.forEach((key, value) =&gt; { if (typeof value === &quot;string&quot;) { infoObj[key] = (0, _util.stringToPDFString)(value); } }); } newXrefInfo = { rootRef: xref.trailer.getRaw(&quot;Root&quot;) || null, encryptRef: xref.trailer.getRaw(&quot;Encrypt&quot;) || null, newRef: xref.getNewRef(), infoRef: xref.trailer.getRaw(&quot;Info&quot;) || null, info: infoObj, fileIds: xref.trailer.get(&quot;ID&quot;) || null, startXRef, filename }; } xref.resetNewRef(); return (0, _writer.incrementalUpdate)({ originalData: stream.bytes, xrefInfo: newXrefInfo, newRefs, xref, hasXfa: !!xfa, xfaDatasetsRef, hasXfaDatasetsEntry, acroFormRef, acroForm, xfaData }); }); }); handler.on(&quot;GetOperatorList&quot;, function wphSetupRenderPage(data, sink) { const pageIndex = data.pageIndex; pdfManager.getPage(pageIndex).then(function (page) { const task = new WorkerTask(`GetOperatorList: page ${pageIndex}`); startWorkerTask(task); const start = verbosity &gt;= _util.VerbosityLevel.INFOS ? Date.now() : 0; page.getOperatorList({ handler, sink, task, intent: data.intent, cacheKey: data.cacheKey, annotationStorage: data.annotationStorage }).then(function (operatorListInfo) { finishWorkerTask(task); if (start) { (0, _util.info)(`page=${pageIndex + 1} - getOperatorList: time=` + `${Date.now() - start}ms, len=${operatorListInfo.length}`); } sink.close(); }, function (reason) { finishWorkerTask(task); if (task.terminated) { return; } sink.error(reason); }); }); }); handler.on(&quot;GetTextContent&quot;, function wphExtractText(data, sink) { const pageIndex = data.pageIndex; pdfManager.getPage(pageIndex).then(function (page) { const task = new WorkerTask(&quot;GetTextContent: page &quot; + pageIndex); startWorkerTask(task); const start = verbosity &gt;= _util.VerbosityLevel.INFOS ? Date.now() : 0; page.extractTextContent({ handler, task, sink, includeMarkedContent: data.includeMarkedContent, combineTextItems: data.combineTextItems }).then(function () { finishWorkerTask(task); if (start) { (0, _util.info)(`page=${pageIndex + 1} - getTextContent: time=` + `${Date.now() - start}ms`); } sink.close(); }, function (reason) { finishWorkerTask(task); if (task.terminated) { return; } sink.error(reason); }); }); }); handler.on(&quot;GetStructTree&quot;, function wphGetStructTree(data) { return pdfManager.getPage(data.pageIndex).then(function (page) { return pdfManager.ensure(page, &quot;getStructTree&quot;); }); }); handler.on(&quot;FontFallback&quot;, function (data) { return pdfManager.fontFallback(data.id, handler); }); handler.on(&quot;Cleanup&quot;, function wphCleanup(data) { return pdfManager.cleanup(true); }); handler.on(&quot;Terminate&quot;, function wphTerminate(data) { terminated = true; const waitOn = []; if (pdfManager) { pdfManager.terminate(new _util.AbortException(&quot;Worker was terminated.&quot;)); const cleanupPromise = pdfManager.cleanup(); waitOn.push(cleanupPromise); pdfManager = null; } else { (0, _cleanup_helper.clearGlobalCaches)(); } if (cancelXHRs) { cancelXHRs(new _util.AbortException(&quot;Worker was terminated.&quot;)); } for (const task of WorkerTasks) { waitOn.push(task.finished); task.terminate(); } return Promise.all(waitOn).then(function () { handler.destroy(); handler = null; }); }); handler.on(&quot;Ready&quot;, function wphReady(data) { setupDoc(docParams); docParams = null; }); return workerHandlerName; } static initializeFromPort(port) { const handler = new _message_handler.MessageHandler(&quot;worker&quot;, &quot;main&quot;, port); WorkerMessageHandler.setup(handler, port); handler.send(&quot;ready&quot;, null); } } exports.WorkerMessageHandler = WorkerMessageHandler; function isMessagePort(maybePort) { return typeof maybePort.postMessage === &quot;function&quot; &amp;&amp; &quot;onmessage&quot; in maybePort; } if (typeof window === &quot;undefined&quot; &amp;&amp; !_is_node.isNodeJS &amp;&amp; typeof self !== &quot;undefined&quot; &amp;&amp; isMessagePort(self)) { WorkerMessageHandler.initializeFromPort(self); } /***/ }), /* 2 */ /***/ ((__unused_webpack_module, exports) =&gt; { Object.defineProperty(exports, &quot;__esModule&quot;, ({ value: true })); exports.VerbosityLevel = exports.Util = exports.UnknownErrorException = exports.UnexpectedResponseException = exports.UNSUPPORTED_FEATURES = exports.TextRenderingMode = exports.StreamType = exports.RenderingIntentFlag = exports.PermissionFlag = exports.PasswordResponses = exports.PasswordException = exports.PageActionEventType = exports.OPS = exports.MissingPDFException = exports.LINE_FACTOR = exports.LINE_DESCENT_FACTOR = exports.InvalidPDFException = exports.ImageKind = exports.IDENTITY_MATRIX = exports.FormatError = exports.FontType = exports.FeatureTest = exports.FONT_IDENTITY_MATRIX = exports.DocumentActionEventType = exports.CMapCompressionType = exports.BaseException = exports.AnnotationType = exports.AnnotationStateModelType = exports.AnnotationReviewState = exports.AnnotationReplyType = exports.AnnotationMode = exports.AnnotationMarkedState = exports.AnnotationFlag = exports.AnnotationFieldFlag = exports.AnnotationEditorType = exports.AnnotationEditorPrefix = exports.AnnotationEditorParamsType = exports.AnnotationBorderStyleType = exports.AnnotationActionEventType = exports.AbortException = void 0; exports.arrayByteLength = arrayByteLength; exports.arraysToBytes = arraysToBytes; exports.assert = assert; exports.bytesToString = bytesToString; exports.createPromiseCapability = createPromiseCapability; exports.createValidAbsoluteUrl = createValidAbsoluteUrl; exports.escapeString = escapeString; exports.getModificationDate = getModificationDate; exports.getVerbosityLevel = getVerbosityLevel; exports.info = info; exports.isArrayBuffer = isArrayBuffer; exports.isArrayEqual = isArrayEqual; exports.isAscii = isAscii; exports.objectFromMap = objectFromMap; exports.objectSize = objectSize; exports.setVerbosityLevel = setVerbosityLevel; exports.shadow = shadow; exports.string32 = string32; exports.stringToBytes = stringToBytes; exports.stringToPDFString = stringToPDFString; exports.stringToUTF16BEString = stringToUTF16BEString; exports.stringToUTF8String = stringToUTF8String; exports.unreachable = unreachable; exports.utf8StringToString = utf8StringToString; exports.warn = warn; ; const IDENTITY_MATRIX = [1, 0, 0, 1, 0, 0]; exports.IDENTITY_MATRIX = IDENTITY_MATRIX; const FONT_IDENTITY_MATRIX = [0.001, 0, 0, 0.001, 0, 0]; exports.FONT_IDENTITY_MATRIX = FONT_IDENTITY_MATRIX; const LINE_FACTOR = 1.35; exports.LINE_FACTOR = LINE_FACTOR; const LINE_DESCENT_FACTOR = 0.35; exports.LINE_DESCENT_FACTOR = LINE_DESCENT_FACTOR; const RenderingIntentFlag = { ANY: 0x01, DISPLAY: 0x02, PRINT: 0x04, ANNOTATIONS_FORMS: 0x10, ANNOTATIONS_STORAGE: 0x20, ANNOTATIONS_DISABLE: 0x40, OPLIST: 0x100 }; exports.RenderingIntentFlag = RenderingIntentFlag; const AnnotationMode = { DISABLE: 0, ENABLE: 1, ENABLE_FORMS: 2, ENABLE_STORAGE: 3 }; exports.AnnotationMode = AnnotationMode; const AnnotationEditorPrefix = &quot;pdfjs_internal_editor_&quot;; exports.AnnotationEditorPrefix = AnnotationEditorPrefix; const AnnotationEditorType = { DISABLE: -1, NONE: 0, FREETEXT: 3, INK: 15 }; exports.AnnotationEditorType = AnnotationEditorType; const AnnotationEditorParamsType = { FREETEXT_SIZE: 1, FREETEXT_COLOR: 2, FREETEXT_OPACITY: 3, INK_COLOR: 11, INK_THICKNESS: 12, INK_OPACITY: 13 }; exports.AnnotationEditorParamsType = AnnotationEditorParamsType; const PermissionFlag = { PRINT: 0x04, MODIFY_CONTENTS: 0x08, COPY: 0x10, MODIFY_ANNOTATIONS: 0x20, FILL_INTERACTIVE_FORMS: 0x100, COPY_FOR_ACCESSIBILITY: 0x200, ASSEMBLE: 0x400, PRINT_HIGH_QUALITY: 0x800 }; exports.PermissionFlag = PermissionFlag; const TextRenderingMode = { FILL: 0, STROKE: 1, FILL_STROKE: 2, INVISIBLE: 3, FILL_ADD_TO_PATH: 4, STROKE_ADD_TO_PATH: 5, FILL_STROKE_ADD_TO_PATH: 6, ADD_TO_PATH: 7, FILL_STROKE_MASK: 3, ADD_TO_PATH_FLAG: 4 }; exports.TextRenderingMode = TextRenderingMode; const ImageKind = { GRAYSCALE_1BPP: 1, RGB_24BPP: 2, RGBA_32BPP: 3 }; exports.ImageKind = ImageKind; const AnnotationType = { TEXT: 1, LINK: 2, FREETEXT: 3, LINE: 4, SQUARE: 5, CIRCLE: 6, POLYGON: 7, POLYLINE: 8, HIGHLIGHT: 9, UNDERLINE: 10, SQUIGGLY: 11, STRIKEOUT: 12, STAMP: 13, CARET: 14, INK: 15, POPUP: 16, FILEATTACHMENT: 17, SOUND: 18, MOVIE: 19, WIDGET: 20, SCREEN: 21, PRINTERMARK: 22, TRAPNET: 23, WATERMARK: 24, THREED: 25, REDACT: 26 }; exports.AnnotationType = AnnotationType; const AnnotationStateModelType = { MARKED: &quot;Marked&quot;, REVIEW: &quot;Review&quot; }; exports.AnnotationStateModelType = AnnotationStateModelType; const AnnotationMarkedState = { MARKED: &quot;Marked&quot;, UNMARKED: &quot;Unmarked&quot; }; exports.AnnotationMarkedState = AnnotationMarkedState; const AnnotationReviewState = { ACCEPTED: &quot;Accepted&quot;, REJECTED: &quot;Rejected&quot;, CANCELLED: &quot;Cancelled&quot;, COMPLETED: &quot;Completed&quot;, NONE: &quot;None&quot; }; exports.AnnotationReviewState = AnnotationReviewState; const AnnotationReplyType = { GROUP: &quot;Group&quot;, REPLY: &quot;R&quot; }; exports.AnnotationReplyType = AnnotationReplyType; const AnnotationFlag = { INVISIBLE: 0x01, HIDDEN: 0x02, PRINT: 0x04, NOZOOM: 0x08, NOROTATE: 0x10, NOVIEW: 0x20, READONLY: 0x40, LOCKED: 0x80, TOGGLENOVIEW: 0x100, LOCKEDCONTENTS: 0x200 }; exports.AnnotationFlag = AnnotationFlag; const AnnotationFieldFlag = { READONLY: 0x0000001, REQUIRED: 0x0000002, NOEXPORT: 0x0000004, MULTILINE: 0x0001000, PASSWORD: 0x0002000, NOTOGGLETOOFF: 0x0004000, RADIO: 0x0008000, PUSHBUTTON: 0x0010000, COMBO: 0x0020000, EDIT: 0x0040000, SORT: 0x0080000, FILESELECT: 0x0100000, MULTISELECT: 0x0200000, DONOTSPELLCHECK: 0x0400000, DONOTSCROLL: 0x0800000, COMB: 0x1000000, RICHTEXT: 0x2000000, RADIOSINUNISON: 0x2000000, COMMITONSELCHANGE: 0x4000000 }; exports.AnnotationFieldFlag = AnnotationFieldFlag; const AnnotationBorderStyleType = { SOLID: 1, DASHED: 2, BEVELED: 3, INSET: 4, UNDERLINE: 5 }; exports.AnnotationBorderStyleType = AnnotationBorderStyleType; const AnnotationActionEventType = { E: &quot;Mouse Enter&quot;, X: &quot;Mouse Exit&quot;, D: &quot;Mouse Down&quot;, U: &quot;Mouse Up&quot;, Fo: &quot;Focus&quot;, Bl: &quot;Blur&quot;, PO: &quot;PageOpen&quot;, PC: &quot;PageClose&quot;, PV: &quot;PageVisible&quot;, PI: &quot;PageInvisible&quot;, K: &quot;Keystroke&quot;, F: &quot;Format&quot;, V: &quot;Validate&quot;, C: &quot;Calculate&quot; }; exports.AnnotationActionEventType = AnnotationActionEventType; const DocumentActionEventType = { WC: &quot;WillClose&quot;, WS: &quot;WillSave&quot;, DS: &quot;DidSave&quot;, WP: &quot;WillPrint&quot;, DP: &quot;DidPrint&quot; }; exports.DocumentActionEventType = DocumentActionEventType; const PageActionEventType = { O: &quot;PageOpen&quot;, C: &quot;PageClose&quot; }; exports.PageActionEventType = PageActionEventType; const StreamType = { UNKNOWN: &quot;UNKNOWN&quot;, FLATE: &quot;FLATE&quot;, LZW: &quot;LZW&quot;, DCT: &quot;DCT&quot;, JPX: &quot;JPX&quot;, JBIG: &quot;JBIG&quot;, A85: &quot;A85&quot;, AHX: &quot;AHX&quot;, CCF: &quot;CCF&quot;, RLX: &quot;RLX&quot; }; exports.StreamType = StreamType; const FontType = { UNKNOWN: &quot;UNKNOWN&quot;, TYPE1: &quot;TYPE1&quot;, TYPE1STANDARD: &quot;TYPE1STANDARD&quot;, TYPE1C: &quot;TYPE1C&quot;, CIDFONTTYPE0: &quot;CIDFONTTYPE0&quot;, CIDFONTTYPE0C: &quot;CIDFONTTYPE0C&quot;, TRUETYPE: &quot;TRUETYPE&quot;, CIDFONTTYPE2: &quot;CIDFONTTYPE2&quot;, TYPE3: &quot;TYPE3&quot;, OPENTYPE: &quot;OPENTYPE&quot;, TYPE0: &quot;TYPE0&quot;, MMTYPE1: &quot;MMTYPE1&quot; }; exports.FontType = FontType; const VerbosityLevel = { ERRORS: 0, WARNINGS: 1, INFOS: 5 }; exports.VerbosityLevel = VerbosityLevel; const CMapCompressionType = { NONE: 0, BINARY: 1 }; exports.CMapCompressionType = CMapCompressionType; const OPS = { dependency: 1, setLineWidth: 2, setLineCap: 3, setLineJoin: 4, setMiterLimit: 5, setDash: 6, setRenderingIntent: 7, setFlatness: 8, setGState: 9, save: 10, restore: 11, transform: 12, moveTo: 13, lineTo: 14, curveTo: 15, curveTo2: 16, curveTo3: 17, closePath: 18, rectangle: 19, stroke: 20, closeStroke: 21, fill: 22, eoFill: 23, fillStroke: 24, eoFillStroke: 25, closeFillStroke: 26, closeEOFillStroke: 27, endPath: 28, clip: 29, eoClip: 30, beginText: 31, endText: 32, setCharSpacing: 33, setWordSpacing: 34, setHScale: 35, setLeading: 36, setFont: 37, setTextRenderingMode: 38, setTextRise: 39, moveText: 40, setLeadingMoveText: 41, setTextMatrix: 42, nextLine: 43, showText: 44, showSpacedText: 45, nextLineShowText: 46, nextLineSetSpacingShowText: 47, setCharWidth: 48, setCharWidthAndBounds: 49, setStrokeColorSpace: 50, setFillColorSpace: 51, setStrokeColor: 52, setStrokeColorN: 53, setFillColor: 54, setFillColorN: 55, setStrokeGray: 56, setFillGray: 57, setStrokeRGBColor: 58, setFillRGBColor: 59, setStrokeCMYKColor: 60, setFillCMYKColor: 61, shadingFill: 62, beginInlineImage: 63, beginImageData: 64, endInlineImage: 65, paintXObject: 66, markPoint: 67, markPointProps: 68, beginMarkedContent: 69, beginMarkedContentProps: 70, endMarkedContent: 71, beginCompat: 72, endCompat: 73, paintFormXObjectBegin: 74, paintFormXObjectEnd: 75, beginGroup: 76, endGroup: 77, beginAnnotation: 80, endAnnotation: 81, paintImageMaskXObject: 83, paintImageMaskXObjectGroup: 84, paintImageXObject: 85, paintInlineImageXObject: 86, paintInlineImageXObjectGroup: 87, paintImageXObjectRepeat: 88, paintImageMaskXObjectRepeat: 89, paintSolidColorImageMask: 90, constructPath: 91 }; exports.OPS = OPS; const UNSUPPORTED_FEATURES = { forms: &quot;forms&quot;, javaScript: &quot;javaScript&quot;, signatures: &quot;signatures&quot;, smask: &quot;smask&quot;, shadingPattern: &quot;shadingPattern&quot;, errorTilingPattern: &quot;errorTilingPattern&quot;, errorExtGState: &quot;errorExtGState&quot;, errorXObject: &quot;errorXObject&quot;, errorFontLoadType3: &quot;errorFontLoadType3&quot;, errorFontState: &quot;errorFontState&quot;, errorFontMissing: &quot;errorFontMissing&quot;, errorFontTranslate: &quot;errorFontTranslate&quot;, errorColorSpace: &quot;errorColorSpace&quot;, errorOperatorList: &quot;errorOperatorList&quot;, errorFontToUnicode: &quot;errorFontToUnicode&quot;, errorFontLoadNative: &quot;errorFontLoadNative&quot;, errorFontBuildPath: &quot;errorFontBuildPath&quot;, errorFontGetPath: &quot;errorFontGetPath&quot;, errorMarkedContent: &quot;errorMarkedContent&quot;, errorContentSubStream: &quot;errorContentSubStream&quot; }; exports.UNSUPPORTED_FEATURES = UNSUPPORTED_FEATURES; const PasswordResponses = { NEED_PASSWORD: 1, INCORRECT_PASSWORD: 2 }; exports.PasswordResponses = PasswordResponses; let verbosity = VerbosityLevel.WARNINGS; function setVerbosityLevel(level) { if (Number.isInteger(level)) { verbosity = level; } } function getVerbosityLevel() { return verbosity; } function info(msg) { if (verbosity &gt;= VerbosityLevel.INFOS) { console.log(`Info: ${msg}`); } } function warn(msg) { if (verbosity &gt;= VerbosityLevel.WARNINGS) { console.log(`Warning: ${msg}`); } } function unreachable(msg) { throw new Error(msg); } function assert(cond, msg) { if (!cond) { unreachable(msg); } } function _isValidProtocol(url) { if (!url) { return false; } switch (url.protocol) { case &quot;http:&quot;: case &quot;https:&quot;: case &quot;ftp:&quot;: case &quot;mailto:&quot;: case &quot;tel:&quot;: return true; default: return false; } } function createValidAbsoluteUrl(url, baseUrl = null, options = null) { if (!url) { return null; } try { if (options &amp;&amp; typeof url === &quot;string&quot;) { if (options.addDefaultProtocol &amp;&amp; url.startsWith(&quot;www.&quot;)) { const dots = url.match(/\\./g); if (dots &amp;&amp; dots.length &gt;= 2) { url = `http://${url}`; } } if (options.tryConvertEncoding) { try { url = stringToUTF8String(url); } catch (ex) {} } } const absoluteUrl = baseUrl ? new URL(url, baseUrl) : new URL(url); if (_isValidProtocol(absoluteUrl)) { return absoluteUrl; } } catch (ex) {} return null; } function shadow(obj, prop, value) { Object.defineProperty(obj, prop, { value, enumerable: true, configurable: true, writable: false }); return value; } const BaseException = function BaseExceptionClosure() { function BaseException(message, name) { if (this.constructor === BaseException) { unreachable(&quot;Cannot initialize BaseException.&quot;); } this.message = message; this.name = name; } BaseException.prototype = new Error(); BaseException.constructor = BaseException; return BaseException; }(); exports.BaseException = BaseException; class PasswordException extends BaseException { constructor(msg, code) { super(msg, &quot;PasswordException&quot;); this.code = code; } } exports.PasswordException = PasswordException; class UnknownErrorException extends BaseException { constructor(msg, details) { super(msg, &quot;UnknownErrorException&quot;); this.details = details; } } exports.UnknownErrorException = UnknownErrorException; class InvalidPDFException extends BaseException { constructor(msg) { super(msg, &quot;InvalidPDFException&quot;); } } exports.InvalidPDFException = InvalidPDFException; class MissingPDFException extends BaseException { constructor(msg) { super(msg, &quot;MissingPDFException&quot;); } } exports.MissingPDFException = MissingPDFException; class UnexpectedResponseException extends BaseException { constructor(msg, status) { super(msg, &quot;UnexpectedResponseException&quot;); this.status = status; } } exports.UnexpectedResponseException = UnexpectedResponseException; class FormatError extends BaseException { constructor(msg) { super(msg, &quot;FormatError&quot;); } } exports.FormatError = FormatError; class AbortException extends BaseException { constructor(msg) { super(msg, &quot;AbortException&quot;); } } exports.AbortException = AbortException; function bytesToString(bytes) { if (typeof bytes !== &quot;object&quot; || bytes === null || bytes.length === undefined) { unreachable(&quot;Invalid argument for bytesToString&quot;); } const length = bytes.length; const MAX_ARGUMENT_COUNT = 8192; if (length &lt; MAX_ARGUMENT_COUNT) { return String.fromCharCode.apply(null, bytes); } const strBuf = []; for (let i = 0; i &lt; length; i += MAX_ARGUMENT_COUNT) { const chunkEnd = Math.min(i + MAX_ARGUMENT_COUNT, length); const chunk = bytes.subarray(i, chunkEnd); strBuf.push(String.fromCharCode.apply(null, chunk)); } return strBuf.join(&quot;&quot;); } function stringToBytes(str) { if (typeof str !== &quot;string&quot;) { unreachable(&quot;Invalid argument for stringToBytes&quot;); } const length = str.length; const bytes = new Uint8Array(length); for (let i = 0; i &lt; length; ++i) { bytes[i] = str.charCodeAt(i) &amp; 0xff; } return bytes; } function arrayByteLength(arr) { if (arr.length !== undefined) { return arr.length; } if (arr.byteLength !== undefined) { return arr.byteLength; } unreachable(&quot;Invalid argument for arrayByteLength&quot;); } function arraysToBytes(arr) { const length = arr.length; if (length === 1 &amp;&amp; arr[0] instanceof Uint8Array) { return arr[0]; } let resultLength = 0; for (let i = 0; i &lt; length; i++) { resultLength += arrayByteLength(arr[i]); } let pos = 0; const data = new Uint8Array(resultLength); for (let i = 0; i &lt; length; i++) { let item = arr[i]; if (!(item instanceof Uint8Array)) { if (typeof item === &quot;string&quot;) { item = stringToBytes(item); } else { item = new Uint8Array(item); } } const itemLength = item.byteLength; data.set(item, pos); pos += itemLength; } return data; } function string32(value) { return String.fromCharCode(value &gt;&gt; 24 &amp; 0xff, value &gt;&gt; 16 &amp; 0xff, value &gt;&gt; 8 &amp; 0xff, value &amp; 0xff); } function objectSize(obj) { return Object.keys(obj).length; } function objectFromMap(map) { const obj = Object.create(null); for (const [key, value] of map) { obj[key] = value; } return obj; } function isLittleEndian() { const buffer8 = new Uint8Array(4); buffer8[0] = 1; const view32 = new Uint32Array(buffer8.buffer, 0, 1); return view32[0] === 1; } function isEvalSupported() { try { new Function(&quot;&quot;); return true; } catch (e) { return false; } } class FeatureTest { static get isLittleEndian() { return shadow(this, &quot;isLittleEndian&quot;, isLittleEndian()); } static get isEvalSupported() { return shadow(this, &quot;isEvalSupported&quot;, isEvalSupported()); } static get isOffscreenCanvasSupported() { return shadow(this, &quot;isOffscreenCanvasSupported&quot;, typeof OffscreenCanvas !== &quot;undefined&quot;); } } exports.FeatureTest = FeatureTest; const hexNumbers = [...Array(256).keys()].map(n =&gt; n.toString(16).padStart(2, &quot;0&quot;)); class Util { static makeHexColor(r, g, b) { return `#${hexNumbers[r]}${hexNumbers[g]}${hexNumbers[b]}`; } static scaleMinMax(transform, minMax) { let temp; if (transform[0]) { if (transform[0] &lt; 0) { temp = minMax[0]; minMax[0] = minMax[1]; minMax[1] = temp; } minMax[0] *= transform[0]; minMax[1] *= transform[0]; if (transform[3] &lt; 0) { temp = minMax[2]; minMax[2] = minMax[3]; minMax[3] = temp; } minMax[2] *= transform[3]; minMax[3] *= transform[3]; } else { temp = minMax[0]; minMax[0] = minMax[2]; minMax[2] = temp; temp = minMax[1]; minMax[1] = minMax[3]; minMax[3] = temp; if (transform[1] &lt; 0) { temp = minMax[2]; minMax[2] = minMax[3]; minMax[3] = temp; } minMax[2] *= transform[1]; minMax[3] *= transform[1]; if (transform[2] &lt; 0) { temp = minMax[0]; minMax[0] = minMax[1]; minMax[1] = temp; } minMax[0] *= transform[2]; minMax[1] *= transform[2]; } minMax[0] += transform[4]; minMax[1] += transform[4]; minMax[2] += transform[5]; minMax[3] += transform[5]; } static transform(m1, m2) { return [m1[0] * m2[0] + m1[2] * m2[1], m1[1] * m2[0] + m1[3] * m2[1], m1[0] * m2[2] + m1[2] * m2[3], m1[1] * m2[2] + m1[3] * m2[3], m1[0] * m2[4] + m1[2] * m2[5] + m1[4], m1[1] * m2[4] + m1[3] * m2[5] + m1[5]]; } static applyTransform(p, m) { const xt = p[0] * m[0] + p[1] * m[2] + m[4]; const yt = p[0] * m[1] + p[1] * m[3] + m[5]; return [xt, yt]; } static applyInverseTransform(p, m) { const d = m[0] * m[3] - m[1] * m[2]; const xt = (p[0] * m[3] - p[1] * m[2] + m[2] * m[5] - m[4] * m[3]) / d; const yt = (-p[0] * m[1] + p[1] * m[0] + m[4] * m[1] - m[5] * m[0]) / d; return [xt, yt]; } static getAxialAlignedBoundingBox(r, m) { const p1 = Util.applyTransform(r, m); const p2 = Util.applyTransform(r.slice(2, 4), m); const p3 = Util.applyTransform([r[0], r[3]], m); const p4 = Util.applyTransform([r[2], r[1]], m); return [Math.min(p1[0], p2[0], p3[0], p4[0]), Math.min(p1[1], p2[1], p3[1], p4[1]), Math.max(p1[0], p2[0], p3[0], p4[0]), Math.max(p1[1], p2[1], p3[1], p4[1])]; } static inverseTransform(m) { const d = m[0] * m[3] - m[1] * m[2]; return [m[3] / d, -m[1] / d, -m[2] / d, m[0] / d, (m[2] * m[5] - m[4] * m[3]) / d, (m[4] * m[1] - m[5] * m[0]) / d]; } static singularValueDecompose2dScale(m) { const transpose = [m[0], m[2], m[1], m[3]]; const a = m[0] * transpose[0] + m[1] * transpose[2]; const b = m[0] * transpose[1] + m[1] * transpose[3]; const c = m[2] * transpose[0] + m[3] * transpose[2]; const d = m[2] * transpose[1] + m[3] * transpose[3]; const first = (a + d) / 2; const second = Math.sqrt((a + d) ** 2 - 4 * (a * d - c * b)) / 2; const sx = first + second || 1; const sy = first - second || 1; return [Math.sqrt(sx), Math.sqrt(sy)]; } static normalizeRect(rect) { const r = rect.slice(0); if (rect[0] &gt; rect[2]) { r[0] = rect[2]; r[2] = rect[0]; } if (rect[1] &gt; rect[3]) { r[1] = rect[3]; r[3] = rect[1]; } return r; } static intersect(rect1, rect2) { const xLow = Math.max(Math.min(rect1[0], rect1[2]), Math.min(rect2[0], rect2[2])); const xHigh = Math.min(Math.max(rect1[0], rect1[2]), Math.max(rect2[0], rect2[2])); if (xLow &gt; xHigh) { return null; } const yLow = Math.max(Math.min(rect1[1], rect1[3]), Math.min(rect2[1], rect2[3])); const yHigh = Math.min(Math.max(rect1[1], rect1[3]), Math.max(rect2[1], rect2[3])); if (yLow &gt; yHigh) { return null; } return [xLow, yLow, xHigh, yHigh]; } static bezierBoundingBox(x0, y0, x1, y1, x2, y2, x3, y3) { const tvalues = [], bounds = [[], []]; let a, b, c, t, t1, t2, b2ac, sqrtb2ac; for (let i = 0; i &lt; 2; ++i) { if (i === 0) { b = 6 * x0 - 12 * x1 + 6 * x2; a = -3 * x0 + 9 * x1 - 9 * x2 + 3 * x3; c = 3 * x1 - 3 * x0; } else { b = 6 * y0 - 12 * y1 + 6 * y2; a = -3 * y0 + 9 * y1 - 9 * y2 + 3 * y3; c = 3 * y1 - 3 * y0; } if (Math.abs(a) &lt; 1e-12) { if (Math.abs(b) &lt; 1e-12) { continue; } t = -c / b; if (0 &lt; t &amp;&amp; t &lt; 1) { tvalues.push(t); } continue; } b2ac = b * b - 4 * c * a; sqrtb2ac = Math.sqrt(b2ac); if (b2ac &lt; 0) { continue; } t1 = (-b + sqrtb2ac) / (2 * a); if (0 &lt; t1 &amp;&amp; t1 &lt; 1) { tvalues.push(t1); } t2 = (-b - sqrtb2ac) / (2 * a); if (0 &lt; t2 &amp;&amp; t2 &lt; 1) { tvalues.push(t2); } } let j = tvalues.length, mt; const jlen = j; while (j--) { t = tvalues[j]; mt = 1 - t; bounds[0][j] = mt * mt * mt * x0 + 3 * mt * mt * t * x1 + 3 * mt * t * t * x2 + t * t * t * x3; bounds[1][j] = mt * mt * mt * y0 + 3 * mt * mt * t * y1 + 3 * mt * t * t * y2 + t * t * t * y3; } bounds[0][jlen] = x0; bounds[1][jlen] = y0; bounds[0][jlen + 1] = x3; bounds[1][jlen + 1] = y3; bounds[0].length = bounds[1].length = jlen + 2; return [Math.min(...bounds[0]), Math.min(...bounds[1]), Math.max(...bounds[0]), Math.max(...bounds[1])]; } } exports.Util = Util; const PDFStringTranslateTable = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0x2d8, 0x2c7, 0x2c6, 0x2d9, 0x2dd, 0x2db, 0x2da, 0x2dc, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0x2022, 0x2020, 0x2021, 0x2026, 0x2014, 0x2013, 0x192, 0x2044, 0x2039, 0x203a, 0x2212, 0x2030, 0x201e, 0x201c, 0x201d, 0x2018, 0x2019, 0x201a, 0x2122, 0xfb01, 0xfb02, 0x141, 0x152, 0x160, 0x178, 0x17d, 0x131, 0x142, 0x153, 0x161, 0x17e, 0, 0x20ac]; function stringToPDFString(str) { if (str[0] &gt;= &quot;\\xEF&quot;) { let encoding; if (str[0] === &quot;\\xFE&quot; &amp;&amp; str[1] === &quot;\\xFF&quot;) { encoding = &quot;utf-16be&quot;; } else if (str[0] === &quot;\\xFF&quot; &amp;&amp; str[1] === &quot;\\xFE&quot;) { encoding = &quot;utf-16le&quot;; } else if (str[0] === &quot;\\xEF&quot; &amp;&amp; str[1] === &quot;\\xBB&quot; &amp;&amp; str[2] === &quot;\\xBF&quot;) { encoding = &quot;utf-8&quot;; } if (encoding) { try { const decoder = new TextDecoder(encoding, { fatal: true }); const buffer = stringToBytes(str); return decoder.decode(buffer); } catch (ex) { warn(`stringToPDFString: &quot;${ex}&quot;.`); } } } const strBuf = []; for (let i = 0, ii = str.length; i &lt; ii; i++) { const code = PDFStringTranslateTable[str.charCodeAt(i)]; strBuf.push(code ? String.fromCharCode(code) : str.charAt(i)); } return strBuf.join(&quot;&quot;); } function escapeString(str) { return str.replace(/([()\\\\\\n\\r])/g, match =&gt; { if (match === &quot;\\n&quot;) { return &quot;\\\\n&quot;; } else if (match === &quot;\\r&quot;) { return &quot;\\\\r&quot;; } return `\\\\${match}`; }); } function isAscii(str) { return /^[\\x00-\\x7F]*$/.test(str); } function stringToUTF16BEString(str) { const buf = [&quot;\\xFE\\xFF&quot;]; for (let i = 0, ii = str.length; i &lt; ii; i++) { const char = str.charCodeAt(i); buf.push(String.fromCharCode(char &gt;&gt; 8 &amp; 0xff), String.fromCharCode(char &amp; 0xff)); } return buf.join(&quot;&quot;); } function stringToUTF8String(str) { return decodeURIComponent(escape(str)); } function utf8StringToString(str) { return unescape(encodeURIComponent(str)); } function isArrayBuffer(v) { return typeof v === &quot;object&quot; &amp;&amp; v !== null &amp;&amp; v.byteLength !== undefined; } function isArrayEqual(arr1, arr2) { if (arr1.length !== arr2.length) { return false; } for (let i = 0, ii = arr1.length; i &lt; ii; i++) { if (arr1[i] !== arr2[i]) { return false; } } return true; } function getModificationDate(date = new Date()) { const buffer = [date.getUTCFullYear().toString(), (date.getUTCMonth() + 1).toString().padStart(2, &quot;0&quot;), date.getUTCDate().toString().padStart(2, &quot;0&quot;), date.getUTCHours().toString().padStart(2, &quot;0&quot;), date.getUTCMinutes().toString().padStart(2, &quot;0&quot;), date.getUTCSeconds().toString().padStart(2, &quot;0&quot;)]; return buffer.join(&quot;&quot;); } function createPromiseCapability() { const capability = Object.create(null); let isSettled = false; Object.defineProperty(capability, &quot;settled&quot;, { get() { return isSettled; } }); capability.promise = new Promise(function (resolve, reject) { capability.resolve = function (data) { isSettled = true; resolve(data); }; capability.reject = function (reason) { isSettled = true; reject(reason); }; }); return capability; } /***/ }), /* 3 */ /***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) =&gt; { Object.defineProperty(exports, &quot;__esModule&quot;, ({ value: true })); exports.RefSetCache = exports.RefSet = exports.Ref = exports.Name = exports.EOF = exports.Dict = exports.Cmd = exports.CIRCULAR_REF = void 0; exports.clearPrimitiveCaches = clearPrimitiveCaches; exports.isCmd = isCmd; exports.isDict = isDict; exports.isName = isName; exports.isRefsEqual = isRefsEqual; var _util = __w_pdfjs_require__(2); const CIRCULAR_REF = Symbol(&quot;CIRCULAR_REF&quot;); exports.CIRCULAR_REF = CIRCULAR_REF; const EOF = Symbol(&quot;EOF&quot;); exports.EOF = EOF; const Name = function NameClosure() { let nameCache = Object.create(null); class Name { constructor(name) { this.name = name; } static get(name) { return nameCache[name] || (nameCache[name] = new Name(name)); } static _clearCache() { nameCache = Object.create(null); } } return Name; }(); exports.Name = Name; const Cmd = function CmdClosure() { let cmdCache = Object.create(null); class Cmd { constructor(cmd) { this.cmd = cmd; } static get(cmd) { return cmdCache[cmd] || (cmdCache[cmd] = new Cmd(cmd)); } static _clearCache() { cmdCache = Object.create(null); } } return Cmd; }(); exports.Cmd = Cmd; const nonSerializable = function nonSerializableClosure() { return nonSerializable; }; class Dict { constructor(xref = null) { this._map = Object.create(null); this.xref = xref; this.objId = null; this.suppressEncryption = false; this.__nonSerializable__ = nonSerializable; } assignXref(newXref) { this.xref = newXref; } get size() { return Object.keys(this._map).length; } get(key1, key2, key3) { let value = this._map[key1]; if (value === undefined &amp;&amp; key2 !== undefined) { value = this._map[key2]; if (value === undefined &amp;&amp; key3 !== undefined) { value = this._map[key3]; } } if (value instanceof Ref &amp;&amp; this.xref) { return this.xref.fetch(value, this.suppressEncryption); } return value; } async getAsync(key1, key2, key3) { let value = this._map[key1]; if (value === undefined &amp;&amp; key2 !== undefined) { value = this._map[key2]; if (value === undefined &amp;&amp; key3 !== undefined) { value = this._map[key3]; } } if (value instanceof Ref &amp;&amp; this.xref) { return this.xref.fetchAsync(value, this.suppressEncryption); } return value; } getArray(key1, key2, key3) { let value = this._map[key1]; if (value === undefined &amp;&amp; key2 !== undefined) { value = this._map[key2]; if (value === undefined &amp;&amp; key3 !== undefined) { value = this._map[key3]; } } if (value instanceof Ref &amp;&amp; this.xref) { value = this.xref.fetch(value, this.suppressEncryption); } if (Array.isArray(value)) { value = value.slice(); for (let i = 0, ii = value.length; i &lt; ii; i++) { if (value[i] instanceof Ref &amp;&amp; this.xref) { value[i] = this.xref.fetch(value[i], this.suppressEncryption); } } } return value; } getRaw(key) { return this._map[key]; } getKeys() { return Object.keys(this._map); } getRawValues() { return Object.values(this._map); } set(key, value) { this._map[key] = value; } has(key) { return this._map[key] !== undefined; } forEach(callback) { for (const key in this._map) { callback(key, this.get(key)); } } static get empty() { const emptyDict = new Dict(null); emptyDict.set = (key, value) =&gt; { (0, _util.unreachable)(&quot;Should not call `set` on the empty dictionary.&quot;); }; return (0, _util.shadow)(this, &quot;empty&quot;, emptyDict); } static merge({ xref, dictArray, mergeSubDicts = false }) { const mergedDict = new Dict(xref), properties = new Map(); for (const dict of dictArray) { if (!(dict instanceof Dict)) { continue; } for (const [key, value] of Object.entries(dict._map)) { let property = properties.get(key); if (property === undefined) { property = []; properties.set(key, property); } else if (!mergeSubDicts || !(value instanceof Dict)) { continue; } property.push(value); } } for (const [name, values] of properties) { if (values.length === 1 || !(values[0] instanceof Dict)) { mergedDict._map[name] = values[0]; continue; } const subDict = new Dict(xref); for (const dict of values) { for (const [key, value] of Object.entries(dict._map)) { if (subDict._map[key] === undefined) { subDict._map[key] = value; } } } if (subDict.size &gt; 0) { mergedDict._map[name] = subDict; } } properties.clear(); return mergedDict.size &gt; 0 ? mergedDict : Dict.empty; } } exports.Dict = Dict; const Ref = function RefClosure() { let refCache = Object.create(null); class Ref { constructor(num, gen) { this.num = num; this.gen = gen; } toString() { if (this.gen === 0) { return `${this.num}R`; } return `${this.num}R${this.gen}`; } static get(num, gen) { const key = gen === 0 ? `${num}R` : `${num}R${gen}`; return refCache[key] || (refCache[key] = new Ref(num, gen)); } static _clearCache() { refCache = Object.create(null); } } return Ref; }(); exports.Ref = Ref; class RefSet { constructor(parent = null) { this._set = new Set(parent &amp;&amp; parent._set); } has(ref) { return this._set.has(ref.toString()); } put(ref) { this._set.add(ref.toString()); } remove(ref) { this._set.delete(ref.toString()); } [Symbol.iterator]() { return this._set.values(); } clear() { this._set.clear(); } } exports.RefSet = RefSet; class RefSetCache { constructor() { this._map = new Map(); } get size() { return this._map.size; } get(ref) { return this._map.get(ref.toString()); } has(ref) { return this._map.has(ref.toString()); } put(ref, obj) { this._map.set(ref.toString(), obj); } putAlias(ref, aliasRef) { this._map.set(ref.toString(), this.get(aliasRef)); } [Symbol.iterator]() { return this._map.values(); } clear() { this._map.clear(); } } exports.RefSetCache = RefSetCache; function isName(v, name) { return v instanceof Name &amp;&amp; (name === undefined || v.name === name); } function isCmd(v, cmd) { return v instanceof Cmd &amp;&amp; (cmd === undefined || v.cmd === cmd); } function isDict(v, type) { return v instanceof Dict &amp;&amp; (type === undefined || isName(v.get(&quot;Type&quot;), type)); } function isRefsEqual(v1, v2) { return v1.num === v2.num &amp;&amp; v1.gen === v2.gen; } function clearPrimitiveCaches() { Cmd._clearCache(); Name._clearCache(); Ref._clearCache(); } /***/ }), /* 4 */ /***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) =&gt; { Object.defineProperty(exports, &quot;__esModule&quot;, ({ value: true })); exports.XRefParseException = exports.XRefEntryException = exports.ParserEOFException = exports.PDF_VERSION_REGEXP = exports.MissingDataException = exports.DocStats = void 0; exports.collectActions = collectActions; exports.encodeToXmlString = encodeToXmlString; exports.escapePDFName = escapePDFName; exports.getArrayLookupTableFactory = getArrayLookupTableFactory; exports.getInheritableProperty = getInheritableProperty; exports.getLookupTableFactory = getLookupTableFactory; exports.getNewAnnotationsMap = getNewAnnotationsMap; exports.isWhiteSpace = isWhiteSpace; exports.log2 = log2; exports.numberToString = numberToString; exports.parseXFAPath = parseXFAPath; exports.readInt8 = readInt8; exports.readUint16 = readUint16; exports.readUint32 = readUint32; exports.recoverJsURL = recoverJsURL; exports.toRomanNumerals = toRomanNumerals; exports.validateCSSFont = validateCSSFont; var _util = __w_pdfjs_require__(2); var _primitives = __w_pdfjs_require__(3); var _base_stream = __w_pdfjs_require__(5); const PDF_VERSION_REGEXP = /^[1-9]\\.\\d$/; exports.PDF_VERSION_REGEXP = PDF_VERSION_REGEXP; function getLookupTableFactory(initializer) { let lookup; return function () { if (initializer) { lookup = Object.create(null); initializer(lookup); initializer = null; } return lookup; }; } function getArrayLookupTableFactory(initializer) { let lookup; return function () { if (initializer) { let arr = initializer(); initializer = null; lookup = Object.create(null); for (let i = 0, ii = arr.length; i &lt; ii; i += 2) { lookup[arr[i]] = arr[i + 1]; } arr = null; } return lookup; }; } class MissingDataException extends _util.BaseException { constructor(begin, end) { super(`Missing data [${begin}, ${end})`, &quot;MissingDataException&quot;); this.begin = begin; this.end = end; } } exports.MissingDataException = MissingDataException; class ParserEOFException extends _util.BaseException { constructor(msg) { super(msg, &quot;ParserEOFException&quot;); } } exports.ParserEOFException = ParserEOFException; class XRefEntryException extends _util.BaseException { constructor(msg) { super(msg, &quot;XRefEntryException&quot;); } } exports.XRefEntryException = XRefEntryException; class XRefParseException extends _util.BaseException { constructor(msg) { super(msg, &quot;XRefParseException&quot;); } } exports.XRefParseException = XRefParseException; class DocStats { constructor(handler) { this._handler = handler; this._streamTypes = new Set(); this._fontTypes = new Set(); } _send() { const streamTypes = Object.create(null), fontTypes = Object.create(null); for (const type of this._streamTypes) { streamTypes[type] = true; } for (const type of this._fontTypes) { fontTypes[type] = true; } this._handler.send(&quot;DocStats&quot;, { streamTypes, fontTypes }); } addStreamType(type) { if (this._streamTypes.has(type)) { return; } this._streamTypes.add(type); this._send(); } addFontType(type) { if (this._fontTypes.has(type)) { return; } this._fontTypes.add(type); this._send(); } } exports.DocStats = DocStats; function getInheritableProperty({ dict, key, getArray = false, stopWhenFound = true }) { let values; const visited = new _primitives.RefSet(); while (dict instanceof _primitives.Dict &amp;&amp; !(dict.objId &amp;&amp; visited.has(dict.objId))) { if (dict.objId) { visited.put(dict.objId); } const value = getArray ? dict.getArray(key) : dict.get(key); if (value !== undefined) { if (stopWhenFound) { return value; } if (!values) { values = []; } values.push(value); } dict = dict.get(&quot;Parent&quot;); } return values; } const ROMAN_NUMBER_MAP = [&quot;&quot;, &quot;C&quot;, &quot;CC&quot;, &quot;CCC&quot;, &quot;CD&quot;, &quot;D&quot;, &quot;DC&quot;, &quot;DCC&quot;, &quot;DCCC&quot;, &quot;CM&quot;, &quot;&quot;, &quot;X&quot;, &quot;XX&quot;, &quot;XXX&quot;, &quot;XL&quot;, &quot;L&quot;, &quot;LX&quot;, &quot;LXX&quot;, &quot;LXXX&quot;, &quot;XC&quot;, &quot;&quot;, &quot;I&quot;, &quot;II&quot;, &quot;III&quot;, &quot;IV&quot;, &quot;V&quot;, &quot;VI&quot;, &quot;VII&quot;, &quot;VIII&quot;, &quot;IX&quot;]; function toRomanNumerals(number, lowerCase = false) { (0, _util.assert)(Number.isInteger(number) &amp;&amp; number &gt; 0, &quot;The number should be a positive integer.&quot;); const romanBuf = []; let pos; while (number &gt;= 1000) { number -= 1000; romanBuf.push(&quot;M&quot;); } pos = number / 100 | 0; number %= 100; romanBuf.push(ROMAN_NUMBER_MAP[pos]); pos = number / 10 | 0; number %= 10; romanBuf.push(ROMAN_NUMBER_MAP[10 + pos]); romanBuf.push(ROMAN_NUMBER_MAP[20 + number]); const romanStr = romanBuf.join(&quot;&quot;); return lowerCase ? romanStr.toLowerCase() : romanStr; } function log2(x) { if (x &lt;= 0) { return 0; } return Math.ceil(Math.log2(x)); } function readInt8(data, offset) { return data[offset] &lt;&lt; 24 &gt;&gt; 24; } function readUint16(data, offset) { return data[offset] &lt;&lt; 8 | data[offset + 1]; } function readUint32(data, offset) { return (data[offset] &lt;&lt; 24 | data[offset + 1] &lt;&lt; 16 | data[offset + 2] &lt;&lt; 8 | data[offset + 3]) &gt;&gt;&gt; 0; } function isWhiteSpace(ch) { return ch === 0x20 || ch === 0x09 || ch === 0x0d || ch === 0x0a; } function parseXFAPath(path) { const positionPattern = /(.+)\\[(\\d+)\\]$/; return path.split(&quot;.&quot;).map(component =&gt; { const m = component.match(positionPattern); if (m) { return { name: m[1], pos: parseInt(m[2], 10) }; } return { name: component, pos: 0 }; }); } function escapePDFName(str) { const buffer = []; let start = 0; for (let i = 0, ii = str.length; i &lt; ii; i++) { const char = str.charCodeAt(i); if (char &lt; 0x21 || char &gt; 0x7e || char === 0x23 || char === 0x28 || char === 0x29 || char === 0x3c || char === 0x3e || char === 0x5b || char === 0x5d || char === 0x7b || char === 0x7d || char === 0x2f || char === 0x25) { if (start &lt; i) { buffer.push(str.substring(start, i)); } buffer.push(`#${char.toString(16)}`); start = i + 1; } } if (buffer.length === 0) { return str; } if (start &lt; str.length) { buffer.push(str.substring(start, str.length)); } return buffer.join(&quot;&quot;); } function _collectJS(entry, xref, list, parents) { if (!entry) { return; } let parent = null; if (entry instanceof _primitives.Ref) { if (parents.has(entry)) { return; } parent = entry; parents.put(parent); entry = xref.fetch(entry); } if (Array.isArray(entry)) { for (const element of entry) { _collectJS(element, xref, list, parents); } } else if (entry instanceof _primitives.Dict) { if ((0, _primitives.isName)(entry.get(&quot;S&quot;), &quot;JavaScript&quot;)) { const js = entry.get(&quot;JS&quot;); let code; if (js instanceof _base_stream.BaseStream) { code = js.getString(); } else if (typeof js === &quot;string&quot;) { code = js; } code = code &amp;&amp; (0, _util.stringToPDFString)(code).replace(/\\u0000/g, &quot;&quot;); if (code) { list.push(code); } } _collectJS(entry.getRaw(&quot;Next&quot;), xref, list, parents); } if (parent) { parents.remove(parent); } } function collectActions(xref, dict, eventType) { const actions = Object.create(null); const additionalActionsDicts = getInheritableProperty({ dict, key: &quot;AA&quot;, stopWhenFound: false }); if (additionalActionsDicts) { for (let i = additionalActionsDicts.length - 1; i &gt;= 0; i--) { const additionalActions = additionalActionsDicts[i]; if (!(additionalActions instanceof _primitives.Dict)) { continue; } for (const key of additionalActions.getKeys()) { const action = eventType[key]; if (!action) { continue; } const actionDict = additionalActions.getRaw(key); const parents = new _primitives.RefSet(); const list = []; _collectJS(actionDict, xref, list, parents); if (list.length &gt; 0) { actions[action] = list; } } } } if (dict.has(&quot;A&quot;)) { const actionDict = dict.get(&quot;A&quot;); const parents = new _primitives.RefSet(); const list = []; _collectJS(actionDict, xref, list, parents); if (list.length &gt; 0) { actions.Action = list; } } return (0, _util.objectSize)(actions) &gt; 0 ? actions : null; } const XMLEntities = { 0x3c: &quot;&lt;&quot;, 0x3e: &quot;&gt;&quot;, 0x26: &quot;&amp;&quot;, 0x22: &quot;&quot;&quot;, 0x27: &quot;&apos;&quot; }; function encodeToXmlString(str) { const buffer = []; let start = 0; for (let i = 0, ii = str.length; i &lt; ii; i++) { const char = str.codePointAt(i); if (0x20 &lt;= char &amp;&amp; char &lt;= 0x7e) { const entity = XMLEntities[char]; if (entity) { if (start &lt; i) { buffer.push(str.substring(start, i)); } buffer.push(entity); start = i + 1; } } else { if (start &lt; i) { buffer.push(str.substring(start, i)); } buffer.push(`&amp;#x${char.toString(16).toUpperCase()};`); if (char &gt; 0xd7ff &amp;&amp; (char &lt; 0xe000 || char &gt; 0xfffd)) { i++; } start = i + 1; } } if (buffer.length === 0) { return str; } if (start &lt; str.length) { buffer.push(str.substring(start, str.length)); } return buffer.join(&quot;&quot;); } function validateCSSFont(cssFontInfo) { const DEFAULT_CSS_FONT_OBLIQUE = &quot;14&quot;; const DEFAULT_CSS_FONT_WEIGHT = &quot;400&quot;; const CSS_FONT_WEIGHT_VALUES = new Set([&quot;100&quot;, &quot;200&quot;, &quot;300&quot;, &quot;400&quot;, &quot;500&quot;, &quot;600&quot;, &quot;700&quot;, &quot;800&quot;, &quot;900&quot;, &quot;1000&quot;, &quot;normal&quot;, &quot;bold&quot;, &quot;bolder&quot;, &quot;lighter&quot;]); const { fontFamily, fontWeight, italicAngle } = cssFontInfo; if (/^&quot;.*&quot;$/.test(fontFamily)) { if (/[^\\\\]&quot;/.test(fontFamily.slice(1, fontFamily.length - 1))) { (0, _util.warn)(`XFA - FontFamily contains some unescaped &quot;: ${fontFamily}.`); return false; } } else if (/^&apos;.*&apos;$/.test(fontFamily)) { if (/[^\\\\]&apos;/.test(fontFamily.slice(1, fontFamily.length - 1))) { (0, _util.warn)(`XFA - FontFamily contains some unescaped &apos;: ${fontFamily}.`); return false; } } else { for (const ident of fontFamily.split(/[ \\t]+/)) { if (/^(\\d|(-(\\d|-)))/.test(ident) || !/^[\\w-\\\\]+$/.test(ident)) { (0, _util.warn)(`XFA - FontFamily contains some invalid : ${fontFamily}.`); return false; } } } const weight = fontWeight ? fontWeight.toString() : &quot;&quot;; cssFontInfo.fontWeight = CSS_FONT_WEIGHT_VALUES.has(weight) ? weight : DEFAULT_CSS_FONT_WEIGHT; const angle = parseFloat(italicAngle); cssFontInfo.italicAngle = isNaN(angle) || angle &lt; -90 || angle &gt; 90 ? DEFAULT_CSS_FONT_OBLIQUE : italicAngle.toString(); return true; } function recoverJsURL(str) { const URL_OPEN_METHODS = [&quot;app.launchURL&quot;, &quot;window.open&quot;, &quot;xfa.host.gotoURL&quot;]; const regex = new RegExp(&quot;^\\\\s*(&quot; + URL_OPEN_METHODS.join(&quot;|&quot;).split(&quot;.&quot;).join(&quot;\\\\.&quot;) + &quot;)\\\\((?:&apos;|\\&quot;)([^&apos;\\&quot;]*)(?:&apos;|\\&quot;)(?:,\\\\s*(\\\\w+)\\\\)|\\\\))&quot;, &quot;i&quot;); const jsUrl = regex.exec(str); if (jsUrl &amp;&amp; jsUrl[2]) { const url = jsUrl[2]; let newWindow = false; if (jsUrl[3] === &quot;true&quot; &amp;&amp; jsUrl[1] === &quot;app.launchURL&quot;) { newWindow = true; } return { url, newWindow }; } return null; } function numberToString(value) { if (Number.isInteger(value)) { return value.toString(); } const roundedValue = Math.round(value * 100); if (roundedValue % 100 === 0) { return (roundedValue / 100).toString(); } if (roundedValue % 10 === 0) { return value.toFixed(1); } return value.toFixed(2); } function getNewAnnotationsMap(annotationStorage) { if (!annotationStorage) { return null; } const newAnnotationsByPage = new Map(); for (const [key, value] of annotationStorage) { if (!key.startsWith(_util.AnnotationEditorPrefix)) { continue; } let annotations = newAnnotationsByPage.get(value.pageIndex); if (!annotations) { annotations = []; newAnnotationsByPage.set(value.pageIndex, annotations); } annotations.push(value); } return newAnnotationsByPage.size &gt; 0 ? newAnnotationsByPage : null; } /***/ }), /* 5 */ /***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) =&gt; { Object.defineProperty(exports, &quot;__esModule&quot;, ({ value: true })); exports.BaseStream = void 0; var _util = __w_pdfjs_require__(2); class BaseStream { constructor() { if (this.constructor === BaseStream) { (0, _util.unreachable)(&quot;Cannot initialize BaseStream.&quot;); } } get length() { (0, _util.unreachable)(&quot;Abstract getter `length` accessed&quot;); } get isEmpty() { (0, _util.unreachable)(&quot;Abstract getter `isEmpty` accessed&quot;); } get isDataLoaded() { return (0, _util.shadow)(this, &quot;isDataLoaded&quot;, true); } getByte() { (0, _util.unreachable)(&quot;Abstract method `getByte` called&quot;); } getBytes(length) { (0, _util.unreachable)(&quot;Abstract method `getBytes` called&quot;); } peekByte() { const peekedByte = this.getByte(); if (peekedByte !== -1) { this.pos--; } return peekedByte; } peekBytes(length) { const bytes = this.getBytes(length); this.pos -= bytes.length; return bytes; } getUint16() { const b0 = this.getByte(); const b1 = this.getByte(); if (b0 === -1 || b1 === -1) { return -1; } return (b0 &lt;&lt; 8) + b1; } getInt32() { const b0 = this.getByte(); const b1 = this.getByte(); const b2 = this.getByte(); const b3 = this.getByte(); return (b0 &lt;&lt; 24) + (b1 &lt;&lt; 16) + (b2 &lt;&lt; 8) + b3; } getByteRange(begin, end) { (0, _util.unreachable)(&quot;Abstract method `getByteRange` called&quot;); } getString(length) { return (0, _util.bytesToString)(this.getBytes(length)); } skip(n) { this.pos += n || 1; } reset() { (0, _util.unreachable)(&quot;Abstract method `reset` called&quot;); } moveStart() { (0, _util.unreachable)(&quot;Abstract method `moveStart` called&quot;); } makeSubStream(start, length, dict = null) { (0, _util.unreachable)(&quot;Abstract method `makeSubStream` called&quot;); } getBaseStreams() { return null; } } exports.BaseStream = BaseStream; /***/ }), /* 6 */ /***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) =&gt; { Object.defineProperty(exports, &quot;__esModule&quot;, ({ value: true })); exports.NetworkPdfManager = exports.LocalPdfManager = void 0; var _util = __w_pdfjs_require__(2); var _chunked_stream = __w_pdfjs_require__(7); var _core_utils = __w_pdfjs_require__(4); var _document = __w_pdfjs_require__(9); var _stream = __w_pdfjs_require__(8); function parseDocBaseUrl(url) { if (url) { const absoluteUrl = (0, _util.createValidAbsoluteUrl)(url); if (absoluteUrl) { return absoluteUrl.href; } (0, _util.warn)(`Invalid absolute docBaseUrl: &quot;${url}&quot;.`); } return null; } class BasePdfManager { constructor() { if (this.constructor === BasePdfManager) { (0, _util.unreachable)(&quot;Cannot initialize BasePdfManager.&quot;); } } get docId() { return this._docId; } get password() { return this._password; } get docBaseUrl() { const catalog = this.pdfDocument.catalog; return (0, _util.shadow)(this, &quot;docBaseUrl&quot;, catalog.baseUrl || this._docBaseUrl); } onLoadedStream() { (0, _util.unreachable)(&quot;Abstract method `onLoadedStream` called&quot;); } ensureDoc(prop, args) { return this.ensure(this.pdfDocument, prop, args); } ensureXRef(prop, args) { return this.ensure(this.pdfDocument.xref, prop, args); } ensureCatalog(prop, args) { return this.ensure(this.pdfDocument.catalog, prop, args); } getPage(pageIndex) { return this.pdfDocument.getPage(pageIndex); } fontFallback(id, handler) { return this.pdfDocument.fontFallback(id, handler); } loadXfaFonts(handler, task) { return this.pdfDocument.loadXfaFonts(handler, task); } loadXfaImages() { return this.pdfDocument.loadXfaImages(); } serializeXfaData(annotationStorage) { return this.pdfDocument.serializeXfaData(annotationStorage); } cleanup(manuallyTriggered = false) { return this.pdfDocument.cleanup(manuallyTriggered); } async ensure(obj, prop, args) { (0, _util.unreachable)(&quot;Abstract method `ensure` called&quot;); } requestRange(begin, end) { (0, _util.unreachable)(&quot;Abstract method `requestRange` called&quot;); } requestLoadedStream() { (0, _util.unreachable)(&quot;Abstract method `requestLoadedStream` called&quot;); } sendProgressiveData(chunk) { (0, _util.unreachable)(&quot;Abstract method `sendProgressiveData` called&quot;); } updatePassword(password) { this._password = password; } terminate(reason) { (0, _util.unreachable)(&quot;Abstract method `terminate` called&quot;); } } class LocalPdfManager extends BasePdfManager { constructor(docId, data, password, msgHandler, evaluatorOptions, enableXfa, docBaseUrl) { super(); this._docId = docId; this._password = password; this._docBaseUrl = parseDocBaseUrl(docBaseUrl); this.msgHandler = msgHandler; this.evaluatorOptions = evaluatorOptions; this.enableXfa = enableXfa; const stream = new _stream.Stream(data); this.pdfDocument = new _document.PDFDocument(this, stream); this._loadedStreamPromise = Promise.resolve(stream); } async ensure(obj, prop, args) { const value = obj[prop]; if (typeof value === &quot;function&quot;) { return value.apply(obj, args); } return value; } requestRange(begin, end) { return Promise.resolve(); } requestLoadedStream() {} onLoadedStream() { return this._loadedStreamPromise; } terminate(reason) {} } exports.LocalPdfManager = LocalPdfManager; class NetworkPdfManager extends BasePdfManager { constructor(docId, pdfNetworkStream, args, evaluatorOptions, enableXfa, docBaseUrl) { super(); this._docId = docId; this._password = args.password; this._docBaseUrl = parseDocBaseUrl(docBaseUrl); this.msgHandler = args.msgHandler; this.evaluatorOptions = evaluatorOptions; this.enableXfa = enableXfa; this.streamManager = new _chunked_stream.ChunkedStreamManager(pdfNetworkStream, { msgHandler: args.msgHandler, length: args.length, disableAutoFetch: args.disableAutoFetch, rangeChunkSize: args.rangeChunkSize }); this.pdfDocument = new _document.PDFDocument(this, this.streamManager.getStream()); } async ensure(obj, prop, args) { try { const value = obj[prop]; if (typeof value === &quot;function&quot;) { return value.apply(obj, args); } return value; } catch (ex) { if (!(ex instanceof _core_utils.MissingDataException)) { throw ex; } await this.requestRange(ex.begin, ex.end); return this.ensure(obj, prop, args); } } requestRange(begin, end) { return this.streamManager.requestRange(begin, end); } requestLoadedStream() { this.streamManager.requestAllChunks(); } sendProgressiveData(chunk) { this.streamManager.onReceiveData({ chunk }); } onLoadedStream() { return this.streamManager.onLoadedStream(); } terminate(reason) { this.streamManager.abort(reason); } } exports.NetworkPdfManager = NetworkPdfManager; /***/ }), /* 7 */ /***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) =&gt; { Object.defineProperty(exports, &quot;__esModule&quot;, ({ value: true })); exports.ChunkedStreamManager = exports.ChunkedStream = void 0; var _util = __w_pdfjs_require__(2); var _core_utils = __w_pdfjs_require__(4); var _stream = __w_pdfjs_require__(8); class ChunkedStream extends _stream.Stream { constructor(length, chunkSize, manager) { super(new Uint8Array(length), 0, length, null); this.chunkSize = chunkSize; this._loadedChunks = new Set(); this.numChunks = Math.ceil(length / chunkSize); this.manager = manager; this.progressiveDataLength = 0; this.lastSuccessfulEnsureByteChunk = -1; } getMissingChunks() { const chunks = []; for (let chunk = 0, n = this.numChunks; chunk &lt; n; ++chunk) { if (!this._loadedChunks.has(chunk)) { chunks.push(chunk); } } return chunks; } get numChunksLoaded() { return this._loadedChunks.size; } get isDataLoaded() { return this.numChunksLoaded === this.numChunks; } onReceiveData(begin, chunk) { const chunkSize = this.chunkSize; if (begin % chunkSize !== 0) { throw new Error(`Bad begin offset: ${begin}`); } const end = begin + chunk.byteLength; if (end % chunkSize !== 0 &amp;&amp; end !== this.bytes.length) { throw new Error(`Bad end offset: ${end}`); } this.bytes.set(new Uint8Array(chunk), begin); const beginChunk = Math.floor(begin / chunkSize); const endChunk = Math.floor((end - 1) / chunkSize) + 1; for (let curChunk = beginChunk; curChunk &lt; endChunk; ++curChunk) { this._loadedChunks.add(curChunk); } } onReceiveProgressiveData(data) { let position = this.progressiveDataLength; const beginChunk = Math.floor(position / this.chunkSize); this.bytes.set(new Uint8Array(data), position); position += data.byteLength; this.progressiveDataLength = position; const endChunk = position &gt;= this.end ? this.numChunks : Math.floor(position / this.chunkSize); for (let curChunk = beginChunk; curChunk &lt; endChunk; ++curChunk) { this._loadedChunks.add(curChunk); } } ensureByte(pos) { if (pos &lt; this.progressiveDataLength) { return; } const chunk = Math.floor(pos / this.chunkSize); if (chunk &gt; this.numChunks) { return; } if (chunk === this.lastSuccessfulEnsureByteChunk) { return; } if (!this._loadedChunks.has(chunk)) { throw new _core_utils.MissingDataException(pos, pos + 1); } this.lastSuccessfulEnsureByteChunk = chunk; } ensureRange(begin, end) { if (begin &gt;= end) { return; } if (end &lt;= this.progressiveDataLength) { return; } const beginChunk = Math.floor(begin / this.chunkSize); if (beginChunk &gt; this.numChunks) { return; } const endChunk = Math.min(Math.floor((end - 1) / this.chunkSize) + 1, this.numChunks); for (let chunk = beginChunk; chunk &lt; endChunk; ++chunk) { if (!this._loadedChunks.has(chunk)) { throw new _core_utils.MissingDataException(begin, end); } } } nextEmptyChunk(beginChunk) { const numChunks = this.numChunks; for (let i = 0; i &lt; numChunks; ++i) { const chunk = (beginChunk + i) % numChunks; if (!this._loadedChunks.has(chunk)) { return chunk; } } return null; } hasChunk(chunk) { return this._loadedChunks.has(chunk); } getByte() { const pos = this.pos; if (pos &gt;= this.end) { return -1; } if (pos &gt;= this.progressiveDataLength) { this.ensureByte(pos); } return this.bytes[this.pos++]; } getBytes(length) { const bytes = this.bytes; const pos = this.pos; const strEnd = this.end; if (!length) { if (strEnd &gt; this.progressiveDataLength) { this.ensureRange(pos, strEnd); } return bytes.subarray(pos, strEnd); } let end = pos + length; if (end &gt; strEnd) { end = strEnd; } if (end &gt; this.progressiveDataLength) { this.ensureRange(pos, end); } this.pos = end; return bytes.subarray(pos, end); } getByteRange(begin, end) { if (begin &lt; 0) { begin = 0; } if (end &gt; this.end) { end = this.end; } if (end &gt; this.progressiveDataLength) { this.ensureRange(begin, end); } return this.bytes.subarray(begin, end); } makeSubStream(start, length, dict = null) { if (length) { if (start + length &gt; this.progressiveDataLength) { this.ensureRange(start, start + length); } } else { if (start &gt;= this.progressiveDataLength) { this.ensureByte(start); } } function ChunkedStreamSubstream() {} ChunkedStreamSubstream.prototype = Object.create(this); ChunkedStreamSubstream.prototype.getMissingChunks = function () { const chunkSize = this.chunkSize; const beginChunk = Math.floor(this.start / chunkSize); const endChunk = Math.floor((this.end - 1) / chunkSize) + 1; const missingChunks = []; for (let chunk = beginChunk; chunk &lt; endChunk; ++chunk) { if (!this._loadedChunks.has(chunk)) { missingChunks.push(chunk); } } return missingChunks; }; Object.defineProperty(ChunkedStreamSubstream.prototype, &quot;isDataLoaded&quot;, { get() { if (this.numChunksLoaded === this.numChunks) { return true; } return this.getMissingChunks().length === 0; }, configurable: true }); const subStream = new ChunkedStreamSubstream(); subStream.pos = subStream.start = start; subStream.end = start + length || this.end; subStream.dict = dict; return subStream; } getBaseStreams() { return [this]; } } exports.ChunkedStream = ChunkedStream; class ChunkedStreamManager { constructor(pdfNetworkStream, args) { this.length = args.length; this.chunkSize = args.rangeChunkSize; this.stream = new ChunkedStream(this.length, this.chunkSize, this); this.pdfNetworkStream = pdfNetworkStream; this.disableAutoFetch = args.disableAutoFetch; this.msgHandler = args.msgHandler; this.currRequestId = 0; this._chunksNeededByRequest = new Map(); this._requestsByChunk = new Map(); this._promisesByRequest = new Map(); this.progressiveDataLength = 0; this.aborted = false; this._loadedStreamCapability = (0, _util.createPromiseCapability)(); } onLoadedStream() { return this._loadedStreamCapability.promise; } sendRequest(begin, end) { const rangeReader = this.pdfNetworkStream.getRangeReader(begin, end); if (!rangeReader.isStreamingSupported) { rangeReader.onProgress = this.onProgress.bind(this); } let chunks = [], loaded = 0; return new Promise((resolve, reject) =&gt; { const readChunk = chunk =&gt; { try { if (!chunk.done) { const data = chunk.value; chunks.push(data); loaded += (0, _util.arrayByteLength)(data); if (rangeReader.isStreamingSupported) { this.onProgress({ loaded }); } rangeReader.read().then(readChunk, reject); return; } const chunkData = (0, _util.arraysToBytes)(chunks); chunks = null; resolve(chunkData); } catch (e) { reject(e); } }; rangeReader.read().then(readChunk, reject); }).then(data =&gt; { if (this.aborted) { return; } this.onReceiveData({ chunk: data, begin }); }); } requestAllChunks() { const missingChunks = this.stream.getMissingChunks(); this._requestChunks(missingChunks); return this._loadedStreamCapability.promise; } _requestChunks(chunks) { const requestId = this.currRequestId++; const chunksNeeded = new Set(); this._chunksNeededByRequest.set(requestId, chunksNeeded); for (const chunk of chunks) { if (!this.stream.hasChunk(chunk)) { chunksNeeded.add(chunk); } } if (chunksNeeded.size === 0) { return Promise.resolve(); } const capability = (0, _util.createPromiseCapability)(); this._promisesByRequest.set(requestId, capability); const chunksToRequest = []; for (const chunk of chunksNeeded) { let requestIds = this._requestsByChunk.get(chunk); if (!requestIds) { requestIds = []; this._requestsByChunk.set(chunk, requestIds); chunksToRequest.push(chunk); } requestIds.push(requestId); } if (chunksToRequest.length &gt; 0) { const groupedChunksToRequest = this.groupChunks(chunksToRequest); for (const groupedChunk of groupedChunksToRequest) { const begin = groupedChunk.beginChunk * this.chunkSize; const end = Math.min(groupedChunk.endChunk * this.chunkSize, this.length); this.sendRequest(begin, end).catch(capability.reject); } } return capability.promise.catch(reason =&gt; { if (this.aborted) { return; } throw reason; }); } getStream() { return this.stream; } requestRange(begin, end) { end = Math.min(end, this.length); const beginChunk = this.getBeginChunk(begin); const endChunk = this.getEndChunk(end); const chunks = []; for (let chunk = beginChunk; chunk &lt; endChunk; ++chunk) { chunks.push(chunk); } return this._requestChunks(chunks); } requestRanges(ranges = []) { const chunksToRequest = []; for (const range of ranges) { const beginChunk = this.getBeginChunk(range.begin); const endChunk = this.getEndChunk(range.end); for (let chunk = beginChunk; chunk &lt; endChunk; ++chunk) { if (!chunksToRequest.includes(chunk)) { chunksToRequest.push(chunk); } } } chunksToRequest.sort(function (a, b) { return a - b; }); return this._requestChunks(chunksToRequest); } groupChunks(chunks) { const groupedChunks = []; let beginChunk = -1; let prevChunk = -1; for (let i = 0, ii = chunks.length; i &lt; ii; ++i) { const chunk = chunks[i]; if (beginChunk &lt; 0) { beginChunk = chunk; } if (prevChunk &gt;= 0 &amp;&amp; prevChunk + 1 !== chunk) { groupedChunks.push({ beginChunk, endChunk: prevChunk + 1 }); beginChunk = chunk; } if (i + 1 === chunks.length) { groupedChunks.push({ beginChunk, endChunk: chunk + 1 }); } prevChunk = chunk; } return groupedChunks; } onProgress(args) { this.msgHandler.send(&quot;DocProgress&quot;, { loaded: this.stream.numChunksLoaded * this.chunkSize + args.loaded, total: this.length }); } onReceiveData(args) { const chunk = args.chunk; const isProgressive = args.begin === undefined; const begin = isProgressive ? this.progressiveDataLength : args.begin; const end = begin + chunk.byteLength; const beginChunk = Math.floor(begin / this.chunkSize); const endChunk = end &lt; this.length ? Math.floor(end / this.chunkSize) : Math.ceil(end / this.chunkSize); if (isProgressive) { this.stream.onReceiveProgressiveData(chunk); this.progressiveDataLength = end; } else { this.stream.onReceiveData(begin, chunk); } if (this.stream.isDataLoaded) { this._loadedStreamCapability.resolve(this.stream); } const loadedRequests = []; for (let curChunk = beginChunk; curChunk &lt; endChunk; ++curChunk) { const requestIds = this._requestsByChunk.get(curChunk); if (!requestIds) { continue; } this._requestsByChunk.delete(curChunk); for (const requestId of requestIds) { const chunksNeeded = this._chunksNeededByRequest.get(requestId); if (chunksNeeded.has(curChunk)) { chunksNeeded.delete(curChunk); } if (chunksNeeded.size &gt; 0) { continue; } loadedRequests.push(requestId); } } if (!this.disableAutoFetch &amp;&amp; this._requestsByChunk.size === 0) { let nextEmptyChunk; if (this.stream.numChunksLoaded === 1) { const lastChunk = this.stream.numChunks - 1; if (!this.stream.hasChunk(lastChunk)) { nextEmptyChunk = lastChunk; } } else { nextEmptyChunk = this.stream.nextEmptyChunk(endChunk); } if (Number.isInteger(nextEmptyChunk)) { this._requestChunks([nextEmptyChunk]); } } for (const requestId of loadedRequests) { const capability = this._promisesByRequest.get(requestId); this._promisesByRequest.delete(requestId); capability.resolve(); } this.msgHandler.send(&quot;DocProgress&quot;, { loaded: this.stream.numChunksLoaded * this.chunkSize, total: this.length }); } onError(err) { this._loadedStreamCapability.reject(err); } getBeginChunk(begin) { return Math.floor(begin / this.chunkSize); } getEndChunk(end) { return Math.floor((end - 1) / this.chunkSize) + 1; } abort(reason) { this.aborted = true; if (this.pdfNetworkStream) { this.pdfNetworkStream.cancelAllRequests(reason); } for (const capability of this._promisesByRequest.values()) { capability.reject(reason); } } } exports.ChunkedStreamManager = ChunkedStreamManager; /***/ }), /* 8 */ /***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) =&gt; { Object.defineProperty(exports, &quot;__esModule&quot;, ({ value: true })); exports.StringStream = exports.Stream = exports.NullStream = void 0; var _base_stream = __w_pdfjs_require__(5); var _util = __w_pdfjs_require__(2); class Stream extends _base_stream.BaseStream { constructor(arrayBuffer, start, length, dict) { super(); this.bytes = arrayBuffer instanceof Uint8Array ? arrayBuffer : new Uint8Array(arrayBuffer); this.start = start || 0; this.pos = this.start; this.end = start + length || this.bytes.length; this.dict = dict; } get length() { return this.end - this.start; } get isEmpty() { return this.length === 0; } getByte() { if (this.pos &gt;= this.end) { return -1; } return this.bytes[this.pos++]; } getBytes(length) { const bytes = this.bytes; const pos = this.pos; const strEnd = this.end; if (!length) { return bytes.subarray(pos, strEnd); } let end = pos + length; if (end &gt; strEnd) { end = strEnd; } this.pos = end; return bytes.subarray(pos, end); } getByteRange(begin, end) { if (begin &lt; 0) { begin = 0; } if (end &gt; this.end) { end = this.end; } return this.bytes.subarray(begin, end); } reset() { this.pos = this.start; } moveStart() { this.start = this.pos; } makeSubStream(start, length, dict = null) { return new Stream(this.bytes.buffer, start, length, dict); } } exports.Stream = Stream; class StringStream extends Stream { constructor(str) { super((0, _util.stringToBytes)(str)); } } exports.StringStream = StringStream; class NullStream extends Stream { constructor() { super(new Uint8Array(0)); } } exports.NullStream = NullStream; /***/ }), /* 9 */ /***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) =&gt; { Object.defineProperty(exports, &quot;__esModule&quot;, ({ value: true })); exports.Page = exports.PDFDocument = void 0; var _annotation = __w_pdfjs_require__(10); var _util = __w_pdfjs_require__(2); var _core_utils = __w_pdfjs_require__(4); var _primitives = __w_pdfjs_require__(3); var _xfa_fonts = __w_pdfjs_require__(49); var _base_stream = __w_pdfjs_require__(5); var _crypto = __w_pdfjs_require__(65); var _catalog = __w_pdfjs_require__(67); var _cleanup_helper = __w_pdfjs_require__(69); var _dataset_reader = __w_pdfjs_require__(98); var _parser = __w_pdfjs_require__(15); var _stream = __w_pdfjs_require__(8); var _object_loader = __w_pdfjs_require__(73); var _operator_list = __w_pdfjs_require__(60); var _evaluator = __w_pdfjs_require__(13); var _decode_stream = __w_pdfjs_require__(17); var _struct_tree = __w_pdfjs_require__(72); var _writer = __w_pdfjs_require__(63); var _factory = __w_pdfjs_require__(74); var _xref = __w_pdfjs_require__(99); const DEFAULT_USER_UNIT = 1.0; const LETTER_SIZE_MEDIABOX = [0, 0, 612, 792]; class Page { constructor({ pdfManager, xref, pageIndex, pageDict, ref, globalIdFactory, fontCache, builtInCMapCache, standardFontDataCache, globalImageCache, nonBlendModesSet, xfaFactory }) { this.pdfManager = pdfManager; this.pageIndex = pageIndex; this.pageDict = pageDict; this.xref = xref; this.ref = ref; this.fontCache = fontCache; this.builtInCMapCache = builtInCMapCache; this.standardFontDataCache = standardFontDataCache; this.globalImageCache = globalImageCache; this.nonBlendModesSet = nonBlendModesSet; this.evaluatorOptions = pdfManager.evaluatorOptions; this.resourcesPromise = null; this.xfaFactory = xfaFactory; const idCounters = { obj: 0 }; this._localIdFactory = class extends globalIdFactory { static createObjId() { return `p${pageIndex}_${++idCounters.obj}`; } static getPageObjId() { return `page${ref.toString()}`; } }; } _getInheritableProperty(key, getArray = false) { const value = (0, _core_utils.getInheritableProperty)({ dict: this.pageDict, key, getArray, stopWhenFound: false }); if (!Array.isArray(value)) { return value; } if (value.length === 1 || !(value[0] instanceof _primitives.Dict)) { return value[0]; } return _primitives.Dict.merge({ xref: this.xref, dictArray: value }); } get content() { return this.pageDict.getArray(&quot;Contents&quot;); } get resources() { const resources = this._getInheritableProperty(&quot;Resources&quot;); return (0, _util.shadow)(this, &quot;resources&quot;, resources instanceof _primitives.Dict ? resources : _primitives.Dict.empty); } _getBoundingBox(name) { if (this.xfaData) { return this.xfaData.bbox; } const box = this._getInheritableProperty(name, true); if (Array.isArray(box) &amp;&amp; box.length === 4) { if (box[2] - box[0] !== 0 &amp;&amp; box[3] - box[1] !== 0) { return box; } (0, _util.warn)(`Empty /${name} entry.`); } return null; } get mediaBox() { return (0, _util.shadow)(this, &quot;mediaBox&quot;, this._getBoundingBox(&quot;MediaBox&quot;) || LETTER_SIZE_MEDIABOX); } get cropBox() { return (0, _util.shadow)(this, &quot;cropBox&quot;, this._getBoundingBox(&quot;CropBox&quot;) || this.mediaBox); } get userUnit() { let obj = this.pageDict.get(&quot;UserUnit&quot;); if (typeof obj !== &quot;number&quot; || obj &lt;= 0) { obj = DEFAULT_USER_UNIT; } return (0, _util.shadow)(this, &quot;userUnit&quot;, obj); } get view() { const { cropBox, mediaBox } = this; let view; if (cropBox === mediaBox || (0, _util.isArrayEqual)(cropBox, mediaBox)) { view = mediaBox; } else { const box = _util.Util.intersect(cropBox, mediaBox); if (box &amp;&amp; box[2] - box[0] !== 0 &amp;&amp; box[3] - box[1] !== 0) { view = box; } else { (0, _util.warn)(&quot;Empty /CropBox and /MediaBox intersection.&quot;); } } return (0, _util.shadow)(this, &quot;view&quot;, view || mediaBox); } get rotate() { let rotate = this._getInheritableProperty(&quot;Rotate&quot;) || 0; if (rotate % 90 !== 0) { rotate = 0; } else if (rotate &gt;= 360) { rotate %= 360; } else if (rotate &lt; 0) { rotate = (rotate % 360 + 360) % 360; } return (0, _util.shadow)(this, &quot;rotate&quot;, rotate); } _onSubStreamError(handler, reason, objId) { if (this.evaluatorOptions.ignoreErrors) { handler.send(&quot;UnsupportedFeature&quot;, { featureId: _util.UNSUPPORTED_FEATURES.errorContentSubStream }); (0, _util.warn)(`getContentStream - ignoring sub-stream (${objId}): &quot;${reason}&quot;.`); return; } throw reason; } getContentStream(handler) { return this.pdfManager.ensure(this, &quot;content&quot;).then(content =&gt; { if (content instanceof _base_stream.BaseStream) { return content; } if (Array.isArray(content)) { return new _decode_stream.StreamsSequenceStream(content, this._onSubStreamError.bind(this, handler)); } return new _stream.NullStream(); }); } get xfaData() { return (0, _util.shadow)(this, &quot;xfaData&quot;, this.xfaFactory ? { bbox: this.xfaFactory.getBoundingBox(this.pageIndex) } : null); } async saveNewAnnotations(handler, task, annotations) { if (this.xfaFactory) { throw new Error(&quot;XFA: Cannot save new annotations.&quot;); } const partialEvaluator = new _evaluator.PartialEvaluator({ xref: this.xref, handler, pageIndex: this.pageIndex, idFactory: this._localIdFactory, fontCache: this.fontCache, builtInCMapCache: this.builtInCMapCache, standardFontDataCache: this.standardFontDataCache, globalImageCache: this.globalImageCache, options: this.evaluatorOptions }); const pageDict = this.pageDict; const annotationsArray = this.annotations.slice(); const newData = await _annotation.AnnotationFactory.saveNewAnnotations(partialEvaluator, task, annotations); for (const { ref } of newData.annotations) { annotationsArray.push(ref); } const savedDict = pageDict.get(&quot;Annots&quot;); pageDict.set(&quot;Annots&quot;, annotationsArray); const buffer = []; let transform = null; if (this.xref.encrypt) { transform = this.xref.encrypt.createCipherTransform(this.ref.num, this.ref.gen); } (0, _writer.writeObject)(this.ref, pageDict, buffer, transform); if (savedDict) { pageDict.set(&quot;Annots&quot;, savedDict); } const objects = newData.dependencies; objects.push({ ref: this.ref, data: buffer.join(&quot;&quot;) }, ...newData.annotations); return objects; } save(handler, task, annotationStorage) { const partialEvaluator = new _evaluator.PartialEvaluator({ xref: this.xref, handler, pageIndex: this.pageIndex, idFactory: this._localIdFactory, fontCache: this.fontCache, builtInCMapCache: this.builtInCMapCache, standardFontDataCache: this.standardFontDataCache, globalImageCache: this.globalImageCache, options: this.evaluatorOptions }); return this._parsedAnnotations.then(function (annotations) { const newRefsPromises = []; for (const annotation of annotations) { if (!annotation.mustBePrinted(annotationStorage)) { continue; } newRefsPromises.push(annotation.save(partialEvaluator, task, annotationStorage).catch(function (reason) { (0, _util.warn)(&quot;save - ignoring annotation data during &quot; + `&quot;${task.name}&quot; task: &quot;${reason}&quot;.`); return null; })); } return Promise.all(newRefsPromises).then(function (newRefs) { return newRefs.filter(newRef =&gt; !!newRef); }); }); } loadResources(keys) { if (!this.resourcesPromise) { this.resourcesPromise = this.pdfManager.ensure(this, &quot;resources&quot;); } return this.resourcesPromise.then(() =&gt; { const objectLoader = new _object_loader.ObjectLoader(this.resources, keys, this.xref); return objectLoader.load(); }); } getOperatorList({ handler, sink, task, intent, cacheKey, annotationStorage = null }) { const contentStreamPromise = this.getContentStream(handler); const resourcesPromise = this.loadResources([&quot;ColorSpace&quot;, &quot;ExtGState&quot;, &quot;Font&quot;, &quot;Pattern&quot;, &quot;Properties&quot;, &quot;Shading&quot;, &quot;XObject&quot;]); const partialEvaluator = new _evaluator.PartialEvaluator({ xref: this.xref, handler, pageIndex: this.pageIndex, idFactory: this._localIdFactory, fontCache: this.fontCache, builtInCMapCache: this.builtInCMapCache, standardFontDataCache: this.standardFontDataCache, globalImageCache: this.globalImageCache, options: this.evaluatorOptions }); const newAnnotationsByPage = !this.xfaFactory ? (0, _core_utils.getNewAnnotationsMap)(annotationStorage) : null; let newAnnotationsPromise = Promise.resolve(null); if (newAnnotationsByPage) { const newAnnotations = newAnnotationsByPage.get(this.pageIndex); if (newAnnotations) { newAnnotationsPromise = _annotation.AnnotationFactory.printNewAnnotations(partialEvaluator, task, newAnnotations); } } const dataPromises = Promise.all([contentStreamPromise, resourcesPromise]); const pageListPromise = dataPromises.then(([contentStream]) =&gt; { const opList = new _operator_list.OperatorList(intent, sink); handler.send(&quot;StartRenderPage&quot;, { transparency: partialEvaluator.hasBlendModes(this.resources, this.nonBlendModesSet), pageIndex: this.pageIndex, cacheKey }); return partialEvaluator.getOperatorList({ stream: contentStream, task, resources: this.resources, operatorList: opList }).then(function () { return opList; }); }); return Promise.all([pageListPromise, this._parsedAnnotations, newAnnotationsPromise]).then(function ([pageOpList, annotations, newAnnotations]) { if (newAnnotations) { annotations = annotations.concat(newAnnotations); } if (annotations.length === 0 || intent &amp; _util.RenderingIntentFlag.ANNOTATIONS_DISABLE) { pageOpList.flush(true); return { length: pageOpList.totalLength }; } const renderForms = !!(intent &amp; _util.RenderingIntentFlag.ANNOTATIONS_FORMS), intentAny = !!(intent &amp; _util.RenderingIntentFlag.ANY), intentDisplay = !!(intent &amp; _util.RenderingIntentFlag.DISPLAY), intentPrint = !!(intent &amp; _util.RenderingIntentFlag.PRINT); const opListPromises = []; for (const annotation of annotations) { if (intentAny || intentDisplay &amp;&amp; annotation.mustBeViewed(annotationStorage) || intentPrint &amp;&amp; annotation.mustBePrinted(annotationStorage)) { opListPromises.push(annotation.getOperatorList(partialEvaluator, task, intent, renderForms, annotationStorage).catch(function (reason) { (0, _util.warn)(&quot;getOperatorList - ignoring annotation data during &quot; + `&quot;${task.name}&quot; task: &quot;${reason}&quot;.`); return { opList: null, separateForm: false, separateCanvas: false }; })); } } return Promise.all(opListPromises).then(function (opLists) { let form = false, canvas = false; for (const { opList, separateForm, separateCanvas } of opLists) { pageOpList.addOpList(opList); if (separateForm) { form = separateForm; } if (separateCanvas) { canvas = separateCanvas; } } pageOpList.flush(true, { form, canvas }); return { length: pageOpList.totalLength }; }); }); } extractTextContent({ handler, task, includeMarkedContent, sink, combineTextItems }) { const contentStreamPromise = this.getContentStream(handler); const resourcesPromise = this.loadResources([&quot;ExtGState&quot;, &quot;Font&quot;, &quot;Properties&quot;, &quot;XObject&quot;]); const dataPromises = Promise.all([contentStreamPromise, resourcesPromise]); return dataPromises.then(([contentStream]) =&gt; { const partialEvaluator = new _evaluator.PartialEvaluator({ xref: this.xref, handler, pageIndex: this.pageIndex, idFactory: this._localIdFactory, fontCache: this.fontCache, builtInCMapCache: this.builtInCMapCache, standardFontDataCache: this.standardFontDataCache, globalImageCache: this.globalImageCache, options: this.evaluatorOptions }); return partialEvaluator.getTextContent({ stream: contentStream, task, resources: this.resources, includeMarkedContent, combineTextItems, sink, viewBox: this.view }); }); } async getStructTree() { const structTreeRoot = await this.pdfManager.ensureCatalog(&quot;structTreeRoot&quot;); if (!structTreeRoot) { return null; } const structTree = await this.pdfManager.ensure(this, &quot;_parseStructTree&quot;, [structTreeRoot]); return structTree.serializable; } _parseStructTree(structTreeRoot) { const tree = new _struct_tree.StructTreePage(structTreeRoot, this.pageDict); tree.parse(); return tree; } async getAnnotationsData(handler, task, intent) { const annotations = await this._parsedAnnotations; if (annotations.length === 0) { return []; } const textContentPromises = []; const annotationsData = []; let partialEvaluator; const intentAny = !!(intent &amp; _util.RenderingIntentFlag.ANY), intentDisplay = !!(intent &amp; _util.RenderingIntentFlag.DISPLAY), intentPrint = !!(intent &amp; _util.RenderingIntentFlag.PRINT); for (const annotation of annotations) { const isVisible = intentAny || intentDisplay &amp;&amp; annotation.viewable; if (isVisible || intentPrint &amp;&amp; annotation.printable) { annotationsData.push(annotation.data); } if (annotation.hasTextContent &amp;&amp; isVisible) { if (!partialEvaluator) { partialEvaluator = new _evaluator.PartialEvaluator({ xref: this.xref, handler, pageIndex: this.pageIndex, idFactory: this._localIdFactory, fontCache: this.fontCache, builtInCMapCache: this.builtInCMapCache, standardFontDataCache: this.standardFontDataCache, globalImageCache: this.globalImageCache, options: this.evaluatorOptions }); } textContentPromises.push(annotation.extractTextContent(partialEvaluator, task, this.view).catch(function (reason) { (0, _util.warn)(`getAnnotationsData - ignoring textContent during &quot;${task.name}&quot; task: &quot;${reason}&quot;.`); })); } } await Promise.all(textContentPromises); return annotationsData; } get annotations() { const annots = this._getInheritableProperty(&quot;Annots&quot;); return (0, _util.shadow)(this, &quot;annotations&quot;, Array.isArray(annots) ? annots : []); } get _parsedAnnotations() { const parsedAnnotations = this.pdfManager.ensure(this, &quot;annotations&quot;).then(() =&gt; { const annotationPromises = []; for (const annotationRef of this.annotations) { annotationPromises.push(_annotation.AnnotationFactory.create(this.xref, annotationRef, this.pdfManager, this._localIdFactory, false).catch(function (reason) { (0, _util.warn)(`_parsedAnnotations: &quot;${reason}&quot;.`); return null; })); } return Promise.all(annotationPromises).then(function (annotations) { if (annotations.length === 0) { return annotations; } const sortedAnnotations = []; let popupAnnotations; for (const annotation of annotations) { if (!annotation) { continue; } if (annotation instanceof _annotation.PopupAnnotation) { if (!popupAnnotations) { popupAnnotations = []; } popupAnnotations.push(annotation); continue; } sortedAnnotations.push(annotation); } if (popupAnnotations) { sortedAnnotations.push(...popupAnnotations); } return sortedAnnotations; }); }); return (0, _util.shadow)(this, &quot;_parsedAnnotations&quot;, parsedAnnotations); } get jsActions() { const actions = (0, _core_utils.collectActions)(this.xref, this.pageDict, _util.PageActionEventType); return (0, _util.shadow)(this, &quot;jsActions&quot;, actions); } } exports.Page = Page; const PDF_HEADER_SIGNATURE = new Uint8Array([0x25, 0x50, 0x44, 0x46, 0x2d]); const STARTXREF_SIGNATURE = new Uint8Array([0x73, 0x74, 0x61, 0x72, 0x74, 0x78, 0x72, 0x65, 0x66]); const ENDOBJ_SIGNATURE = new Uint8Array([0x65, 0x6e, 0x64, 0x6f, 0x62, 0x6a]); const FINGERPRINT_FIRST_BYTES = 1024; const EMPTY_FINGERPRINT = &quot;\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00&quot;; function find(stream, signature, limit = 1024, backwards = false) { const signatureLength = signature.length; const scanBytes = stream.peekBytes(limit); const scanLength = scanBytes.length - signatureLength; if (scanLength &lt;= 0) { return false; } if (backwards) { const signatureEnd = signatureLength - 1; let pos = scanBytes.length - 1; while (pos &gt;= signatureEnd) { let j = 0; while (j &lt; signatureLength &amp;&amp; scanBytes[pos - j] === signature[signatureEnd - j]) { j++; } if (j &gt;= signatureLength) { stream.pos += pos - signatureEnd; return true; } pos--; } } else { let pos = 0; while (pos &lt;= scanLength) { let j = 0; while (j &lt; signatureLength &amp;&amp; scanBytes[pos + j] === signature[j]) { j++; } if (j &gt;= signatureLength) { stream.pos += pos; return true; } pos++; } } return false; } class PDFDocument { constructor(pdfManager, stream) { if (stream.length &lt;= 0) { throw new _util.InvalidPDFException(&quot;The PDF file is empty, i.e. its size is zero bytes.&quot;); } this.pdfManager = pdfManager; this.stream = stream; this.xref = new _xref.XRef(stream, pdfManager); this._pagePromises = new Map(); this._version = null; const idCounters = { font: 0 }; this._globalIdFactory = class { static getDocId() { return `g_${pdfManager.docId}`; } static createFontId() { return `f${++idCounters.font}`; } static createObjId() { (0, _util.unreachable)(&quot;Abstract method `createObjId` called.&quot;); } static getPageObjId() { (0, _util.unreachable)(&quot;Abstract method `getPageObjId` called.&quot;); } }; } parse(recoveryMode) { this.xref.parse(recoveryMode); this.catalog = new _catalog.Catalog(this.pdfManager, this.xref); } get linearization() { let linearization = null; try { linearization = _parser.Linearization.create(this.stream); } catch (err) { if (err instanceof _core_utils.MissingDataException) { throw err; } (0, _util.info)(err); } return (0, _util.shadow)(this, &quot;linearization&quot;, linearization); } get startXRef() { const stream = this.stream; let startXRef = 0; if (this.linearization) { stream.reset(); if (find(stream, ENDOBJ_SIGNATURE)) { startXRef = stream.pos + 6 - stream.start; } } else { const step = 1024; const startXRefLength = STARTXREF_SIGNATURE.length; let found = false, pos = stream.end; while (!found &amp;&amp; pos &gt; 0) { pos -= step - startXRefLength; if (pos &lt; 0) { pos = 0; } stream.pos = pos; found = find(stream, STARTXREF_SIGNATURE, step, true); } if (found) { stream.skip(9); let ch; do { ch = stream.getByte(); } while ((0, _core_utils.isWhiteSpace)(ch)); let str = &quot;&quot;; while (ch &gt;= 0x20 &amp;&amp; ch &lt;= 0x39) { str += String.fromCharCode(ch); ch = stream.getByte(); } startXRef = parseInt(str, 10); if (isNaN(startXRef)) { startXRef = 0; } } } return (0, _util.shadow)(this, &quot;startXRef&quot;, startXRef); } checkHeader() { const stream = this.stream; stream.reset(); if (!find(stream, PDF_HEADER_SIGNATURE)) { return; } stream.moveStart(); stream.skip(PDF_HEADER_SIGNATURE.length); let version = &quot;&quot;, ch; while ((ch = stream.getByte()) &gt; 0x20 &amp;&amp; version.length &lt; 7) { version += String.fromCharCode(ch); } if (_core_utils.PDF_VERSION_REGEXP.test(version)) { this._version = version; } else { (0, _util.warn)(`Invalid PDF header version: ${version}`); } } parseStartXRef() { this.xref.setStartXRef(this.startXRef); } get numPages() { let num = 0; if (this.catalog.hasActualNumPages) { num = this.catalog.numPages; } else if (this.xfaFactory) { num = this.xfaFactory.getNumPages(); } else if (this.linearization) { num = this.linearization.numPages; } else { num = this.catalog.numPages; } return (0, _util.shadow)(this, &quot;numPages&quot;, num); } _hasOnlyDocumentSignatures(fields, recursionDepth = 0) { const RECURSION_LIMIT = 10; if (!Array.isArray(fields)) { return false; } return fields.every(field =&gt; { field = this.xref.fetchIfRef(field); if (!(field instanceof _primitives.Dict)) { return false; } if (field.has(&quot;Kids&quot;)) { if (++recursionDepth &gt; RECURSION_LIMIT) { (0, _util.warn)(&quot;_hasOnlyDocumentSignatures: maximum recursion depth reached&quot;); return false; } return this._hasOnlyDocumentSignatures(field.get(&quot;Kids&quot;), recursionDepth); } const isSignature = (0, _primitives.isName)(field.get(&quot;FT&quot;), &quot;Sig&quot;); const rectangle = field.get(&quot;Rect&quot;); const isInvisible = Array.isArray(rectangle) &amp;&amp; rectangle.every(value =&gt; value === 0); return isSignature &amp;&amp; isInvisible; }); } get _xfaStreams() { const acroForm = this.catalog.acroForm; if (!acroForm) { return null; } const xfa = acroForm.get(&quot;XFA&quot;); const entries = { &quot;xdp:xdp&quot;: &quot;&quot;, template: &quot;&quot;, datasets: &quot;&quot;, config: &quot;&quot;, connectionSet: &quot;&quot;, localeSet: &quot;&quot;, stylesheet: &quot;&quot;, &quot;/xdp:xdp&quot;: &quot;&quot; }; if (xfa instanceof _base_stream.BaseStream &amp;&amp; !xfa.isEmpty) { entries[&quot;xdp:xdp&quot;] = xfa; return entries; } if (!Array.isArray(xfa) || xfa.length === 0) { return null; } for (let i = 0, ii = xfa.length; i &lt; ii; i += 2) { let name; if (i === 0) { name = &quot;xdp:xdp&quot;; } else if (i === ii - 2) { name = &quot;/xdp:xdp&quot;; } else { name = xfa[i]; } if (!entries.hasOwnProperty(name)) { continue; } const data = this.xref.fetchIfRef(xfa[i + 1]); if (!(data instanceof _base_stream.BaseStream) || data.isEmpty) { continue; } entries[name] = data; } return entries; } get xfaDatasets() { const streams = this._xfaStreams; if (!streams) { return (0, _util.shadow)(this, &quot;xfaDatasets&quot;, null); } for (const key of [&quot;datasets&quot;, &quot;xdp:xdp&quot;]) { const stream = streams[key]; if (!stream) { continue; } try { const str = (0, _util.stringToUTF8String)(stream.getString()); const data = { [key]: str }; return (0, _util.shadow)(this, &quot;xfaDatasets&quot;, new _dataset_reader.DatasetReader(data)); } catch (_) { (0, _util.warn)(&quot;XFA - Invalid utf-8 string.&quot;); break; } } return (0, _util.shadow)(this, &quot;xfaDatasets&quot;, null); } get xfaData() { const streams = this._xfaStreams; if (!streams) { return null; } const data = Object.create(null); for (const [key, stream] of Object.entries(streams)) { if (!stream) { continue; } try { data[key] = (0, _util.stringToUTF8String)(stream.getString()); } catch (_) { (0, _util.warn)(&quot;XFA - Invalid utf-8 string.&quot;); return null; } } return data; } get xfaFactory() { let data; if (this.pdfManager.enableXfa &amp;&amp; this.catalog.needsRendering &amp;&amp; this.formInfo.hasXfa &amp;&amp; !this.formInfo.hasAcroForm) { data = this.xfaData; } return (0, _util.shadow)(this, &quot;xfaFactory&quot;, data ? new _factory.XFAFactory(data) : null); } get isPureXfa() { return this.xfaFactory ? this.xfaFactory.isValid() : false; } get htmlForXfa() { return this.xfaFactory ? this.xfaFactory.getPages() : null; } async loadXfaImages() { const xfaImagesDict = await this.pdfManager.ensureCatalog(&quot;xfaImages&quot;); if (!xfaImagesDict) { return; } const keys = xfaImagesDict.getKeys(); const objectLoader = new _object_loader.ObjectLoader(xfaImagesDict, keys, this.xref); await objectLoader.load(); const xfaImages = new Map(); for (const key of keys) { const stream = xfaImagesDict.get(key); if (stream instanceof _base_stream.BaseStream) { xfaImages.set(key, stream.getBytes()); } } this.xfaFactory.setImages(xfaImages); } async loadXfaFonts(handler, task) { const acroForm = await this.pdfManager.ensureCatalog(&quot;acroForm&quot;); if (!acroForm) { return; } const resources = await acroForm.getAsync(&quot;DR&quot;); if (!(resources instanceof _primitives.Dict)) { return; } const objectLoader = new _object_loader.ObjectLoader(resources, [&quot;Font&quot;], this.xref); await objectLoader.load(); const fontRes = resources.get(&quot;Font&quot;); if (!(fontRes instanceof _primitives.Dict)) { return; } const options = Object.assign(Object.create(null), this.pdfManager.evaluatorOptions); options.useSystemFonts = false; const partialEvaluator = new _evaluator.PartialEvaluator({ xref: this.xref, handler, pageIndex: -1, idFactory: this._globalIdFactory, fontCache: this.catalog.fontCache, builtInCMapCache: this.catalog.builtInCMapCache, standardFontDataCache: this.catalog.standardFontDataCache, options }); const operatorList = new _operator_list.OperatorList(); const pdfFonts = []; const initialState = { get font() { return pdfFonts.at(-1); }, set font(font) { pdfFonts.push(font); }, clone() { return this; } }; const fonts = new Map(); fontRes.forEach((fontName, font) =&gt; { fonts.set(fontName, font); }); const promises = []; for (const [fontName, font] of fonts) { const descriptor = font.get(&quot;FontDescriptor&quot;); if (!(descriptor instanceof _primitives.Dict)) { continue; } let fontFamily = descriptor.get(&quot;FontFamily&quot;); fontFamily = fontFamily.replace(/[ ]+(\\d)/g, &quot;$1&quot;); const fontWeight = descriptor.get(&quot;FontWeight&quot;); const italicAngle = -descriptor.get(&quot;ItalicAngle&quot;); const cssFontInfo = { fontFamily, fontWeight, italicAngle }; if (!(0, _core_utils.validateCSSFont)(cssFontInfo)) { continue; } promises.push(partialEvaluator.handleSetFont(resources, [_primitives.Name.get(fontName), 1], null, operatorList, task, initialState, null, cssFontInfo).catch(function (reason) { (0, _util.warn)(`loadXfaFonts: &quot;${reason}&quot;.`); return null; })); } await Promise.all(promises); const missingFonts = this.xfaFactory.setFonts(pdfFonts); if (!missingFonts) { return; } options.ignoreErrors = true; promises.length = 0; pdfFonts.length = 0; const reallyMissingFonts = new Set(); for (const missing of missingFonts) { if (!(0, _xfa_fonts.getXfaFontName)(`${missing}-Regular`)) { reallyMissingFonts.add(missing); } } if (reallyMissingFonts.size) { missingFonts.push(&quot;PdfJS-Fallback&quot;); } for (const missing of missingFonts) { if (reallyMissingFonts.has(missing)) { continue; } for (const fontInfo of [{ name: &quot;Regular&quot;, fontWeight: 400, italicAngle: 0 }, { name: &quot;Bold&quot;, fontWeight: 700, italicAngle: 0 }, { name: &quot;Italic&quot;, fontWeight: 400, italicAngle: 12 }, { name: &quot;BoldItalic&quot;, fontWeight: 700, italicAngle: 12 }]) { const name = `${missing}-${fontInfo.name}`; const dict = (0, _xfa_fonts.getXfaFontDict)(name); promises.push(partialEvaluator.handleSetFont(resources, [_primitives.Name.get(name), 1], null, operatorList, task, initialState, dict, { fontFamily: missing, fontWeight: fontInfo.fontWeight, italicAngle: fontInfo.italicAngle }).catch(function (reason) { (0, _util.warn)(`loadXfaFonts: &quot;${reason}&quot;.`); return null; })); } } await Promise.all(promises); this.xfaFactory.appendFonts(pdfFonts, reallyMissingFonts); } async serializeXfaData(annotationStorage) { return this.xfaFactory ? this.xfaFactory.serializeData(annotationStorage) : null; } get version() { return this.catalog.version || this._version; } get formInfo() { const formInfo = { hasFields: false, hasAcroForm: false, hasXfa: false, hasSignatures: false }; const acroForm = this.catalog.acroForm; if (!acroForm) { return (0, _util.shadow)(this, &quot;formInfo&quot;, formInfo); } try { const fields = acroForm.get(&quot;Fields&quot;); const hasFields = Array.isArray(fields) &amp;&amp; fields.length &gt; 0; formInfo.hasFields = hasFields; const xfa = acroForm.get(&quot;XFA&quot;); formInfo.hasXfa = Array.isArray(xfa) &amp;&amp; xfa.length &gt; 0 || xfa instanceof _base_stream.BaseStream &amp;&amp; !xfa.isEmpty; const sigFlags = acroForm.get(&quot;SigFlags&quot;); const hasSignatures = !!(sigFlags &amp; 0x1); const hasOnlyDocumentSignatures = hasSignatures &amp;&amp; this._hasOnlyDocumentSignatures(fields); formInfo.hasAcroForm = hasFields &amp;&amp; !hasOnlyDocumentSignatures; formInfo.hasSignatures = hasSignatures; } catch (ex) { if (ex instanceof _core_utils.MissingDataException) { throw ex; } (0, _util.warn)(`Cannot fetch form information: &quot;${ex}&quot;.`); } return (0, _util.shadow)(this, &quot;formInfo&quot;, formInfo); } get documentInfo() { const docInfo = { PDFFormatVersion: this.version, Language: this.catalog.lang, EncryptFilterName: this.xref.encrypt ? this.xref.encrypt.filterName : null, IsLinearized: !!this.linearization, IsAcroFormPresent: this.formInfo.hasAcroForm, IsXFAPresent: this.formInfo.hasXfa, IsCollectionPresent: !!this.catalog.collection, IsSignaturesPresent: this.formInfo.hasSignatures }; let infoDict; try { infoDict = this.xref.trailer.get(&quot;Info&quot;); } catch (err) { if (err instanceof _core_utils.MissingDataException) { throw err; } (0, _util.info)(&quot;The document information dictionary is invalid.&quot;); } if (!(infoDict instanceof _primitives.Dict)) { return (0, _util.shadow)(this, &quot;documentInfo&quot;, docInfo); } for (const key of infoDict.getKeys()) { const value = infoDict.get(key); switch (key) { case &quot;Title&quot;: case &quot;Author&quot;: case &quot;Subject&quot;: case &quot;Keywords&quot;: case &quot;Creator&quot;: case &quot;Producer&quot;: case &quot;CreationDate&quot;: case &quot;ModDate&quot;: if (typeof value === &quot;string&quot;) { docInfo[key] = (0, _util.stringToPDFString)(value); continue; } break; case &quot;Trapped&quot;: if (value instanceof _primitives.Name) { docInfo[key] = value; continue; } break; default: let customValue; switch (typeof value) { case &quot;string&quot;: customValue = (0, _util.stringToPDFString)(value); break; case &quot;number&quot;: case &quot;boolean&quot;: customValue = value; break; default: if (value instanceof _primitives.Name) { customValue = value; } break; } if (customValue === undefined) { (0, _util.warn)(`Bad value, for custom key &quot;${key}&quot;, in Info: ${value}.`); continue; } if (!docInfo.Custom) { docInfo.Custom = Object.create(null); } docInfo.Custom[key] = customValue; continue; } (0, _util.warn)(`Bad value, for key &quot;${key}&quot;, in Info: ${value}.`); } return (0, _util.shadow)(this, &quot;documentInfo&quot;, docInfo); } get fingerprints() { function validate(data) { return typeof data === &quot;string&quot; &amp;&amp; data.length &gt; 0 &amp;&amp; data !== EMPTY_FINGERPRINT; } function hexString(hash) { const buf = []; for (const num of hash) { const hex = num.toString(16); buf.push(hex.padStart(2, &quot;0&quot;)); } return buf.join(&quot;&quot;); } const idArray = this.xref.trailer.get(&quot;ID&quot;); let hashOriginal, hashModified; if (Array.isArray(idArray) &amp;&amp; validate(idArray[0])) { hashOriginal = (0, _util.stringToBytes)(idArray[0]); if (idArray[1] !== idArray[0] &amp;&amp; validate(idArray[1])) { hashModified = (0, _util.stringToBytes)(idArray[1]); } } else { hashOriginal = (0, _crypto.calculateMD5)(this.stream.getByteRange(0, FINGERPRINT_FIRST_BYTES), 0, FINGERPRINT_FIRST_BYTES); } return (0, _util.shadow)(this, &quot;fingerprints&quot;, [hexString(hashOriginal), hashModified ? hexString(hashModified) : null]); } async _getLinearizationPage(pageIndex) { const { catalog, linearization, xref } = this; const ref = _primitives.Ref.get(linearization.objectNumberFirst, 0); try { const obj = await xref.fetchAsync(ref); if (obj instanceof _primitives.Dict) { let type = obj.getRaw(&quot;Type&quot;); if (type instanceof _primitives.Ref) { type = await xref.fetchAsync(type); } if ((0, _primitives.isName)(type, &quot;Page&quot;) || !obj.has(&quot;Type&quot;) &amp;&amp; !obj.has(&quot;Kids&quot;)) { if (!catalog.pageKidsCountCache.has(ref)) { catalog.pageKidsCountCache.put(ref, 1); } if (!catalog.pageIndexCache.has(ref)) { catalog.pageIndexCache.put(ref, 0); } return [obj, ref]; } } throw new _util.FormatError(&quot;The Linearization dictionary doesn&apos;t point to a valid Page dictionary.&quot;); } catch (reason) { (0, _util.warn)(`_getLinearizationPage: &quot;${reason.message}&quot;.`); return catalog.getPageDict(pageIndex); } } getPage(pageIndex) { const cachedPromise = this._pagePromises.get(pageIndex); if (cachedPromise) { return cachedPromise; } const { catalog, linearization, xfaFactory } = this; let promise; if (xfaFactory) { promise = Promise.resolve([_primitives.Dict.empty, null]); } else if (linearization &amp;&amp; linearization.pageFirst === pageIndex) { promise = this._getLinearizationPage(pageIndex); } else { promise = catalog.getPageDict(pageIndex); } promise = promise.then(([pageDict, ref]) =&gt; { return new Page({ pdfManager: this.pdfManager, xref: this.xref, pageIndex, pageDict, ref, globalIdFactory: this._globalIdFactory, fontCache: catalog.fontCache, builtInCMapCache: catalog.builtInCMapCache, standardFontDataCache: catalog.standardFontDataCache, globalImageCache: catalog.globalImageCache, nonBlendModesSet: catalog.nonBlendModesSet, xfaFactory }); }); this._pagePromises.set(pageIndex, promise); return promise; } async checkFirstPage(recoveryMode = false) { if (recoveryMode) { return; } try { await this.getPage(0); } catch (reason) { if (reason instanceof _core_utils.XRefEntryException) { this._pagePromises.delete(0); await this.cleanup(); throw new _core_utils.XRefParseException(); } } } async checkLastPage(recoveryMode = false) { const { catalog, pdfManager } = this; catalog.setActualNumPages(); let numPages; try { await Promise.all([pdfManager.ensureDoc(&quot;xfaFactory&quot;), pdfManager.ensureDoc(&quot;linearization&quot;), pdfManager.ensureCatalog(&quot;numPages&quot;)]); if (this.xfaFactory) { return; } else if (this.linearization) { numPages = this.linearization.numPages; } else { numPages = catalog.numPages; } if (!Number.isInteger(numPages)) { throw new _util.FormatError(&quot;Page count is not an integer.&quot;); } else if (numPages &lt;= 1) { return; } await this.getPage(numPages - 1); } catch (reason) { this._pagePromises.delete(numPages - 1); await this.cleanup(); if (reason instanceof _core_utils.XRefEntryException &amp;&amp; !recoveryMode) { throw new _core_utils.XRefParseException(); } (0, _util.warn)(`checkLastPage - invalid /Pages tree /Count: ${numPages}.`); let pagesTree; try { pagesTree = await catalog.getAllPageDicts(recoveryMode); } catch (reasonAll) { if (reasonAll instanceof _core_utils.XRefEntryException &amp;&amp; !recoveryMode) { throw new _core_utils.XRefParseException(); } catalog.setActualNumPages(1); return; } for (const [pageIndex, [pageDict, ref]] of pagesTree) { let promise; if (pageDict instanceof Error) { promise = Promise.reject(pageDict); promise.catch(() =&gt; {}); } else { promise = Promise.resolve(new Page({ pdfManager, xref: this.xref, pageIndex, pageDict, ref, globalIdFactory: this._globalIdFactory, fontCache: catalog.fontCache, builtInCMapCache: catalog.builtInCMapCache, standardFontDataCache: catalog.standardFontDataCache, globalImageCache: catalog.globalImageCache, nonBlendModesSet: catalog.nonBlendModesSet, xfaFactory: null })); } this._pagePromises.set(pageIndex, promise); } catalog.setActualNumPages(pagesTree.size); } } fontFallback(id, handler) { return this.catalog.fontFallback(id, handler); } async cleanup(manuallyTriggered = false) { return this.catalog ? this.catalog.cleanup(manuallyTriggered) : (0, _cleanup_helper.clearGlobalCaches)(); } _collectFieldObjects(name, fieldRef, promises) { const field = this.xref.fetchIfRef(fieldRef); if (field.has(&quot;T&quot;)) { const partName = (0, _util.stringToPDFString)(field.get(&quot;T&quot;)); if (name === &quot;&quot;) { name = partName; } else { name = `${name}.${partName}`; } } if (!promises.has(name)) { promises.set(name, []); } promises.get(name).push(_annotation.AnnotationFactory.create(this.xref, fieldRef, this.pdfManager, this._localIdFactory, true).then(annotation =&gt; annotation &amp;&amp; annotation.getFieldObject()).catch(function (reason) { (0, _util.warn)(`_collectFieldObjects: &quot;${reason}&quot;.`); return null; })); if (field.has(&quot;Kids&quot;)) { const kids = field.get(&quot;Kids&quot;); for (const kid of kids) { this._collectFieldObjects(name, kid, promises); } } } get fieldObjects() { if (!this.formInfo.hasFields) { return (0, _util.shadow)(this, &quot;fieldObjects&quot;, Promise.resolve(null)); } const allFields = Object.create(null); const fieldPromises = new Map(); for (const fieldRef of this.catalog.acroForm.get(&quot;Fields&quot;)) { this._collectFieldObjects(&quot;&quot;, fieldRef, fieldPromises); } const allPromises = []; for (const [name, promises] of fieldPromises) { allPromises.push(Promise.all(promises).then(fields =&gt; { fields = fields.filter(field =&gt; !!field); if (fields.length &gt; 0) { allFields[name] = fields; } })); } return (0, _util.shadow)(this, &quot;fieldObjects&quot;, Promise.all(allPromises).then(() =&gt; allFields)); } get hasJSActions() { const promise = this.pdfManager.ensureDoc(&quot;_parseHasJSActions&quot;); return (0, _util.shadow)(this, &quot;hasJSActions&quot;, promise); } async _parseHasJSActions() { const [catalogJsActions, fieldObjects] = await Promise.all([this.pdfManager.ensureCatalog(&quot;jsActions&quot;), this.pdfManager.ensureDoc(&quot;fieldObjects&quot;)]); if (catalogJsActions) { return true; } if (fieldObjects) { return Object.values(fieldObjects).some(fieldObject =&gt; fieldObject.some(object =&gt; object.actions !== null)); } return false; } get calculationOrderIds() { const acroForm = this.catalog.acroForm; if (!acroForm || !acroForm.has(&quot;CO&quot;)) { return (0, _util.shadow)(this, &quot;calculationOrderIds&quot;, null); } const calculationOrder = acroForm.get(&quot;CO&quot;); if (!Array.isArray(calculationOrder) || calculationOrder.length === 0) { return (0, _util.shadow)(this, &quot;calculationOrderIds&quot;, null); } const ids = []; for (const id of calculationOrder) { if (id instanceof _primitives.Ref) { ids.push(id.toString()); } } if (ids.length === 0) { return (0, _util.shadow)(this, &quot;calculationOrderIds&quot;, null); } return (0, _util.shadow)(this, &quot;calculationOrderIds&quot;, ids); } } exports.PDFDocument = PDFDocument; /***/ }), /* 10 */ /***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) =&gt; { Object.defineProperty(exports, &quot;__esModule&quot;, ({ value: true })); exports.PopupAnnotation = exports.MarkupAnnotation = exports.AnnotationFactory = exports.AnnotationBorderStyle = exports.Annotation = void 0; exports.getQuadPoints = getQuadPoints; var _util = __w_pdfjs_require__(2); var _core_utils = __w_pdfjs_require__(4); var _default_appearance = __w_pdfjs_require__(11); var _primitives = __w_pdfjs_require__(3); var _writer = __w_pdfjs_require__(63); var _base_stream = __w_pdfjs_require__(5); var _bidi = __w_pdfjs_require__(58); var _catalog = __w_pdfjs_require__(67); var _colorspace = __w_pdfjs_require__(12); var _file_spec = __w_pdfjs_require__(70); var _object_loader = __w_pdfjs_require__(73); var _operator_list = __w_pdfjs_require__(60); var _stream = __w_pdfjs_require__(8); var _factory = __w_pdfjs_require__(74); class AnnotationFactory { static create(xref, ref, pdfManager, idFactory, collectFields) { return Promise.all([pdfManager.ensureCatalog(&quot;acroForm&quot;), pdfManager.ensureCatalog(&quot;baseUrl&quot;), pdfManager.ensureCatalog(&quot;attachments&quot;), pdfManager.ensureDoc(&quot;xfaDatasets&quot;), collectFields ? this._getPageIndex(xref, ref, pdfManager) : -1]).then(([acroForm, baseUrl, attachments, xfaDatasets, pageIndex]) =&gt; pdfManager.ensure(this, &quot;_create&quot;, [xref, ref, pdfManager, idFactory, acroForm, attachments, xfaDatasets, collectFields, pageIndex])); } static _create(xref, ref, pdfManager, idFactory, acroForm, attachments = null, xfaDatasets, collectFields, pageIndex = -1) { const dict = xref.fetchIfRef(ref); if (!(dict instanceof _primitives.Dict)) { return undefined; } const id = ref instanceof _primitives.Ref ? ref.toString() : `annot_${idFactory.createObjId()}`; let subtype = dict.get(&quot;Subtype&quot;); subtype = subtype instanceof _primitives.Name ? subtype.name : null; const parameters = { xref, ref, dict, subtype, id, pdfManager, acroForm: acroForm instanceof _primitives.Dict ? acroForm : _primitives.Dict.empty, attachments, xfaDatasets, collectFields, pageIndex }; switch (subtype) { case &quot;Link&quot;: return new LinkAnnotation(parameters); case &quot;Text&quot;: return new TextAnnotation(parameters); case &quot;Widget&quot;: let fieldType = (0, _core_utils.getInheritableProperty)({ dict, key: &quot;FT&quot; }); fieldType = fieldType instanceof _primitives.Name ? fieldType.name : null; switch (fieldType) { case &quot;Tx&quot;: return new TextWidgetAnnotation(parameters); case &quot;Btn&quot;: return new ButtonWidgetAnnotation(parameters); case &quot;Ch&quot;: return new ChoiceWidgetAnnotation(parameters); case &quot;Sig&quot;: return new SignatureWidgetAnnotation(parameters); } (0, _util.warn)(`Unimplemented widget field type &quot;${fieldType}&quot;, ` + &quot;falling back to base field type.&quot;); return new WidgetAnnotation(parameters); case &quot;Popup&quot;: return new PopupAnnotation(parameters); case &quot;FreeText&quot;: return new FreeTextAnnotation(parameters); case &quot;Line&quot;: return new LineAnnotation(parameters); case &quot;Square&quot;: return new SquareAnnotation(parameters); case &quot;Circle&quot;: return new CircleAnnotation(parameters); case &quot;PolyLine&quot;: return new PolylineAnnotation(parameters); case &quot;Polygon&quot;: return new PolygonAnnotation(parameters); case &quot;Caret&quot;: return new CaretAnnotation(parameters); case &quot;Ink&quot;: return new InkAnnotation(parameters); case &quot;Highlight&quot;: return new HighlightAnnotation(parameters); case &quot;Underline&quot;: return new UnderlineAnnotation(parameters); case &quot;Squiggly&quot;: return new SquigglyAnnotation(parameters); case &quot;StrikeOut&quot;: return new StrikeOutAnnotation(parameters); case &quot;Stamp&quot;: return new StampAnnotation(parameters); case &quot;FileAttachment&quot;: return new FileAttachmentAnnotation(parameters); default: if (!collectFields) { if (!subtype) { (0, _util.warn)(&quot;Annotation is missing the required /Subtype.&quot;); } else { (0, _util.warn)(`Unimplemented annotation type &quot;${subtype}&quot;, ` + &quot;falling back to base annotation.&quot;); } } return new Annotation(parameters); } } static async _getPageIndex(xref, ref, pdfManager) { try { const annotDict = await xref.fetchIfRefAsync(ref); if (!(annotDict instanceof _primitives.Dict)) { return -1; } const pageRef = annotDict.getRaw(&quot;P&quot;); if (!(pageRef instanceof _primitives.Ref)) { return -1; } const pageIndex = await pdfManager.ensureCatalog(&quot;getPageIndex&quot;, [pageRef]); return pageIndex; } catch (ex) { (0, _util.warn)(`_getPageIndex: &quot;${ex}&quot;.`); return -1; } } static async saveNewAnnotations(evaluator, task, annotations) { const xref = evaluator.xref; let baseFontRef; const dependencies = []; const promises = []; for (const annotation of annotations) { switch (annotation.annotationType) { case _util.AnnotationEditorType.FREETEXT: if (!baseFontRef) { const baseFont = new _primitives.Dict(xref); baseFont.set(&quot;BaseFont&quot;, _primitives.Name.get(&quot;Helvetica&quot;)); baseFont.set(&quot;Type&quot;, _primitives.Name.get(&quot;Font&quot;)); baseFont.set(&quot;Subtype&quot;, _primitives.Name.get(&quot;Type1&quot;)); baseFont.set(&quot;Encoding&quot;, _primitives.Name.get(&quot;WinAnsiEncoding&quot;)); const buffer = []; baseFontRef = xref.getNewRef(); (0, _writer.writeObject)(baseFontRef, baseFont, buffer, null); dependencies.push({ ref: baseFontRef, data: buffer.join(&quot;&quot;) }); } promises.push(FreeTextAnnotation.createNewAnnotation(xref, annotation, dependencies, { evaluator, task, baseFontRef })); break; case _util.AnnotationEditorType.INK: promises.push(InkAnnotation.createNewAnnotation(xref, annotation, dependencies)); } } return { annotations: await Promise.all(promises), dependencies }; } static async printNewAnnotations(evaluator, task, annotations) { if (!annotations) { return null; } const xref = evaluator.xref; const promises = []; for (const annotation of annotations) { switch (annotation.annotationType) { case _util.AnnotationEditorType.FREETEXT: promises.push(FreeTextAnnotation.createNewPrintAnnotation(xref, annotation, { evaluator, task })); break; case _util.AnnotationEditorType.INK: promises.push(InkAnnotation.createNewPrintAnnotation(xref, annotation)); break; } } return Promise.all(promises); } } exports.AnnotationFactory = AnnotationFactory; function getRgbColor(color, defaultColor = new Uint8ClampedArray(3)) { if (!Array.isArray(color)) { return defaultColor; } const rgbColor = defaultColor || new Uint8ClampedArray(3); switch (color.length) { case 0: return null; case 1: _colorspace.ColorSpace.singletons.gray.getRgbItem(color, 0, rgbColor, 0); return rgbColor; case 3: _colorspace.ColorSpace.singletons.rgb.getRgbItem(color, 0, rgbColor, 0); return rgbColor; case 4: _colorspace.ColorSpace.singletons.cmyk.getRgbItem(color, 0, rgbColor, 0); return rgbColor; default: return defaultColor; } } function getQuadPoints(dict, rect) { if (!dict.has(&quot;QuadPoints&quot;)) { return null; } const quadPoints = dict.getArray(&quot;QuadPoints&quot;); if (!Array.isArray(quadPoints) || quadPoints.length === 0 || quadPoints.length % 8 &gt; 0) { return null; } const quadPointsLists = []; for (let i = 0, ii = quadPoints.length / 8; i &lt; ii; i++) { quadPointsLists.push([]); for (let j = i * 8, jj = i * 8 + 8; j &lt; jj; j += 2) { const x = quadPoints[j]; const y = quadPoints[j + 1]; if (rect !== null &amp;&amp; (x &lt; rect[0] || x &gt; rect[2] || y &lt; rect[1] || y &gt; rect[3])) { return null; } quadPointsLists[i].push({ x, y }); } } return quadPointsLists.map(quadPointsList =&gt; { const [minX, maxX, minY, maxY] = quadPointsList.reduce(([mX, MX, mY, MY], quadPoint) =&gt; [Math.min(mX, quadPoint.x), Math.max(MX, quadPoint.x), Math.min(mY, quadPoint.y), Math.max(MY, quadPoint.y)], [Number.MAX_VALUE, Number.MIN_VALUE, Number.MAX_VALUE, Number.MIN_VALUE]); return [{ x: minX, y: maxY }, { x: maxX, y: maxY }, { x: minX, y: minY }, { x: maxX, y: minY }]; }); } function getTransformMatrix(rect, bbox, matrix) { const [minX, minY, maxX, maxY] = _util.Util.getAxialAlignedBoundingBox(bbox, matrix); if (minX === maxX || minY === maxY) { return [1, 0, 0, 1, rect[0], rect[1]]; } const xRatio = (rect[2] - rect[0]) / (maxX - minX); const yRatio = (rect[3] - rect[1]) / (maxY - minY); return [xRatio, 0, 0, yRatio, rect[0] - minX * xRatio, rect[1] - minY * yRatio]; } class Annotation { constructor(params) { const dict = params.dict; this.setTitle(dict.get(&quot;T&quot;)); this.setContents(dict.get(&quot;Contents&quot;)); this.setModificationDate(dict.get(&quot;M&quot;)); this.setFlags(dict.get(&quot;F&quot;)); this.setRectangle(dict.getArray(&quot;Rect&quot;)); this.setColor(dict.getArray(&quot;C&quot;)); this.setBorderStyle(dict); this.setAppearance(dict); this.setOptionalContent(dict); const MK = dict.get(&quot;MK&quot;); this.setBorderAndBackgroundColors(MK); this.setRotation(MK); this._streams = []; if (this.appearance) { this._streams.push(this.appearance); } this.data = { annotationFlags: this.flags, borderStyle: this.borderStyle, color: this.color, backgroundColor: this.backgroundColor, borderColor: this.borderColor, rotation: this.rotation, contentsObj: this._contents, hasAppearance: !!this.appearance, id: params.id, modificationDate: this.modificationDate, rect: this.rectangle, subtype: params.subtype, hasOwnCanvas: false }; if (params.collectFields) { const kids = dict.get(&quot;Kids&quot;); if (Array.isArray(kids)) { const kidIds = []; for (const kid of kids) { if (kid instanceof _primitives.Ref) { kidIds.push(kid.toString()); } } if (kidIds.length !== 0) { this.data.kidIds = kidIds; } } this.data.actions = (0, _core_utils.collectActions)(params.xref, dict, _util.AnnotationActionEventType); this.data.fieldName = this._constructFieldName(dict); this.data.pageIndex = params.pageIndex; } this._fallbackFontDict = null; } _hasFlag(flags, flag) { return !!(flags &amp; flag); } _isViewable(flags) { return !this._hasFlag(flags, _util.AnnotationFlag.INVISIBLE) &amp;&amp; !this._hasFlag(flags, _util.AnnotationFlag.NOVIEW); } _isPrintable(flags) { return this._hasFlag(flags, _util.AnnotationFlag.PRINT) &amp;&amp; !this._hasFlag(flags, _util.AnnotationFlag.INVISIBLE); } mustBeViewed(annotationStorage) { const storageEntry = annotationStorage &amp;&amp; annotationStorage.get(this.data.id); if (storageEntry &amp;&amp; storageEntry.hidden !== undefined) { return !storageEntry.hidden; } return this.viewable &amp;&amp; !this._hasFlag(this.flags, _util.AnnotationFlag.HIDDEN); } mustBePrinted(annotationStorage) { const storageEntry = annotationStorage &amp;&amp; annotationStorage.get(this.data.id); if (storageEntry &amp;&amp; storageEntry.print !== undefined) { return storageEntry.print; } return this.printable; } get viewable() { if (this.data.quadPoints === null) { return false; } if (this.flags === 0) { return true; } return this._isViewable(this.flags); } get printable() { if (this.data.quadPoints === null) { return false; } if (this.flags === 0) { return false; } return this._isPrintable(this.flags); } _parseStringHelper(data) { const str = typeof data === &quot;string&quot; ? (0, _util.stringToPDFString)(data) : &quot;&quot;; const dir = str &amp;&amp; (0, _bidi.bidi)(str).dir === &quot;rtl&quot; ? &quot;rtl&quot; : &quot;ltr&quot;; return { str, dir }; } setTitle(title) { this._title = this._parseStringHelper(title); } setContents(contents) { this._contents = this._parseStringHelper(contents); } setModificationDate(modificationDate) { this.modificationDate = typeof modificationDate === &quot;string&quot; ? modificationDate : null; } setFlags(flags) { this.flags = Number.isInteger(flags) &amp;&amp; flags &gt; 0 ? flags : 0; } hasFlag(flag) { return this._hasFlag(this.flags, flag); } setRectangle(rectangle) { if (Array.isArray(rectangle) &amp;&amp; rectangle.length === 4) { this.rectangle = _util.Util.normalizeRect(rectangle); } else { this.rectangle = [0, 0, 0, 0]; } } setColor(color) { this.color = getRgbColor(color); } setLineEndings(lineEndings) { this.lineEndings = [&quot;None&quot;, &quot;None&quot;]; if (Array.isArray(lineEndings) &amp;&amp; lineEndings.length === 2) { for (let i = 0; i &lt; 2; i++) { const obj = lineEndings[i]; if (obj instanceof _primitives.Name) { switch (obj.name) { case &quot;None&quot;: continue; case &quot;Square&quot;: case &quot;Circle&quot;: case &quot;Diamond&quot;: case &quot;OpenArrow&quot;: case &quot;ClosedArrow&quot;: case &quot;Butt&quot;: case &quot;ROpenArrow&quot;: case &quot;RClosedArrow&quot;: case &quot;Slash&quot;: this.lineEndings[i] = obj.name; continue; } } (0, _util.warn)(`Ignoring invalid lineEnding: ${obj}`); } } } setRotation(mk) { this.rotation = 0; if (mk instanceof _primitives.Dict) { let angle = mk.get(&quot;R&quot;) || 0; if (Number.isInteger(angle) &amp;&amp; angle !== 0) { angle %= 360; if (angle &lt; 0) { angle += 360; } if (angle % 90 === 0) { this.rotation = angle; } } } } setBorderAndBackgroundColors(mk) { if (mk instanceof _primitives.Dict) { this.borderColor = getRgbColor(mk.getArray(&quot;BC&quot;), null); this.backgroundColor = getRgbColor(mk.getArray(&quot;BG&quot;), null); } else { this.borderColor = this.backgroundColor = null; } } setBorderStyle(borderStyle) { this.borderStyle = new AnnotationBorderStyle(); if (!(borderStyle instanceof _primitives.Dict)) { return; } if (borderStyle.has(&quot;BS&quot;)) { const dict = borderStyle.get(&quot;BS&quot;); const dictType = dict.get(&quot;Type&quot;); if (!dictType || (0, _primitives.isName)(dictType, &quot;Border&quot;)) { this.borderStyle.setWidth(dict.get(&quot;W&quot;), this.rectangle); this.borderStyle.setStyle(dict.get(&quot;S&quot;)); this.borderStyle.setDashArray(dict.getArray(&quot;D&quot;)); } } else if (borderStyle.has(&quot;Border&quot;)) { const array = borderStyle.getArray(&quot;Border&quot;); if (Array.isArray(array) &amp;&amp; array.length &gt;= 3) { this.borderStyle.setHorizontalCornerRadius(array[0]); this.borderStyle.setVerticalCornerRadius(array[1]); this.borderStyle.setWidth(array[2], this.rectangle); if (array.length === 4) { this.borderStyle.setDashArray(array[3], true); } } } else { this.borderStyle.setWidth(0); } } setAppearance(dict) { this.appearance = null; const appearanceStates = dict.get(&quot;AP&quot;); if (!(appearanceStates instanceof _primitives.Dict)) { return; } const normalAppearanceState = appearanceStates.get(&quot;N&quot;); if (normalAppearanceState instanceof _base_stream.BaseStream) { this.appearance = normalAppearanceState; return; } if (!(normalAppearanceState instanceof _primitives.Dict)) { return; } const as = dict.get(&quot;AS&quot;); if (!(as instanceof _primitives.Name) || !normalAppearanceState.has(as.name)) { return; } this.appearance = normalAppearanceState.get(as.name); } setOptionalContent(dict) { this.oc = null; const oc = dict.get(&quot;OC&quot;); if (oc instanceof _primitives.Name) { (0, _util.warn)(&quot;setOptionalContent: Support for /Name-entry is not implemented.&quot;); } else if (oc instanceof _primitives.Dict) { this.oc = oc; } } loadResources(keys, appearance) { return appearance.dict.getAsync(&quot;Resources&quot;).then(resources =&gt; { if (!resources) { return undefined; } const objectLoader = new _object_loader.ObjectLoader(resources, keys, resources.xref); return objectLoader.load().then(function () { return resources; }); }); } async getOperatorList(evaluator, task, intent, renderForms, annotationStorage) { const data = this.data; let appearance = this.appearance; const isUsingOwnCanvas = !!(this.data.hasOwnCanvas &amp;&amp; intent &amp; _util.RenderingIntentFlag.DISPLAY); if (!appearance) { if (!isUsingOwnCanvas) { return { opList: new _operator_list.OperatorList(), separateForm: false, separateCanvas: false }; } appearance = new _stream.StringStream(&quot;&quot;); appearance.dict = new _primitives.Dict(); } const appearanceDict = appearance.dict; const resources = await this.loadResources([&quot;ExtGState&quot;, &quot;ColorSpace&quot;, &quot;Pattern&quot;, &quot;Shading&quot;, &quot;XObject&quot;, &quot;Font&quot;], appearance); const bbox = appearanceDict.getArray(&quot;BBox&quot;) || [0, 0, 1, 1]; const matrix = appearanceDict.getArray(&quot;Matrix&quot;) || [1, 0, 0, 1, 0, 0]; const transform = getTransformMatrix(data.rect, bbox, matrix); const opList = new _operator_list.OperatorList(); let optionalContent; if (this.oc) { optionalContent = await evaluator.parseMarkedContentProps(this.oc, null); } if (optionalContent !== undefined) { opList.addOp(_util.OPS.beginMarkedContentProps, [&quot;OC&quot;, optionalContent]); } opList.addOp(_util.OPS.beginAnnotation, [data.id, data.rect, transform, matrix, isUsingOwnCanvas]); await evaluator.getOperatorList({ stream: appearance, task, resources, operatorList: opList, fallbackFontDict: this._fallbackFontDict }); opList.addOp(_util.OPS.endAnnotation, []); if (optionalContent !== undefined) { opList.addOp(_util.OPS.endMarkedContent, []); } this.reset(); return { opList, separateForm: false, separateCanvas: isUsingOwnCanvas }; } async save(evaluator, task, annotationStorage) { return null; } get hasTextContent() { return false; } async extractTextContent(evaluator, task, viewBox) { if (!this.appearance) { return; } const resources = await this.loadResources([&quot;ExtGState&quot;, &quot;Font&quot;, &quot;Properties&quot;, &quot;XObject&quot;], this.appearance); const text = []; const buffer = []; const sink = { desiredSize: Math.Infinity, ready: true, enqueue(chunk, size) { for (const item of chunk.items) { buffer.push(item.str); if (item.hasEOL) { text.push(buffer.join(&quot;&quot;)); buffer.length = 0; } } } }; await evaluator.getTextContent({ stream: this.appearance, task, resources, includeMarkedContent: true, combineTextItems: true, sink, viewBox }); this.reset(); if (buffer.length) { text.push(buffer.join(&quot;&quot;)); } if (text.length &gt; 0) { this.data.textContent = text; } } getFieldObject() { if (this.data.kidIds) { return { id: this.data.id, actions: this.data.actions, name: this.data.fieldName, strokeColor: this.data.borderColor, fillColor: this.data.backgroundColor, type: &quot;&quot;, kidIds: this.data.kidIds, page: this.data.pageIndex, rotation: this.rotation }; } return null; } reset() { for (const stream of this._streams) { stream.reset(); } } _constructFieldName(dict) { if (!dict.has(&quot;T&quot;) &amp;&amp; !dict.has(&quot;Parent&quot;)) { (0, _util.warn)(&quot;Unknown field name, falling back to empty field name.&quot;); return &quot;&quot;; } if (!dict.has(&quot;Parent&quot;)) { return (0, _util.stringToPDFString)(dict.get(&quot;T&quot;)); } const fieldName = []; if (dict.has(&quot;T&quot;)) { fieldName.unshift((0, _util.stringToPDFString)(dict.get(&quot;T&quot;))); } let loopDict = dict; const visited = new _primitives.RefSet(); if (dict.objId) { visited.put(dict.objId); } while (loopDict.has(&quot;Parent&quot;)) { loopDict = loopDict.get(&quot;Parent&quot;); if (!(loopDict instanceof _primitives.Dict) || loopDict.objId &amp;&amp; visited.has(loopDict.objId)) { break; } if (loopDict.objId) { visited.put(loopDict.objId); } if (loopDict.has(&quot;T&quot;)) { fieldName.unshift((0, _util.stringToPDFString)(loopDict.get(&quot;T&quot;))); } } return fieldName.join(&quot;.&quot;); } } exports.Annotation = Annotation; class AnnotationBorderStyle { constructor() { this.width = 1; this.style = _util.AnnotationBorderStyleType.SOLID; this.dashArray = [3]; this.horizontalCornerRadius = 0; this.verticalCornerRadius = 0; } setWidth(width, rect = [0, 0, 0, 0]) { if (width instanceof _primitives.Name) { this.width = 0; return; } if (typeof width === &quot;number&quot;) { if (width &gt; 0) { const maxWidth = (rect[2] - rect[0]) / 2; const maxHeight = (rect[3] - rect[1]) / 2; if (maxWidth &gt; 0 &amp;&amp; maxHeight &gt; 0 &amp;&amp; (width &gt; maxWidth || width &gt; maxHeight)) { (0, _util.warn)(`AnnotationBorderStyle.setWidth - ignoring width: ${width}`); width = 1; } } this.width = width; } } setStyle(style) { if (!(style instanceof _primitives.Name)) { return; } switch (style.name) { case &quot;S&quot;: this.style = _util.AnnotationBorderStyleType.SOLID; break; case &quot;D&quot;: this.style = _util.AnnotationBorderStyleType.DASHED; break; case &quot;B&quot;: this.style = _util.AnnotationBorderStyleType.BEVELED; break; case &quot;I&quot;: this.style = _util.AnnotationBorderStyleType.INSET; break; case &quot;U&quot;: this.style = _util.AnnotationBorderStyleType.UNDERLINE; break; default: break; } } setDashArray(dashArray, forceStyle = false) { if (Array.isArray(dashArray) &amp;&amp; dashArray.length &gt; 0) { let isValid = true; let allZeros = true; for (const element of dashArray) { const validNumber = +element &gt;= 0; if (!validNumber) { isValid = false; break; } else if (element &gt; 0) { allZeros = false; } } if (isValid &amp;&amp; !allZeros) { this.dashArray = dashArray; if (forceStyle) { this.setStyle(_primitives.Name.get(&quot;D&quot;)); } } else { this.width = 0; } } else if (dashArray) { this.width = 0; } } setHorizontalCornerRadius(radius) { if (Number.isInteger(radius)) { this.horizontalCornerRadius = radius; } } setVerticalCornerRadius(radius) { if (Number.isInteger(radius)) { this.verticalCornerRadius = radius; } } } exports.AnnotationBorderStyle = AnnotationBorderStyle; class MarkupAnnotation extends Annotation { constructor(parameters) { super(parameters); const dict = parameters.dict; if (dict.has(&quot;IRT&quot;)) { const rawIRT = dict.getRaw(&quot;IRT&quot;); this.data.inReplyTo = rawIRT instanceof _primitives.Ref ? rawIRT.toString() : null; const rt = dict.get(&quot;RT&quot;); this.data.replyType = rt instanceof _primitives.Name ? rt.name : _util.AnnotationReplyType.REPLY; } if (this.data.replyType === _util.AnnotationReplyType.GROUP) { const parent = dict.get(&quot;IRT&quot;); this.setTitle(parent.get(&quot;T&quot;)); this.data.titleObj = this._title; this.setContents(parent.get(&quot;Contents&quot;)); this.data.contentsObj = this._contents; if (!parent.has(&quot;CreationDate&quot;)) { this.data.creationDate = null; } else { this.setCreationDate(parent.get(&quot;CreationDate&quot;)); this.data.creationDate = this.creationDate; } if (!parent.has(&quot;M&quot;)) { this.data.modificationDate = null; } else { this.setModificationDate(parent.get(&quot;M&quot;)); this.data.modificationDate = this.modificationDate; } this.data.hasPopup = parent.has(&quot;Popup&quot;); if (!parent.has(&quot;C&quot;)) { this.data.color = null; } else { this.setColor(parent.getArray(&quot;C&quot;)); this.data.color = this.color; } } else { this.data.titleObj = this._title; this.setCreationDate(dict.get(&quot;CreationDate&quot;)); this.data.creationDate = this.creationDate; this.data.hasPopup = dict.has(&quot;Popup&quot;); if (!dict.has(&quot;C&quot;)) { this.data.color = null; } } if (dict.has(&quot;RC&quot;)) { this.data.richText = _factory.XFAFactory.getRichTextAsHtml(dict.get(&quot;RC&quot;)); } } setCreationDate(creationDate) { this.creationDate = typeof creationDate === &quot;string&quot; ? creationDate : null; } _setDefaultAppearance({ xref, extra, strokeColor, fillColor, blendMode, strokeAlpha, fillAlpha, pointsCallback }) { let minX = Number.MAX_VALUE; let minY = Number.MAX_VALUE; let maxX = Number.MIN_VALUE; let maxY = Number.MIN_VALUE; const buffer = [&quot;q&quot;]; if (extra) { buffer.push(extra); } if (strokeColor) { buffer.push(`${strokeColor[0]} ${strokeColor[1]} ${strokeColor[2]} RG`); } if (fillColor) { buffer.push(`${fillColor[0]} ${fillColor[1]} ${fillColor[2]} rg`); } let pointsArray = this.data.quadPoints; if (!pointsArray) { pointsArray = [[{ x: this.rectangle[0], y: this.rectangle[3] }, { x: this.rectangle[2], y: this.rectangle[3] }, { x: this.rectangle[0], y: this.rectangle[1] }, { x: this.rectangle[2], y: this.rectangle[1] }]]; } for (const points of pointsArray) { const [mX, MX, mY, MY] = pointsCallback(buffer, points); minX = Math.min(minX, mX); maxX = Math.max(maxX, MX); minY = Math.min(minY, mY); maxY = Math.max(maxY, MY); } buffer.push(&quot;Q&quot;); const formDict = new _primitives.Dict(xref); const appearanceStreamDict = new _primitives.Dict(xref); appearanceStreamDict.set(&quot;Subtype&quot;, _primitives.Name.get(&quot;Form&quot;)); const appearanceStream = new _stream.StringStream(buffer.join(&quot; &quot;)); appearanceStream.dict = appearanceStreamDict; formDict.set(&quot;Fm0&quot;, appearanceStream); const gsDict = new _primitives.Dict(xref); if (blendMode) { gsDict.set(&quot;BM&quot;, _primitives.Name.get(blendMode)); } if (typeof strokeAlpha === &quot;number&quot;) { gsDict.set(&quot;CA&quot;, strokeAlpha); } if (typeof fillAlpha === &quot;number&quot;) { gsDict.set(&quot;ca&quot;, fillAlpha); } const stateDict = new _primitives.Dict(xref); stateDict.set(&quot;GS0&quot;, gsDict); const resources = new _primitives.Dict(xref); resources.set(&quot;ExtGState&quot;, stateDict); resources.set(&quot;XObject&quot;, formDict); const appearanceDict = new _primitives.Dict(xref); appearanceDict.set(&quot;Resources&quot;, resources); const bbox = this.data.rect = [minX, minY, maxX, maxY]; appearanceDict.set(&quot;BBox&quot;, bbox); this.appearance = new _stream.StringStream(&quot;/GS0 gs /Fm0 Do&quot;); this.appearance.dict = appearanceDict; this._streams.push(this.appearance, appearanceStream); } static async createNewAnnotation(xref, annotation, dependencies, params) { const annotationRef = xref.getNewRef(); const apRef = xref.getNewRef(); const annotationDict = this.createNewDict(annotation, xref, { apRef }); const ap = await this.createNewAppearanceStream(annotation, xref, params); const buffer = []; let transform = xref.encrypt ? xref.encrypt.createCipherTransform(apRef.num, apRef.gen) : null; (0, _writer.writeObject)(apRef, ap, buffer, transform); dependencies.push({ ref: apRef, data: buffer.join(&quot;&quot;) }); buffer.length = 0; transform = xref.encrypt ? xref.encrypt.createCipherTransform(annotationRef.num, annotationRef.gen) : null; (0, _writer.writeObject)(annotationRef, annotationDict, buffer, transform); return { ref: annotationRef, data: buffer.join(&quot;&quot;) }; } static async createNewPrintAnnotation(xref, annotation, params) { const ap = await this.createNewAppearanceStream(annotation, xref, params); const annotationDict = this.createNewDict(annotation, xref, { ap }); return new this.prototype.constructor({ dict: annotationDict, xref }); } } exports.MarkupAnnotation = MarkupAnnotation; class WidgetAnnotation extends Annotation { constructor(params) { super(params); const dict = params.dict; const data = this.data; this.ref = params.ref; data.annotationType = _util.AnnotationType.WIDGET; if (data.fieldName === undefined) { data.fieldName = this._constructFieldName(dict); } if (data.actions === undefined) { data.actions = (0, _core_utils.collectActions)(params.xref, dict, _util.AnnotationActionEventType); } let fieldValue = (0, _core_utils.getInheritableProperty)({ dict, key: &quot;V&quot;, getArray: true }); data.fieldValue = this._decodeFormValue(fieldValue); const defaultFieldValue = (0, _core_utils.getInheritableProperty)({ dict, key: &quot;DV&quot;, getArray: true }); data.defaultFieldValue = this._decodeFormValue(defaultFieldValue); if (fieldValue === undefined &amp;&amp; params.xfaDatasets) { const path = this._title.str; if (path) { this._hasValueFromXFA = true; data.fieldValue = fieldValue = params.xfaDatasets.getValue(path); } } if (fieldValue === undefined &amp;&amp; data.defaultFieldValue !== null) { data.fieldValue = data.defaultFieldValue; } data.alternativeText = (0, _util.stringToPDFString)(dict.get(&quot;TU&quot;) || &quot;&quot;); const defaultAppearance = (0, _core_utils.getInheritableProperty)({ dict, key: &quot;DA&quot; }) || params.acroForm.get(&quot;DA&quot;); this._defaultAppearance = typeof defaultAppearance === &quot;string&quot; ? defaultAppearance : &quot;&quot;; data.defaultAppearanceData = (0, _default_appearance.parseDefaultAppearance)(this._defaultAppearance); const fieldType = (0, _core_utils.getInheritableProperty)({ dict, key: &quot;FT&quot; }); data.fieldType = fieldType instanceof _primitives.Name ? fieldType.name : null; const localResources = (0, _core_utils.getInheritableProperty)({ dict, key: &quot;DR&quot; }); const acroFormResources = params.acroForm.get(&quot;DR&quot;); const appearanceResources = this.appearance &amp;&amp; this.appearance.dict.get(&quot;Resources&quot;); this._fieldResources = { localResources, acroFormResources, appearanceResources, mergedResources: _primitives.Dict.merge({ xref: params.xref, dictArray: [localResources, appearanceResources, acroFormResources], mergeSubDicts: true }) }; data.fieldFlags = (0, _core_utils.getInheritableProperty)({ dict, key: &quot;Ff&quot; }); if (!Number.isInteger(data.fieldFlags) || data.fieldFlags &lt; 0) { data.fieldFlags = 0; } data.readOnly = this.hasFieldFlag(_util.AnnotationFieldFlag.READONLY); data.required = this.hasFieldFlag(_util.AnnotationFieldFlag.REQUIRED); data.hidden = this._hasFlag(data.annotationFlags, _util.AnnotationFlag.HIDDEN); } _decodeFormValue(formValue) { if (Array.isArray(formValue)) { return formValue.filter(item =&gt; typeof item === &quot;string&quot;).map(item =&gt; (0, _util.stringToPDFString)(item)); } else if (formValue instanceof _primitives.Name) { return (0, _util.stringToPDFString)(formValue.name); } else if (typeof formValue === &quot;string&quot;) { return (0, _util.stringToPDFString)(formValue); } return null; } hasFieldFlag(flag) { return !!(this.data.fieldFlags &amp; flag); } static _getRotationMatrix(rotation, width, height) { switch (rotation) { case 90: return [0, 1, -1, 0, width, 0]; case 180: return [-1, 0, 0, -1, width, height]; case 270: return [0, -1, 1, 0, 0, height]; default: throw new Error(&quot;Invalid rotation&quot;); } } getRotationMatrix(annotationStorage) { const storageEntry = annotationStorage ? annotationStorage.get(this.data.id) : undefined; let rotation = storageEntry &amp;&amp; storageEntry.rotation; if (rotation === undefined) { rotation = this.rotation; } if (rotation === 0) { return _util.IDENTITY_MATRIX; } const width = this.data.rect[2] - this.data.rect[0]; const height = this.data.rect[3] - this.data.rect[1]; return WidgetAnnotation._getRotationMatrix(rotation, width, height); } getBorderAndBackgroundAppearances(annotationStorage) { const storageEntry = annotationStorage ? annotationStorage.get(this.data.id) : undefined; let rotation = storageEntry &amp;&amp; storageEntry.rotation; if (rotation === undefined) { rotation = this.rotation; } if (!this.backgroundColor &amp;&amp; !this.borderColor) { return &quot;&quot;; } const width = this.data.rect[2] - this.data.rect[0]; const height = this.data.rect[3] - this.data.rect[1]; const rect = rotation === 0 || rotation === 180 ? `0 0 ${width} ${height} re` : `0 0 ${height} ${width} re`; let str = &quot;&quot;; if (this.backgroundColor) { str = `${(0, _default_appearance.getPdfColor)(this.backgroundColor, true)} ${rect} f `; } if (this.borderColor) { const borderWidth = this.borderStyle.width || 1; str += `${borderWidth} w ${(0, _default_appearance.getPdfColor)(this.borderColor, false)} ${rect} S `; } return str; } async getOperatorList(evaluator, task, intent, renderForms, annotationStorage) { if (renderForms &amp;&amp; !(this instanceof SignatureWidgetAnnotation)) { return { opList: new _operator_list.OperatorList(), separateForm: true, separateCanvas: false }; } if (!this._hasText) { return super.getOperatorList(evaluator, task, intent, renderForms, annotationStorage); } const content = await this._getAppearance(evaluator, task, annotationStorage); if (this.appearance &amp;&amp; content === null) { return super.getOperatorList(evaluator, task, intent, renderForms, annotationStorage); } const opList = new _operator_list.OperatorList(); if (!this._defaultAppearance || content === null) { return { opList, separateForm: false, separateCanvas: false }; } const matrix = [1, 0, 0, 1, 0, 0]; const bbox = [0, 0, this.data.rect[2] - this.data.rect[0], this.data.rect[3] - this.data.rect[1]]; const transform = getTransformMatrix(this.data.rect, bbox, matrix); let optionalContent; if (this.oc) { optionalContent = await evaluator.parseMarkedContentProps(this.oc, null); } if (optionalContent !== undefined) { opList.addOp(_util.OPS.beginMarkedContentProps, [&quot;OC&quot;, optionalContent]); } opList.addOp(_util.OPS.beginAnnotation, [this.data.id, this.data.rect, transform, this.getRotationMatrix(annotationStorage), false]); const stream = new _stream.StringStream(content); await evaluator.getOperatorList({ stream, task, resources: this._fieldResources.mergedResources, operatorList: opList }); opList.addOp(_util.OPS.endAnnotation, []); if (optionalContent !== undefined) { opList.addOp(_util.OPS.endMarkedContent, []); } return { opList, separateForm: false, separateCanvas: false }; } _getMKDict(rotation) { const mk = new _primitives.Dict(null); if (rotation) { mk.set(&quot;R&quot;, rotation); } if (this.borderColor) { mk.set(&quot;BC&quot;, Array.from(this.borderColor).map(c =&gt; c / 255)); } if (this.backgroundColor) { mk.set(&quot;BG&quot;, Array.from(this.backgroundColor).map(c =&gt; c / 255)); } return mk.size &gt; 0 ? mk : null; } async save(evaluator, task, annotationStorage) { const storageEntry = annotationStorage ? annotationStorage.get(this.data.id) : undefined; let value = storageEntry &amp;&amp; storageEntry.value; let rotation = storageEntry &amp;&amp; storageEntry.rotation; if (value === this.data.fieldValue || value === undefined) { if (!this._hasValueFromXFA &amp;&amp; rotation === undefined) { return null; } value = value || this.data.fieldValue; } if (rotation === undefined &amp;&amp; !this._hasValueFromXFA &amp;&amp; Array.isArray(value) &amp;&amp; Array.isArray(this.data.fieldValue) &amp;&amp; value.length === this.data.fieldValue.length &amp;&amp; value.every((x, i) =&gt; x === this.data.fieldValue[i])) { return null; } if (rotation === undefined) { rotation = this.rotation; } let appearance = await this._getAppearance(evaluator, task, annotationStorage); if (appearance === null) { return null; } const { xref } = evaluator; const dict = xref.fetchIfRef(this.ref); if (!(dict instanceof _primitives.Dict)) { return null; } const bbox = [0, 0, this.data.rect[2] - this.data.rect[0], this.data.rect[3] - this.data.rect[1]]; const xfa = { path: (0, _util.stringToPDFString)(dict.get(&quot;T&quot;) || &quot;&quot;), value }; const newRef = xref.getNewRef(); const AP = new _primitives.Dict(xref); AP.set(&quot;N&quot;, newRef); const encrypt = xref.encrypt; let originalTransform = null; let newTransform = null; if (encrypt) { originalTransform = encrypt.createCipherTransform(this.ref.num, this.ref.gen); newTransform = encrypt.createCipherTransform(newRef.num, newRef.gen); appearance = newTransform.encryptString(appearance); } const encoder = val =&gt; (0, _util.isAscii)(val) ? val : (0, _util.stringToUTF16BEString)(val); dict.set(&quot;V&quot;, Array.isArray(value) ? value.map(encoder) : encoder(value)); dict.set(&quot;AP&quot;, AP); dict.set(&quot;M&quot;, `D:${(0, _util.getModificationDate)()}`); const maybeMK = this._getMKDict(rotation); if (maybeMK) { dict.set(&quot;MK&quot;, maybeMK); } const appearanceDict = new _primitives.Dict(xref); appearanceDict.set(&quot;Length&quot;, appearance.length); appearanceDict.set(&quot;Subtype&quot;, _primitives.Name.get(&quot;Form&quot;)); appearanceDict.set(&quot;Resources&quot;, this._getSaveFieldResources(xref)); appearanceDict.set(&quot;BBox&quot;, bbox); const rotationMatrix = this.getRotationMatrix(annotationStorage); if (rotationMatrix !== _util.IDENTITY_MATRIX) { appearanceDict.set(&quot;Matrix&quot;, rotationMatrix); } const bufferOriginal = [`${this.ref.num} ${this.ref.gen} obj\\n`]; (0, _writer.writeDict)(dict, bufferOriginal, originalTransform); bufferOriginal.push(&quot;\\nendobj\\n&quot;); const bufferNew = [`${newRef.num} ${newRef.gen} obj\\n`]; (0, _writer.writeDict)(appearanceDict, bufferNew, newTransform); bufferNew.push(&quot; stream\\n&quot;, appearance, &quot;\\nendstream\\nendobj\\n&quot;); return [{ ref: this.ref, data: bufferOriginal.join(&quot;&quot;), xfa }, { ref: newRef, data: bufferNew.join(&quot;&quot;), xfa: null }]; } async _getAppearance(evaluator, task, annotationStorage) { const isPassword = this.hasFieldFlag(_util.AnnotationFieldFlag.PASSWORD); if (isPassword) { return null; } const storageEntry = annotationStorage ? annotationStorage.get(this.data.id) : undefined; let value, rotation; if (storageEntry) { value = storageEntry.formattedValue || storageEntry.value; rotation = storageEntry.rotation; } if (rotation === undefined &amp;&amp; value === undefined) { if (!this._hasValueFromXFA || this.appearance) { return null; } } if (value === undefined) { value = this.data.fieldValue; if (!value) { return &quot;&quot;; } } if (Array.isArray(value) &amp;&amp; value.length === 1) { value = value[0]; } (0, _util.assert)(typeof value === &quot;string&quot;, &quot;Expected `value` to be a string.&quot;); value = value.trim(); if (value === &quot;&quot;) { return &quot;&quot;; } if (rotation === undefined) { rotation = this.rotation; } let lineCount = -1; if (this.data.multiLine) { lineCount = value.split(/\\r\\n|\\r|\\n/).length; } const defaultPadding = 2; const hPadding = defaultPadding; let totalHeight = this.data.rect[3] - this.data.rect[1]; let totalWidth = this.data.rect[2] - this.data.rect[0]; if (rotation === 90 || rotation === 270) { [totalWidth, totalHeight] = [totalHeight, totalWidth]; } if (!this._defaultAppearance) { this.data.defaultAppearanceData = (0, _default_appearance.parseDefaultAppearance)(this._defaultAppearance = &quot;/Helvetica 0 Tf 0 g&quot;); } const font = await WidgetAnnotation._getFontData(evaluator, task, this.data.defaultAppearanceData, this._fieldResources.mergedResources); const [defaultAppearance, fontSize] = this._computeFontSize(totalHeight - defaultPadding, totalWidth - 2 * hPadding, value, font, lineCount); let descent = font.descent; if (isNaN(descent)) { descent = 0; } const defaultVPadding = Math.min(Math.floor((totalHeight - fontSize) / 2), defaultPadding); const vPadding = defaultVPadding + Math.abs(descent) * fontSize; const alignment = this.data.textAlignment; if (this.data.multiLine) { return this._getMultilineAppearance(defaultAppearance, value, font, fontSize, totalWidth, totalHeight, alignment, hPadding, vPadding, annotationStorage); } const encodedString = font.encodeString(value).join(&quot;&quot;); if (this.data.comb) { return this._getCombAppearance(defaultAppearance, font, encodedString, totalWidth, hPadding, vPadding, annotationStorage); } const colors = this.getBorderAndBackgroundAppearances(annotationStorage); if (alignment === 0 || alignment &gt; 2) { return `/Tx BMC q ${colors}BT ` + defaultAppearance + ` 1 0 0 1 ${hPadding} ${vPadding} Tm (${(0, _util.escapeString)(encodedString)}) Tj` + &quot; ET Q EMC&quot;; } const renderedText = this._renderText(encodedString, font, fontSize, totalWidth, alignment, hPadding, vPadding); return `/Tx BMC q ${colors}BT ` + defaultAppearance + ` 1 0 0 1 0 0 Tm ${renderedText}` + &quot; ET Q EMC&quot;; } static async _getFontData(evaluator, task, appearanceData, resources) { const operatorList = new _operator_list.OperatorList(); const initialState = { font: null, clone() { return this; } }; const { fontName, fontSize } = appearanceData; await evaluator.handleSetFont(resources, [fontName &amp;&amp; _primitives.Name.get(fontName), fontSize], null, operatorList, task, initialState, null); return initialState.font; } _getTextWidth(text, font) { return font.charsToGlyphs(text).reduce((width, glyph) =&gt; width + glyph.width, 0) / 1000; } _computeFontSize(height, width, text, font, lineCount) { let { fontSize } = this.data.defaultAppearanceData; if (!fontSize) { const roundWithTwoDigits = x =&gt; Math.floor(x * 100) / 100; if (lineCount === -1) { const textWidth = this._getTextWidth(text, font); fontSize = roundWithTwoDigits(Math.min(height / _util.LINE_FACTOR, width / textWidth)); } else { const lines = text.split(/\\r\\n?|\\n/); const cachedLines = []; for (const line of lines) { const encoded = font.encodeString(line).join(&quot;&quot;); const glyphs = font.charsToGlyphs(encoded); const positions = font.getCharPositions(encoded); cachedLines.push({ line: encoded, glyphs, positions }); } const isTooBig = fsize =&gt; { let totalHeight = 0; for (const cache of cachedLines) { const chunks = this._splitLine(null, font, fsize, width, cache); totalHeight += chunks.length * fsize; if (totalHeight &gt; height) { return true; } } return false; }; fontSize = 12; let lineHeight = fontSize * _util.LINE_FACTOR; let numberOfLines = Math.round(height / lineHeight); numberOfLines = Math.max(numberOfLines, lineCount); while (true) { lineHeight = height / numberOfLines; fontSize = roundWithTwoDigits(lineHeight / _util.LINE_FACTOR); if (isTooBig(fontSize)) { numberOfLines++; continue; } break; } } const { fontName, fontColor } = this.data.defaultAppearanceData; this._defaultAppearance = (0, _default_appearance.createDefaultAppearance)({ fontSize, fontName, fontColor }); } return [this._defaultAppearance, fontSize]; } _renderText(text, font, fontSize, totalWidth, alignment, hPadding, vPadding) { let shift; if (alignment === 1) { const width = this._getTextWidth(text, font) * fontSize; shift = (totalWidth - width) / 2; } else if (alignment === 2) { const width = this._getTextWidth(text, font) * fontSize; shift = totalWidth - width - hPadding; } else { shift = hPadding; } shift = (0, _core_utils.numberToString)(shift); vPadding = (0, _core_utils.numberToString)(vPadding); return `${shift} ${vPadding} Td (${(0, _util.escapeString)(text)}) Tj`; } _getSaveFieldResources(xref) { const { localResources, appearanceResources, acroFormResources } = this._fieldResources; const fontName = this.data.defaultAppearanceData &amp;&amp; this.data.defaultAppearanceData.fontName; if (!fontName) { return localResources || _primitives.Dict.empty; } for (const resources of [localResources, appearanceResources]) { if (resources instanceof _primitives.Dict) { const localFont = resources.get(&quot;Font&quot;); if (localFont instanceof _primitives.Dict &amp;&amp; localFont.has(fontName)) { return resources; } } } if (acroFormResources instanceof _primitives.Dict) { const acroFormFont = acroFormResources.get(&quot;Font&quot;); if (acroFormFont instanceof _primitives.Dict &amp;&amp; acroFormFont.has(fontName)) { const subFontDict = new _primitives.Dict(xref); subFontDict.set(fontName, acroFormFont.getRaw(fontName)); const subResourcesDict = new _primitives.Dict(xref); subResourcesDict.set(&quot;Font&quot;, subFontDict); return _primitives.Dict.merge({ xref, dictArray: [subResourcesDict, localResources], mergeSubDicts: true }); } } return localResources || _primitives.Dict.empty; } getFieldObject() { return null; } } class TextWidgetAnnotation extends WidgetAnnotation { constructor(params) { super(params); this._hasText = true; const dict = params.dict; if (typeof this.data.fieldValue !== &quot;string&quot;) { this.data.fieldValue = &quot;&quot;; } let alignment = (0, _core_utils.getInheritableProperty)({ dict, key: &quot;Q&quot; }); if (!Number.isInteger(alignment) || alignment &lt; 0 || alignment &gt; 2) { alignment = null; } this.data.textAlignment = alignment; let maximumLength = (0, _core_utils.getInheritableProperty)({ dict, key: &quot;MaxLen&quot; }); if (!Number.isInteger(maximumLength) || maximumLength &lt; 0) { maximumLength = 0; } this.data.maxLen = maximumLength; this.data.multiLine = this.hasFieldFlag(_util.AnnotationFieldFlag.MULTILINE); this.data.comb = this.hasFieldFlag(_util.AnnotationFieldFlag.COMB) &amp;&amp; !this.hasFieldFlag(_util.AnnotationFieldFlag.MULTILINE) &amp;&amp; !this.hasFieldFlag(_util.AnnotationFieldFlag.PASSWORD) &amp;&amp; !this.hasFieldFlag(_util.AnnotationFieldFlag.FILESELECT) &amp;&amp; this.data.maxLen !== 0; this.data.doNotScroll = this.hasFieldFlag(_util.AnnotationFieldFlag.DONOTSCROLL); } _getCombAppearance(defaultAppearance, font, text, width, hPadding, vPadding, annotationStorage) { const combWidth = (0, _core_utils.numberToString)(width / this.data.maxLen); const buf = []; const positions = font.getCharPositions(text); for (const [start, end] of positions) { buf.push(`(${(0, _util.escapeString)(text.substring(start, end))}) Tj`); } const colors = this.getBorderAndBackgroundAppearances(annotationStorage); const renderedComb = buf.join(` ${combWidth} 0 Td `); return `/Tx BMC q ${colors}BT ` + defaultAppearance + ` 1 0 0 1 ${hPadding} ${vPadding} Tm ${renderedComb}` + &quot; ET Q EMC&quot;; } _getMultilineAppearance(defaultAppearance, text, font, fontSize, width, height, alignment, hPadding, vPadding, annotationStorage) { const lines = text.split(/\\r\\n?|\\n/); const buf = []; const totalWidth = width - 2 * hPadding; for (const line of lines) { const chunks = this._splitLine(line, font, fontSize, totalWidth); for (const chunk of chunks) { const padding = buf.length === 0 ? hPadding : 0; buf.push(this._renderText(chunk, font, fontSize, width, alignment, padding, -fontSize)); } } const renderedText = buf.join(&quot;\\n&quot;); const colors = this.getBorderAndBackgroundAppearances(annotationStorage); return `/Tx BMC q ${colors}BT ` + defaultAppearance + ` 1 0 0 1 0 ${height} Tm ${renderedText}` + &quot; ET Q EMC&quot;; } _splitLine(line, font, fontSize, width, cache = {}) { line = cache.line || font.encodeString(line).join(&quot;&quot;); const glyphs = cache.glyphs || font.charsToGlyphs(line); if (glyphs.length &lt;= 1) { return [line]; } const positions = cache.positions || font.getCharPositions(line); const scale = fontSize / 1000; const chunks = []; let lastSpacePosInStringStart = -1, lastSpacePosInStringEnd = -1, lastSpacePos = -1, startChunk = 0, currentWidth = 0; for (let i = 0, ii = glyphs.length; i &lt; ii; i++) { const [start, end] = positions[i]; const glyph = glyphs[i]; const glyphWidth = glyph.width * scale; if (glyph.unicode === &quot; &quot;) { if (currentWidth + glyphWidth &gt; width) { chunks.push(line.substring(startChunk, start)); startChunk = start; currentWidth = glyphWidth; lastSpacePosInStringStart = -1; lastSpacePos = -1; } else { currentWidth += glyphWidth; lastSpacePosInStringStart = start; lastSpacePosInStringEnd = end; lastSpacePos = i; } } else { if (currentWidth + glyphWidth &gt; width) { if (lastSpacePosInStringStart !== -1) { chunks.push(line.substring(startChunk, lastSpacePosInStringEnd)); startChunk = lastSpacePosInStringEnd; i = lastSpacePos + 1; lastSpacePosInStringStart = -1; currentWidth = 0; } else { chunks.push(line.substring(startChunk, start)); startChunk = start; currentWidth = glyphWidth; } } else { currentWidth += glyphWidth; } } } if (startChunk &lt; line.length) { chunks.push(line.substring(startChunk, line.length)); } return chunks; } getFieldObject() { return { id: this.data.id, value: this.data.fieldValue, defaultValue: this.data.defaultFieldValue || &quot;&quot;, multiline: this.data.multiLine, password: this.hasFieldFlag(_util.AnnotationFieldFlag.PASSWORD), charLimit: this.data.maxLen, comb: this.data.comb, editable: !this.data.readOnly, hidden: this.data.hidden, name: this.data.fieldName, rect: this.data.rect, actions: this.data.actions, page: this.data.pageIndex, strokeColor: this.data.borderColor, fillColor: this.data.backgroundColor, rotation: this.rotation, type: &quot;text&quot; }; } } class ButtonWidgetAnnotation extends WidgetAnnotation { constructor(params) { super(params); this.checkedAppearance = null; this.uncheckedAppearance = null; this.data.checkBox = !this.hasFieldFlag(_util.AnnotationFieldFlag.RADIO) &amp;&amp; !this.hasFieldFlag(_util.AnnotationFieldFlag.PUSHBUTTON); this.data.radioButton = this.hasFieldFlag(_util.AnnotationFieldFlag.RADIO) &amp;&amp; !this.hasFieldFlag(_util.AnnotationFieldFlag.PUSHBUTTON); this.data.pushButton = this.hasFieldFlag(_util.AnnotationFieldFlag.PUSHBUTTON); this.data.isTooltipOnly = false; if (this.data.checkBox) { this._processCheckBox(params); } else if (this.data.radioButton) { this._processRadioButton(params); } else if (this.data.pushButton) { this.data.hasOwnCanvas = true; this._processPushButton(params); } else { (0, _util.warn)(&quot;Invalid field flags for button widget annotation&quot;); } } async getOperatorList(evaluator, task, intent, renderForms, annotationStorage) { if (this.data.pushButton) { return super.getOperatorList(evaluator, task, intent, false, annotationStorage); } let value = null; let rotation = null; if (annotationStorage) { const storageEntry = annotationStorage.get(this.data.id); value = storageEntry ? storageEntry.value : null; rotation = storageEntry ? storageEntry.rotation : null; } if (value === null &amp;&amp; this.appearance) { return super.getOperatorList(evaluator, task, intent, renderForms, annotationStorage); } if (value === null || value === undefined) { if (this.data.checkBox) { value = this.data.fieldValue === this.data.exportValue; } else { value = this.data.fieldValue === this.data.buttonValue; } } const appearance = value ? this.checkedAppearance : this.uncheckedAppearance; if (appearance) { const savedAppearance = this.appearance; const savedMatrix = appearance.dict.getArray(&quot;Matrix&quot;) || _util.IDENTITY_MATRIX; if (rotation) { appearance.dict.set(&quot;Matrix&quot;, this.getRotationMatrix(annotationStorage)); } this.appearance = appearance; const operatorList = super.getOperatorList(evaluator, task, intent, renderForms, annotationStorage); this.appearance = savedAppearance; appearance.dict.set(&quot;Matrix&quot;, savedMatrix); return operatorList; } return { opList: new _operator_list.OperatorList(), separateForm: false, separateCanvas: false }; } async save(evaluator, task, annotationStorage) { if (this.data.checkBox) { return this._saveCheckbox(evaluator, task, annotationStorage); } if (this.data.radioButton) { return this._saveRadioButton(evaluator, task, annotationStorage); } return null; } async _saveCheckbox(evaluator, task, annotationStorage) { if (!annotationStorage) { return null; } const storageEntry = annotationStorage.get(this.data.id); let rotation = storageEntry &amp;&amp; storageEntry.rotation; let value = storageEntry &amp;&amp; storageEntry.value; if (rotation === undefined) { if (value === undefined) { return null; } const defaultValue = this.data.fieldValue === this.data.exportValue; if (defaultValue === value) { return null; } } const dict = evaluator.xref.fetchIfRef(this.ref); if (!(dict instanceof _primitives.Dict)) { return null; } if (rotation === undefined) { rotation = this.rotation; } if (value === undefined) { value = this.data.fieldValue === this.data.exportValue; } const xfa = { path: (0, _util.stringToPDFString)(dict.get(&quot;T&quot;) || &quot;&quot;), value: value ? this.data.exportValue : &quot;&quot; }; const name = _primitives.Name.get(value ? this.data.exportValue : &quot;Off&quot;); dict.set(&quot;V&quot;, name); dict.set(&quot;AS&quot;, name); dict.set(&quot;M&quot;, `D:${(0, _util.getModificationDate)()}`); const maybeMK = this._getMKDict(rotation); if (maybeMK) { dict.set(&quot;MK&quot;, maybeMK); } const encrypt = evaluator.xref.encrypt; let originalTransform = null; if (encrypt) { originalTransform = encrypt.createCipherTransform(this.ref.num, this.ref.gen); } const buffer = [`${this.ref.num} ${this.ref.gen} obj\\n`]; (0, _writer.writeDict)(dict, buffer, originalTransform); buffer.push(&quot;\\nendobj\\n&quot;); return [{ ref: this.ref, data: buffer.join(&quot;&quot;), xfa }]; } async _saveRadioButton(evaluator, task, annotationStorage) { if (!annotationStorage) { return null; } const storageEntry = annotationStorage.get(this.data.id); let rotation = storageEntry &amp;&amp; storageEntry.rotation; let value = storageEntry &amp;&amp; storageEntry.value; if (rotation === undefined) { if (value === undefined) { return null; } const defaultValue = this.data.fieldValue === this.data.buttonValue; if (defaultValue === value) { return null; } } const dict = evaluator.xref.fetchIfRef(this.ref); if (!(dict instanceof _primitives.Dict)) { return null; } if (value === undefined) { value = this.data.fieldValue === this.data.buttonValue; } if (rotation === undefined) { rotation = this.rotation; } const xfa = { path: (0, _util.stringToPDFString)(dict.get(&quot;T&quot;) || &quot;&quot;), value: value ? this.data.buttonValue : &quot;&quot; }; const name = _primitives.Name.get(value ? this.data.buttonValue : &quot;Off&quot;); let parentBuffer = null; const encrypt = evaluator.xref.encrypt; if (value) { if (this.parent instanceof _primitives.Ref) { const parent = evaluator.xref.fetch(this.parent); let parentTransform = null; if (encrypt) { parentTransform = encrypt.createCipherTransform(this.parent.num, this.parent.gen); } parent.set(&quot;V&quot;, name); parentBuffer = [`${this.parent.num} ${this.parent.gen} obj\\n`]; (0, _writer.writeDict)(parent, parentBuffer, parentTransform); parentBuffer.push(&quot;\\nendobj\\n&quot;); } else if (this.parent instanceof _primitives.Dict) { this.parent.set(&quot;V&quot;, name); } } dict.set(&quot;AS&quot;, name); dict.set(&quot;M&quot;, `D:${(0, _util.getModificationDate)()}`); const maybeMK = this._getMKDict(rotation); if (maybeMK) { dict.set(&quot;MK&quot;, maybeMK); } let originalTransform = null; if (encrypt) { originalTransform = encrypt.createCipherTransform(this.ref.num, this.ref.gen); } const buffer = [`${this.ref.num} ${this.ref.gen} obj\\n`]; (0, _writer.writeDict)(dict, buffer, originalTransform); buffer.push(&quot;\\nendobj\\n&quot;); const newRefs = [{ ref: this.ref, data: buffer.join(&quot;&quot;), xfa }]; if (parentBuffer !== null) { newRefs.push({ ref: this.parent, data: parentBuffer.join(&quot;&quot;), xfa: null }); } return newRefs; } _getDefaultCheckedAppearance(params, type) { const width = this.data.rect[2] - this.data.rect[0]; const height = this.data.rect[3] - this.data.rect[1]; const bbox = [0, 0, width, height]; const FONT_RATIO = 0.8; const fontSize = Math.min(width, height) * FONT_RATIO; let metrics, char; if (type === &quot;check&quot;) { metrics = { width: 0.755 * fontSize, height: 0.705 * fontSize }; char = &quot;\\x33&quot;; } else if (type === &quot;disc&quot;) { metrics = { width: 0.791 * fontSize, height: 0.705 * fontSize }; char = &quot;\\x6C&quot;; } else { (0, _util.unreachable)(`_getDefaultCheckedAppearance - unsupported type: ${type}`); } const xShift = (0, _core_utils.numberToString)((width - metrics.width) / 2); const yShift = (0, _core_utils.numberToString)((height - metrics.height) / 2); const appearance = `q BT /PdfJsZaDb ${fontSize} Tf 0 g ${xShift} ${yShift} Td (${char}) Tj ET Q`; const appearanceStreamDict = new _primitives.Dict(params.xref); appearanceStreamDict.set(&quot;FormType&quot;, 1); appearanceStreamDict.set(&quot;Subtype&quot;, _primitives.Name.get(&quot;Form&quot;)); appearanceStreamDict.set(&quot;Type&quot;, _primitives.Name.get(&quot;XObject&quot;)); appearanceStreamDict.set(&quot;BBox&quot;, bbox); appearanceStreamDict.set(&quot;Matrix&quot;, [1, 0, 0, 1, 0, 0]); appearanceStreamDict.set(&quot;Length&quot;, appearance.length); const resources = new _primitives.Dict(params.xref); const font = new _primitives.Dict(params.xref); font.set(&quot;PdfJsZaDb&quot;, this.fallbackFontDict); resources.set(&quot;Font&quot;, font); appearanceStreamDict.set(&quot;Resources&quot;, resources); this.checkedAppearance = new _stream.StringStream(appearance); this.checkedAppearance.dict = appearanceStreamDict; this._streams.push(this.checkedAppearance); } _processCheckBox(params) { const customAppearance = params.dict.get(&quot;AP&quot;); if (!(customAppearance instanceof _primitives.Dict)) { return; } const normalAppearance = customAppearance.get(&quot;N&quot;); if (!(normalAppearance instanceof _primitives.Dict)) { return; } const asValue = this._decodeFormValue(params.dict.get(&quot;AS&quot;)); if (typeof asValue === &quot;string&quot;) { this.data.fieldValue = asValue; } const yes = this.data.fieldValue !== null &amp;&amp; this.data.fieldValue !== &quot;Off&quot; ? this.data.fieldValue : &quot;Yes&quot;; const exportValues = normalAppearance.getKeys(); if (exportValues.length === 0) { exportValues.push(&quot;Off&quot;, yes); } else if (exportValues.length === 1) { if (exportValues[0] === &quot;Off&quot;) { exportValues.push(yes); } else { exportValues.unshift(&quot;Off&quot;); } } else if (exportValues.includes(yes)) { exportValues.length = 0; exportValues.push(&quot;Off&quot;, yes); } else { const otherYes = exportValues.find(v =&gt; v !== &quot;Off&quot;); exportValues.length = 0; exportValues.push(&quot;Off&quot;, otherYes); } if (!exportValues.includes(this.data.fieldValue)) { this.data.fieldValue = &quot;Off&quot;; } this.data.exportValue = exportValues[1]; this.checkedAppearance = normalAppearance.get(this.data.exportValue) || null; this.uncheckedAppearance = normalAppearance.get(&quot;Off&quot;) || null; if (this.checkedAppearance) { this._streams.push(this.checkedAppearance); } else { this._getDefaultCheckedAppearance(params, &quot;check&quot;); } if (this.uncheckedAppearance) { this._streams.push(this.uncheckedAppearance); } this._fallbackFontDict = this.fallbackFontDict; } _processRadioButton(params) { this.data.fieldValue = this.data.buttonValue = null; const fieldParent = params.dict.get(&quot;Parent&quot;); if (fieldParent instanceof _primitives.Dict) { this.parent = params.dict.getRaw(&quot;Parent&quot;); const fieldParentValue = fieldParent.get(&quot;V&quot;); if (fieldParentValue instanceof _primitives.Name) { this.data.fieldValue = this._decodeFormValue(fieldParentValue); } } const appearanceStates = params.dict.get(&quot;AP&quot;); if (!(appearanceStates instanceof _primitives.Dict)) { return; } const normalAppearance = appearanceStates.get(&quot;N&quot;); if (!(normalAppearance instanceof _primitives.Dict)) { return; } for (const key of normalAppearance.getKeys()) { if (key !== &quot;Off&quot;) { this.data.buttonValue = this._decodeFormValue(key); break; } } this.checkedAppearance = normalAppearance.get(this.data.buttonValue) || null; this.uncheckedAppearance = normalAppearance.get(&quot;Off&quot;) || null; if (this.checkedAppearance) { this._streams.push(this.checkedAppearance); } else { this._getDefaultCheckedAppearance(params, &quot;disc&quot;); } if (this.uncheckedAppearance) { this._streams.push(this.uncheckedAppearance); } this._fallbackFontDict = this.fallbackFontDict; } _processPushButton(params) { if (!params.dict.has(&quot;A&quot;) &amp;&amp; !params.dict.has(&quot;AA&quot;) &amp;&amp; !this.data.alternativeText) { (0, _util.warn)(&quot;Push buttons without action dictionaries are not supported&quot;); return; } this.data.isTooltipOnly = !params.dict.has(&quot;A&quot;) &amp;&amp; !params.dict.has(&quot;AA&quot;); _catalog.Catalog.parseDestDictionary({ destDict: params.dict, resultObj: this.data, docBaseUrl: params.pdfManager.docBaseUrl, docAttachments: params.attachments }); } getFieldObject() { let type = &quot;button&quot;; let exportValues; if (this.data.checkBox) { type = &quot;checkbox&quot;; exportValues = this.data.exportValue; } else if (this.data.radioButton) { type = &quot;radiobutton&quot;; exportValues = this.data.buttonValue; } return { id: this.data.id, value: this.data.fieldValue || &quot;Off&quot;, defaultValue: this.data.defaultFieldValue, exportValues, editable: !this.data.readOnly, name: this.data.fieldName, rect: this.data.rect, hidden: this.data.hidden, actions: this.data.actions, page: this.data.pageIndex, strokeColor: this.data.borderColor, fillColor: this.data.backgroundColor, rotation: this.rotation, type }; } get fallbackFontDict() { const dict = new _primitives.Dict(); dict.set(&quot;BaseFont&quot;, _primitives.Name.get(&quot;ZapfDingbats&quot;)); dict.set(&quot;Type&quot;, _primitives.Name.get(&quot;FallbackType&quot;)); dict.set(&quot;Subtype&quot;, _primitives.Name.get(&quot;FallbackType&quot;)); dict.set(&quot;Encoding&quot;, _primitives.Name.get(&quot;ZapfDingbatsEncoding&quot;)); return (0, _util.shadow)(this, &quot;fallbackFontDict&quot;, dict); } } class ChoiceWidgetAnnotation extends WidgetAnnotation { constructor(params) { super(params); this.data.options = []; const options = (0, _core_utils.getInheritableProperty)({ dict: params.dict, key: &quot;Opt&quot; }); if (Array.isArray(options)) { const xref = params.xref; for (let i = 0, ii = options.length; i &lt; ii; i++) { const option = xref.fetchIfRef(options[i]); const isOptionArray = Array.isArray(option); this.data.options[i] = { exportValue: this._decodeFormValue(isOptionArray ? xref.fetchIfRef(option[0]) : option), displayValue: this._decodeFormValue(isOptionArray ? xref.fetchIfRef(option[1]) : option) }; } } if (typeof this.data.fieldValue === &quot;string&quot;) { this.data.fieldValue = [this.data.fieldValue]; } else if (!this.data.fieldValue) { this.data.fieldValue = []; } this.data.combo = this.hasFieldFlag(_util.AnnotationFieldFlag.COMBO); this.data.multiSelect = this.hasFieldFlag(_util.AnnotationFieldFlag.MULTISELECT); this._hasText = true; } getFieldObject() { const type = this.data.combo ? &quot;combobox&quot; : &quot;listbox&quot;; const value = this.data.fieldValue.length &gt; 0 ? this.data.fieldValue[0] : null; return { id: this.data.id, value, defaultValue: this.data.defaultFieldValue, editable: !this.data.readOnly, name: this.data.fieldName, rect: this.data.rect, numItems: this.data.fieldValue.length, multipleSelection: this.data.multiSelect, hidden: this.data.hidden, actions: this.data.actions, items: this.data.options, page: this.data.pageIndex, strokeColor: this.data.borderColor, fillColor: this.data.backgroundColor, rotation: this.rotation, type }; } async _getAppearance(evaluator, task, annotationStorage) { if (this.data.combo) { return super._getAppearance(evaluator, task, annotationStorage); } if (!annotationStorage) { return null; } const storageEntry = annotationStorage.get(this.data.id); if (!storageEntry) { return null; } const rotation = storageEntry.rotation; let exportedValue = storageEntry.value; if (rotation === undefined &amp;&amp; exportedValue === undefined) { return null; } if (exportedValue === undefined) { exportedValue = this.data.fieldValue; } else if (!Array.isArray(exportedValue)) { exportedValue = [exportedValue]; } const defaultPadding = 2; const hPadding = defaultPadding; let totalHeight = this.data.rect[3] - this.data.rect[1]; let totalWidth = this.data.rect[2] - this.data.rect[0]; if (rotation === 90 || rotation === 270) { [totalWidth, totalHeight] = [totalHeight, totalWidth]; } const lineCount = this.data.options.length; const valueIndices = []; for (let i = 0; i &lt; lineCount; i++) { const { exportValue } = this.data.options[i]; if (exportedValue.includes(exportValue)) { valueIndices.push(i); } } if (!this._defaultAppearance) { this.data.defaultAppearanceData = (0, _default_appearance.parseDefaultAppearance)(this._defaultAppearance = &quot;/Helvetica 0 Tf 0 g&quot;); } const font = await WidgetAnnotation._getFontData(evaluator, task, this.data.defaultAppearanceData, this._fieldResources.mergedResources); let defaultAppearance; let { fontSize } = this.data.defaultAppearanceData; if (!fontSize) { const lineHeight = (totalHeight - defaultPadding) / lineCount; let lineWidth = -1; let value; for (const { displayValue } of this.data.options) { const width = this._getTextWidth(displayValue, font); if (width &gt; lineWidth) { lineWidth = width; value = displayValue; } } [defaultAppearance, fontSize] = this._computeFontSize(lineHeight, totalWidth - 2 * hPadding, value, font, -1); } else { defaultAppearance = this._defaultAppearance; } const lineHeight = fontSize * _util.LINE_FACTOR; const vPadding = (lineHeight - fontSize) / 2; const numberOfVisibleLines = Math.floor(totalHeight / lineHeight); let firstIndex; if (valueIndices.length === 1) { const valuePosition = valueIndices[0]; const indexInPage = valuePosition % numberOfVisibleLines; firstIndex = valuePosition - indexInPage; } else { firstIndex = valueIndices.length ? valueIndices[0] : 0; } const end = Math.min(firstIndex + numberOfVisibleLines + 1, lineCount); const buf = [&quot;/Tx BMC q&quot;, `1 1 ${totalWidth} ${totalHeight} re W n`]; if (valueIndices.length) { buf.push(&quot;0.600006 0.756866 0.854904 rg&quot;); for (const index of valueIndices) { if (firstIndex &lt;= index &amp;&amp; index &lt; end) { buf.push(`1 ${totalHeight - (index - firstIndex + 1) * lineHeight} ${totalWidth} ${lineHeight} re f`); } } } buf.push(&quot;BT&quot;, defaultAppearance, `1 0 0 1 0 ${totalHeight} Tm`); for (let i = firstIndex; i &lt; end; i++) { const { displayValue } = this.data.options[i]; const hpadding = i === firstIndex ? hPadding : 0; const vpadding = i === firstIndex ? vPadding : 0; buf.push(this._renderText(displayValue, font, fontSize, totalWidth, 0, hpadding, -lineHeight + vpadding)); } buf.push(&quot;ET Q EMC&quot;); return buf.join(&quot;\\n&quot;); } } class SignatureWidgetAnnotation extends WidgetAnnotation { constructor(params) { super(params); this.data.fieldValue = null; } getFieldObject() { return { id: this.data.id, value: null, page: this.data.pageIndex, type: &quot;signature&quot; }; } } class TextAnnotation extends MarkupAnnotation { constructor(parameters) { const DEFAULT_ICON_SIZE = 22; super(parameters); const dict = parameters.dict; this.data.annotationType = _util.AnnotationType.TEXT; if (this.data.hasAppearance) { this.data.name = &quot;NoIcon&quot;; } else { this.data.rect[1] = this.data.rect[3] - DEFAULT_ICON_SIZE; this.data.rect[2] = this.data.rect[0] + DEFAULT_ICON_SIZE; this.data.name = dict.has(&quot;Name&quot;) ? dict.get(&quot;Name&quot;).name : &quot;Note&quot;; } if (dict.has(&quot;State&quot;)) { this.data.state = dict.get(&quot;State&quot;) || null; this.data.stateModel = dict.get(&quot;StateModel&quot;) || null; } else { this.data.state = null; this.data.stateModel = null; } } } class LinkAnnotation extends Annotation { constructor(params) { super(params); this.data.annotationType = _util.AnnotationType.LINK; const quadPoints = getQuadPoints(params.dict, this.rectangle); if (quadPoints) { this.data.quadPoints = quadPoints; } this.data.borderColor = this.data.borderColor || this.data.color; _catalog.Catalog.parseDestDictionary({ destDict: params.dict, resultObj: this.data, docBaseUrl: params.pdfManager.docBaseUrl, docAttachments: params.attachments }); } } class PopupAnnotation extends Annotation { constructor(parameters) { super(parameters); this.data.annotationType = _util.AnnotationType.POPUP; let parentItem = parameters.dict.get(&quot;Parent&quot;); if (!parentItem) { (0, _util.warn)(&quot;Popup annotation has a missing or invalid parent annotation.&quot;); return; } const parentSubtype = parentItem.get(&quot;Subtype&quot;); this.data.parentType = parentSubtype instanceof _primitives.Name ? parentSubtype.name : null; const rawParent = parameters.dict.getRaw(&quot;Parent&quot;); this.data.parentId = rawParent instanceof _primitives.Ref ? rawParent.toString() : null; const parentRect = parentItem.getArray(&quot;Rect&quot;); if (Array.isArray(parentRect) &amp;&amp; parentRect.length === 4) { this.data.parentRect = _util.Util.normalizeRect(parentRect); } else { this.data.parentRect = [0, 0, 0, 0]; } const rt = parentItem.get(&quot;RT&quot;); if ((0, _primitives.isName)(rt, _util.AnnotationReplyType.GROUP)) { parentItem = parentItem.get(&quot;IRT&quot;); } if (!parentItem.has(&quot;M&quot;)) { this.data.modificationDate = null; } else { this.setModificationDate(parentItem.get(&quot;M&quot;)); this.data.modificationDate = this.modificationDate; } if (!parentItem.has(&quot;C&quot;)) { this.data.color = null; } else { this.setColor(parentItem.getArray(&quot;C&quot;)); this.data.color = this.color; } if (!this.viewable) { const parentFlags = parentItem.get(&quot;F&quot;); if (this._isViewable(parentFlags)) { this.setFlags(parentFlags); } } this.setTitle(parentItem.get(&quot;T&quot;)); this.data.titleObj = this._title; this.setContents(parentItem.get(&quot;Contents&quot;)); this.data.contentsObj = this._contents; if (parentItem.has(&quot;RC&quot;)) { this.data.richText = _factory.XFAFactory.getRichTextAsHtml(parentItem.get(&quot;RC&quot;)); } } } exports.PopupAnnotation = PopupAnnotation; class FreeTextAnnotation extends MarkupAnnotation { constructor(parameters) { super(parameters); this.data.annotationType = _util.AnnotationType.FREETEXT; } get hasTextContent() { return !!this.appearance; } static createNewDict(annotation, xref, { apRef, ap }) { const { color, fontSize, rect, rotation, user, value } = annotation; const freetext = new _primitives.Dict(xref); freetext.set(&quot;Type&quot;, _primitives.Name.get(&quot;Annot&quot;)); freetext.set(&quot;Subtype&quot;, _primitives.Name.get(&quot;FreeText&quot;)); freetext.set(&quot;CreationDate&quot;, `D:${(0, _util.getModificationDate)()}`); freetext.set(&quot;Rect&quot;, rect); const da = `/Helv ${fontSize} Tf ${(0, _default_appearance.getPdfColor)(color, true)}`; freetext.set(&quot;DA&quot;, da); freetext.set(&quot;Contents&quot;, value); freetext.set(&quot;F&quot;, 4); freetext.set(&quot;Border&quot;, [0, 0, 0]); freetext.set(&quot;Rotate&quot;, rotation); if (user) { freetext.set(&quot;T&quot;, (0, _util.stringToUTF8String)(user)); } const n = new _primitives.Dict(xref); freetext.set(&quot;AP&quot;, n); if (apRef) { n.set(&quot;N&quot;, apRef); } else { n.set(&quot;N&quot;, ap); } return freetext; } static async createNewAppearanceStream(annotation, xref, params) { const { baseFontRef, evaluator, task } = params; const { color, fontSize, rect, rotation, value } = annotation; const resources = new _primitives.Dict(xref); const font = new _primitives.Dict(xref); if (baseFontRef) { font.set(&quot;Helv&quot;, baseFontRef); } else { const baseFont = new _primitives.Dict(xref); baseFont.set(&quot;BaseFont&quot;, _primitives.Name.get(&quot;Helvetica&quot;)); baseFont.set(&quot;Type&quot;, _primitives.Name.get(&quot;Font&quot;)); baseFont.set(&quot;Subtype&quot;, _primitives.Name.get(&quot;Type1&quot;)); baseFont.set(&quot;Encoding&quot;, _primitives.Name.get(&quot;WinAnsiEncoding&quot;)); font.set(&quot;Helv&quot;, baseFont); } resources.set(&quot;Font&quot;, font); const helv = await WidgetAnnotation._getFontData(evaluator, task, { fontName: &quot;Helvetica&quot;, fontSize }, resources); const [x1, y1, x2, y2] = rect; let w = x2 - x1; let h = y2 - y1; if (rotation % 180 !== 0) { [w, h] = [h, w]; } const lines = value.split(&quot;\\n&quot;); const scale = fontSize / 1000; let totalWidth = -Infinity; const encodedLines = []; for (let line of lines) { line = helv.encodeString(line).join(&quot;&quot;); encodedLines.push(line); let lineWidth = 0; const glyphs = helv.charsToGlyphs(line); for (const glyph of glyphs) { lineWidth += glyph.width * scale; } totalWidth = Math.max(totalWidth, lineWidth); } let hscale = 1; if (totalWidth &gt; w) { hscale = w / totalWidth; } let vscale = 1; const lineHeight = _util.LINE_FACTOR * fontSize; const lineDescent = _util.LINE_DESCENT_FACTOR * fontSize; const totalHeight = lineHeight * lines.length; if (totalHeight &gt; h) { vscale = h / totalHeight; } const fscale = Math.min(hscale, vscale); const newFontSize = fontSize * fscale; const buffer = [&quot;q&quot;, `0 0 ${(0, _core_utils.numberToString)(w)} ${(0, _core_utils.numberToString)(h)} re W n`, `BT`, `1 0 0 1 0 ${(0, _core_utils.numberToString)(h + lineDescent)} Tm 0 Tc ${(0, _default_appearance.getPdfColor)(color, true)}`, `/Helv ${(0, _core_utils.numberToString)(newFontSize)} Tf`]; const vShift = (0, _core_utils.numberToString)(lineHeight); for (const line of encodedLines) { buffer.push(`0 -${vShift} Td (${(0, _util.escapeString)(line)}) Tj`); } buffer.push(&quot;ET&quot;, &quot;Q&quot;); const appearance = buffer.join(&quot;\\n&quot;); const appearanceStreamDict = new _primitives.Dict(xref); appearanceStreamDict.set(&quot;FormType&quot;, 1); appearanceStreamDict.set(&quot;Subtype&quot;, _primitives.Name.get(&quot;Form&quot;)); appearanceStreamDict.set(&quot;Type&quot;, _primitives.Name.get(&quot;XObject&quot;)); appearanceStreamDict.set(&quot;BBox&quot;, [0, 0, w, h]); appearanceStreamDict.set(&quot;Length&quot;, appearance.length); appearanceStreamDict.set(&quot;Resources&quot;, resources); if (rotation) { const matrix = WidgetAnnotation._getRotationMatrix(rotation, w, h); appearanceStreamDict.set(&quot;Matrix&quot;, matrix); } const ap = new _stream.StringStream(appearance); ap.dict = appearanceStreamDict; return ap; } } class LineAnnotation extends MarkupAnnotation { constructor(parameters) { super(parameters); const { dict } = parameters; this.data.annotationType = _util.AnnotationType.LINE; const lineCoordinates = dict.getArray(&quot;L&quot;); this.data.lineCoordinates = _util.Util.normalizeRect(lineCoordinates); this.setLineEndings(dict.getArray(&quot;LE&quot;)); this.data.lineEndings = this.lineEndings; if (!this.appearance) { const strokeColor = this.color ? Array.from(this.color).map(c =&gt; c / 255) : [0, 0, 0]; const strokeAlpha = dict.get(&quot;CA&quot;); let fillColor = null, interiorColor = dict.getArray(&quot;IC&quot;); if (interiorColor) { interiorColor = getRgbColor(interiorColor, null); fillColor = interiorColor ? Array.from(interiorColor).map(c =&gt; c / 255) : null; } const fillAlpha = fillColor ? strokeAlpha : null; const borderWidth = this.borderStyle.width || 1, borderAdjust = 2 * borderWidth; const bbox = [this.data.lineCoordinates[0] - borderAdjust, this.data.lineCoordinates[1] - borderAdjust, this.data.lineCoordinates[2] + borderAdjust, this.data.lineCoordinates[3] + borderAdjust]; if (!_util.Util.intersect(this.rectangle, bbox)) { this.rectangle = bbox; } this._setDefaultAppearance({ xref: parameters.xref, extra: `${borderWidth} w`, strokeColor, fillColor, strokeAlpha, fillAlpha, pointsCallback: (buffer, points) =&gt; { buffer.push(`${lineCoordinates[0]} ${lineCoordinates[1]} m`, `${lineCoordinates[2]} ${lineCoordinates[3]} l`, &quot;S&quot;); return [points[0].x - borderWidth, points[1].x + borderWidth, points[3].y - borderWidth, points[1].y + borderWidth]; } }); } } } class SquareAnnotation extends MarkupAnnotation { constructor(parameters) { super(parameters); this.data.annotationType = _util.AnnotationType.SQUARE; if (!this.appearance) { const strokeColor = this.color ? Array.from(this.color).map(c =&gt; c / 255) : [0, 0, 0]; const strokeAlpha = parameters.dict.get(&quot;CA&quot;); let fillColor = null, interiorColor = parameters.dict.getArray(&quot;IC&quot;); if (interiorColor) { interiorColor = getRgbColor(interiorColor, null); fillColor = interiorColor ? Array.from(interiorColor).map(c =&gt; c / 255) : null; } const fillAlpha = fillColor ? strokeAlpha : null; if (this.borderStyle.width === 0 &amp;&amp; !fillColor) { return; } this._setDefaultAppearance({ xref: parameters.xref, extra: `${this.borderStyle.width} w`, strokeColor, fillColor, strokeAlpha, fillAlpha, pointsCallback: (buffer, points) =&gt; { const x = points[2].x + this.borderStyle.width / 2; const y = points[2].y + this.borderStyle.width / 2; const width = points[3].x - points[2].x - this.borderStyle.width; const height = points[1].y - points[3].y - this.borderStyle.width; buffer.push(`${x} ${y} ${width} ${height} re`); if (fillColor) { buffer.push(&quot;B&quot;); } else { buffer.push(&quot;S&quot;); } return [points[0].x, points[1].x, points[3].y, points[1].y]; } }); } } } class CircleAnnotation extends MarkupAnnotation { constructor(parameters) { super(parameters); this.data.annotationType = _util.AnnotationType.CIRCLE; if (!this.appearance) { const strokeColor = this.color ? Array.from(this.color).map(c =&gt; c / 255) : [0, 0, 0]; const strokeAlpha = parameters.dict.get(&quot;CA&quot;); let fillColor = null; let interiorColor = parameters.dict.getArray(&quot;IC&quot;); if (interiorColor) { interiorColor = getRgbColor(interiorColor, null); fillColor = interiorColor ? Array.from(interiorColor).map(c =&gt; c / 255) : null; } const fillAlpha = fillColor ? strokeAlpha : null; if (this.borderStyle.width === 0 &amp;&amp; !fillColor) { return; } const controlPointsDistance = 4 / 3 * Math.tan(Math.PI / (2 * 4)); this._setDefaultAppearance({ xref: parameters.xref, extra: `${this.borderStyle.width} w`, strokeColor, fillColor, strokeAlpha, fillAlpha, pointsCallback: (buffer, points) =&gt; { const x0 = points[0].x + this.borderStyle.width / 2; const y0 = points[0].y - this.borderStyle.width / 2; const x1 = points[3].x - this.borderStyle.width / 2; const y1 = points[3].y + this.borderStyle.width / 2; const xMid = x0 + (x1 - x0) / 2; const yMid = y0 + (y1 - y0) / 2; const xOffset = (x1 - x0) / 2 * controlPointsDistance; const yOffset = (y1 - y0) / 2 * controlPointsDistance; buffer.push(`${xMid} ${y1} m`, `${xMid + xOffset} ${y1} ${x1} ${yMid + yOffset} ${x1} ${yMid} c`, `${x1} ${yMid - yOffset} ${xMid + xOffset} ${y0} ${xMid} ${y0} c`, `${xMid - xOffset} ${y0} ${x0} ${yMid - yOffset} ${x0} ${yMid} c`, `${x0} ${yMid + yOffset} ${xMid - xOffset} ${y1} ${xMid} ${y1} c`, &quot;h&quot;); if (fillColor) { buffer.push(&quot;B&quot;); } else { buffer.push(&quot;S&quot;); } return [points[0].x, points[1].x, points[3].y, points[1].y]; } }); } } } class PolylineAnnotation extends MarkupAnnotation { constructor(parameters) { super(parameters); const { dict } = parameters; this.data.annotationType = _util.AnnotationType.POLYLINE; this.data.vertices = []; if (!(this instanceof PolygonAnnotation)) { this.setLineEndings(dict.getArray(&quot;LE&quot;)); this.data.lineEndings = this.lineEndings; } const rawVertices = dict.getArray(&quot;Vertices&quot;); if (!Array.isArray(rawVertices)) { return; } for (let i = 0, ii = rawVertices.length; i &lt; ii; i += 2) { this.data.vertices.push({ x: rawVertices[i], y: rawVertices[i + 1] }); } if (!this.appearance) { const strokeColor = this.color ? Array.from(this.color).map(c =&gt; c / 255) : [0, 0, 0]; const strokeAlpha = dict.get(&quot;CA&quot;); const borderWidth = this.borderStyle.width || 1, borderAdjust = 2 * borderWidth; const bbox = [Infinity, Infinity, -Infinity, -Infinity]; for (const vertex of this.data.vertices) { bbox[0] = Math.min(bbox[0], vertex.x - borderAdjust); bbox[1] = Math.min(bbox[1], vertex.y - borderAdjust); bbox[2] = Math.max(bbox[2], vertex.x + borderAdjust); bbox[3] = Math.max(bbox[3], vertex.y + borderAdjust); } if (!_util.Util.intersect(this.rectangle, bbox)) { this.rectangle = bbox; } this._setDefaultAppearance({ xref: parameters.xref, extra: `${borderWidth} w`, strokeColor, strokeAlpha, pointsCallback: (buffer, points) =&gt; { const vertices = this.data.vertices; for (let i = 0, ii = vertices.length; i &lt; ii; i++) { buffer.push(`${vertices[i].x} ${vertices[i].y} ${i === 0 ? &quot;m&quot; : &quot;l&quot;}`); } buffer.push(&quot;S&quot;); return [points[0].x, points[1].x, points[3].y, points[1].y]; } }); } } } class PolygonAnnotation extends PolylineAnnotation { constructor(parameters) { super(parameters); this.data.annotationType = _util.AnnotationType.POLYGON; } } class CaretAnnotation extends MarkupAnnotation { constructor(parameters) { super(parameters); this.data.annotationType = _util.AnnotationType.CARET; } } class InkAnnotation extends MarkupAnnotation { constructor(parameters) { super(parameters); this.data.annotationType = _util.AnnotationType.INK; this.data.inkLists = []; const rawInkLists = parameters.dict.getArray(&quot;InkList&quot;); if (!Array.isArray(rawInkLists)) { return; } const xref = parameters.xref; for (let i = 0, ii = rawInkLists.length; i &lt; ii; ++i) { this.data.inkLists.push([]); for (let j = 0, jj = rawInkLists[i].length; j &lt; jj; j += 2) { this.data.inkLists[i].push({ x: xref.fetchIfRef(rawInkLists[i][j]), y: xref.fetchIfRef(rawInkLists[i][j + 1]) }); } } if (!this.appearance) { const strokeColor = this.color ? Array.from(this.color).map(c =&gt; c / 255) : [0, 0, 0]; const strokeAlpha = parameters.dict.get(&quot;CA&quot;); const borderWidth = this.borderStyle.width || 1, borderAdjust = 2 * borderWidth; const bbox = [Infinity, Infinity, -Infinity, -Infinity]; for (const inkLists of this.data.inkLists) { for (const vertex of inkLists) { bbox[0] = Math.min(bbox[0], vertex.x - borderAdjust); bbox[1] = Math.min(bbox[1], vertex.y - borderAdjust); bbox[2] = Math.max(bbox[2], vertex.x + borderAdjust); bbox[3] = Math.max(bbox[3], vertex.y + borderAdjust); } } if (!_util.Util.intersect(this.rectangle, bbox)) { this.rectangle = bbox; } this._setDefaultAppearance({ xref: parameters.xref, extra: `${borderWidth} w`, strokeColor, strokeAlpha, pointsCallback: (buffer, points) =&gt; { for (const inkList of this.data.inkLists) { for (let i = 0, ii = inkList.length; i &lt; ii; i++) { buffer.push(`${inkList[i].x} ${inkList[i].y} ${i === 0 ? &quot;m&quot; : &quot;l&quot;}`); } buffer.push(&quot;S&quot;); } return [points[0].x, points[1].x, points[3].y, points[1].y]; } }); } } static createNewDict(annotation, xref, { apRef, ap }) { const { paths, rect, rotation } = annotation; const ink = new _primitives.Dict(xref); ink.set(&quot;Type&quot;, _primitives.Name.get(&quot;Annot&quot;)); ink.set(&quot;Subtype&quot;, _primitives.Name.get(&quot;Ink&quot;)); ink.set(&quot;CreationDate&quot;, `D:${(0, _util.getModificationDate)()}`); ink.set(&quot;Rect&quot;, rect); ink.set(&quot;InkList&quot;, paths.map(p =&gt; p.points)); ink.set(&quot;F&quot;, 4); ink.set(&quot;Border&quot;, [0, 0, 0]); ink.set(&quot;Rotate&quot;, rotation); const n = new _primitives.Dict(xref); ink.set(&quot;AP&quot;, n); if (apRef) { n.set(&quot;N&quot;, apRef); } else { n.set(&quot;N&quot;, ap); } return ink; } static async createNewAppearanceStream(annotation, xref, params) { const { color, rect, rotation, paths, thickness, opacity } = annotation; const [x1, y1, x2, y2] = rect; let w = x2 - x1; let h = y2 - y1; if (rotation % 180 !== 0) { [w, h] = [h, w]; } const appearanceBuffer = [`${thickness} w 1 J 1 j`, `${(0, _default_appearance.getPdfColor)(color, false)}`]; if (opacity !== 1) { appearanceBuffer.push(&quot;/R0 gs&quot;); } const buffer = []; for (const { bezier } of paths) { buffer.length = 0; buffer.push(`${(0, _core_utils.numberToString)(bezier[0])} ${(0, _core_utils.numberToString)(bezier[1])} m`); for (let i = 2, ii = bezier.length; i &lt; ii; i += 6) { const curve = bezier.slice(i, i + 6).map(_core_utils.numberToString).join(&quot; &quot;); buffer.push(`${curve} c`); } buffer.push(&quot;S&quot;); appearanceBuffer.push(buffer.join(&quot;\\n&quot;)); } const appearance = appearanceBuffer.join(&quot;\\n&quot;); const appearanceStreamDict = new _primitives.Dict(xref); appearanceStreamDict.set(&quot;FormType&quot;, 1); appearanceStreamDict.set(&quot;Subtype&quot;, _primitives.Name.get(&quot;Form&quot;)); appearanceStreamDict.set(&quot;Type&quot;, _primitives.Name.get(&quot;XObject&quot;)); appearanceStreamDict.set(&quot;BBox&quot;, [0, 0, w, h]); appearanceStreamDict.set(&quot;Length&quot;, appearance.length); if (rotation) { const matrix = WidgetAnnotation._getRotationMatrix(rotation, w, h); appearanceStreamDict.set(&quot;Matrix&quot;, matrix); } if (opacity !== 1) { const resources = new _primitives.Dict(xref); const extGState = new _primitives.Dict(xref); const r0 = new _primitives.Dict(xref); r0.set(&quot;CA&quot;, opacity); r0.set(&quot;Type&quot;, _primitives.Name.get(&quot;ExtGState&quot;)); extGState.set(&quot;R0&quot;, r0); resources.set(&quot;ExtGState&quot;, extGState); appearanceStreamDict.set(&quot;Resources&quot;, resources); } const ap = new _stream.StringStream(appearance); ap.dict = appearanceStreamDict; return ap; } } class HighlightAnnotation extends MarkupAnnotation { constructor(parameters) { super(parameters); this.data.annotationType = _util.AnnotationType.HIGHLIGHT; const quadPoints = this.data.quadPoints = getQuadPoints(parameters.dict, null); if (quadPoints) { const resources = this.appearance &amp;&amp; this.appearance.dict.get(&quot;Resources&quot;); if (!this.appearance || !(resources &amp;&amp; resources.has(&quot;ExtGState&quot;))) { if (this.appearance) { (0, _util.warn)(&quot;HighlightAnnotation - ignoring built-in appearance stream.&quot;); } const fillColor = this.color ? Array.from(this.color).map(c =&gt; c / 255) : [1, 1, 0]; const fillAlpha = parameters.dict.get(&quot;CA&quot;); this._setDefaultAppearance({ xref: parameters.xref, fillColor, blendMode: &quot;Multiply&quot;, fillAlpha, pointsCallback: (buffer, points) =&gt; { buffer.push(`${points[0].x} ${points[0].y} m`, `${points[1].x} ${points[1].y} l`, `${points[3].x} ${points[3].y} l`, `${points[2].x} ${points[2].y} l`, &quot;f&quot;); return [points[0].x, points[1].x, points[3].y, points[1].y]; } }); } } else { this.data.hasPopup = false; } } } class UnderlineAnnotation extends MarkupAnnotation { constructor(parameters) { super(parameters); this.data.annotationType = _util.AnnotationType.UNDERLINE; const quadPoints = this.data.quadPoints = getQuadPoints(parameters.dict, null); if (quadPoints) { if (!this.appearance) { const strokeColor = this.color ? Array.from(this.color).map(c =&gt; c / 255) : [0, 0, 0]; const strokeAlpha = parameters.dict.get(&quot;CA&quot;); this._setDefaultAppearance({ xref: parameters.xref, extra: &quot;[] 0 d 1 w&quot;, strokeColor, strokeAlpha, pointsCallback: (buffer, points) =&gt; { buffer.push(`${points[2].x} ${points[2].y} m`, `${points[3].x} ${points[3].y} l`, &quot;S&quot;); return [points[0].x, points[1].x, points[3].y, points[1].y]; } }); } } else { this.data.hasPopup = false; } } } class SquigglyAnnotation extends MarkupAnnotation { constructor(parameters) { super(parameters); this.data.annotationType = _util.AnnotationType.SQUIGGLY; const quadPoints = this.data.quadPoints = getQuadPoints(parameters.dict, null); if (quadPoints) { if (!this.appearance) { const strokeColor = this.color ? Array.from(this.color).map(c =&gt; c / 255) : [0, 0, 0]; const strokeAlpha = parameters.dict.get(&quot;CA&quot;); this._setDefaultAppearance({ xref: parameters.xref, extra: &quot;[] 0 d 1 w&quot;, strokeColor, strokeAlpha, pointsCallback: (buffer, points) =&gt; { const dy = (points[0].y - points[2].y) / 6; let shift = dy; let x = points[2].x; const y = points[2].y; const xEnd = points[3].x; buffer.push(`${x} ${y + shift} m`); do { x += 2; shift = shift === 0 ? dy : 0; buffer.push(`${x} ${y + shift} l`); } while (x &lt; xEnd); buffer.push(&quot;S&quot;); return [points[2].x, xEnd, y - 2 * dy, y + 2 * dy]; } }); } } else { this.data.hasPopup = false; } } } class StrikeOutAnnotation extends MarkupAnnotation { constructor(parameters) { super(parameters); this.data.annotationType = _util.AnnotationType.STRIKEOUT; const quadPoints = this.data.quadPoints = getQuadPoints(parameters.dict, null); if (quadPoints) { if (!this.appearance) { const strokeColor = this.color ? Array.from(this.color).map(c =&gt; c / 255) : [0, 0, 0]; const strokeAlpha = parameters.dict.get(&quot;CA&quot;); this._setDefaultAppearance({ xref: parameters.xref, extra: &quot;[] 0 d 1 w&quot;, strokeColor, strokeAlpha, pointsCallback: (buffer, points) =&gt; { buffer.push(`${(points[0].x + points[2].x) / 2} ` + `${(points[0].y + points[2].y) / 2} m`, `${(points[1].x + points[3].x) / 2} ` + `${(points[1].y + points[3].y) / 2} l`, &quot;S&quot;); return [points[0].x, points[1].x, points[3].y, points[1].y]; } }); } } else { this.data.hasPopup = false; } } } class StampAnnotation extends MarkupAnnotation { constructor(parameters) { super(parameters); this.data.annotationType = _util.AnnotationType.STAMP; } } class FileAttachmentAnnotation extends MarkupAnnotation { constructor(parameters) { super(parameters); const file = new _file_spec.FileSpec(parameters.dict.get(&quot;FS&quot;), parameters.xref); this.data.annotationType = _util.AnnotationType.FILEATTACHMENT; this.data.file = file.serializable; } } /***/ }), /* 11 */ /***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) =&gt; { Object.defineProperty(exports, &quot;__esModule&quot;, ({ value: true })); exports.createDefaultAppearance = createDefaultAppearance; exports.getPdfColor = getPdfColor; exports.parseDefaultAppearance = parseDefaultAppearance; var _core_utils = __w_pdfjs_require__(4); var _util = __w_pdfjs_require__(2); var _colorspace = __w_pdfjs_require__(12); var _evaluator = __w_pdfjs_require__(13); var _primitives = __w_pdfjs_require__(3); var _stream = __w_pdfjs_require__(8); class DefaultAppearanceEvaluator extends _evaluator.EvaluatorPreprocessor { constructor(str) { super(new _stream.StringStream(str)); } parse() { const operation = { fn: 0, args: [] }; const result = { fontSize: 0, fontName: &quot;&quot;, fontColor: new Uint8ClampedArray(3) }; try { while (true) { operation.args.length = 0; if (!this.read(operation)) { break; } if (this.savedStatesDepth !== 0) { continue; } const { fn, args } = operation; switch (fn | 0) { case _util.OPS.setFont: const [fontName, fontSize] = args; if (fontName instanceof _primitives.Name) { result.fontName = fontName.name; } if (typeof fontSize === &quot;number&quot; &amp;&amp; fontSize &gt; 0) { result.fontSize = fontSize; } break; case _util.OPS.setFillRGBColor: _colorspace.ColorSpace.singletons.rgb.getRgbItem(args, 0, result.fontColor, 0); break; case _util.OPS.setFillGray: _colorspace.ColorSpace.singletons.gray.getRgbItem(args, 0, result.fontColor, 0); break; case _util.OPS.setFillColorSpace: _colorspace.ColorSpace.singletons.cmyk.getRgbItem(args, 0, result.fontColor, 0); break; } } } catch (reason) { (0, _util.warn)(`parseDefaultAppearance - ignoring errors: &quot;${reason}&quot;.`); } return result; } } function parseDefaultAppearance(str) { return new DefaultAppearanceEvaluator(str).parse(); } function getPdfColor(color, isFill) { if (color[0] === color[1] &amp;&amp; color[1] === color[2]) { const gray = color[0] / 255; return `${(0, _core_utils.numberToString)(gray)} ${isFill ? &quot;g&quot; : &quot;G&quot;}`; } return Array.from(color).map(c =&gt; (0, _core_utils.numberToString)(c / 255)).join(&quot; &quot;) + ` ${isFill ? &quot;rg&quot; : &quot;RG&quot;}`; } function createDefaultAppearance({ fontSize, fontName, fontColor }) { return `/${(0, _core_utils.escapePDFName)(fontName)} ${fontSize} Tf ${getPdfColor(fontColor, true)}`; } /***/ }), /* 12 */ /***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) =&gt; { Object.defineProperty(exports, &quot;__esModule&quot;, ({ value: true })); exports.ColorSpace = void 0; var _util = __w_pdfjs_require__(2); var _primitives = __w_pdfjs_require__(3); var _base_stream = __w_pdfjs_require__(5); var _core_utils = __w_pdfjs_require__(4); function resizeRgbImage(src, dest, w1, h1, w2, h2, alpha01) { const COMPONENTS = 3; alpha01 = alpha01 !== 1 ? 0 : alpha01; const xRatio = w1 / w2; const yRatio = h1 / h2; let newIndex = 0, oldIndex; const xScaled = new Uint16Array(w2); const w1Scanline = w1 * COMPONENTS; for (let i = 0; i &lt; w2; i++) { xScaled[i] = Math.floor(i * xRatio) * COMPONENTS; } for (let i = 0; i &lt; h2; i++) { const py = Math.floor(i * yRatio) * w1Scanline; for (let j = 0; j &lt; w2; j++) { oldIndex = py + xScaled[j]; dest[newIndex++] = src[oldIndex++]; dest[newIndex++] = src[oldIndex++]; dest[newIndex++] = src[oldIndex++]; newIndex += alpha01; } } } class ColorSpace { constructor(name, numComps) { if (this.constructor === ColorSpace) { (0, _util.unreachable)(&quot;Cannot initialize ColorSpace.&quot;); } this.name = name; this.numComps = numComps; } getRgb(src, srcOffset) { const rgb = new Uint8ClampedArray(3); this.getRgbItem(src, srcOffset, rgb, 0); return rgb; } getRgbItem(src, srcOffset, dest, destOffset) { (0, _util.unreachable)(&quot;Should not call ColorSpace.getRgbItem&quot;); } getRgbBuffer(src, srcOffset, count, dest, destOffset, bits, alpha01) { (0, _util.unreachable)(&quot;Should not call ColorSpace.getRgbBuffer&quot;); } getOutputLength(inputLength, alpha01) { (0, _util.unreachable)(&quot;Should not call ColorSpace.getOutputLength&quot;); } isPassthrough(bits) { return false; } isDefaultDecode(decodeMap, bpc) { return ColorSpace.isDefaultDecode(decodeMap, this.numComps); } fillRgb(dest, originalWidth, originalHeight, width, height, actualHeight, bpc, comps, alpha01) { const count = originalWidth * originalHeight; let rgbBuf = null; const numComponentColors = 1 &lt;&lt; bpc; const needsResizing = originalHeight !== height || originalWidth !== width; if (this.isPassthrough(bpc)) { rgbBuf = comps; } else if (this.numComps === 1 &amp;&amp; count &gt; numComponentColors &amp;&amp; this.name !== &quot;DeviceGray&quot; &amp;&amp; this.name !== &quot;DeviceRGB&quot;) { const allColors = bpc &lt;= 8 ? new Uint8Array(numComponentColors) : new Uint16Array(numComponentColors); for (let i = 0; i &lt; numComponentColors; i++) { allColors[i] = i; } const colorMap = new Uint8ClampedArray(numComponentColors * 3); this.getRgbBuffer(allColors, 0, numComponentColors, colorMap, 0, bpc, 0); if (!needsResizing) { let destPos = 0; for (let i = 0; i &lt; count; ++i) { const key = comps[i] * 3; dest[destPos++] = colorMap[key]; dest[destPos++] = colorMap[key + 1]; dest[destPos++] = colorMap[key + 2]; destPos += alpha01; } } else { rgbBuf = new Uint8Array(count * 3); let rgbPos = 0; for (let i = 0; i &lt; count; ++i) { const key = comps[i] * 3; rgbBuf[rgbPos++] = colorMap[key]; rgbBuf[rgbPos++] = colorMap[key + 1]; rgbBuf[rgbPos++] = colorMap[key + 2]; } } } else { if (!needsResizing) { this.getRgbBuffer(comps, 0, width * actualHeight, dest, 0, bpc, alpha01); } else { rgbBuf = new Uint8ClampedArray(count * 3); this.getRgbBuffer(comps, 0, count, rgbBuf, 0, bpc, 0); } } if (rgbBuf) { if (needsResizing) { resizeRgbImage(rgbBuf, dest, originalWidth, originalHeight, width, height, alpha01); } else { let destPos = 0, rgbPos = 0; for (let i = 0, ii = width * actualHeight; i &lt; ii; i++) { dest[destPos++] = rgbBuf[rgbPos++]; dest[destPos++] = rgbBuf[rgbPos++]; dest[destPos++] = rgbBuf[rgbPos++]; destPos += alpha01; } } } } get usesZeroToOneRange() { return (0, _util.shadow)(this, &quot;usesZeroToOneRange&quot;, true); } static _cache(cacheKey, xref, localColorSpaceCache, parsedColorSpace) { if (!localColorSpaceCache) { throw new Error(&apos;ColorSpace._cache - expected &quot;localColorSpaceCache&quot; argument.&apos;); } if (!parsedColorSpace) { throw new Error(&apos;ColorSpace._cache - expected &quot;parsedColorSpace&quot; argument.&apos;); } let csName, csRef; if (cacheKey instanceof _primitives.Ref) { csRef = cacheKey; cacheKey = xref.fetch(cacheKey); } if (cacheKey instanceof _primitives.Name) { csName = cacheKey.name; } if (csName || csRef) { localColorSpaceCache.set(csName, csRef, parsedColorSpace); } } static getCached(cacheKey, xref, localColorSpaceCache) { if (!localColorSpaceCache) { throw new Error(&apos;ColorSpace.getCached - expected &quot;localColorSpaceCache&quot; argument.&apos;); } if (cacheKey instanceof _primitives.Ref) { const localColorSpace = localColorSpaceCache.getByRef(cacheKey); if (localColorSpace) { return localColorSpace; } try { cacheKey = xref.fetch(cacheKey); } catch (ex) { if (ex instanceof _core_utils.MissingDataException) { throw ex; } } } if (cacheKey instanceof _primitives.Name) { const localColorSpace = localColorSpaceCache.getByName(cacheKey.name); if (localColorSpace) { return localColorSpace; } } return null; } static async parseAsync({ cs, xref, resources = null, pdfFunctionFactory, localColorSpaceCache }) { const parsedColorSpace = this._parse(cs, xref, resources, pdfFunctionFactory); this._cache(cs, xref, localColorSpaceCache, parsedColorSpace); return parsedColorSpace; } static parse({ cs, xref, resources = null, pdfFunctionFactory, localColorSpaceCache }) { const cachedColorSpace = this.getCached(cs, xref, localColorSpaceCache); if (cachedColorSpace) { return cachedColorSpace; } const parsedColorSpace = this._parse(cs, xref, resources, pdfFunctionFactory); this._cache(cs, xref, localColorSpaceCache, parsedColorSpace); return parsedColorSpace; } static _parse(cs, xref, resources = null, pdfFunctionFactory) { cs = xref.fetchIfRef(cs); if (cs instanceof _primitives.Name) { switch (cs.name) { case &quot;G&quot;: case &quot;DeviceGray&quot;: return this.singletons.gray; case &quot;RGB&quot;: case &quot;DeviceRGB&quot;: return this.singletons.rgb; case &quot;CMYK&quot;: case &quot;DeviceCMYK&quot;: return this.singletons.cmyk; case &quot;Pattern&quot;: return new PatternCS(null); default: if (resources instanceof _primitives.Dict) { const colorSpaces = resources.get(&quot;ColorSpace&quot;); if (colorSpaces instanceof _primitives.Dict) { const resourcesCS = colorSpaces.get(cs.name); if (resourcesCS) { if (resourcesCS instanceof _primitives.Name) { return this._parse(resourcesCS, xref, resources, pdfFunctionFactory); } cs = resourcesCS; break; } } } throw new _util.FormatError(`Unrecognized ColorSpace: ${cs.name}`); } } if (Array.isArray(cs)) { const mode = xref.fetchIfRef(cs[0]).name; let params, numComps, baseCS, whitePoint, blackPoint, gamma; switch (mode) { case &quot;G&quot;: case &quot;DeviceGray&quot;: return this.singletons.gray; case &quot;RGB&quot;: case &quot;DeviceRGB&quot;: return this.singletons.rgb; case &quot;CMYK&quot;: case &quot;DeviceCMYK&quot;: return this.singletons.cmyk; case &quot;CalGray&quot;: params = xref.fetchIfRef(cs[1]); whitePoint = params.getArray(&quot;WhitePoint&quot;); blackPoint = params.getArray(&quot;BlackPoint&quot;); gamma = params.get(&quot;Gamma&quot;); return new CalGrayCS(whitePoint, blackPoint, gamma); case &quot;CalRGB&quot;: params = xref.fetchIfRef(cs[1]); whitePoint = params.getArray(&quot;WhitePoint&quot;); blackPoint = params.getArray(&quot;BlackPoint&quot;); gamma = params.getArray(&quot;Gamma&quot;); const matrix = params.getArray(&quot;Matrix&quot;); return new CalRGBCS(whitePoint, blackPoint, gamma, matrix); case &quot;ICCBased&quot;: const stream = xref.fetchIfRef(cs[1]); const dict = stream.dict; numComps = dict.get(&quot;N&quot;); const alt = dict.get(&quot;Alternate&quot;); if (alt) { const altCS = this._parse(alt, xref, resources, pdfFunctionFactory); if (altCS.numComps === numComps) { return altCS; } (0, _util.warn)(&quot;ICCBased color space: Ignoring incorrect /Alternate entry.&quot;); } if (numComps === 1) { return this.singletons.gray; } else if (numComps === 3) { return this.singletons.rgb; } else if (numComps === 4) { return this.singletons.cmyk; } break; case &quot;Pattern&quot;: baseCS = cs[1] || null; if (baseCS) { baseCS = this._parse(baseCS, xref, resources, pdfFunctionFactory); } return new PatternCS(baseCS); case &quot;I&quot;: case &quot;Indexed&quot;: baseCS = this._parse(cs[1], xref, resources, pdfFunctionFactory); const hiVal = xref.fetchIfRef(cs[2]) + 1; const lookup = xref.fetchIfRef(cs[3]); return new IndexedCS(baseCS, hiVal, lookup); case &quot;Separation&quot;: case &quot;DeviceN&quot;: const name = xref.fetchIfRef(cs[1]); numComps = Array.isArray(name) ? name.length : 1; baseCS = this._parse(cs[2], xref, resources, pdfFunctionFactory); const tintFn = pdfFunctionFactory.create(cs[3]); return new AlternateCS(numComps, baseCS, tintFn); case &quot;Lab&quot;: params = xref.fetchIfRef(cs[1]); whitePoint = params.getArray(&quot;WhitePoint&quot;); blackPoint = params.getArray(&quot;BlackPoint&quot;); const range = params.getArray(&quot;Range&quot;); return new LabCS(whitePoint, blackPoint, range); default: throw new _util.FormatError(`Unimplemented ColorSpace object: ${mode}`); } } throw new _util.FormatError(`Unrecognized ColorSpace object: ${cs}`); } static isDefaultDecode(decode, numComps) { if (!Array.isArray(decode)) { return true; } if (numComps * 2 !== decode.length) { (0, _util.warn)(&quot;The decode map is not the correct length&quot;); return true; } for (let i = 0, ii = decode.length; i &lt; ii; i += 2) { if (decode[i] !== 0 || decode[i + 1] !== 1) { return false; } } return true; } static get singletons() { return (0, _util.shadow)(this, &quot;singletons&quot;, { get gray() { return (0, _util.shadow)(this, &quot;gray&quot;, new DeviceGrayCS()); }, get rgb() { return (0, _util.shadow)(this, &quot;rgb&quot;, new DeviceRgbCS()); }, get cmyk() { return (0, _util.shadow)(this, &quot;cmyk&quot;, new DeviceCmykCS()); } }); } } exports.ColorSpace = ColorSpace; class AlternateCS extends ColorSpace { constructor(numComps, base, tintFn) { super(&quot;Alternate&quot;, numComps); this.base = base; this.tintFn = tintFn; this.tmpBuf = new Float32Array(base.numComps); } getRgbItem(src, srcOffset, dest, destOffset) { const tmpBuf = this.tmpBuf; this.tintFn(src, srcOffset, tmpBuf, 0); this.base.getRgbItem(tmpBuf, 0, dest, destOffset); } getRgbBuffer(src, srcOffset, count, dest, destOffset, bits, alpha01) { const tintFn = this.tintFn; const base = this.base; const scale = 1 / ((1 &lt;&lt; bits) - 1); const baseNumComps = base.numComps; const usesZeroToOneRange = base.usesZeroToOneRange; const isPassthrough = (base.isPassthrough(8) || !usesZeroToOneRange) &amp;&amp; alpha01 === 0; let pos = isPassthrough ? destOffset : 0; const baseBuf = isPassthrough ? dest : new Uint8ClampedArray(baseNumComps * count); const numComps = this.numComps; const scaled = new Float32Array(numComps); const tinted = new Float32Array(baseNumComps); let i, j; for (i = 0; i &lt; count; i++) { for (j = 0; j &lt; numComps; j++) { scaled[j] = src[srcOffset++] * scale; } tintFn(scaled, 0, tinted, 0); if (usesZeroToOneRange) { for (j = 0; j &lt; baseNumComps; j++) { baseBuf[pos++] = tinted[j] * 255; } } else { base.getRgbItem(tinted, 0, baseBuf, pos); pos += baseNumComps; } } if (!isPassthrough) { base.getRgbBuffer(baseBuf, 0, count, dest, destOffset, 8, alpha01); } } getOutputLength(inputLength, alpha01) { return this.base.getOutputLength(inputLength * this.base.numComps / this.numComps, alpha01); } } class PatternCS extends ColorSpace { constructor(baseCS) { super(&quot;Pattern&quot;, null); this.base = baseCS; } isDefaultDecode(decodeMap, bpc) { (0, _util.unreachable)(&quot;Should not call PatternCS.isDefaultDecode&quot;); } } class IndexedCS extends ColorSpace { constructor(base, highVal, lookup) { super(&quot;Indexed&quot;, 1); this.base = base; this.highVal = highVal; const length = base.numComps * highVal; this.lookup = new Uint8Array(length); if (lookup instanceof _base_stream.BaseStream) { const bytes = lookup.getBytes(length); this.lookup.set(bytes); } else if (typeof lookup === &quot;string&quot;) { for (let i = 0; i &lt; length; ++i) { this.lookup[i] = lookup.charCodeAt(i) &amp; 0xff; } } else { throw new _util.FormatError(`IndexedCS - unrecognized lookup table: ${lookup}`); } } getRgbItem(src, srcOffset, dest, destOffset) { const numComps = this.base.numComps; const start = src[srcOffset] * numComps; this.base.getRgbBuffer(this.lookup, start, 1, dest, destOffset, 8, 0); } getRgbBuffer(src, srcOffset, count, dest, destOffset, bits, alpha01) { const base = this.base; const numComps = base.numComps; const outputDelta = base.getOutputLength(numComps, alpha01); const lookup = this.lookup; for (let i = 0; i &lt; count; ++i) { const lookupPos = src[srcOffset++] * numComps; base.getRgbBuffer(lookup, lookupPos, 1, dest, destOffset, 8, alpha01); destOffset += outputDelta; } } getOutputLength(inputLength, alpha01) { return this.base.getOutputLength(inputLength * this.base.numComps, alpha01); } isDefaultDecode(decodeMap, bpc) { if (!Array.isArray(decodeMap)) { return true; } if (decodeMap.length !== 2) { (0, _util.warn)(&quot;Decode map length is not correct&quot;); return true; } if (!Number.isInteger(bpc) || bpc &lt; 1) { (0, _util.warn)(&quot;Bits per component is not correct&quot;); return true; } return decodeMap[0] === 0 &amp;&amp; decodeMap[1] === (1 &lt;&lt; bpc) - 1; } } class DeviceGrayCS extends ColorSpace { constructor() { super(&quot;DeviceGray&quot;, 1); } getRgbItem(src, srcOffset, dest, destOffset) { const c = src[srcOffset] * 255; dest[destOffset] = dest[destOffset + 1] = dest[destOffset + 2] = c; } getRgbBuffer(src, srcOffset, count, dest, destOffset, bits, alpha01) { const scale = 255 / ((1 &lt;&lt; bits) - 1); let j = srcOffset, q = destOffset; for (let i = 0; i &lt; count; ++i) { const c = scale * src[j++]; dest[q++] = c; dest[q++] = c; dest[q++] = c; q += alpha01; } } getOutputLength(inputLength, alpha01) { return inputLength * (3 + alpha01); } } class DeviceRgbCS extends ColorSpace { constructor() { super(&quot;DeviceRGB&quot;, 3); } getRgbItem(src, srcOffset, dest, destOffset) { dest[destOffset] = src[srcOffset] * 255; dest[destOffset + 1] = src[srcOffset + 1] * 255; dest[destOffset + 2] = src[srcOffset + 2] * 255; } getRgbBuffer(src, srcOffset, count, dest, destOffset, bits, alpha01) { if (bits === 8 &amp;&amp; alpha01 === 0) { dest.set(src.subarray(srcOffset, srcOffset + count * 3), destOffset); return; } const scale = 255 / ((1 &lt;&lt; bits) - 1); let j = srcOffset, q = destOffset; for (let i = 0; i &lt; count; ++i) { dest[q++] = scale * src[j++]; dest[q++] = scale * src[j++]; dest[q++] = scale * src[j++]; q += alpha01; } } getOutputLength(inputLength, alpha01) { return inputLength * (3 + alpha01) / 3 | 0; } isPassthrough(bits) { return bits === 8; } } const DeviceCmykCS = function DeviceCmykCSClosure() { function convertToRgb(src, srcOffset, srcScale, dest, destOffset) { const c = src[srcOffset] * srcScale; const m = src[srcOffset + 1] * srcScale; const y = src[srcOffset + 2] * srcScale; const k = src[srcOffset + 3] * srcScale; dest[destOffset] = 255 + c * (-4.387332384609988 * c + 54.48615194189176 * m + 18.82290502165302 * y + 212.25662451639585 * k + -285.2331026137004) + m * (1.7149763477362134 * m - 5.6096736904047315 * y + -17.873870861415444 * k - 5.497006427196366) + y * (-2.5217340131683033 * y - 21.248923337353073 * k + 17.5119270841813) + k * (-21.86122147463605 * k - 189.48180835922747); dest[destOffset + 1] = 255 + c * (8.841041422036149 * c + 60.118027045597366 * m + 6.871425592049007 * y + 31.159100130055922 * k + -79.2970844816548) + m * (-15.310361306967817 * m + 17.575251261109482 * y + 131.35250912493976 * k - 190.9453302588951) + y * (4.444339102852739 * y + 9.8632861493405 * k - 24.86741582555878) + k * (-20.737325471181034 * k - 187.80453709719578); dest[destOffset + 2] = 255 + c * (0.8842522430003296 * c + 8.078677503112928 * m + 30.89978309703729 * y - 0.23883238689178934 * k + -14.183576799673286) + m * (10.49593273432072 * m + 63.02378494754052 * y + 50.606957656360734 * k - 112.23884253719248) + y * (0.03296041114873217 * y + 115.60384449646641 * k + -193.58209356861505) + k * (-22.33816807309886 * k - 180.12613974708367); } class DeviceCmykCS extends ColorSpace { constructor() { super(&quot;DeviceCMYK&quot;, 4); } getRgbItem(src, srcOffset, dest, destOffset) { convertToRgb(src, srcOffset, 1, dest, destOffset); } getRgbBuffer(src, srcOffset, count, dest, destOffset, bits, alpha01) { const scale = 1 / ((1 &lt;&lt; bits) - 1); for (let i = 0; i &lt; count; i++) { convertToRgb(src, srcOffset, scale, dest, destOffset); srcOffset += 4; destOffset += 3 + alpha01; } } getOutputLength(inputLength, alpha01) { return inputLength / 4 * (3 + alpha01) | 0; } } return DeviceCmykCS; }(); const CalGrayCS = function CalGrayCSClosure() { function convertToRgb(cs, src, srcOffset, dest, destOffset, scale) { const A = src[srcOffset] * scale; const AG = A ** cs.G; const L = cs.YW * AG; const val = Math.max(295.8 * L ** 0.3333333333333333 - 40.8, 0); dest[destOffset] = val; dest[destOffset + 1] = val; dest[destOffset + 2] = val; } class CalGrayCS extends ColorSpace { constructor(whitePoint, blackPoint, gamma) { super(&quot;CalGray&quot;, 1); if (!whitePoint) { throw new _util.FormatError(&quot;WhitePoint missing - required for color space CalGray&quot;); } blackPoint = blackPoint || [0, 0, 0]; gamma = gamma || 1; this.XW = whitePoint[0]; this.YW = whitePoint[1]; this.ZW = whitePoint[2]; this.XB = blackPoint[0]; this.YB = blackPoint[1]; this.ZB = blackPoint[2]; this.G = gamma; if (this.XW &lt; 0 || this.ZW &lt; 0 || this.YW !== 1) { throw new _util.FormatError(`Invalid WhitePoint components for ${this.name}` + &quot;, no fallback available&quot;); } if (this.XB &lt; 0 || this.YB &lt; 0 || this.ZB &lt; 0) { (0, _util.info)(`Invalid BlackPoint for ${this.name}, falling back to default.`); this.XB = this.YB = this.ZB = 0; } if (this.XB !== 0 || this.YB !== 0 || this.ZB !== 0) { (0, _util.warn)(`${this.name}, BlackPoint: XB: ${this.XB}, YB: ${this.YB}, ` + `ZB: ${this.ZB}, only default values are supported.`); } if (this.G &lt; 1) { (0, _util.info)(`Invalid Gamma: ${this.G} for ${this.name}, ` + &quot;falling back to default.&quot;); this.G = 1; } } getRgbItem(src, srcOffset, dest, destOffset) { convertToRgb(this, src, srcOffset, dest, destOffset, 1); } getRgbBuffer(src, srcOffset, count, dest, destOffset, bits, alpha01) { const scale = 1 / ((1 &lt;&lt; bits) - 1); for (let i = 0; i &lt; count; ++i) { convertToRgb(this, src, srcOffset, dest, destOffset, scale); srcOffset += 1; destOffset += 3 + alpha01; } } getOutputLength(inputLength, alpha01) { return inputLength * (3 + alpha01); } } return CalGrayCS; }(); const CalRGBCS = function CalRGBCSClosure() { const BRADFORD_SCALE_MATRIX = new Float32Array([0.8951, 0.2664, -0.1614, -0.7502, 1.7135, 0.0367, 0.0389, -0.0685, 1.0296]); const BRADFORD_SCALE_INVERSE_MATRIX = new Float32Array([0.9869929, -0.1470543, 0.1599627, 0.4323053, 0.5183603, 0.0492912, -0.0085287, 0.0400428, 0.9684867]); const SRGB_D65_XYZ_TO_RGB_MATRIX = new Float32Array([3.2404542, -1.5371385, -0.4985314, -0.9692660, 1.8760108, 0.0415560, 0.0556434, -0.2040259, 1.0572252]); const FLAT_WHITEPOINT_MATRIX = new Float32Array([1, 1, 1]); const tempNormalizeMatrix = new Float32Array(3); const tempConvertMatrix1 = new Float32Array(3); const tempConvertMatrix2 = new Float32Array(3); const DECODE_L_CONSTANT = ((8 + 16) / 116) ** 3 / 8.0; function matrixProduct(a, b, result) { result[0] = a[0] * b[0] + a[1] * b[1] + a[2] * b[2]; result[1] = a[3] * b[0] + a[4] * b[1] + a[5] * b[2]; result[2] = a[6] * b[0] + a[7] * b[1] + a[8] * b[2]; } function convertToFlat(sourceWhitePoint, LMS, result) { result[0] = LMS[0] * 1 / sourceWhitePoint[0]; result[1] = LMS[1] * 1 / sourceWhitePoint[1]; result[2] = LMS[2] * 1 / sourceWhitePoint[2]; } function convertToD65(sourceWhitePoint, LMS, result) { const D65X = 0.95047; const D65Y = 1; const D65Z = 1.08883; result[0] = LMS[0] * D65X / sourceWhitePoint[0]; result[1] = LMS[1] * D65Y / sourceWhitePoint[1]; result[2] = LMS[2] * D65Z / sourceWhitePoint[2]; } function sRGBTransferFunction(color) { if (color &lt;= 0.0031308) { return adjustToRange(0, 1, 12.92 * color); } if (color &gt;= 0.99554525) { return 1; } return adjustToRange(0, 1, (1 + 0.055) * color ** (1 / 2.4) - 0.055); } function adjustToRange(min, max, value) { return Math.max(min, Math.min(max, value)); } function decodeL(L) { if (L &lt; 0) { return -decodeL(-L); } if (L &gt; 8.0) { return ((L + 16) / 116) ** 3; } return L * DECODE_L_CONSTANT; } function compensateBlackPoint(sourceBlackPoint, XYZ_Flat, result) { if (sourceBlackPoint[0] === 0 &amp;&amp; sourceBlackPoint[1] === 0 &amp;&amp; sourceBlackPoint[2] === 0) { result[0] = XYZ_Flat[0]; result[1] = XYZ_Flat[1]; result[2] = XYZ_Flat[2]; return; } const zeroDecodeL = decodeL(0); const X_DST = zeroDecodeL; const X_SRC = decodeL(sourceBlackPoint[0]); const Y_DST = zeroDecodeL; const Y_SRC = decodeL(sourceBlackPoint[1]); const Z_DST = zeroDecodeL; const Z_SRC = decodeL(sourceBlackPoint[2]); const X_Scale = (1 - X_DST) / (1 - X_SRC); const X_Offset = 1 - X_Scale; const Y_Scale = (1 - Y_DST) / (1 - Y_SRC); const Y_Offset = 1 - Y_Scale; const Z_Scale = (1 - Z_DST) / (1 - Z_SRC); const Z_Offset = 1 - Z_Scale; result[0] = XYZ_Flat[0] * X_Scale + X_Offset; result[1] = XYZ_Flat[1] * Y_Scale + Y_Offset; result[2] = XYZ_Flat[2] * Z_Scale + Z_Offset; } function normalizeWhitePointToFlat(sourceWhitePoint, XYZ_In, result) { if (sourceWhitePoint[0] === 1 &amp;&amp; sourceWhitePoint[2] === 1) { result[0] = XYZ_In[0]; result[1] = XYZ_In[1]; result[2] = XYZ_In[2]; return; } const LMS = result; matrixProduct(BRADFORD_SCALE_MATRIX, XYZ_In, LMS); const LMS_Flat = tempNormalizeMatrix; convertToFlat(sourceWhitePoint, LMS, LMS_Flat); matrixProduct(BRADFORD_SCALE_INVERSE_MATRIX, LMS_Flat, result); } function normalizeWhitePointToD65(sourceWhitePoint, XYZ_In, result) { const LMS = result; matrixProduct(BRADFORD_SCALE_MATRIX, XYZ_In, LMS); const LMS_D65 = tempNormalizeMatrix; convertToD65(sourceWhitePoint, LMS, LMS_D65); matrixProduct(BRADFORD_SCALE_INVERSE_MATRIX, LMS_D65, result); } function convertToRgb(cs, src, srcOffset, dest, destOffset, scale) { const A = adjustToRange(0, 1, src[srcOffset] * scale); const B = adjustToRange(0, 1, src[srcOffset + 1] * scale); const C = adjustToRange(0, 1, src[srcOffset + 2] * scale); const AGR = A === 1 ? 1 : A ** cs.GR; const BGG = B === 1 ? 1 : B ** cs.GG; const CGB = C === 1 ? 1 : C ** cs.GB; const X = cs.MXA * AGR + cs.MXB * BGG + cs.MXC * CGB; const Y = cs.MYA * AGR + cs.MYB * BGG + cs.MYC * CGB; const Z = cs.MZA * AGR + cs.MZB * BGG + cs.MZC * CGB; const XYZ = tempConvertMatrix1; XYZ[0] = X; XYZ[1] = Y; XYZ[2] = Z; const XYZ_Flat = tempConvertMatrix2; normalizeWhitePointToFlat(cs.whitePoint, XYZ, XYZ_Flat); const XYZ_Black = tempConvertMatrix1; compensateBlackPoint(cs.blackPoint, XYZ_Flat, XYZ_Black); const XYZ_D65 = tempConvertMatrix2; normalizeWhitePointToD65(FLAT_WHITEPOINT_MATRIX, XYZ_Black, XYZ_D65); const SRGB = tempConvertMatrix1; matrixProduct(SRGB_D65_XYZ_TO_RGB_MATRIX, XYZ_D65, SRGB); dest[destOffset] = sRGBTransferFunction(SRGB[0]) * 255; dest[destOffset + 1] = sRGBTransferFunction(SRGB[1]) * 255; dest[destOffset + 2] = sRGBTransferFunction(SRGB[2]) * 255; } class CalRGBCS extends ColorSpace { constructor(whitePoint, blackPoint, gamma, matrix) { super(&quot;CalRGB&quot;, 3); if (!whitePoint) { throw new _util.FormatError(&quot;WhitePoint missing - required for color space CalRGB&quot;); } blackPoint = blackPoint || new Float32Array(3); gamma = gamma || new Float32Array([1, 1, 1]); matrix = matrix || new Float32Array([1, 0, 0, 0, 1, 0, 0, 0, 1]); const XW = whitePoint[0]; const YW = whitePoint[1]; const ZW = whitePoint[2]; this.whitePoint = whitePoint; const XB = blackPoint[0]; const YB = blackPoint[1]; const ZB = blackPoint[2]; this.blackPoint = blackPoint; this.GR = gamma[0]; this.GG = gamma[1]; this.GB = gamma[2]; this.MXA = matrix[0]; this.MYA = matrix[1]; this.MZA = matrix[2]; this.MXB = matrix[3]; this.MYB = matrix[4]; this.MZB = matrix[5]; this.MXC = matrix[6]; this.MYC = matrix[7]; this.MZC = matrix[8]; if (XW &lt; 0 || ZW &lt; 0 || YW !== 1) { throw new _util.FormatError(`Invalid WhitePoint components for ${this.name}` + &quot;, no fallback available&quot;); } if (XB &lt; 0 || YB &lt; 0 || ZB &lt; 0) { (0, _util.info)(`Invalid BlackPoint for ${this.name} [${XB}, ${YB}, ${ZB}], ` + &quot;falling back to default.&quot;); this.blackPoint = new Float32Array(3); } if (this.GR &lt; 0 || this.GG &lt; 0 || this.GB &lt; 0) { (0, _util.info)(`Invalid Gamma [${this.GR}, ${this.GG}, ${this.GB}] for ` + `${this.name}, falling back to default.`); this.GR = this.GG = this.GB = 1; } } getRgbItem(src, srcOffset, dest, destOffset) { convertToRgb(this, src, srcOffset, dest, destOffset, 1); } getRgbBuffer(src, srcOffset, count, dest, destOffset, bits, alpha01) { const scale = 1 / ((1 &lt;&lt; bits) - 1); for (let i = 0; i &lt; count; ++i) { convertToRgb(this, src, srcOffset, dest, destOffset, scale); srcOffset += 3; destOffset += 3 + alpha01; } } getOutputLength(inputLength, alpha01) { return inputLength * (3 + alpha01) / 3 | 0; } } return CalRGBCS; }(); const LabCS = function LabCSClosure() { function fn_g(x) { let result; if (x &gt;= 6 / 29) { result = x ** 3; } else { result = 108 / 841 * (x - 4 / 29); } return result; } function decode(value, high1, low2, high2) { return low2 + value * (high2 - low2) / high1; } function convertToRgb(cs, src, srcOffset, maxVal, dest, destOffset) { let Ls = src[srcOffset]; let as = src[srcOffset + 1]; let bs = src[srcOffset + 2]; if (maxVal !== false) { Ls = decode(Ls, maxVal, 0, 100); as = decode(as, maxVal, cs.amin, cs.amax); bs = decode(bs, maxVal, cs.bmin, cs.bmax); } if (as &gt; cs.amax) { as = cs.amax; } else if (as &lt; cs.amin) { as = cs.amin; } if (bs &gt; cs.bmax) { bs = cs.bmax; } else if (bs &lt; cs.bmin) { bs = cs.bmin; } const M = (Ls + 16) / 116; const L = M + as / 500; const N = M - bs / 200; const X = cs.XW * fn_g(L); const Y = cs.YW * fn_g(M); const Z = cs.ZW * fn_g(N); let r, g, b; if (cs.ZW &lt; 1) { r = X * 3.1339 + Y * -1.617 + Z * -0.4906; g = X * -0.9785 + Y * 1.916 + Z * 0.0333; b = X * 0.072 + Y * -0.229 + Z * 1.4057; } else { r = X * 3.2406 + Y * -1.5372 + Z * -0.4986; g = X * -0.9689 + Y * 1.8758 + Z * 0.0415; b = X * 0.0557 + Y * -0.204 + Z * 1.057; } dest[destOffset] = Math.sqrt(r) * 255; dest[destOffset + 1] = Math.sqrt(g) * 255; dest[destOffset + 2] = Math.sqrt(b) * 255; } class LabCS extends ColorSpace { constructor(whitePoint, blackPoint, range) { super(&quot;Lab&quot;, 3); if (!whitePoint) { throw new _util.FormatError(&quot;WhitePoint missing - required for color space Lab&quot;); } blackPoint = blackPoint || [0, 0, 0]; range = range || [-100, 100, -100, 100]; this.XW = whitePoint[0]; this.YW = whitePoint[1]; this.ZW = whitePoint[2]; this.amin = range[0]; this.amax = range[1]; this.bmin = range[2]; this.bmax = range[3]; this.XB = blackPoint[0]; this.YB = blackPoint[1]; this.ZB = blackPoint[2]; if (this.XW &lt; 0 || this.ZW &lt; 0 || this.YW !== 1) { throw new _util.FormatError(&quot;Invalid WhitePoint components, no fallback available&quot;); } if (this.XB &lt; 0 || this.YB &lt; 0 || this.ZB &lt; 0) { (0, _util.info)(&quot;Invalid BlackPoint, falling back to default&quot;); this.XB = this.YB = this.ZB = 0; } if (this.amin &gt; this.amax || this.bmin &gt; this.bmax) { (0, _util.info)(&quot;Invalid Range, falling back to defaults&quot;); this.amin = -100; this.amax = 100; this.bmin = -100; this.bmax = 100; } } getRgbItem(src, srcOffset, dest, destOffset) { convertToRgb(this, src, srcOffset, false, dest, destOffset); } getRgbBuffer(src, srcOffset, count, dest, destOffset, bits, alpha01) { const maxVal = (1 &lt;&lt; bits) - 1; for (let i = 0; i &lt; count; i++) { convertToRgb(this, src, srcOffset, maxVal, dest, destOffset); srcOffset += 3; destOffset += 3 + alpha01; } } getOutputLength(inputLength, alpha01) { return inputLength * (3 + alpha01) / 3 | 0; } isDefaultDecode(decodeMap, bpc) { return true; } get usesZeroToOneRange() { return (0, _util.shadow)(this, &quot;usesZeroToOneRange&quot;, false); } } return LabCS; }(); /***/ }), /* 13 */ /***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) =&gt; { Object.defineProperty(exports, &quot;__esModule&quot;, ({ value: true })); exports.PartialEvaluator = exports.EvaluatorPreprocessor = void 0; var _util = __w_pdfjs_require__(2); var _cmap = __w_pdfjs_require__(14); var _primitives = __w_pdfjs_require__(3); var _fonts = __w_pdfjs_require__(32); var _fonts_utils = __w_pdfjs_require__(36); var _encodings = __w_pdfjs_require__(35); var _standard_fonts = __w_pdfjs_require__(39); var _unicode = __w_pdfjs_require__(38); var _pattern = __w_pdfjs_require__(48); var _xfa_fonts = __w_pdfjs_require__(49); var _to_unicode_map = __w_pdfjs_require__(40); var _function = __w_pdfjs_require__(55); var _parser = __w_pdfjs_require__(15); var _image_utils = __w_pdfjs_require__(57); var _stream = __w_pdfjs_require__(8); var _base_stream = __w_pdfjs_require__(5); var _bidi = __w_pdfjs_require__(58); var _colorspace = __w_pdfjs_require__(12); var _decode_stream = __w_pdfjs_require__(17); var _glyphlist = __w_pdfjs_require__(37); var _core_utils = __w_pdfjs_require__(4); var _metrics = __w_pdfjs_require__(43); var _murmurhash = __w_pdfjs_require__(59); var _operator_list = __w_pdfjs_require__(60); var _image = __w_pdfjs_require__(61); const DefaultPartialEvaluatorOptions = Object.freeze({ maxImageSize: -1, disableFontFace: false, ignoreErrors: false, isEvalSupported: true, isOffscreenCanvasSupported: true, fontExtraProperties: false, useSystemFonts: true, cMapUrl: null, standardFontDataUrl: null }); const PatternType = { TILING: 1, SHADING: 2 }; const TEXT_CHUNK_BATCH_SIZE = 10; const deferred = Promise.resolve(); function normalizeBlendMode(value, parsingArray = false) { if (Array.isArray(value)) { for (const val of value) { const maybeBM = normalizeBlendMode(val, true); if (maybeBM) { return maybeBM; } } (0, _util.warn)(`Unsupported blend mode Array: ${value}`); return &quot;source-over&quot;; } if (!(value instanceof _primitives.Name)) { if (parsingArray) { return null; } return &quot;source-over&quot;; } switch (value.name) { case &quot;Normal&quot;: case &quot;Compatible&quot;: return &quot;source-over&quot;; case &quot;Multiply&quot;: return &quot;multiply&quot;; case &quot;Screen&quot;: return &quot;screen&quot;; case &quot;Overlay&quot;: return &quot;overlay&quot;; case &quot;Darken&quot;: return &quot;darken&quot;; case &quot;Lighten&quot;: return &quot;lighten&quot;; case &quot;ColorDodge&quot;: return &quot;color-dodge&quot;; case &quot;ColorBurn&quot;: return &quot;color-burn&quot;; case &quot;HardLight&quot;: return &quot;hard-light&quot;; case &quot;SoftLight&quot;: return &quot;soft-light&quot;; case &quot;Difference&quot;: return &quot;difference&quot;; case &quot;Exclusion&quot;: return &quot;exclusion&quot;; case &quot;Hue&quot;: return &quot;hue&quot;; case &quot;Saturation&quot;: return &quot;saturation&quot;; case &quot;Color&quot;: return &quot;color&quot;; case &quot;Luminosity&quot;: return &quot;luminosity&quot;; } if (parsingArray) { return null; } (0, _util.warn)(`Unsupported blend mode: ${value.name}`); return &quot;source-over&quot;; } function incrementCachedImageMaskCount(data) { if (data.fn === _util.OPS.paintImageMaskXObject &amp;&amp; data.args[0] &amp;&amp; data.args[0].count &gt; 0) { data.args[0].count++; } } class TimeSlotManager { static get TIME_SLOT_DURATION_MS() { return (0, _util.shadow)(this, &quot;TIME_SLOT_DURATION_MS&quot;, 20); } static get CHECK_TIME_EVERY() { return (0, _util.shadow)(this, &quot;CHECK_TIME_EVERY&quot;, 100); } constructor() { this.reset(); } check() { if (++this.checked &lt; TimeSlotManager.CHECK_TIME_EVERY) { return false; } this.checked = 0; return this.endTime &lt;= Date.now(); } reset() { this.endTime = Date.now() + TimeSlotManager.TIME_SLOT_DURATION_MS; this.checked = 0; } } class PartialEvaluator { constructor({ xref, handler, pageIndex, idFactory, fontCache, builtInCMapCache, standardFontDataCache, globalImageCache, options = null }) { this.xref = xref; this.handler = handler; this.pageIndex = pageIndex; this.idFactory = idFactory; this.fontCache = fontCache; this.builtInCMapCache = builtInCMapCache; this.standardFontDataCache = standardFontDataCache; this.globalImageCache = globalImageCache; this.options = options || DefaultPartialEvaluatorOptions; this.parsingType3Font = false; this._fetchBuiltInCMapBound = this.fetchBuiltInCMap.bind(this); } get _pdfFunctionFactory() { const pdfFunctionFactory = new _function.PDFFunctionFactory({ xref: this.xref, isEvalSupported: this.options.isEvalSupported }); return (0, _util.shadow)(this, &quot;_pdfFunctionFactory&quot;, pdfFunctionFactory); } clone(newOptions = null) { const newEvaluator = Object.create(this); newEvaluator.options = Object.assign(Object.create(null), this.options, newOptions); return newEvaluator; } hasBlendModes(resources, nonBlendModesSet) { if (!(resources instanceof _primitives.Dict)) { return false; } if (resources.objId &amp;&amp; nonBlendModesSet.has(resources.objId)) { return false; } const processed = new _primitives.RefSet(nonBlendModesSet); if (resources.objId) { processed.put(resources.objId); } const nodes = [resources], xref = this.xref; while (nodes.length) { const node = nodes.shift(); const graphicStates = node.get(&quot;ExtGState&quot;); if (graphicStates instanceof _primitives.Dict) { for (let graphicState of graphicStates.getRawValues()) { if (graphicState instanceof _primitives.Ref) { if (processed.has(graphicState)) { continue; } try { graphicState = xref.fetch(graphicState); } catch (ex) { processed.put(graphicState); (0, _util.info)(`hasBlendModes - ignoring ExtGState: &quot;${ex}&quot;.`); continue; } } if (!(graphicState instanceof _primitives.Dict)) { continue; } if (graphicState.objId) { processed.put(graphicState.objId); } const bm = graphicState.get(&quot;BM&quot;); if (bm instanceof _primitives.Name) { if (bm.name !== &quot;Normal&quot;) { return true; } continue; } if (bm !== undefined &amp;&amp; Array.isArray(bm)) { for (const element of bm) { if (element instanceof _primitives.Name &amp;&amp; element.name !== &quot;Normal&quot;) { return true; } } } } } const xObjects = node.get(&quot;XObject&quot;); if (!(xObjects instanceof _primitives.Dict)) { continue; } for (let xObject of xObjects.getRawValues()) { if (xObject instanceof _primitives.Ref) { if (processed.has(xObject)) { continue; } try { xObject = xref.fetch(xObject); } catch (ex) { processed.put(xObject); (0, _util.info)(`hasBlendModes - ignoring XObject: &quot;${ex}&quot;.`); continue; } } if (!(xObject instanceof _base_stream.BaseStream)) { continue; } if (xObject.dict.objId) { processed.put(xObject.dict.objId); } const xResources = xObject.dict.get(&quot;Resources&quot;); if (!(xResources instanceof _primitives.Dict)) { continue; } if (xResources.objId &amp;&amp; processed.has(xResources.objId)) { continue; } nodes.push(xResources); if (xResources.objId) { processed.put(xResources.objId); } } } for (const ref of processed) { nonBlendModesSet.put(ref); } return false; } async fetchBuiltInCMap(name) { const cachedData = this.builtInCMapCache.get(name); if (cachedData) { return cachedData; } let data; if (this.options.cMapUrl !== null) { const url = `${this.options.cMapUrl}${name}.bcmap`; const response = await fetch(url); if (!response.ok) { throw new Error(`fetchBuiltInCMap: failed to fetch file &quot;${url}&quot; with &quot;${response.statusText}&quot;.`); } data = { cMapData: new Uint8Array(await response.arrayBuffer()), compressionType: _util.CMapCompressionType.BINARY }; } else { data = await this.handler.sendWithPromise(&quot;FetchBuiltInCMap&quot;, { name }); } if (data.compressionType !== _util.CMapCompressionType.NONE) { this.builtInCMapCache.set(name, data); } return data; } async fetchStandardFontData(name) { const cachedData = this.standardFontDataCache.get(name); if (cachedData) { return new _stream.Stream(cachedData); } if (this.options.useSystemFonts &amp;&amp; name !== &quot;Symbol&quot; &amp;&amp; name !== &quot;ZapfDingbats&quot;) { return null; } const standardFontNameToFileName = (0, _standard_fonts.getFontNameToFileMap)(), filename = standardFontNameToFileName[name]; let data; if (this.options.standardFontDataUrl !== null) { const url = `${this.options.standardFontDataUrl}${filename}`; const response = await fetch(url); if (!response.ok) { (0, _util.warn)(`fetchStandardFontData: failed to fetch file &quot;${url}&quot; with &quot;${response.statusText}&quot;.`); } else { data = await response.arrayBuffer(); } } else { try { data = await this.handler.sendWithPromise(&quot;FetchStandardFontData&quot;, { filename }); } catch (e) { (0, _util.warn)(`fetchStandardFontData: failed to fetch file &quot;${filename}&quot; with &quot;${e}&quot;.`); } } if (!data) { return null; } this.standardFontDataCache.set(name, data); return new _stream.Stream(data); } async buildFormXObject(resources, xobj, smask, operatorList, task, initialState, localColorSpaceCache) { const dict = xobj.dict; const matrix = dict.getArray(&quot;Matrix&quot;); let bbox = dict.getArray(&quot;BBox&quot;); if (Array.isArray(bbox) &amp;&amp; bbox.length === 4) { bbox = _util.Util.normalizeRect(bbox); } else { bbox = null; } let optionalContent, groupOptions; if (dict.has(&quot;OC&quot;)) { optionalContent = await this.parseMarkedContentProps(dict.get(&quot;OC&quot;), resources); } if (optionalContent !== undefined) { operatorList.addOp(_util.OPS.beginMarkedContentProps, [&quot;OC&quot;, optionalContent]); } const group = dict.get(&quot;Group&quot;); if (group) { groupOptions = { matrix, bbox, smask, isolated: false, knockout: false }; const groupSubtype = group.get(&quot;S&quot;); let colorSpace = null; if ((0, _primitives.isName)(groupSubtype, &quot;Transparency&quot;)) { groupOptions.isolated = group.get(&quot;I&quot;) || false; groupOptions.knockout = group.get(&quot;K&quot;) || false; if (group.has(&quot;CS&quot;)) { const cs = group.getRaw(&quot;CS&quot;); const cachedColorSpace = _colorspace.ColorSpace.getCached(cs, this.xref, localColorSpaceCache); if (cachedColorSpace) { colorSpace = cachedColorSpace; } else { colorSpace = await this.parseColorSpace({ cs, resources, localColorSpaceCache }); } } } if (smask &amp;&amp; smask.backdrop) { colorSpace = colorSpace || _colorspace.ColorSpace.singletons.rgb; smask.backdrop = colorSpace.getRgb(smask.backdrop, 0); } operatorList.addOp(_util.OPS.beginGroup, [groupOptions]); } const args = group ? [matrix, null] : [matrix, bbox]; operatorList.addOp(_util.OPS.paintFormXObjectBegin, args); return this.getOperatorList({ stream: xobj, task, resources: dict.get(&quot;Resources&quot;) || resources, operatorList, initialState }).then(function () { operatorList.addOp(_util.OPS.paintFormXObjectEnd, []); if (group) { operatorList.addOp(_util.OPS.endGroup, [groupOptions]); } if (optionalContent !== undefined) { operatorList.addOp(_util.OPS.endMarkedContent, []); } }); } _sendImgData(objId, imgData, cacheGlobally = false) { const transfers = imgData ? [imgData.bitmap || imgData.data.buffer] : null; if (this.parsingType3Font || cacheGlobally) { return this.handler.send(&quot;commonobj&quot;, [objId, &quot;Image&quot;, imgData], transfers); } return this.handler.send(&quot;obj&quot;, [objId, this.pageIndex, &quot;Image&quot;, imgData], transfers); } async buildPaintImageXObject({ resources, image, isInline = false, operatorList, cacheKey, localImageCache, localColorSpaceCache }) { const dict = image.dict; const imageRef = dict.objId; const w = dict.get(&quot;W&quot;, &quot;Width&quot;); const h = dict.get(&quot;H&quot;, &quot;Height&quot;); if (!(w &amp;&amp; typeof w === &quot;number&quot;) || !(h &amp;&amp; typeof h === &quot;number&quot;)) { (0, _util.warn)(&quot;Image dimensions are missing, or not numbers.&quot;); return; } const maxImageSize = this.options.maxImageSize; if (maxImageSize !== -1 &amp;&amp; w * h &gt; maxImageSize) { const msg = &quot;Image exceeded maximum allowed size and was removed.&quot;; if (this.options.ignoreErrors) { (0, _util.warn)(msg); return; } throw new Error(msg); } let optionalContent; if (dict.has(&quot;OC&quot;)) { optionalContent = await this.parseMarkedContentProps(dict.get(&quot;OC&quot;), resources); } const imageMask = dict.get(&quot;IM&quot;, &quot;ImageMask&quot;) || false; let imgData, args; if (imageMask) { const interpolate = dict.get(&quot;I&quot;, &quot;Interpolate&quot;); const bitStrideLength = w + 7 &gt;&gt; 3; const imgArray = image.getBytes(bitStrideLength * h); const decode = dict.getArray(&quot;D&quot;, &quot;Decode&quot;); if (this.parsingType3Font) { imgData = _image.PDFImage.createRawMask({ imgArray, width: w, height: h, imageIsFromDecodeStream: image instanceof _decode_stream.DecodeStream, inverseDecode: !!decode &amp;&amp; decode[0] &gt; 0, interpolate }); imgData.cached = !!cacheKey; args = [imgData]; operatorList.addImageOps(_util.OPS.paintImageMaskXObject, args, optionalContent); if (cacheKey) { localImageCache.set(cacheKey, imageRef, { fn: _util.OPS.paintImageMaskXObject, args, optionalContent }); } return; } imgData = _image.PDFImage.createMask({ imgArray, width: w, height: h, imageIsFromDecodeStream: image instanceof _decode_stream.DecodeStream, inverseDecode: !!decode &amp;&amp; decode[0] &gt; 0, interpolate, isOffscreenCanvasSupported: this.options.isOffscreenCanvasSupported }); if (imgData.isSingleOpaquePixel) { operatorList.addImageOps(_util.OPS.paintSolidColorImageMask, [], optionalContent); if (cacheKey) { localImageCache.set(cacheKey, imageRef, { fn: _util.OPS.paintSolidColorImageMask, args: [], optionalContent }); } return; } const objId = `mask_${this.idFactory.createObjId()}`; operatorList.addDependency(objId); this._sendImgData(objId, imgData); args = [{ data: objId, width: imgData.width, height: imgData.height, interpolate: imgData.interpolate, count: 1 }]; operatorList.addImageOps(_util.OPS.paintImageMaskXObject, args, optionalContent); if (cacheKey) { localImageCache.set(cacheKey, imageRef, { fn: _util.OPS.paintImageMaskXObject, args, optionalContent }); } return; } const softMask = dict.get(&quot;SM&quot;, &quot;SMask&quot;) || false; const mask = dict.get(&quot;Mask&quot;) || false; const SMALL_IMAGE_DIMENSIONS = 200; if (isInline &amp;&amp; !softMask &amp;&amp; !mask &amp;&amp; w + h &lt; SMALL_IMAGE_DIMENSIONS) { const imageObj = new _image.PDFImage({ xref: this.xref, res: resources, image, isInline, pdfFunctionFactory: this._pdfFunctionFactory, localColorSpaceCache }); imgData = imageObj.createImageData(true); operatorList.addImageOps(_util.OPS.paintInlineImageXObject, [imgData], optionalContent); return; } let objId = `img_${this.idFactory.createObjId()}`, cacheGlobally = false; if (this.parsingType3Font) { objId = `${this.idFactory.getDocId()}_type3_${objId}`; } else if (imageRef) { cacheGlobally = this.globalImageCache.shouldCache(imageRef, this.pageIndex); if (cacheGlobally) { objId = `${this.idFactory.getDocId()}_${objId}`; } } operatorList.addDependency(objId); args = [objId, w, h]; _image.PDFImage.buildImage({ xref: this.xref, res: resources, image, isInline, pdfFunctionFactory: this._pdfFunctionFactory, localColorSpaceCache }).then(imageObj =&gt; { imgData = imageObj.createImageData(false); if (cacheKey &amp;&amp; imageRef &amp;&amp; cacheGlobally) { this.globalImageCache.addByteSize(imageRef, imgData.data.length); } return this._sendImgData(objId, imgData, cacheGlobally); }).catch(reason =&gt; { (0, _util.warn)(`Unable to decode image &quot;${objId}&quot;: &quot;${reason}&quot;.`); return this._sendImgData(objId, null, cacheGlobally); }); operatorList.addImageOps(_util.OPS.paintImageXObject, args, optionalContent); if (cacheKey) { localImageCache.set(cacheKey, imageRef, { fn: _util.OPS.paintImageXObject, args, optionalContent }); if (imageRef) { (0, _util.assert)(!isInline, &quot;Cannot cache an inline image globally.&quot;); this.globalImageCache.addPageIndex(imageRef, this.pageIndex); if (cacheGlobally) { this.globalImageCache.setData(imageRef, { objId, fn: _util.OPS.paintImageXObject, args, optionalContent, byteSize: 0 }); } } } } handleSMask(smask, resources, operatorList, task, stateManager, localColorSpaceCache) { const smaskContent = smask.get(&quot;G&quot;); const smaskOptions = { subtype: smask.get(&quot;S&quot;).name, backdrop: smask.get(&quot;BC&quot;) }; const transferObj = smask.get(&quot;TR&quot;); if ((0, _function.isPDFFunction)(transferObj)) { const transferFn = this._pdfFunctionFactory.create(transferObj); const transferMap = new Uint8Array(256); const tmp = new Float32Array(1); for (let i = 0; i &lt; 256; i++) { tmp[0] = i / 255; transferFn(tmp, 0, tmp, 0); transferMap[i] = tmp[0] * 255 | 0; } smaskOptions.transferMap = transferMap; } return this.buildFormXObject(resources, smaskContent, smaskOptions, operatorList, task, stateManager.state.clone(), localColorSpaceCache); } handleTransferFunction(tr) { let transferArray; if (Array.isArray(tr)) { transferArray = tr; } else if ((0, _function.isPDFFunction)(tr)) { transferArray = [tr]; } else { return null; } const transferMaps = []; let numFns = 0, numEffectfulFns = 0; for (const entry of transferArray) { const transferObj = this.xref.fetchIfRef(entry); numFns++; if ((0, _primitives.isName)(transferObj, &quot;Identity&quot;)) { transferMaps.push(null); continue; } else if (!(0, _function.isPDFFunction)(transferObj)) { return null; } const transferFn = this._pdfFunctionFactory.create(transferObj); const transferMap = new Uint8Array(256), tmp = new Float32Array(1); for (let j = 0; j &lt; 256; j++) { tmp[0] = j / 255; transferFn(tmp, 0, tmp, 0); transferMap[j] = tmp[0] * 255 | 0; } transferMaps.push(transferMap); numEffectfulFns++; } if (!(numFns === 1 || numFns === 4)) { return null; } if (numEffectfulFns === 0) { return null; } return transferMaps; } handleTilingType(fn, color, resources, pattern, patternDict, operatorList, task, localTilingPatternCache) { const tilingOpList = new _operator_list.OperatorList(); const patternResources = _primitives.Dict.merge({ xref: this.xref, dictArray: [patternDict.get(&quot;Resources&quot;), resources] }); return this.getOperatorList({ stream: pattern, task, resources: patternResources, operatorList: tilingOpList }).then(function () { const operatorListIR = tilingOpList.getIR(); const tilingPatternIR = (0, _pattern.getTilingPatternIR)(operatorListIR, patternDict, color); operatorList.addDependencies(tilingOpList.dependencies); operatorList.addOp(fn, tilingPatternIR); if (patternDict.objId) { localTilingPatternCache.set(null, patternDict.objId, { operatorListIR, dict: patternDict }); } }).catch(reason =&gt; { if (reason instanceof _util.AbortException) { return; } if (this.options.ignoreErrors) { this.handler.send(&quot;UnsupportedFeature&quot;, { featureId: _util.UNSUPPORTED_FEATURES.errorTilingPattern }); (0, _util.warn)(`handleTilingType - ignoring pattern: &quot;${reason}&quot;.`); return; } throw reason; }); } handleSetFont(resources, fontArgs, fontRef, operatorList, task, state, fallbackFontDict = null, cssFontInfo = null) { const fontName = fontArgs &amp;&amp; fontArgs[0] instanceof _primitives.Name ? fontArgs[0].name : null; return this.loadFont(fontName, fontRef, resources, fallbackFontDict, cssFontInfo).then(translated =&gt; { if (!translated.font.isType3Font) { return translated; } return translated.loadType3Data(this, resources, task).then(function () { operatorList.addDependencies(translated.type3Dependencies); return translated; }).catch(reason =&gt; { this.handler.send(&quot;UnsupportedFeature&quot;, { featureId: _util.UNSUPPORTED_FEATURES.errorFontLoadType3 }); return new TranslatedFont({ loadedName: &quot;g_font_error&quot;, font: new _fonts.ErrorFont(`Type3 font load error: ${reason}`), dict: translated.font, evaluatorOptions: this.options }); }); }).then(translated =&gt; { state.font = translated.font; translated.send(this.handler); return translated.loadedName; }); } handleText(chars, state) { const font = state.font; const glyphs = font.charsToGlyphs(chars); if (font.data) { const isAddToPathSet = !!(state.textRenderingMode &amp; _util.TextRenderingMode.ADD_TO_PATH_FLAG); if (isAddToPathSet || state.fillColorSpace.name === &quot;Pattern&quot; || font.disableFontFace || this.options.disableFontFace) { PartialEvaluator.buildFontPaths(font, glyphs, this.handler, this.options); } } return glyphs; } ensureStateFont(state) { if (state.font) { return; } const reason = new _util.FormatError(&quot;Missing setFont (Tf) operator before text rendering operator.&quot;); if (this.options.ignoreErrors) { this.handler.send(&quot;UnsupportedFeature&quot;, { featureId: _util.UNSUPPORTED_FEATURES.errorFontState }); (0, _util.warn)(`ensureStateFont: &quot;${reason}&quot;.`); return; } throw reason; } async setGState({ resources, gState, operatorList, cacheKey, task, stateManager, localGStateCache, localColorSpaceCache }) { const gStateRef = gState.objId; let isSimpleGState = true; const gStateObj = []; let promise = Promise.resolve(); for (const key of gState.getKeys()) { const value = gState.get(key); switch (key) { case &quot;Type&quot;: break; case &quot;LW&quot;: case &quot;LC&quot;: case &quot;LJ&quot;: case &quot;ML&quot;: case &quot;D&quot;: case &quot;RI&quot;: case &quot;FL&quot;: case &quot;CA&quot;: case &quot;ca&quot;: gStateObj.push([key, value]); break; case &quot;Font&quot;: isSimpleGState = false; promise = promise.then(() =&gt; { return this.handleSetFont(resources, null, value[0], operatorList, task, stateManager.state).then(function (loadedName) { operatorList.addDependency(loadedName); gStateObj.push([key, [loadedName, value[1]]]); }); }); break; case &quot;BM&quot;: gStateObj.push([key, normalizeBlendMode(value)]); break; case &quot;SMask&quot;: if ((0, _primitives.isName)(value, &quot;None&quot;)) { gStateObj.push([key, false]); break; } if (value instanceof _primitives.Dict) { isSimpleGState = false; promise = promise.then(() =&gt; { return this.handleSMask(value, resources, operatorList, task, stateManager, localColorSpaceCache); }); gStateObj.push([key, true]); } else { (0, _util.warn)(&quot;Unsupported SMask type&quot;); } break; case &quot;TR&quot;: const transferMaps = this.handleTransferFunction(value); gStateObj.push([key, transferMaps]); break; case &quot;OP&quot;: case &quot;op&quot;: case &quot;OPM&quot;: case &quot;BG&quot;: case &quot;BG2&quot;: case &quot;UCR&quot;: case &quot;UCR2&quot;: case &quot;TR2&quot;: case &quot;HT&quot;: case &quot;SM&quot;: case &quot;SA&quot;: case &quot;AIS&quot;: case &quot;TK&quot;: (0, _util.info)(&quot;graphic state operator &quot; + key); break; default: (0, _util.info)(&quot;Unknown graphic state operator &quot; + key); break; } } return promise.then(function () { if (gStateObj.length &gt; 0) { operatorList.addOp(_util.OPS.setGState, [gStateObj]); } if (isSimpleGState) { localGStateCache.set(cacheKey, gStateRef, gStateObj); } }); } loadFont(fontName, font, resources, fallbackFontDict = null, cssFontInfo = null) { const errorFont = async () =&gt; { return new TranslatedFont({ loadedName: &quot;g_font_error&quot;, font: new _fonts.ErrorFont(`Font &quot;${fontName}&quot; is not available.`), dict: font, evaluatorOptions: this.options }); }; const xref = this.xref; let fontRef; if (font) { if (font instanceof _primitives.Ref) { fontRef = font; } } else { const fontRes = resources.get(&quot;Font&quot;); if (fontRes) { fontRef = fontRes.getRaw(fontName); } } if (!fontRef) { const partialMsg = `Font &quot;${fontName || font &amp;&amp; font.toString()}&quot; is not available`; if (!this.options.ignoreErrors &amp;&amp; !this.parsingType3Font) { (0, _util.warn)(`${partialMsg}.`); return errorFont(); } this.handler.send(&quot;UnsupportedFeature&quot;, { featureId: _util.UNSUPPORTED_FEATURES.errorFontMissing }); (0, _util.warn)(`${partialMsg} -- attempting to fallback to a default font.`); if (fallbackFontDict) { fontRef = fallbackFontDict; } else { fontRef = PartialEvaluator.fallbackFontDict; } } if (this.parsingType3Font &amp;&amp; this.type3FontRefs.has(fontRef)) { return errorFont(); } if (this.fontCache.has(fontRef)) { return this.fontCache.get(fontRef); } font = xref.fetchIfRef(fontRef); if (!(font instanceof _primitives.Dict)) { return errorFont(); } if (font.cacheKey &amp;&amp; this.fontCache.has(font.cacheKey)) { return this.fontCache.get(font.cacheKey); } const fontCapability = (0, _util.createPromiseCapability)(); let preEvaluatedFont; try { preEvaluatedFont = this.preEvaluateFont(font); preEvaluatedFont.cssFontInfo = cssFontInfo; } catch (reason) { (0, _util.warn)(`loadFont - preEvaluateFont failed: &quot;${reason}&quot;.`); return errorFont(); } const { descriptor, hash } = preEvaluatedFont; const fontRefIsRef = fontRef instanceof _primitives.Ref; let fontID; if (fontRefIsRef) { fontID = `f${fontRef.toString()}`; } if (hash &amp;&amp; descriptor instanceof _primitives.Dict) { if (!descriptor.fontAliases) { descriptor.fontAliases = Object.create(null); } const fontAliases = descriptor.fontAliases; if (fontAliases[hash]) { const aliasFontRef = fontAliases[hash].aliasRef; if (fontRefIsRef &amp;&amp; aliasFontRef &amp;&amp; this.fontCache.has(aliasFontRef)) { this.fontCache.putAlias(fontRef, aliasFontRef); return this.fontCache.get(fontRef); } } else { fontAliases[hash] = { fontID: this.idFactory.createFontId() }; } if (fontRefIsRef) { fontAliases[hash].aliasRef = fontRef; } fontID = fontAliases[hash].fontID; } if (fontRefIsRef) { this.fontCache.put(fontRef, fontCapability.promise); } else { if (!fontID) { fontID = this.idFactory.createFontId(); } font.cacheKey = `cacheKey_${fontID}`; this.fontCache.put(font.cacheKey, fontCapability.promise); } (0, _util.assert)(fontID &amp;&amp; fontID.startsWith(&quot;f&quot;), &apos;The &quot;fontID&quot; must be (correctly) defined.&apos;); font.loadedName = `${this.idFactory.getDocId()}_${fontID}`; this.translateFont(preEvaluatedFont).then(translatedFont =&gt; { if (translatedFont.fontType !== undefined) { xref.stats.addFontType(translatedFont.fontType); } fontCapability.resolve(new TranslatedFont({ loadedName: font.loadedName, font: translatedFont, dict: font, evaluatorOptions: this.options })); }).catch(reason =&gt; { this.handler.send(&quot;UnsupportedFeature&quot;, { featureId: _util.UNSUPPORTED_FEATURES.errorFontTranslate }); (0, _util.warn)(`loadFont - translateFont failed: &quot;${reason}&quot;.`); try { const fontFile3 = descriptor &amp;&amp; descriptor.get(&quot;FontFile3&quot;); const subtype = fontFile3 &amp;&amp; fontFile3.get(&quot;Subtype&quot;); const fontType = (0, _fonts_utils.getFontType)(preEvaluatedFont.type, subtype &amp;&amp; subtype.name); if (fontType !== undefined) { xref.stats.addFontType(fontType); } } catch (ex) {} fontCapability.resolve(new TranslatedFont({ loadedName: font.loadedName, font: new _fonts.ErrorFont(reason instanceof Error ? reason.message : reason), dict: font, evaluatorOptions: this.options })); }); return fontCapability.promise; } buildPath(operatorList, fn, args, parsingText = false) { const lastIndex = operatorList.length - 1; if (!args) { args = []; } if (lastIndex &lt; 0 || operatorList.fnArray[lastIndex] !== _util.OPS.constructPath) { if (parsingText) { (0, _util.warn)(`Encountered path operator &quot;${fn}&quot; inside of a text object.`); operatorList.addOp(_util.OPS.save, null); } let minMax; switch (fn) { case _util.OPS.rectangle: const x = args[0] + args[2]; const y = args[1] + args[3]; minMax = [Math.min(args[0], x), Math.max(args[0], x), Math.min(args[1], y), Math.max(args[1], y)]; break; case _util.OPS.moveTo: case _util.OPS.lineTo: minMax = [args[0], args[0], args[1], args[1]]; break; default: minMax = [Infinity, -Infinity, Infinity, -Infinity]; break; } operatorList.addOp(_util.OPS.constructPath, [[fn], args, minMax]); if (parsingText) { operatorList.addOp(_util.OPS.restore, null); } } else { const opArgs = operatorList.argsArray[lastIndex]; opArgs[0].push(fn); opArgs[1].push(...args); const minMax = opArgs[2]; switch (fn) { case _util.OPS.rectangle: const x = args[0] + args[2]; const y = args[1] + args[3]; minMax[0] = Math.min(minMax[0], args[0], x); minMax[1] = Math.max(minMax[1], args[0], x); minMax[2] = Math.min(minMax[2], args[1], y); minMax[3] = Math.max(minMax[3], args[1], y); break; case _util.OPS.moveTo: case _util.OPS.lineTo: minMax[0] = Math.min(minMax[0], args[0]); minMax[1] = Math.max(minMax[1], args[0]); minMax[2] = Math.min(minMax[2], args[1]); minMax[3] = Math.max(minMax[3], args[1]); break; } } } parseColorSpace({ cs, resources, localColorSpaceCache }) { return _colorspace.ColorSpace.parseAsync({ cs, xref: this.xref, resources, pdfFunctionFactory: this._pdfFunctionFactory, localColorSpaceCache }).catch(reason =&gt; { if (reason instanceof _util.AbortException) { return null; } if (this.options.ignoreErrors) { this.handler.send(&quot;UnsupportedFeature&quot;, { featureId: _util.UNSUPPORTED_FEATURES.errorColorSpace }); (0, _util.warn)(`parseColorSpace - ignoring ColorSpace: &quot;${reason}&quot;.`); return null; } throw reason; }); } parseShading({ shading, resources, localColorSpaceCache, localShadingPatternCache }) { let id = localShadingPatternCache.get(shading); if (!id) { var shadingFill = _pattern.Pattern.parseShading(shading, this.xref, resources, this.handler, this._pdfFunctionFactory, localColorSpaceCache); const patternIR = shadingFill.getIR(); id = `pattern_${this.idFactory.createObjId()}`; localShadingPatternCache.set(shading, id); this.handler.send(&quot;obj&quot;, [id, this.pageIndex, &quot;Pattern&quot;, patternIR]); } return id; } handleColorN(operatorList, fn, args, cs, patterns, resources, task, localColorSpaceCache, localTilingPatternCache, localShadingPatternCache) { const patternName = args.pop(); if (patternName instanceof _primitives.Name) { const rawPattern = patterns.getRaw(patternName.name); const localTilingPattern = rawPattern instanceof _primitives.Ref &amp;&amp; localTilingPatternCache.getByRef(rawPattern); if (localTilingPattern) { try { const color = cs.base ? cs.base.getRgb(args, 0) : null; const tilingPatternIR = (0, _pattern.getTilingPatternIR)(localTilingPattern.operatorListIR, localTilingPattern.dict, color); operatorList.addOp(fn, tilingPatternIR); return undefined; } catch (ex) {} } const pattern = this.xref.fetchIfRef(rawPattern); if (pattern) { const dict = pattern instanceof _base_stream.BaseStream ? pattern.dict : pattern; const typeNum = dict.get(&quot;PatternType&quot;); if (typeNum === PatternType.TILING) { const color = cs.base ? cs.base.getRgb(args, 0) : null; return this.handleTilingType(fn, color, resources, pattern, dict, operatorList, task, localTilingPatternCache); } else if (typeNum === PatternType.SHADING) { const shading = dict.get(&quot;Shading&quot;); const matrix = dict.getArray(&quot;Matrix&quot;); const objId = this.parseShading({ shading, resources, localColorSpaceCache, localShadingPatternCache }); operatorList.addOp(fn, [&quot;Shading&quot;, objId, matrix]); return undefined; } throw new _util.FormatError(`Unknown PatternType: ${typeNum}`); } } throw new _util.FormatError(`Unknown PatternName: ${patternName}`); } _parseVisibilityExpression(array, nestingCounter, currentResult) { const MAX_NESTING = 10; if (++nestingCounter &gt; MAX_NESTING) { (0, _util.warn)(&quot;Visibility expression is too deeply nested&quot;); return; } const length = array.length; const operator = this.xref.fetchIfRef(array[0]); if (length &lt; 2 || !(operator instanceof _primitives.Name)) { (0, _util.warn)(&quot;Invalid visibility expression&quot;); return; } switch (operator.name) { case &quot;And&quot;: case &quot;Or&quot;: case &quot;Not&quot;: currentResult.push(operator.name); break; default: (0, _util.warn)(`Invalid operator ${operator.name} in visibility expression`); return; } for (let i = 1; i &lt; length; i++) { const raw = array[i]; const object = this.xref.fetchIfRef(raw); if (Array.isArray(object)) { const nestedResult = []; currentResult.push(nestedResult); this._parseVisibilityExpression(object, nestingCounter, nestedResult); } else if (raw instanceof _primitives.Ref) { currentResult.push(raw.toString()); } } } async parseMarkedContentProps(contentProperties, resources) { let optionalContent; if (contentProperties instanceof _primitives.Name) { const properties = resources.get(&quot;Properties&quot;); optionalContent = properties.get(contentProperties.name); } else if (contentProperties instanceof _primitives.Dict) { optionalContent = contentProperties; } else { throw new _util.FormatError(&quot;Optional content properties malformed.&quot;); } const optionalContentType = optionalContent.get(&quot;Type&quot;).name; if (optionalContentType === &quot;OCG&quot;) { return { type: optionalContentType, id: optionalContent.objId }; } else if (optionalContentType === &quot;OCMD&quot;) { const expression = optionalContent.get(&quot;VE&quot;); if (Array.isArray(expression)) { const result = []; this._parseVisibilityExpression(expression, 0, result); if (result.length &gt; 0) { return { type: &quot;OCMD&quot;, expression: result }; } } const optionalContentGroups = optionalContent.get(&quot;OCGs&quot;); if (Array.isArray(optionalContentGroups) || optionalContentGroups instanceof _primitives.Dict) { const groupIds = []; if (Array.isArray(optionalContentGroups)) { for (const ocg of optionalContentGroups) { groupIds.push(ocg.toString()); } } else { groupIds.push(optionalContentGroups.objId); } return { type: optionalContentType, ids: groupIds, policy: optionalContent.get(&quot;P&quot;) instanceof _primitives.Name ? optionalContent.get(&quot;P&quot;).name : null, expression: null }; } else if (optionalContentGroups instanceof _primitives.Ref) { return { type: optionalContentType, id: optionalContentGroups.toString() }; } } return null; } getOperatorList({ stream, task, resources, operatorList, initialState = null, fallbackFontDict = null }) { resources = resources || _primitives.Dict.empty; initialState = initialState || new EvalState(); if (!operatorList) { throw new Error(&apos;getOperatorList: missing &quot;operatorList&quot; parameter&apos;); } const self = this; const xref = this.xref; let parsingText = false; const localImageCache = new _image_utils.LocalImageCache(); const localColorSpaceCache = new _image_utils.LocalColorSpaceCache(); const localGStateCache = new _image_utils.LocalGStateCache(); const localTilingPatternCache = new _image_utils.LocalTilingPatternCache(); const localShadingPatternCache = new Map(); const xobjs = resources.get(&quot;XObject&quot;) || _primitives.Dict.empty; const patterns = resources.get(&quot;Pattern&quot;) || _primitives.Dict.empty; const stateManager = new StateManager(initialState); const preprocessor = new EvaluatorPreprocessor(stream, xref, stateManager); const timeSlotManager = new TimeSlotManager(); function closePendingRestoreOPS(argument) { for (let i = 0, ii = preprocessor.savedStatesDepth; i &lt; ii; i++) { operatorList.addOp(_util.OPS.restore, []); } } return new Promise(function promiseBody(resolve, reject) { const next = function (promise) { Promise.all([promise, operatorList.ready]).then(function () { try { promiseBody(resolve, reject); } catch (ex) { reject(ex); } }, reject); }; task.ensureNotTerminated(); timeSlotManager.reset(); const operation = {}; let stop, i, ii, cs, name, isValidName; while (!(stop = timeSlotManager.check())) { operation.args = null; if (!preprocessor.read(operation)) { break; } let args = operation.args; let fn = operation.fn; switch (fn | 0) { case _util.OPS.paintXObject: isValidName = args[0] instanceof _primitives.Name; name = args[0].name; if (isValidName) { const localImage = localImageCache.getByName(name); if (localImage) { operatorList.addImageOps(localImage.fn, localImage.args, localImage.optionalContent); incrementCachedImageMaskCount(localImage); args = null; continue; } } next(new Promise(function (resolveXObject, rejectXObject) { if (!isValidName) { throw new _util.FormatError(&quot;XObject must be referred to by name.&quot;); } let xobj = xobjs.getRaw(name); if (xobj instanceof _primitives.Ref) { const localImage = localImageCache.getByRef(xobj); if (localImage) { operatorList.addImageOps(localImage.fn, localImage.args, localImage.optionalContent); incrementCachedImageMaskCount(localImage); resolveXObject(); return; } const globalImage = self.globalImageCache.getData(xobj, self.pageIndex); if (globalImage) { operatorList.addDependency(globalImage.objId); operatorList.addImageOps(globalImage.fn, globalImage.args, globalImage.optionalContent); resolveXObject(); return; } xobj = xref.fetch(xobj); } if (!(xobj instanceof _base_stream.BaseStream)) { throw new _util.FormatError(&quot;XObject should be a stream&quot;); } const type = xobj.dict.get(&quot;Subtype&quot;); if (!(type instanceof _primitives.Name)) { throw new _util.FormatError(&quot;XObject should have a Name subtype&quot;); } if (type.name === &quot;Form&quot;) { stateManager.save(); self.buildFormXObject(resources, xobj, null, operatorList, task, stateManager.state.clone(), localColorSpaceCache).then(function () { stateManager.restore(); resolveXObject(); }, rejectXObject); return; } else if (type.name === &quot;Image&quot;) { self.buildPaintImageXObject({ resources, image: xobj, operatorList, cacheKey: name, localImageCache, localColorSpaceCache }).then(resolveXObject, rejectXObject); return; } else if (type.name === &quot;PS&quot;) { (0, _util.info)(&quot;Ignored XObject subtype PS&quot;); } else { throw new _util.FormatError(`Unhandled XObject subtype ${type.name}`); } resolveXObject(); }).catch(function (reason) { if (reason instanceof _util.AbortException) { return; } if (self.options.ignoreErrors) { self.handler.send(&quot;UnsupportedFeature&quot;, { featureId: _util.UNSUPPORTED_FEATURES.errorXObject }); (0, _util.warn)(`getOperatorList - ignoring XObject: &quot;${reason}&quot;.`); return; } throw reason; })); return; case _util.OPS.setFont: var fontSize = args[1]; next(self.handleSetFont(resources, args, null, operatorList, task, stateManager.state, fallbackFontDict).then(function (loadedName) { operatorList.addDependency(loadedName); operatorList.addOp(_util.OPS.setFont, [loadedName, fontSize]); })); return; case _util.OPS.beginText: parsingText = true; break; case _util.OPS.endText: parsingText = false; break; case _util.OPS.endInlineImage: var cacheKey = args[0].cacheKey; if (cacheKey) { const localImage = localImageCache.getByName(cacheKey); if (localImage) { operatorList.addImageOps(localImage.fn, localImage.args, localImage.optionalContent); incrementCachedImageMaskCount(localImage); args = null; continue; } } next(self.buildPaintImageXObject({ resources, image: args[0], isInline: true, operatorList, cacheKey, localImageCache, localColorSpaceCache })); return; case _util.OPS.showText: if (!stateManager.state.font) { self.ensureStateFont(stateManager.state); continue; } args[0] = self.handleText(args[0], stateManager.state); break; case _util.OPS.showSpacedText: if (!stateManager.state.font) { self.ensureStateFont(stateManager.state); continue; } var combinedGlyphs = []; var state = stateManager.state; for (const arrItem of args[0]) { if (typeof arrItem === &quot;string&quot;) { combinedGlyphs.push(...self.handleText(arrItem, state)); } else if (typeof arrItem === &quot;number&quot;) { combinedGlyphs.push(arrItem); } } args[0] = combinedGlyphs; fn = _util.OPS.showText; break; case _util.OPS.nextLineShowText: if (!stateManager.state.font) { self.ensureStateFont(stateManager.state); continue; } operatorList.addOp(_util.OPS.nextLine); args[0] = self.handleText(args[0], stateManager.state); fn = _util.OPS.showText; break; case _util.OPS.nextLineSetSpacingShowText: if (!stateManager.state.font) { self.ensureStateFont(stateManager.state); continue; } operatorList.addOp(_util.OPS.nextLine); operatorList.addOp(_util.OPS.setWordSpacing, [args.shift()]); operatorList.addOp(_util.OPS.setCharSpacing, [args.shift()]); args[0] = self.handleText(args[0], stateManager.state); fn = _util.OPS.showText; break; case _util.OPS.setTextRenderingMode: stateManager.state.textRenderingMode = args[0]; break; case _util.OPS.setFillColorSpace: { const cachedColorSpace = _colorspace.ColorSpace.getCached(args[0], xref, localColorSpaceCache); if (cachedColorSpace) { stateManager.state.fillColorSpace = cachedColorSpace; continue; } next(self.parseColorSpace({ cs: args[0], resources, localColorSpaceCache }).then(function (colorSpace) { if (colorSpace) { stateManager.state.fillColorSpace = colorSpace; } })); return; } case _util.OPS.setStrokeColorSpace: { const cachedColorSpace = _colorspace.ColorSpace.getCached(args[0], xref, localColorSpaceCache); if (cachedColorSpace) { stateManager.state.strokeColorSpace = cachedColorSpace; continue; } next(self.parseColorSpace({ cs: args[0], resources, localColorSpaceCache }).then(function (colorSpace) { if (colorSpace) { stateManager.state.strokeColorSpace = colorSpace; } })); return; } case _util.OPS.setFillColor: cs = stateManager.state.fillColorSpace; args = cs.getRgb(args, 0); fn = _util.OPS.setFillRGBColor; break; case _util.OPS.setStrokeColor: cs = stateManager.state.strokeColorSpace; args = cs.getRgb(args, 0); fn = _util.OPS.setStrokeRGBColor; break; case _util.OPS.setFillGray: stateManager.state.fillColorSpace = _colorspace.ColorSpace.singletons.gray; args = _colorspace.ColorSpace.singletons.gray.getRgb(args, 0); fn = _util.OPS.setFillRGBColor; break; case _util.OPS.setStrokeGray: stateManager.state.strokeColorSpace = _colorspace.ColorSpace.singletons.gray; args = _colorspace.ColorSpace.singletons.gray.getRgb(args, 0); fn = _util.OPS.setStrokeRGBColor; break; case _util.OPS.setFillCMYKColor: stateManager.state.fillColorSpace = _colorspace.ColorSpace.singletons.cmyk; args = _colorspace.ColorSpace.singletons.cmyk.getRgb(args, 0); fn = _util.OPS.setFillRGBColor; break; case _util.OPS.setStrokeCMYKColor: stateManager.state.strokeColorSpace = _colorspace.ColorSpace.singletons.cmyk; args = _colorspace.ColorSpace.singletons.cmyk.getRgb(args, 0); fn = _util.OPS.setStrokeRGBColor; break; case _util.OPS.setFillRGBColor: stateManager.state.fillColorSpace = _colorspace.ColorSpace.singletons.rgb; args = _colorspace.ColorSpace.singletons.rgb.getRgb(args, 0); break; case _util.OPS.setStrokeRGBColor: stateManager.state.strokeColorSpace = _colorspace.ColorSpace.singletons.rgb; args = _colorspace.ColorSpace.singletons.rgb.getRgb(args, 0); break; case _util.OPS.setFillColorN: cs = stateManager.state.fillColorSpace; if (cs.name === &quot;Pattern&quot;) { next(self.handleColorN(operatorList, _util.OPS.setFillColorN, args, cs, patterns, resources, task, localColorSpaceCache, localTilingPatternCache, localShadingPatternCache)); return; } args = cs.getRgb(args, 0); fn = _util.OPS.setFillRGBColor; break; case _util.OPS.setStrokeColorN: cs = stateManager.state.strokeColorSpace; if (cs.name === &quot;Pattern&quot;) { next(self.handleColorN(operatorList, _util.OPS.setStrokeColorN, args, cs, patterns, resources, task, localColorSpaceCache, localTilingPatternCache, localShadingPatternCache)); return; } args = cs.getRgb(args, 0); fn = _util.OPS.setStrokeRGBColor; break; case _util.OPS.shadingFill: var shadingRes = resources.get(&quot;Shading&quot;); if (!shadingRes) { throw new _util.FormatError(&quot;No shading resource found&quot;); } var shading = shadingRes.get(args[0].name); if (!shading) { throw new _util.FormatError(&quot;No shading object found&quot;); } const patternId = self.parseShading({ shading, resources, localColorSpaceCache, localShadingPatternCache }); args = [patternId]; fn = _util.OPS.shadingFill; break; case _util.OPS.setGState: isValidName = args[0] instanceof _primitives.Name; name = args[0].name; if (isValidName) { const localGStateObj = localGStateCache.getByName(name); if (localGStateObj) { if (localGStateObj.length &gt; 0) { operatorList.addOp(_util.OPS.setGState, [localGStateObj]); } args = null; continue; } } next(new Promise(function (resolveGState, rejectGState) { if (!isValidName) { throw new _util.FormatError(&quot;GState must be referred to by name.&quot;); } const extGState = resources.get(&quot;ExtGState&quot;); if (!(extGState instanceof _primitives.Dict)) { throw new _util.FormatError(&quot;ExtGState should be a dictionary.&quot;); } const gState = extGState.get(name); if (!(gState instanceof _primitives.Dict)) { throw new _util.FormatError(&quot;GState should be a dictionary.&quot;); } self.setGState({ resources, gState, operatorList, cacheKey: name, task, stateManager, localGStateCache, localColorSpaceCache }).then(resolveGState, rejectGState); }).catch(function (reason) { if (reason instanceof _util.AbortException) { return; } if (self.options.ignoreErrors) { self.handler.send(&quot;UnsupportedFeature&quot;, { featureId: _util.UNSUPPORTED_FEATURES.errorExtGState }); (0, _util.warn)(`getOperatorList - ignoring ExtGState: &quot;${reason}&quot;.`); return; } throw reason; })); return; case _util.OPS.moveTo: case _util.OPS.lineTo: case _util.OPS.curveTo: case _util.OPS.curveTo2: case _util.OPS.curveTo3: case _util.OPS.closePath: case _util.OPS.rectangle: self.buildPath(operatorList, fn, args, parsingText); continue; case _util.OPS.markPoint: case _util.OPS.markPointProps: case _util.OPS.beginCompat: case _util.OPS.endCompat: continue; case _util.OPS.beginMarkedContentProps: if (!(args[0] instanceof _primitives.Name)) { (0, _util.warn)(`Expected name for beginMarkedContentProps arg0=${args[0]}`); continue; } if (args[0].name === &quot;OC&quot;) { next(self.parseMarkedContentProps(args[1], resources).then(data =&gt; { operatorList.addOp(_util.OPS.beginMarkedContentProps, [&quot;OC&quot;, data]); }).catch(reason =&gt; { if (reason instanceof _util.AbortException) { return; } if (self.options.ignoreErrors) { self.handler.send(&quot;UnsupportedFeature&quot;, { featureId: _util.UNSUPPORTED_FEATURES.errorMarkedContent }); (0, _util.warn)(`getOperatorList - ignoring beginMarkedContentProps: &quot;${reason}&quot;.`); return; } throw reason; })); return; } args = [args[0].name, args[1] instanceof _primitives.Dict ? args[1].get(&quot;MCID&quot;) : null]; break; case _util.OPS.beginMarkedContent: case _util.OPS.endMarkedContent: default: if (args !== null) { for (i = 0, ii = args.length; i &lt; ii; i++) { if (args[i] instanceof _primitives.Dict) { break; } } if (i &lt; ii) { (0, _util.warn)(&quot;getOperatorList - ignoring operator: &quot; + fn); continue; } } } operatorList.addOp(fn, args); } if (stop) { next(deferred); return; } closePendingRestoreOPS(); resolve(); }).catch(reason =&gt; { if (reason instanceof _util.AbortException) { return; } if (this.options.ignoreErrors) { this.handler.send(&quot;UnsupportedFeature&quot;, { featureId: _util.UNSUPPORTED_FEATURES.errorOperatorList }); (0, _util.warn)(`getOperatorList - ignoring errors during &quot;${task.name}&quot; ` + `task: &quot;${reason}&quot;.`); closePendingRestoreOPS(); return; } throw reason; }); } getTextContent({ stream, task, resources, stateManager = null, combineTextItems = false, includeMarkedContent = false, sink, seenStyles = new Set(), viewBox }) { resources = resources || _primitives.Dict.empty; stateManager = stateManager || new StateManager(new TextState()); const NormalizedUnicodes = (0, _unicode.getNormalizedUnicodes)(); const textContent = { items: [], styles: Object.create(null) }; const textContentItem = { initialized: false, str: [], totalWidth: 0, totalHeight: 0, width: 0, height: 0, vertical: false, prevTransform: null, textAdvanceScale: 0, spaceInFlowMin: 0, spaceInFlowMax: 0, trackingSpaceMin: Infinity, negativeSpaceMax: -Infinity, notASpace: -Infinity, transform: null, fontName: null, hasEOL: false }; const twoLastChars = [&quot; &quot;, &quot; &quot;]; let twoLastCharsPos = 0; function saveLastChar(char) { const nextPos = (twoLastCharsPos + 1) % 2; const ret = twoLastChars[twoLastCharsPos] !== &quot; &quot; &amp;&amp; twoLastChars[nextPos] === &quot; &quot;; twoLastChars[twoLastCharsPos] = char; twoLastCharsPos = nextPos; return ret; } function resetLastChars() { twoLastChars[0] = twoLastChars[1] = &quot; &quot;; twoLastCharsPos = 0; } const TRACKING_SPACE_FACTOR = 0.1; const NOT_A_SPACE_FACTOR = 0.03; const NEGATIVE_SPACE_FACTOR = -0.2; const SPACE_IN_FLOW_MIN_FACTOR = 0.1; const SPACE_IN_FLOW_MAX_FACTOR = 0.6; const self = this; const xref = this.xref; const showSpacedTextBuffer = []; let xobjs = null; const emptyXObjectCache = new _image_utils.LocalImageCache(); const emptyGStateCache = new _image_utils.LocalGStateCache(); const preprocessor = new EvaluatorPreprocessor(stream, xref, stateManager); let textState; function getCurrentTextTransform() { const font = textState.font; const tsm = [textState.fontSize * textState.textHScale, 0, 0, textState.fontSize, 0, textState.textRise]; if (font.isType3Font &amp;&amp; (textState.fontSize &lt;= 1 || font.isCharBBox) &amp;&amp; !(0, _util.isArrayEqual)(textState.fontMatrix, _util.FONT_IDENTITY_MATRIX)) { const glyphHeight = font.bbox[3] - font.bbox[1]; if (glyphHeight &gt; 0) { tsm[3] *= glyphHeight * textState.fontMatrix[3]; } } return _util.Util.transform(textState.ctm, _util.Util.transform(textState.textMatrix, tsm)); } function ensureTextContentItem() { if (textContentItem.initialized) { return textContentItem; } const font = textState.font, loadedName = font.loadedName; if (!seenStyles.has(loadedName)) { seenStyles.add(loadedName); textContent.styles[loadedName] = { fontFamily: font.fallbackName, ascent: font.ascent, descent: font.descent, vertical: font.vertical }; } textContentItem.fontName = loadedName; const trm = textContentItem.transform = getCurrentTextTransform(); if (!font.vertical) { textContentItem.width = textContentItem.totalWidth = 0; textContentItem.height = textContentItem.totalHeight = Math.hypot(trm[2], trm[3]); textContentItem.vertical = false; } else { textContentItem.width = textContentItem.totalWidth = Math.hypot(trm[0], trm[1]); textContentItem.height = textContentItem.totalHeight = 0; textContentItem.vertical = true; } const scaleLineX = Math.hypot(textState.textLineMatrix[0], textState.textLineMatrix[1]); const scaleCtmX = Math.hypot(textState.ctm[0], textState.ctm[1]); textContentItem.textAdvanceScale = scaleCtmX * scaleLineX; textContentItem.trackingSpaceMin = textState.fontSize * TRACKING_SPACE_FACTOR; textContentItem.notASpace = textState.fontSize * NOT_A_SPACE_FACTOR; textContentItem.negativeSpaceMax = textState.fontSize * NEGATIVE_SPACE_FACTOR; textContentItem.spaceInFlowMin = textState.fontSize * SPACE_IN_FLOW_MIN_FACTOR; textContentItem.spaceInFlowMax = textState.fontSize * SPACE_IN_FLOW_MAX_FACTOR; textContentItem.hasEOL = false; textContentItem.initialized = true; return textContentItem; } function updateAdvanceScale() { if (!textContentItem.initialized) { return; } const scaleLineX = Math.hypot(textState.textLineMatrix[0], textState.textLineMatrix[1]); const scaleCtmX = Math.hypot(textState.ctm[0], textState.ctm[1]); const scaleFactor = scaleCtmX * scaleLineX; if (scaleFactor === textContentItem.textAdvanceScale) { return; } if (!textContentItem.vertical) { textContentItem.totalWidth += textContentItem.width * textContentItem.textAdvanceScale; textContentItem.width = 0; } else { textContentItem.totalHeight += textContentItem.height * textContentItem.textAdvanceScale; textContentItem.height = 0; } textContentItem.textAdvanceScale = scaleFactor; } function runBidiTransform(textChunk) { const text = textChunk.str.join(&quot;&quot;); const bidiResult = (0, _bidi.bidi)(text, -1, textChunk.vertical); return { str: bidiResult.str, dir: bidiResult.dir, width: Math.abs(textChunk.totalWidth), height: Math.abs(textChunk.totalHeight), transform: textChunk.transform, fontName: textChunk.fontName, hasEOL: textChunk.hasEOL }; } function handleSetFont(fontName, fontRef) { return self.loadFont(fontName, fontRef, resources).then(function (translated) { if (!translated.font.isType3Font) { return translated; } return translated.loadType3Data(self, resources, task).catch(function () {}).then(function () { return translated; }); }).then(function (translated) { textState.font = translated.font; textState.fontMatrix = translated.font.fontMatrix || _util.FONT_IDENTITY_MATRIX; }); } function applyInverseRotation(x, y, matrix) { const scale = Math.hypot(matrix[0], matrix[1]); return [(matrix[0] * x + matrix[1] * y) / scale, (matrix[2] * x + matrix[3] * y) / scale]; } function compareWithLastPosition() { const currentTransform = getCurrentTextTransform(); let posX = currentTransform[4]; let posY = currentTransform[5]; const shiftedX = posX - viewBox[0]; const shiftedY = posY - viewBox[1]; if (shiftedX &lt; 0 || shiftedX &gt; viewBox[2] || shiftedY &lt; 0 || shiftedY &gt; viewBox[3]) { return false; } if (!combineTextItems || !textState.font || !textContentItem.prevTransform) { return true; } let lastPosX = textContentItem.prevTransform[4]; let lastPosY = textContentItem.prevTransform[5]; if (lastPosX === posX &amp;&amp; lastPosY === posY) { return true; } let rotate = -1; if (currentTransform[0] &amp;&amp; currentTransform[1] === 0 &amp;&amp; currentTransform[2] === 0) { rotate = currentTransform[0] &gt; 0 ? 0 : 180; } else if (currentTransform[1] &amp;&amp; currentTransform[0] === 0 &amp;&amp; currentTransform[3] === 0) { rotate = currentTransform[1] &gt; 0 ? 90 : 270; } switch (rotate) { case 0: break; case 90: [posX, posY] = [posY, posX]; [lastPosX, lastPosY] = [lastPosY, lastPosX]; break; case 180: [posX, posY, lastPosX, lastPosY] = [-posX, -posY, -lastPosX, -lastPosY]; break; case 270: [posX, posY] = [-posY, -posX]; [lastPosX, lastPosY] = [-lastPosY, -lastPosX]; break; default: [posX, posY] = applyInverseRotation(posX, posY, currentTransform); [lastPosX, lastPosY] = applyInverseRotation(lastPosX, lastPosY, textContentItem.prevTransform); } if (textState.font.vertical) { const advanceY = (lastPosY - posY) / textContentItem.textAdvanceScale; const advanceX = posX - lastPosX; const textOrientation = Math.sign(textContentItem.height); if (advanceY &lt; textOrientation * textContentItem.negativeSpaceMax) { if (Math.abs(advanceX) &gt; 0.5 * textContentItem.width) { appendEOL(); return true; } resetLastChars(); flushTextContentItem(); return true; } if (Math.abs(advanceX) &gt; textContentItem.width) { appendEOL(); return true; } if (advanceY &lt;= textOrientation * textContentItem.notASpace) { resetLastChars(); } if (advanceY &lt;= textOrientation * textContentItem.trackingSpaceMin) { textContentItem.height += advanceY; } else if (!addFakeSpaces(advanceY, textContentItem.prevTransform, textOrientation)) { if (textContentItem.str.length === 0) { resetLastChars(); textContent.items.push({ str: &quot; &quot;, dir: &quot;ltr&quot;, width: 0, height: Math.abs(advanceY), transform: textContentItem.prevTransform, fontName: textContentItem.fontName, hasEOL: false }); } else { textContentItem.height += advanceY; } } return true; } const advanceX = (posX - lastPosX) / textContentItem.textAdvanceScale; const advanceY = posY - lastPosY; const textOrientation = Math.sign(textContentItem.width); if (advanceX &lt; textOrientation * textContentItem.negativeSpaceMax) { if (Math.abs(advanceY) &gt; 0.5 * textContentItem.height) { appendEOL(); return true; } resetLastChars(); flushTextContentItem(); return true; } if (Math.abs(advanceY) &gt; textContentItem.height) { appendEOL(); return true; } if (advanceX &lt;= textOrientation * textContentItem.notASpace) { resetLastChars(); } if (advanceX &lt;= textOrientation * textContentItem.trackingSpaceMin) { textContentItem.width += advanceX; } else if (!addFakeSpaces(advanceX, textContentItem.prevTransform, textOrientation)) { if (textContentItem.str.length === 0) { resetLastChars(); textContent.items.push({ str: &quot; &quot;, dir: &quot;ltr&quot;, width: Math.abs(advanceX), height: 0, transform: textContentItem.prevTransform, fontName: textContentItem.fontName, hasEOL: false }); } else { textContentItem.width += advanceX; } } return true; } function buildTextContentItem({ chars, extraSpacing }) { const font = textState.font; if (!chars) { const charSpacing = textState.charSpacing + extraSpacing; if (charSpacing) { if (!font.vertical) { textState.translateTextMatrix(charSpacing * textState.textHScale, 0); } else { textState.translateTextMatrix(0, -charSpacing); } } return; } const glyphs = font.charsToGlyphs(chars); const scale = textState.fontMatrix[0] * textState.fontSize; for (let i = 0, ii = glyphs.length; i &lt; ii; i++) { const glyph = glyphs[i]; if (glyph.isInvisibleFormatMark) { continue; } let charSpacing = textState.charSpacing + (i + 1 === ii ? extraSpacing : 0); let glyphWidth = glyph.width; if (font.vertical) { glyphWidth = glyph.vmetric ? glyph.vmetric[0] : -glyphWidth; } let scaledDim = glyphWidth * scale; if (glyph.isWhitespace) { if (!font.vertical) { charSpacing += scaledDim + textState.wordSpacing; textState.translateTextMatrix(charSpacing * textState.textHScale, 0); } else { charSpacing += -scaledDim + textState.wordSpacing; textState.translateTextMatrix(0, -charSpacing); } saveLastChar(&quot; &quot;); continue; } if (!compareWithLastPosition()) { continue; } const textChunk = ensureTextContentItem(); if (glyph.isZeroWidthDiacritic) { scaledDim = 0; } if (!font.vertical) { scaledDim *= textState.textHScale; textState.translateTextMatrix(scaledDim, 0); textChunk.width += scaledDim; } else { textState.translateTextMatrix(0, scaledDim); scaledDim = Math.abs(scaledDim); textChunk.height += scaledDim; } if (scaledDim) { textChunk.prevTransform = getCurrentTextTransform(); } let glyphUnicode = glyph.unicode; glyphUnicode = NormalizedUnicodes[glyphUnicode] || glyphUnicode; glyphUnicode = (0, _unicode.reverseIfRtl)(glyphUnicode); if (saveLastChar(glyphUnicode)) { textChunk.str.push(&quot; &quot;); } textChunk.str.push(glyphUnicode); if (charSpacing) { if (!font.vertical) { textState.translateTextMatrix(charSpacing * textState.textHScale, 0); } else { textState.translateTextMatrix(0, -charSpacing); } } } } function appendEOL() { resetLastChars(); if (textContentItem.initialized) { textContentItem.hasEOL = true; flushTextContentItem(); } else { textContent.items.push({ str: &quot;&quot;, dir: &quot;ltr&quot;, width: 0, height: 0, transform: getCurrentTextTransform(), fontName: textState.font.loadedName, hasEOL: true }); } } function addFakeSpaces(width, transf, textOrientation) { if (textOrientation * textContentItem.spaceInFlowMin &lt;= width &amp;&amp; width &lt;= textOrientation * textContentItem.spaceInFlowMax) { if (textContentItem.initialized) { resetLastChars(); textContentItem.str.push(&quot; &quot;); } return false; } const fontName = textContentItem.fontName; let height = 0; if (textContentItem.vertical) { height = width; width = 0; } flushTextContentItem(); resetLastChars(); textContent.items.push({ str: &quot; &quot;, dir: &quot;ltr&quot;, width: Math.abs(width), height: Math.abs(height), transform: transf || getCurrentTextTransform(), fontName, hasEOL: false }); return true; } function flushTextContentItem() { if (!textContentItem.initialized || !textContentItem.str) { return; } if (!textContentItem.vertical) { textContentItem.totalWidth += textContentItem.width * textContentItem.textAdvanceScale; } else { textContentItem.totalHeight += textContentItem.height * textContentItem.textAdvanceScale; } textContent.items.push(runBidiTransform(textContentItem)); textContentItem.initialized = false; textContentItem.str.length = 0; } function enqueueChunk(batch = false) { const length = textContent.items.length; if (length === 0) { return; } if (batch &amp;&amp; length &lt; TEXT_CHUNK_BATCH_SIZE) { return; } sink.enqueue(textContent, length); textContent.items = []; textContent.styles = Object.create(null); } const timeSlotManager = new TimeSlotManager(); return new Promise(function promiseBody(resolve, reject) { const next = function (promise) { enqueueChunk(true); Promise.all([promise, sink.ready]).then(function () { try { promiseBody(resolve, reject); } catch (ex) { reject(ex); } }, reject); }; task.ensureNotTerminated(); timeSlotManager.reset(); const operation = {}; let stop, args = []; while (!(stop = timeSlotManager.check())) { args.length = 0; operation.args = args; if (!preprocessor.read(operation)) { break; } textState = stateManager.state; const fn = operation.fn; args = operation.args; switch (fn | 0) { case _util.OPS.setFont: var fontNameArg = args[0].name, fontSizeArg = args[1]; if (textState.font &amp;&amp; fontNameArg === textState.fontName &amp;&amp; fontSizeArg === textState.fontSize) { break; } flushTextContentItem(); textState.fontName = fontNameArg; textState.fontSize = fontSizeArg; next(handleSetFont(fontNameArg, null)); return; case _util.OPS.setTextRise: textState.textRise = args[0]; break; case _util.OPS.setHScale: textState.textHScale = args[0] / 100; break; case _util.OPS.setLeading: textState.leading = args[0]; break; case _util.OPS.moveText: textState.translateTextLineMatrix(args[0], args[1]); textState.textMatrix = textState.textLineMatrix.slice(); break; case _util.OPS.setLeadingMoveText: textState.leading = -args[1]; textState.translateTextLineMatrix(args[0], args[1]); textState.textMatrix = textState.textLineMatrix.slice(); break; case _util.OPS.nextLine: textState.carriageReturn(); break; case _util.OPS.setTextMatrix: textState.setTextMatrix(args[0], args[1], args[2], args[3], args[4], args[5]); textState.setTextLineMatrix(args[0], args[1], args[2], args[3], args[4], args[5]); updateAdvanceScale(); break; case _util.OPS.setCharSpacing: textState.charSpacing = args[0]; break; case _util.OPS.setWordSpacing: textState.wordSpacing = args[0]; break; case _util.OPS.beginText: textState.textMatrix = _util.IDENTITY_MATRIX.slice(); textState.textLineMatrix = _util.IDENTITY_MATRIX.slice(); break; case _util.OPS.showSpacedText: if (!stateManager.state.font) { self.ensureStateFont(stateManager.state); continue; } const spaceFactor = (textState.font.vertical ? 1 : -1) * textState.fontSize / 1000; const elements = args[0]; for (let i = 0, ii = elements.length; i &lt; ii - 1; i++) { const item = elements[i]; if (typeof item === &quot;string&quot;) { showSpacedTextBuffer.push(item); } else if (typeof item === &quot;number&quot; &amp;&amp; item !== 0) { const str = showSpacedTextBuffer.join(&quot;&quot;); showSpacedTextBuffer.length = 0; buildTextContentItem({ chars: str, extraSpacing: item * spaceFactor }); } } const item = elements.at(-1); if (typeof item === &quot;string&quot;) { showSpacedTextBuffer.push(item); } if (showSpacedTextBuffer.length &gt; 0) { const str = showSpacedTextBuffer.join(&quot;&quot;); showSpacedTextBuffer.length = 0; buildTextContentItem({ chars: str, extraSpacing: 0 }); } break; case _util.OPS.showText: if (!stateManager.state.font) { self.ensureStateFont(stateManager.state); continue; } buildTextContentItem({ chars: args[0], extraSpacing: 0 }); break; case _util.OPS.nextLineShowText: if (!stateManager.state.font) { self.ensureStateFont(stateManager.state); continue; } textState.carriageReturn(); buildTextContentItem({ chars: args[0], extraSpacing: 0 }); break; case _util.OPS.nextLineSetSpacingShowText: if (!stateManager.state.font) { self.ensureStateFont(stateManager.state); continue; } textState.wordSpacing = args[0]; textState.charSpacing = args[1]; textState.carriageReturn(); buildTextContentItem({ chars: args[2], extraSpacing: 0 }); break; case _util.OPS.paintXObject: flushTextContentItem(); if (!xobjs) { xobjs = resources.get(&quot;XObject&quot;) || _primitives.Dict.empty; } var isValidName = args[0] instanceof _primitives.Name; var name = args[0].name; if (isValidName &amp;&amp; emptyXObjectCache.getByName(name)) { break; } next(new Promise(function (resolveXObject, rejectXObject) { if (!isValidName) { throw new _util.FormatError(&quot;XObject must be referred to by name.&quot;); } let xobj = xobjs.getRaw(name); if (xobj instanceof _primitives.Ref) { if (emptyXObjectCache.getByRef(xobj)) { resolveXObject(); return; } const globalImage = self.globalImageCache.getData(xobj, self.pageIndex); if (globalImage) { resolveXObject(); return; } xobj = xref.fetch(xobj); } if (!(xobj instanceof _base_stream.BaseStream)) { throw new _util.FormatError(&quot;XObject should be a stream&quot;); } const type = xobj.dict.get(&quot;Subtype&quot;); if (!(type instanceof _primitives.Name)) { throw new _util.FormatError(&quot;XObject should have a Name subtype&quot;); } if (type.name !== &quot;Form&quot;) { emptyXObjectCache.set(name, xobj.dict.objId, true); resolveXObject(); return; } const currentState = stateManager.state.clone(); const xObjStateManager = new StateManager(currentState); const matrix = xobj.dict.getArray(&quot;Matrix&quot;); if (Array.isArray(matrix) &amp;&amp; matrix.length === 6) { xObjStateManager.transform(matrix); } enqueueChunk(); const sinkWrapper = { enqueueInvoked: false, enqueue(chunk, size) { this.enqueueInvoked = true; sink.enqueue(chunk, size); }, get desiredSize() { return sink.desiredSize; }, get ready() { return sink.ready; } }; self.getTextContent({ stream: xobj, task, resources: xobj.dict.get(&quot;Resources&quot;) || resources, stateManager: xObjStateManager, combineTextItems, includeMarkedContent, sink: sinkWrapper, seenStyles, viewBox }).then(function () { if (!sinkWrapper.enqueueInvoked) { emptyXObjectCache.set(name, xobj.dict.objId, true); } resolveXObject(); }, rejectXObject); }).catch(function (reason) { if (reason instanceof _util.AbortException) { return; } if (self.options.ignoreErrors) { (0, _util.warn)(`getTextContent - ignoring XObject: &quot;${reason}&quot;.`); return; } throw reason; })); return; case _util.OPS.setGState: isValidName = args[0] instanceof _primitives.Name; name = args[0].name; if (isValidName &amp;&amp; emptyGStateCache.getByName(name)) { break; } next(new Promise(function (resolveGState, rejectGState) { if (!isValidName) { throw new _util.FormatError(&quot;GState must be referred to by name.&quot;); } const extGState = resources.get(&quot;ExtGState&quot;); if (!(extGState instanceof _primitives.Dict)) { throw new _util.FormatError(&quot;ExtGState should be a dictionary.&quot;); } const gState = extGState.get(name); if (!(gState instanceof _primitives.Dict)) { throw new _util.FormatError(&quot;GState should be a dictionary.&quot;); } const gStateFont = gState.get(&quot;Font&quot;); if (!gStateFont) { emptyGStateCache.set(name, gState.objId, true); resolveGState(); return; } flushTextContentItem(); textState.fontName = null; textState.fontSize = gStateFont[1]; handleSetFont(null, gStateFont[0]).then(resolveGState, rejectGState); }).catch(function (reason) { if (reason instanceof _util.AbortException) { return; } if (self.options.ignoreErrors) { (0, _util.warn)(`getTextContent - ignoring ExtGState: &quot;${reason}&quot;.`); return; } throw reason; })); return; case _util.OPS.beginMarkedContent: flushTextContentItem(); if (includeMarkedContent) { textContent.items.push({ type: &quot;beginMarkedContent&quot;, tag: args[0] instanceof _primitives.Name ? args[0].name : null }); } break; case _util.OPS.beginMarkedContentProps: flushTextContentItem(); if (includeMarkedContent) { let mcid = null; if (args[1] instanceof _primitives.Dict) { mcid = args[1].get(&quot;MCID&quot;); } textContent.items.push({ type: &quot;beginMarkedContentProps&quot;, id: Number.isInteger(mcid) ? `${self.idFactory.getPageObjId()}_mcid${mcid}` : null, tag: args[0] instanceof _primitives.Name ? args[0].name : null }); } break; case _util.OPS.endMarkedContent: flushTextContentItem(); if (includeMarkedContent) { textContent.items.push({ type: &quot;endMarkedContent&quot; }); } break; } if (textContent.items.length &gt;= sink.desiredSize) { stop = true; break; } } if (stop) { next(deferred); return; } flushTextContentItem(); enqueueChunk(); resolve(); }).catch(reason =&gt; { if (reason instanceof _util.AbortException) { return; } if (this.options.ignoreErrors) { (0, _util.warn)(`getTextContent - ignoring errors during &quot;${task.name}&quot; ` + `task: &quot;${reason}&quot;.`); flushTextContentItem(); enqueueChunk(); return; } throw reason; }); } extractDataStructures(dict, baseDict, properties) { const xref = this.xref; let cidToGidBytes; const toUnicodePromise = this.readToUnicode(properties.toUnicode || dict.get(&quot;ToUnicode&quot;) || baseDict.get(&quot;ToUnicode&quot;)); if (properties.composite) { const cidSystemInfo = dict.get(&quot;CIDSystemInfo&quot;); if (cidSystemInfo instanceof _primitives.Dict) { properties.cidSystemInfo = { registry: (0, _util.stringToPDFString)(cidSystemInfo.get(&quot;Registry&quot;)), ordering: (0, _util.stringToPDFString)(cidSystemInfo.get(&quot;Ordering&quot;)), supplement: cidSystemInfo.get(&quot;Supplement&quot;) }; } try { const cidToGidMap = dict.get(&quot;CIDToGIDMap&quot;); if (cidToGidMap instanceof _base_stream.BaseStream) { cidToGidBytes = cidToGidMap.getBytes(); } } catch (ex) { if (!this.options.ignoreErrors) { throw ex; } (0, _util.warn)(`extractDataStructures - ignoring CIDToGIDMap data: &quot;${ex}&quot;.`); } } const differences = []; let baseEncodingName = null; let encoding; if (dict.has(&quot;Encoding&quot;)) { encoding = dict.get(&quot;Encoding&quot;); if (encoding instanceof _primitives.Dict) { baseEncodingName = encoding.get(&quot;BaseEncoding&quot;); baseEncodingName = baseEncodingName instanceof _primitives.Name ? baseEncodingName.name : null; if (encoding.has(&quot;Differences&quot;)) { const diffEncoding = encoding.get(&quot;Differences&quot;); let index = 0; for (const entry of diffEncoding) { const data = xref.fetchIfRef(entry); if (typeof data === &quot;number&quot;) { index = data; } else if (data instanceof _primitives.Name) { differences[index++] = data.name; } else { throw new _util.FormatError(`Invalid entry in &apos;Differences&apos; array: ${data}`); } } } } else if (encoding instanceof _primitives.Name) { baseEncodingName = encoding.name; } else { const msg = &quot;Encoding is not a Name nor a Dict&quot;; if (!this.options.ignoreErrors) { throw new _util.FormatError(msg); } (0, _util.warn)(msg); } if (baseEncodingName !== &quot;MacRomanEncoding&quot; &amp;&amp; baseEncodingName !== &quot;MacExpertEncoding&quot; &amp;&amp; baseEncodingName !== &quot;WinAnsiEncoding&quot;) { baseEncodingName = null; } } if (baseEncodingName) { properties.defaultEncoding = (0, _encodings.getEncoding)(baseEncodingName); } else { const isSymbolicFont = !!(properties.flags &amp; _fonts_utils.FontFlags.Symbolic); const isNonsymbolicFont = !!(properties.flags &amp; _fonts_utils.FontFlags.Nonsymbolic); encoding = _encodings.StandardEncoding; if (properties.type === &quot;TrueType&quot; &amp;&amp; !isNonsymbolicFont) { encoding = _encodings.WinAnsiEncoding; } if (isSymbolicFont) { encoding = _encodings.MacRomanEncoding; if (!properties.file || properties.isInternalFont) { if (/Symbol/i.test(properties.name)) { encoding = _encodings.SymbolSetEncoding; } else if (/Dingbats|Wingdings/i.test(properties.name)) { encoding = _encodings.ZapfDingbatsEncoding; } } } properties.defaultEncoding = encoding; } properties.differences = differences; properties.baseEncodingName = baseEncodingName; properties.hasEncoding = !!baseEncodingName || differences.length &gt; 0; properties.dict = dict; return toUnicodePromise.then(readToUnicode =&gt; { properties.toUnicode = readToUnicode; return this.buildToUnicode(properties); }).then(builtToUnicode =&gt; { properties.toUnicode = builtToUnicode; if (cidToGidBytes) { properties.cidToGidMap = this.readCidToGidMap(cidToGidBytes, builtToUnicode); } return properties; }); } _simpleFontToUnicode(properties, forceGlyphs = false) { (0, _util.assert)(!properties.composite, &quot;Must be a simple font.&quot;); const toUnicode = []; const encoding = properties.defaultEncoding.slice(); const baseEncodingName = properties.baseEncodingName; const differences = properties.differences; for (const charcode in differences) { const glyphName = differences[charcode]; if (glyphName === &quot;.notdef&quot;) { continue; } encoding[charcode] = glyphName; } const glyphsUnicodeMap = (0, _glyphlist.getGlyphsUnicode)(); for (const charcode in encoding) { let glyphName = encoding[charcode]; if (glyphName === &quot;&quot;) { continue; } let unicode = glyphsUnicodeMap[glyphName]; if (unicode !== undefined) { toUnicode[charcode] = String.fromCharCode(unicode); continue; } let code = 0; switch (glyphName[0]) { case &quot;G&quot;: if (glyphName.length === 3) { code = parseInt(glyphName.substring(1), 16); } break; case &quot;g&quot;: if (glyphName.length === 5) { code = parseInt(glyphName.substring(1), 16); } break; case &quot;C&quot;: case &quot;c&quot;: if (glyphName.length &gt;= 3 &amp;&amp; glyphName.length &lt;= 4) { const codeStr = glyphName.substring(1); if (forceGlyphs) { code = parseInt(codeStr, 16); break; } code = +codeStr; if (Number.isNaN(code) &amp;&amp; Number.isInteger(parseInt(codeStr, 16))) { return this._simpleFontToUnicode(properties, true); } } break; case &quot;u&quot;: unicode = (0, _unicode.getUnicodeForGlyph)(glyphName, glyphsUnicodeMap); if (unicode !== -1) { code = unicode; } break; } if (code &gt; 0 &amp;&amp; code &lt;= 0x10ffff &amp;&amp; Number.isInteger(code)) { if (baseEncodingName &amp;&amp; code === +charcode) { const baseEncoding = (0, _encodings.getEncoding)(baseEncodingName); if (baseEncoding &amp;&amp; (glyphName = baseEncoding[charcode])) { toUnicode[charcode] = String.fromCharCode(glyphsUnicodeMap[glyphName]); continue; } } toUnicode[charcode] = String.fromCodePoint(code); } } return toUnicode; } async buildToUnicode(properties) { properties.hasIncludedToUnicodeMap = !!properties.toUnicode &amp;&amp; properties.toUnicode.length &gt; 0; if (properties.hasIncludedToUnicodeMap) { if (!properties.composite &amp;&amp; properties.hasEncoding) { properties.fallbackToUnicode = this._simpleFontToUnicode(properties); } return properties.toUnicode; } if (!properties.composite) { return new _to_unicode_map.ToUnicodeMap(this._simpleFontToUnicode(properties)); } if (properties.composite &amp;&amp; (properties.cMap.builtInCMap &amp;&amp; !(properties.cMap instanceof _cmap.IdentityCMap) || properties.cidSystemInfo.registry === &quot;Adobe&quot; &amp;&amp; (properties.cidSystemInfo.ordering === &quot;GB1&quot; || properties.cidSystemInfo.ordering === &quot;CNS1&quot; || properties.cidSystemInfo.ordering === &quot;Japan1&quot; || properties.cidSystemInfo.ordering === &quot;Korea1&quot;))) { const { registry, ordering } = properties.cidSystemInfo; const ucs2CMapName = _primitives.Name.get(`${registry}-${ordering}-UCS2`); const ucs2CMap = await _cmap.CMapFactory.create({ encoding: ucs2CMapName, fetchBuiltInCMap: this._fetchBuiltInCMapBound, useCMap: null }); const toUnicode = []; properties.cMap.forEach(function (charcode, cid) { if (cid &gt; 0xffff) { throw new _util.FormatError(&quot;Max size of CID is 65,535&quot;); } const ucs2 = ucs2CMap.lookup(cid); if (ucs2) { toUnicode[charcode] = String.fromCharCode((ucs2.charCodeAt(0) &lt;&lt; 8) + ucs2.charCodeAt(1)); } }); return new _to_unicode_map.ToUnicodeMap(toUnicode); } return new _to_unicode_map.IdentityToUnicodeMap(properties.firstChar, properties.lastChar); } readToUnicode(cmapObj) { if (!cmapObj) { return Promise.resolve(null); } if (cmapObj instanceof _primitives.Name) { return _cmap.CMapFactory.create({ encoding: cmapObj, fetchBuiltInCMap: this._fetchBuiltInCMapBound, useCMap: null }).then(function (cmap) { if (cmap instanceof _cmap.IdentityCMap) { return new _to_unicode_map.IdentityToUnicodeMap(0, 0xffff); } return new _to_unicode_map.ToUnicodeMap(cmap.getMap()); }); } else if (cmapObj instanceof _base_stream.BaseStream) { return _cmap.CMapFactory.create({ encoding: cmapObj, fetchBuiltInCMap: this._fetchBuiltInCMapBound, useCMap: null }).then(function (cmap) { if (cmap instanceof _cmap.IdentityCMap) { return new _to_unicode_map.IdentityToUnicodeMap(0, 0xffff); } const map = new Array(cmap.length); cmap.forEach(function (charCode, token) { if (typeof token === &quot;number&quot;) { map[charCode] = String.fromCodePoint(token); return; } const str = []; for (let k = 0; k &lt; token.length; k += 2) { const w1 = token.charCodeAt(k) &lt;&lt; 8 | token.charCodeAt(k + 1); if ((w1 &amp; 0xf800) !== 0xd800) { str.push(w1); continue; } k += 2; const w2 = token.charCodeAt(k) &lt;&lt; 8 | token.charCodeAt(k + 1); str.push(((w1 &amp; 0x3ff) &lt;&lt; 10) + (w2 &amp; 0x3ff) + 0x10000); } map[charCode] = String.fromCodePoint(...str); }); return new _to_unicode_map.ToUnicodeMap(map); }, reason =&gt; { if (reason instanceof _util.AbortException) { return null; } if (this.options.ignoreErrors) { this.handler.send(&quot;UnsupportedFeature&quot;, { featureId: _util.UNSUPPORTED_FEATURES.errorFontToUnicode }); (0, _util.warn)(`readToUnicode - ignoring ToUnicode data: &quot;${reason}&quot;.`); return null; } throw reason; }); } return Promise.resolve(null); } readCidToGidMap(glyphsData, toUnicode) { const result = []; for (let j = 0, jj = glyphsData.length; j &lt; jj; j++) { const glyphID = glyphsData[j++] &lt;&lt; 8 | glyphsData[j]; const code = j &gt;&gt; 1; if (glyphID === 0 &amp;&amp; !toUnicode.has(code)) { continue; } result[code] = glyphID; } return result; } extractWidths(dict, descriptor, properties) { const xref = this.xref; let glyphsWidths = []; let defaultWidth = 0; const glyphsVMetrics = []; let defaultVMetrics; let i, ii, j, jj, start, code, widths; if (properties.composite) { defaultWidth = dict.has(&quot;DW&quot;) ? dict.get(&quot;DW&quot;) : 1000; widths = dict.get(&quot;W&quot;); if (widths) { for (i = 0, ii = widths.length; i &lt; ii; i++) { start = xref.fetchIfRef(widths[i++]); code = xref.fetchIfRef(widths[i]); if (Array.isArray(code)) { for (j = 0, jj = code.length; j &lt; jj; j++) { glyphsWidths[start++] = xref.fetchIfRef(code[j]); } } else { const width = xref.fetchIfRef(widths[++i]); for (j = start; j &lt;= code; j++) { glyphsWidths[j] = width; } } } } if (properties.vertical) { let vmetrics = dict.getArray(&quot;DW2&quot;) || [880, -1000]; defaultVMetrics = [vmetrics[1], defaultWidth * 0.5, vmetrics[0]]; vmetrics = dict.get(&quot;W2&quot;); if (vmetrics) { for (i = 0, ii = vmetrics.length; i &lt; ii; i++) { start = xref.fetchIfRef(vmetrics[i++]); code = xref.fetchIfRef(vmetrics[i]); if (Array.isArray(code)) { for (j = 0, jj = code.length; j &lt; jj; j++) { glyphsVMetrics[start++] = [xref.fetchIfRef(code[j++]), xref.fetchIfRef(code[j++]), xref.fetchIfRef(code[j])]; } } else { const vmetric = [xref.fetchIfRef(vmetrics[++i]), xref.fetchIfRef(vmetrics[++i]), xref.fetchIfRef(vmetrics[++i])]; for (j = start; j &lt;= code; j++) { glyphsVMetrics[j] = vmetric; } } } } } } else { const firstChar = properties.firstChar; widths = dict.get(&quot;Widths&quot;); if (widths) { j = firstChar; for (i = 0, ii = widths.length; i &lt; ii; i++) { glyphsWidths[j++] = xref.fetchIfRef(widths[i]); } defaultWidth = parseFloat(descriptor.get(&quot;MissingWidth&quot;)) || 0; } else { const baseFontName = dict.get(&quot;BaseFont&quot;); if (baseFontName instanceof _primitives.Name) { const metrics = this.getBaseFontMetrics(baseFontName.name); glyphsWidths = this.buildCharCodeToWidth(metrics.widths, properties); defaultWidth = metrics.defaultWidth; } } } let isMonospace = true; let firstWidth = defaultWidth; for (const glyph in glyphsWidths) { const glyphWidth = glyphsWidths[glyph]; if (!glyphWidth) { continue; } if (!firstWidth) { firstWidth = glyphWidth; continue; } if (firstWidth !== glyphWidth) { isMonospace = false; break; } } if (isMonospace) { properties.flags |= _fonts_utils.FontFlags.FixedPitch; } properties.defaultWidth = defaultWidth; properties.widths = glyphsWidths; properties.defaultVMetrics = defaultVMetrics; properties.vmetrics = glyphsVMetrics; } isSerifFont(baseFontName) { const fontNameWoStyle = baseFontName.split(&quot;-&quot;)[0]; return fontNameWoStyle in (0, _standard_fonts.getSerifFonts)() || /serif/gi.test(fontNameWoStyle); } getBaseFontMetrics(name) { let defaultWidth = 0; let widths = Object.create(null); let monospace = false; const stdFontMap = (0, _standard_fonts.getStdFontMap)(); let lookupName = stdFontMap[name] || name; const Metrics = (0, _metrics.getMetrics)(); if (!(lookupName in Metrics)) { if (this.isSerifFont(name)) { lookupName = &quot;Times-Roman&quot;; } else { lookupName = &quot;Helvetica&quot;; } } const glyphWidths = Metrics[lookupName]; if (typeof glyphWidths === &quot;number&quot;) { defaultWidth = glyphWidths; monospace = true; } else { widths = glyphWidths(); } return { defaultWidth, monospace, widths }; } buildCharCodeToWidth(widthsByGlyphName, properties) { const widths = Object.create(null); const differences = properties.differences; const encoding = properties.defaultEncoding; for (let charCode = 0; charCode &lt; 256; charCode++) { if (charCode in differences &amp;&amp; widthsByGlyphName[differences[charCode]]) { widths[charCode] = widthsByGlyphName[differences[charCode]]; continue; } if (charCode in encoding &amp;&amp; widthsByGlyphName[encoding[charCode]]) { widths[charCode] = widthsByGlyphName[encoding[charCode]]; continue; } } return widths; } preEvaluateFont(dict) { const baseDict = dict; let type = dict.get(&quot;Subtype&quot;); if (!(type instanceof _primitives.Name)) { throw new _util.FormatError(&quot;invalid font Subtype&quot;); } let composite = false; let hash, toUnicode; if (type.name === &quot;Type0&quot;) { const df = dict.get(&quot;DescendantFonts&quot;); if (!df) { throw new _util.FormatError(&quot;Descendant fonts are not specified&quot;); } dict = Array.isArray(df) ? this.xref.fetchIfRef(df[0]) : df; if (!(dict instanceof _primitives.Dict)) { throw new _util.FormatError(&quot;Descendant font is not a dictionary.&quot;); } type = dict.get(&quot;Subtype&quot;); if (!(type instanceof _primitives.Name)) { throw new _util.FormatError(&quot;invalid font Subtype&quot;); } composite = true; } const firstChar = dict.get(&quot;FirstChar&quot;) || 0, lastChar = dict.get(&quot;LastChar&quot;) || (composite ? 0xffff : 0xff); const descriptor = dict.get(&quot;FontDescriptor&quot;); if (descriptor) { hash = new _murmurhash.MurmurHash3_64(); const encoding = baseDict.getRaw(&quot;Encoding&quot;); if (encoding instanceof _primitives.Name) { hash.update(encoding.name); } else if (encoding instanceof _primitives.Ref) { hash.update(encoding.toString()); } else if (encoding instanceof _primitives.Dict) { for (const entry of encoding.getRawValues()) { if (entry instanceof _primitives.Name) { hash.update(entry.name); } else if (entry instanceof _primitives.Ref) { hash.update(entry.toString()); } else if (Array.isArray(entry)) { const diffLength = entry.length, diffBuf = new Array(diffLength); for (let j = 0; j &lt; diffLength; j++) { const diffEntry = entry[j]; if (diffEntry instanceof _primitives.Name) { diffBuf[j] = diffEntry.name; } else if (typeof diffEntry === &quot;number&quot; || diffEntry instanceof _primitives.Ref) { diffBuf[j] = diffEntry.toString(); } } hash.update(diffBuf.join()); } } } hash.update(`${firstChar}-${lastChar}`); toUnicode = dict.get(&quot;ToUnicode&quot;) || baseDict.get(&quot;ToUnicode&quot;); if (toUnicode instanceof _base_stream.BaseStream) { const stream = toUnicode.str || toUnicode; const uint8array = stream.buffer ? new Uint8Array(stream.buffer.buffer, 0, stream.bufferLength) : new Uint8Array(stream.bytes.buffer, stream.start, stream.end - stream.start); hash.update(uint8array); } else if (toUnicode instanceof _primitives.Name) { hash.update(toUnicode.name); } const widths = dict.get(&quot;Widths&quot;) || baseDict.get(&quot;Widths&quot;); if (Array.isArray(widths)) { const widthsBuf = []; for (const entry of widths) { if (typeof entry === &quot;number&quot; || entry instanceof _primitives.Ref) { widthsBuf.push(entry.toString()); } } hash.update(widthsBuf.join()); } if (composite) { hash.update(&quot;compositeFont&quot;); const compositeWidths = dict.get(&quot;W&quot;) || baseDict.get(&quot;W&quot;); if (Array.isArray(compositeWidths)) { const widthsBuf = []; for (const entry of compositeWidths) { if (typeof entry === &quot;number&quot; || entry instanceof _primitives.Ref) { widthsBuf.push(entry.toString()); } else if (Array.isArray(entry)) { const subWidthsBuf = []; for (const element of entry) { if (typeof element === &quot;number&quot; || element instanceof _primitives.Ref) { subWidthsBuf.push(element.toString()); } } widthsBuf.push(`[${subWidthsBuf.join()}]`); } } hash.update(widthsBuf.join()); } const cidToGidMap = dict.getRaw(&quot;CIDToGIDMap&quot;) || baseDict.getRaw(&quot;CIDToGIDMap&quot;); if (cidToGidMap instanceof _primitives.Name) { hash.update(cidToGidMap.name); } else if (cidToGidMap instanceof _primitives.Ref) { hash.update(cidToGidMap.toString()); } else if (cidToGidMap instanceof _base_stream.BaseStream) { hash.update(cidToGidMap.peekBytes()); } } } return { descriptor, dict, baseDict, composite, type: type.name, firstChar, lastChar, toUnicode, hash: hash ? hash.hexdigest() : &quot;&quot; }; } async translateFont({ descriptor, dict, baseDict, composite, type, firstChar, lastChar, toUnicode, cssFontInfo }) { const isType3Font = type === &quot;Type3&quot;; let properties; if (!descriptor) { if (isType3Font) { descriptor = new _primitives.Dict(null); descriptor.set(&quot;FontName&quot;, _primitives.Name.get(type)); descriptor.set(&quot;FontBBox&quot;, dict.getArray(&quot;FontBBox&quot;) || [0, 0, 0, 0]); } else { let baseFontName = dict.get(&quot;BaseFont&quot;); if (!(baseFontName instanceof _primitives.Name)) { throw new _util.FormatError(&quot;Base font is not specified&quot;); } baseFontName = baseFontName.name.replace(/[,_]/g, &quot;-&quot;); const metrics = this.getBaseFontMetrics(baseFontName); const fontNameWoStyle = baseFontName.split(&quot;-&quot;)[0]; const flags = (this.isSerifFont(fontNameWoStyle) ? _fonts_utils.FontFlags.Serif : 0) | (metrics.monospace ? _fonts_utils.FontFlags.FixedPitch : 0) | ((0, _standard_fonts.getSymbolsFonts)()[fontNameWoStyle] ? _fonts_utils.FontFlags.Symbolic : _fonts_utils.FontFlags.Nonsymbolic); properties = { type, name: baseFontName, loadedName: baseDict.loadedName, widths: metrics.widths, defaultWidth: metrics.defaultWidth, isSimulatedFlags: true, flags, firstChar, lastChar, toUnicode, xHeight: 0, capHeight: 0, italicAngle: 0, isType3Font }; const widths = dict.get(&quot;Widths&quot;); const standardFontName = (0, _standard_fonts.getStandardFontName)(baseFontName); let file = null; if (standardFontName) { properties.isStandardFont = true; file = await this.fetchStandardFontData(standardFontName); properties.isInternalFont = !!file; } return this.extractDataStructures(dict, dict, properties).then(newProperties =&gt; { if (widths) { const glyphWidths = []; let j = firstChar; for (const width of widths) { glyphWidths[j++] = this.xref.fetchIfRef(width); } newProperties.widths = glyphWidths; } else { newProperties.widths = this.buildCharCodeToWidth(metrics.widths, newProperties); } return new _fonts.Font(baseFontName, file, newProperties); }); } } let fontName = descriptor.get(&quot;FontName&quot;); let baseFont = dict.get(&quot;BaseFont&quot;); if (typeof fontName === &quot;string&quot;) { fontName = _primitives.Name.get(fontName); } if (typeof baseFont === &quot;string&quot;) { baseFont = _primitives.Name.get(baseFont); } if (!isType3Font) { const fontNameStr = fontName &amp;&amp; fontName.name; const baseFontStr = baseFont &amp;&amp; baseFont.name; if (fontNameStr !== baseFontStr) { (0, _util.info)(`The FontDescriptor&apos;s FontName is &quot;${fontNameStr}&quot; but ` + `should be the same as the Font&apos;s BaseFont &quot;${baseFontStr}&quot;.`); if (fontNameStr &amp;&amp; baseFontStr &amp;&amp; baseFontStr.startsWith(fontNameStr)) { fontName = baseFont; } } } fontName = fontName || baseFont; if (!(fontName instanceof _primitives.Name)) { throw new _util.FormatError(&quot;invalid font name&quot;); } let fontFile, subtype, length1, length2, length3; try { fontFile = descriptor.get(&quot;FontFile&quot;, &quot;FontFile2&quot;, &quot;FontFile3&quot;); } catch (ex) { if (!this.options.ignoreErrors) { throw ex; } (0, _util.warn)(`translateFont - fetching &quot;${fontName.name}&quot; font file: &quot;${ex}&quot;.`); fontFile = new _stream.NullStream(); } let isStandardFont = false; let isInternalFont = false; let glyphScaleFactors = null; if (fontFile) { if (fontFile.dict) { const subtypeEntry = fontFile.dict.get(&quot;Subtype&quot;); if (subtypeEntry instanceof _primitives.Name) { subtype = subtypeEntry.name; } length1 = fontFile.dict.get(&quot;Length1&quot;); length2 = fontFile.dict.get(&quot;Length2&quot;); length3 = fontFile.dict.get(&quot;Length3&quot;); } } else if (cssFontInfo) { const standardFontName = (0, _xfa_fonts.getXfaFontName)(fontName.name); if (standardFontName) { cssFontInfo.fontFamily = `${cssFontInfo.fontFamily}-PdfJS-XFA`; cssFontInfo.metrics = standardFontName.metrics || null; glyphScaleFactors = standardFontName.factors || null; fontFile = await this.fetchStandardFontData(standardFontName.name); isInternalFont = !!fontFile; baseDict = dict = (0, _xfa_fonts.getXfaFontDict)(fontName.name); composite = true; } } else if (!isType3Font) { const standardFontName = (0, _standard_fonts.getStandardFontName)(fontName.name); if (standardFontName) { isStandardFont = true; fontFile = await this.fetchStandardFontData(standardFontName); isInternalFont = !!fontFile; } } properties = { type, name: fontName.name, subtype, file: fontFile, length1, length2, length3, isStandardFont, isInternalFont, loadedName: baseDict.loadedName, composite, fixedPitch: false, fontMatrix: dict.getArray(&quot;FontMatrix&quot;) || _util.FONT_IDENTITY_MATRIX, firstChar, lastChar, toUnicode, bbox: descriptor.getArray(&quot;FontBBox&quot;) || dict.getArray(&quot;FontBBox&quot;), ascent: descriptor.get(&quot;Ascent&quot;), descent: descriptor.get(&quot;Descent&quot;), xHeight: descriptor.get(&quot;XHeight&quot;) || 0, capHeight: descriptor.get(&quot;CapHeight&quot;) || 0, flags: descriptor.get(&quot;Flags&quot;), italicAngle: descriptor.get(&quot;ItalicAngle&quot;) || 0, isType3Font, cssFontInfo, scaleFactors: glyphScaleFactors }; if (composite) { const cidEncoding = baseDict.get(&quot;Encoding&quot;); if (cidEncoding instanceof _primitives.Name) { properties.cidEncoding = cidEncoding.name; } const cMap = await _cmap.CMapFactory.create({ encoding: cidEncoding, fetchBuiltInCMap: this._fetchBuiltInCMapBound, useCMap: null }); properties.cMap = cMap; properties.vertical = properties.cMap.vertical; } return this.extractDataStructures(dict, baseDict, properties).then(newProperties =&gt; { this.extractWidths(dict, descriptor, newProperties); return new _fonts.Font(fontName.name, fontFile, newProperties); }); } static buildFontPaths(font, glyphs, handler, evaluatorOptions) { function buildPath(fontChar) { const glyphName = `${font.loadedName}_path_${fontChar}`; try { if (font.renderer.hasBuiltPath(fontChar)) { return; } handler.send(&quot;commonobj&quot;, [glyphName, &quot;FontPath&quot;, font.renderer.getPathJs(fontChar)]); } catch (reason) { if (evaluatorOptions.ignoreErrors) { handler.send(&quot;UnsupportedFeature&quot;, { featureId: _util.UNSUPPORTED_FEATURES.errorFontBuildPath }); (0, _util.warn)(`buildFontPaths - ignoring ${glyphName} glyph: &quot;${reason}&quot;.`); return; } throw reason; } } for (const glyph of glyphs) { buildPath(glyph.fontChar); const accent = glyph.accent; if (accent &amp;&amp; accent.fontChar) { buildPath(accent.fontChar); } } } static get fallbackFontDict() { const dict = new _primitives.Dict(); dict.set(&quot;BaseFont&quot;, _primitives.Name.get(&quot;PDFJS-FallbackFont&quot;)); dict.set(&quot;Type&quot;, _primitives.Name.get(&quot;FallbackType&quot;)); dict.set(&quot;Subtype&quot;, _primitives.Name.get(&quot;FallbackType&quot;)); dict.set(&quot;Encoding&quot;, _primitives.Name.get(&quot;WinAnsiEncoding&quot;)); return (0, _util.shadow)(this, &quot;fallbackFontDict&quot;, dict); } } exports.PartialEvaluator = PartialEvaluator; class TranslatedFont { constructor({ loadedName, font, dict, evaluatorOptions }) { this.loadedName = loadedName; this.font = font; this.dict = dict; this._evaluatorOptions = evaluatorOptions || DefaultPartialEvaluatorOptions; this.type3Loaded = null; this.type3Dependencies = font.isType3Font ? new Set() : null; this.sent = false; } send(handler) { if (this.sent) { return; } this.sent = true; handler.send(&quot;commonobj&quot;, [this.loadedName, &quot;Font&quot;, this.font.exportData(this._evaluatorOptions.fontExtraProperties)]); } fallback(handler) { if (!this.font.data) { return; } this.font.disableFontFace = true; PartialEvaluator.buildFontPaths(this.font, this.font.glyphCacheValues, handler, this._evaluatorOptions); } loadType3Data(evaluator, resources, task) { if (this.type3Loaded) { return this.type3Loaded; } if (!this.font.isType3Font) { throw new Error(&quot;Must be a Type3 font.&quot;); } const type3Evaluator = evaluator.clone({ ignoreErrors: false }); type3Evaluator.parsingType3Font = true; const type3FontRefs = new _primitives.RefSet(evaluator.type3FontRefs); if (this.dict.objId &amp;&amp; !type3FontRefs.has(this.dict.objId)) { type3FontRefs.put(this.dict.objId); } type3Evaluator.type3FontRefs = type3FontRefs; const translatedFont = this.font, type3Dependencies = this.type3Dependencies; let loadCharProcsPromise = Promise.resolve(); const charProcs = this.dict.get(&quot;CharProcs&quot;); const fontResources = this.dict.get(&quot;Resources&quot;) || resources; const charProcOperatorList = Object.create(null); const fontBBox = _util.Util.normalizeRect(translatedFont.bbox || [0, 0, 0, 0]), width = fontBBox[2] - fontBBox[0], height = fontBBox[3] - fontBBox[1]; const fontBBoxSize = Math.hypot(width, height); for (const key of charProcs.getKeys()) { loadCharProcsPromise = loadCharProcsPromise.then(() =&gt; { const glyphStream = charProcs.get(key); const operatorList = new _operator_list.OperatorList(); return type3Evaluator.getOperatorList({ stream: glyphStream, task, resources: fontResources, operatorList }).then(() =&gt; { if (operatorList.fnArray[0] === _util.OPS.setCharWidthAndBounds) { this._removeType3ColorOperators(operatorList, fontBBoxSize); } charProcOperatorList[key] = operatorList.getIR(); for (const dependency of operatorList.dependencies) { type3Dependencies.add(dependency); } }).catch(function (reason) { (0, _util.warn)(`Type3 font resource &quot;${key}&quot; is not available.`); const dummyOperatorList = new _operator_list.OperatorList(); charProcOperatorList[key] = dummyOperatorList.getIR(); }); }); } this.type3Loaded = loadCharProcsPromise.then(() =&gt; { translatedFont.charProcOperatorList = charProcOperatorList; if (this._bbox) { translatedFont.isCharBBox = true; translatedFont.bbox = this._bbox; } }); return this.type3Loaded; } _removeType3ColorOperators(operatorList, fontBBoxSize = NaN) { const charBBox = _util.Util.normalizeRect(operatorList.argsArray[0].slice(2)), width = charBBox[2] - charBBox[0], height = charBBox[3] - charBBox[1]; const charBBoxSize = Math.hypot(width, height); if (width === 0 || height === 0) { operatorList.fnArray.splice(0, 1); operatorList.argsArray.splice(0, 1); } else if (fontBBoxSize === 0 || Math.round(charBBoxSize / fontBBoxSize) &gt;= 10) { if (!this._bbox) { this._bbox = [Infinity, Infinity, -Infinity, -Infinity]; } this._bbox[0] = Math.min(this._bbox[0], charBBox[0]); this._bbox[1] = Math.min(this._bbox[1], charBBox[1]); this._bbox[2] = Math.max(this._bbox[2], charBBox[2]); this._bbox[3] = Math.max(this._bbox[3], charBBox[3]); } let i = 0, ii = operatorList.length; while (i &lt; ii) { switch (operatorList.fnArray[i]) { case _util.OPS.setCharWidthAndBounds: break; case _util.OPS.setStrokeColorSpace: case _util.OPS.setFillColorSpace: case _util.OPS.setStrokeColor: case _util.OPS.setStrokeColorN: case _util.OPS.setFillColor: case _util.OPS.setFillColorN: case _util.OPS.setStrokeGray: case _util.OPS.setFillGray: case _util.OPS.setStrokeRGBColor: case _util.OPS.setFillRGBColor: case _util.OPS.setStrokeCMYKColor: case _util.OPS.setFillCMYKColor: case _util.OPS.shadingFill: case _util.OPS.setRenderingIntent: operatorList.fnArray.splice(i, 1); operatorList.argsArray.splice(i, 1); ii--; continue; case _util.OPS.setGState: const [gStateObj] = operatorList.argsArray[i]; let j = 0, jj = gStateObj.length; while (j &lt; jj) { const [gStateKey] = gStateObj[j]; switch (gStateKey) { case &quot;TR&quot;: case &quot;TR2&quot;: case &quot;HT&quot;: case &quot;BG&quot;: case &quot;BG2&quot;: case &quot;UCR&quot;: case &quot;UCR2&quot;: gStateObj.splice(j, 1); jj--; continue; } j++; } break; } i++; } } } class StateManager { constructor(initialState = new EvalState()) { this.state = initialState; this.stateStack = []; } save() { const old = this.state; this.stateStack.push(this.state); this.state = old.clone(); } restore() { const prev = this.stateStack.pop(); if (prev) { this.state = prev; } } transform(args) { this.state.ctm = _util.Util.transform(this.state.ctm, args); } } class TextState { constructor() { this.ctm = new Float32Array(_util.IDENTITY_MATRIX); this.fontName = null; this.fontSize = 0; this.font = null; this.fontMatrix = _util.FONT_IDENTITY_MATRIX; this.textMatrix = _util.IDENTITY_MATRIX.slice(); this.textLineMatrix = _util.IDENTITY_MATRIX.slice(); this.charSpacing = 0; this.wordSpacing = 0; this.leading = 0; this.textHScale = 1; this.textRise = 0; } setTextMatrix(a, b, c, d, e, f) { const m = this.textMatrix; m[0] = a; m[1] = b; m[2] = c; m[3] = d; m[4] = e; m[5] = f; } setTextLineMatrix(a, b, c, d, e, f) { const m = this.textLineMatrix; m[0] = a; m[1] = b; m[2] = c; m[3] = d; m[4] = e; m[5] = f; } translateTextMatrix(x, y) { const m = this.textMatrix; m[4] = m[0] * x + m[2] * y + m[4]; m[5] = m[1] * x + m[3] * y + m[5]; } translateTextLineMatrix(x, y) { const m = this.textLineMatrix; m[4] = m[0] * x + m[2] * y + m[4]; m[5] = m[1] * x + m[3] * y + m[5]; } carriageReturn() { this.translateTextLineMatrix(0, -this.leading); this.textMatrix = this.textLineMatrix.slice(); } clone() { const clone = Object.create(this); clone.textMatrix = this.textMatrix.slice(); clone.textLineMatrix = this.textLineMatrix.slice(); clone.fontMatrix = this.fontMatrix.slice(); return clone; } } class EvalState { constructor() { this.ctm = new Float32Array(_util.IDENTITY_MATRIX); this.font = null; this.textRenderingMode = _util.TextRenderingMode.FILL; this.fillColorSpace = _colorspace.ColorSpace.singletons.gray; this.strokeColorSpace = _colorspace.ColorSpace.singletons.gray; } clone() { return Object.create(this); } } class EvaluatorPreprocessor { static get opMap() { const getOPMap = (0, _core_utils.getLookupTableFactory)(function (t) { t.w = { id: _util.OPS.setLineWidth, numArgs: 1, variableArgs: false }; t.J = { id: _util.OPS.setLineCap, numArgs: 1, variableArgs: false }; t.j = { id: _util.OPS.setLineJoin, numArgs: 1, variableArgs: false }; t.M = { id: _util.OPS.setMiterLimit, numArgs: 1, variableArgs: false }; t.d = { id: _util.OPS.setDash, numArgs: 2, variableArgs: false }; t.ri = { id: _util.OPS.setRenderingIntent, numArgs: 1, variableArgs: false }; t.i = { id: _util.OPS.setFlatness, numArgs: 1, variableArgs: false }; t.gs = { id: _util.OPS.setGState, numArgs: 1, variableArgs: false }; t.q = { id: _util.OPS.save, numArgs: 0, variableArgs: false }; t.Q = { id: _util.OPS.restore, numArgs: 0, variableArgs: false }; t.cm = { id: _util.OPS.transform, numArgs: 6, variableArgs: false }; t.m = { id: _util.OPS.moveTo, numArgs: 2, variableArgs: false }; t.l = { id: _util.OPS.lineTo, numArgs: 2, variableArgs: false }; t.c = { id: _util.OPS.curveTo, numArgs: 6, variableArgs: false }; t.v = { id: _util.OPS.curveTo2, numArgs: 4, variableArgs: false }; t.y = { id: _util.OPS.curveTo3, numArgs: 4, variableArgs: false }; t.h = { id: _util.OPS.closePath, numArgs: 0, variableArgs: false }; t.re = { id: _util.OPS.rectangle, numArgs: 4, variableArgs: false }; t.S = { id: _util.OPS.stroke, numArgs: 0, variableArgs: false }; t.s = { id: _util.OPS.closeStroke, numArgs: 0, variableArgs: false }; t.f = { id: _util.OPS.fill, numArgs: 0, variableArgs: false }; t.F = { id: _util.OPS.fill, numArgs: 0, variableArgs: false }; t[&quot;f*&quot;] = { id: _util.OPS.eoFill, numArgs: 0, variableArgs: false }; t.B = { id: _util.OPS.fillStroke, numArgs: 0, variableArgs: false }; t[&quot;B*&quot;] = { id: _util.OPS.eoFillStroke, numArgs: 0, variableArgs: false }; t.b = { id: _util.OPS.closeFillStroke, numArgs: 0, variableArgs: false }; t[&quot;b*&quot;] = { id: _util.OPS.closeEOFillStroke, numArgs: 0, variableArgs: false }; t.n = { id: _util.OPS.endPath, numArgs: 0, variableArgs: false }; t.W = { id: _util.OPS.clip, numArgs: 0, variableArgs: false }; t[&quot;W*&quot;] = { id: _util.OPS.eoClip, numArgs: 0, variableArgs: false }; t.BT = { id: _util.OPS.beginText, numArgs: 0, variableArgs: false }; t.ET = { id: _util.OPS.endText, numArgs: 0, variableArgs: false }; t.Tc = { id: _util.OPS.setCharSpacing, numArgs: 1, variableArgs: false }; t.Tw = { id: _util.OPS.setWordSpacing, numArgs: 1, variableArgs: false }; t.Tz = { id: _util.OPS.setHScale, numArgs: 1, variableArgs: false }; t.TL = { id: _util.OPS.setLeading, numArgs: 1, variableArgs: false }; t.Tf = { id: _util.OPS.setFont, numArgs: 2, variableArgs: false }; t.Tr = { id: _util.OPS.setTextRenderingMode, numArgs: 1, variableArgs: false }; t.Ts = { id: _util.OPS.setTextRise, numArgs: 1, variableArgs: false }; t.Td = { id: _util.OPS.moveText, numArgs: 2, variableArgs: false }; t.TD = { id: _util.OPS.setLeadingMoveText, numArgs: 2, variableArgs: false }; t.Tm = { id: _util.OPS.setTextMatrix, numArgs: 6, variableArgs: false }; t[&quot;T*&quot;] = { id: _util.OPS.nextLine, numArgs: 0, variableArgs: false }; t.Tj = { id: _util.OPS.showText, numArgs: 1, variableArgs: false }; t.TJ = { id: _util.OPS.showSpacedText, numArgs: 1, variableArgs: false }; t[&quot;&apos;&quot;] = { id: _util.OPS.nextLineShowText, numArgs: 1, variableArgs: false }; t[&apos;&quot;&apos;] = { id: _util.OPS.nextLineSetSpacingShowText, numArgs: 3, variableArgs: false }; t.d0 = { id: _util.OPS.setCharWidth, numArgs: 2, variableArgs: false }; t.d1 = { id: _util.OPS.setCharWidthAndBounds, numArgs: 6, variableArgs: false }; t.CS = { id: _util.OPS.setStrokeColorSpace, numArgs: 1, variableArgs: false }; t.cs = { id: _util.OPS.setFillColorSpace, numArgs: 1, variableArgs: false }; t.SC = { id: _util.OPS.setStrokeColor, numArgs: 4, variableArgs: true }; t.SCN = { id: _util.OPS.setStrokeColorN, numArgs: 33, variableArgs: true }; t.sc = { id: _util.OPS.setFillColor, numArgs: 4, variableArgs: true }; t.scn = { id: _util.OPS.setFillColorN, numArgs: 33, variableArgs: true }; t.G = { id: _util.OPS.setStrokeGray, numArgs: 1, variableArgs: false }; t.g = { id: _util.OPS.setFillGray, numArgs: 1, variableArgs: false }; t.RG = { id: _util.OPS.setStrokeRGBColor, numArgs: 3, variableArgs: false }; t.rg = { id: _util.OPS.setFillRGBColor, numArgs: 3, variableArgs: false }; t.K = { id: _util.OPS.setStrokeCMYKColor, numArgs: 4, variableArgs: false }; t.k = { id: _util.OPS.setFillCMYKColor, numArgs: 4, variableArgs: false }; t.sh = { id: _util.OPS.shadingFill, numArgs: 1, variableArgs: false }; t.BI = { id: _util.OPS.beginInlineImage, numArgs: 0, variableArgs: false }; t.ID = { id: _util.OPS.beginImageData, numArgs: 0, variableArgs: false }; t.EI = { id: _util.OPS.endInlineImage, numArgs: 1, variableArgs: false }; t.Do = { id: _util.OPS.paintXObject, numArgs: 1, variableArgs: false }; t.MP = { id: _util.OPS.markPoint, numArgs: 1, variableArgs: false }; t.DP = { id: _util.OPS.markPointProps, numArgs: 2, variableArgs: false }; t.BMC = { id: _util.OPS.beginMarkedContent, numArgs: 1, variableArgs: false }; t.BDC = { id: _util.OPS.beginMarkedContentProps, numArgs: 2, variableArgs: false }; t.EMC = { id: _util.OPS.endMarkedContent, numArgs: 0, variableArgs: false }; t.BX = { id: _util.OPS.beginCompat, numArgs: 0, variableArgs: false }; t.EX = { id: _util.OPS.endCompat, numArgs: 0, variableArgs: false }; t.BM = null; t.BD = null; t.true = null; t.fa = null; t.fal = null; t.fals = null; t.false = null; t.nu = null; t.nul = null; t.null = null; }); return (0, _util.shadow)(this, &quot;opMap&quot;, getOPMap()); } static get MAX_INVALID_PATH_OPS() { return (0, _util.shadow)(this, &quot;MAX_INVALID_PATH_OPS&quot;, 10); } constructor(stream, xref, stateManager = new StateManager()) { this.parser = new _parser.Parser({ lexer: new _parser.Lexer(stream, EvaluatorPreprocessor.opMap), xref }); this.stateManager = stateManager; this.nonProcessedArgs = []; this._isPathOp = false; this._numInvalidPathOPS = 0; } get savedStatesDepth() { return this.stateManager.stateStack.length; } read(operation) { let args = operation.args; while (true) { const obj = this.parser.getObj(); if (obj instanceof _primitives.Cmd) { const cmd = obj.cmd; const opSpec = EvaluatorPreprocessor.opMap[cmd]; if (!opSpec) { (0, _util.warn)(`Unknown command &quot;${cmd}&quot;.`); continue; } const fn = opSpec.id; const numArgs = opSpec.numArgs; let argsLength = args !== null ? args.length : 0; if (!this._isPathOp) { this._numInvalidPathOPS = 0; } this._isPathOp = fn &gt;= _util.OPS.moveTo &amp;&amp; fn &lt;= _util.OPS.endPath; if (!opSpec.variableArgs) { if (argsLength !== numArgs) { const nonProcessedArgs = this.nonProcessedArgs; while (argsLength &gt; numArgs) { nonProcessedArgs.push(args.shift()); argsLength--; } while (argsLength &lt; numArgs &amp;&amp; nonProcessedArgs.length !== 0) { if (args === null) { args = []; } args.unshift(nonProcessedArgs.pop()); argsLength++; } } if (argsLength &lt; numArgs) { const partialMsg = `command ${cmd}: expected ${numArgs} args, ` + `but received ${argsLength} args.`; if (this._isPathOp &amp;&amp; ++this._numInvalidPathOPS &gt; EvaluatorPreprocessor.MAX_INVALID_PATH_OPS) { throw new _util.FormatError(`Invalid ${partialMsg}`); } (0, _util.warn)(`Skipping ${partialMsg}`); if (args !== null) { args.length = 0; } continue; } } else if (argsLength &gt; numArgs) { (0, _util.info)(`Command ${cmd}: expected [0, ${numArgs}] args, ` + `but received ${argsLength} args.`); } this.preprocessCommand(fn, args); operation.fn = fn; operation.args = args; return true; } if (obj === _primitives.EOF) { return false; } if (obj !== null) { if (args === null) { args = []; } args.push(obj); if (args.length &gt; 33) { throw new _util.FormatError(&quot;Too many arguments&quot;); } } } } preprocessCommand(fn, args) { switch (fn | 0) { case _util.OPS.save: this.stateManager.save(); break; case _util.OPS.restore: this.stateManager.restore(); break; case _util.OPS.transform: this.stateManager.transform(args); break; } } } exports.EvaluatorPreprocessor = EvaluatorPreprocessor; /***/ }), /* 14 */ /***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) =&gt; { Object.defineProperty(exports, &quot;__esModule&quot;, ({ value: true })); exports.IdentityCMap = exports.CMapFactory = exports.CMap = void 0; var _util = __w_pdfjs_require__(2); var _primitives = __w_pdfjs_require__(3); var _base_stream = __w_pdfjs_require__(5); var _parser = __w_pdfjs_require__(15); var _core_utils = __w_pdfjs_require__(4); var _stream = __w_pdfjs_require__(8); const BUILT_IN_CMAPS = [&quot;Adobe-GB1-UCS2&quot;, &quot;Adobe-CNS1-UCS2&quot;, &quot;Adobe-Japan1-UCS2&quot;, &quot;Adobe-Korea1-UCS2&quot;, &quot;78-EUC-H&quot;, &quot;78-EUC-V&quot;, &quot;78-H&quot;, &quot;78-RKSJ-H&quot;, &quot;78-RKSJ-V&quot;, &quot;78-V&quot;, &quot;78ms-RKSJ-H&quot;, &quot;78ms-RKSJ-V&quot;, &quot;83pv-RKSJ-H&quot;, &quot;90ms-RKSJ-H&quot;, &quot;90ms-RKSJ-V&quot;, &quot;90msp-RKSJ-H&quot;, &quot;90msp-RKSJ-V&quot;, &quot;90pv-RKSJ-H&quot;, &quot;90pv-RKSJ-V&quot;, &quot;Add-H&quot;, &quot;Add-RKSJ-H&quot;, &quot;Add-RKSJ-V&quot;, &quot;Add-V&quot;, &quot;Adobe-CNS1-0&quot;, &quot;Adobe-CNS1-1&quot;, &quot;Adobe-CNS1-2&quot;, &quot;Adobe-CNS1-3&quot;, &quot;Adobe-CNS1-4&quot;, &quot;Adobe-CNS1-5&quot;, &quot;Adobe-CNS1-6&quot;, &quot;Adobe-GB1-0&quot;, &quot;Adobe-GB1-1&quot;, &quot;Adobe-GB1-2&quot;, &quot;Adobe-GB1-3&quot;, &quot;Adobe-GB1-4&quot;, &quot;Adobe-GB1-5&quot;, &quot;Adobe-Japan1-0&quot;, &quot;Adobe-Japan1-1&quot;, &quot;Adobe-Japan1-2&quot;, &quot;Adobe-Japan1-3&quot;, &quot;Adobe-Japan1-4&quot;, &quot;Adobe-Japan1-5&quot;, &quot;Adobe-Japan1-6&quot;, &quot;Adobe-Korea1-0&quot;, &quot;Adobe-Korea1-1&quot;, &quot;Adobe-Korea1-2&quot;, &quot;B5-H&quot;, &quot;B5-V&quot;, &quot;B5pc-H&quot;, &quot;B5pc-V&quot;, &quot;CNS-EUC-H&quot;, &quot;CNS-EUC-V&quot;, &quot;CNS1-H&quot;, &quot;CNS1-V&quot;, &quot;CNS2-H&quot;, &quot;CNS2-V&quot;, &quot;ETHK-B5-H&quot;, &quot;ETHK-B5-V&quot;, &quot;ETen-B5-H&quot;, &quot;ETen-B5-V&quot;, &quot;ETenms-B5-H&quot;, &quot;ETenms-B5-V&quot;, &quot;EUC-H&quot;, &quot;EUC-V&quot;, &quot;Ext-H&quot;, &quot;Ext-RKSJ-H&quot;, &quot;Ext-RKSJ-V&quot;, &quot;Ext-V&quot;, &quot;GB-EUC-H&quot;, &quot;GB-EUC-V&quot;, &quot;GB-H&quot;, &quot;GB-V&quot;, &quot;GBK-EUC-H&quot;, &quot;GBK-EUC-V&quot;, &quot;GBK2K-H&quot;, &quot;GBK2K-V&quot;, &quot;GBKp-EUC-H&quot;, &quot;GBKp-EUC-V&quot;, &quot;GBT-EUC-H&quot;, &quot;GBT-EUC-V&quot;, &quot;GBT-H&quot;, &quot;GBT-V&quot;, &quot;GBTpc-EUC-H&quot;, &quot;GBTpc-EUC-V&quot;, &quot;GBpc-EUC-H&quot;, &quot;GBpc-EUC-V&quot;, &quot;H&quot;, &quot;HKdla-B5-H&quot;, &quot;HKdla-B5-V&quot;, &quot;HKdlb-B5-H&quot;, &quot;HKdlb-B5-V&quot;, &quot;HKgccs-B5-H&quot;, &quot;HKgccs-B5-V&quot;, &quot;HKm314-B5-H&quot;, &quot;HKm314-B5-V&quot;, &quot;HKm471-B5-H&quot;, &quot;HKm471-B5-V&quot;, &quot;HKscs-B5-H&quot;, &quot;HKscs-B5-V&quot;, &quot;Hankaku&quot;, &quot;Hiragana&quot;, &quot;KSC-EUC-H&quot;, &quot;KSC-EUC-V&quot;, &quot;KSC-H&quot;, &quot;KSC-Johab-H&quot;, &quot;KSC-Johab-V&quot;, &quot;KSC-V&quot;, &quot;KSCms-UHC-H&quot;, &quot;KSCms-UHC-HW-H&quot;, &quot;KSCms-UHC-HW-V&quot;, &quot;KSCms-UHC-V&quot;, &quot;KSCpc-EUC-H&quot;, &quot;KSCpc-EUC-V&quot;, &quot;Katakana&quot;, &quot;NWP-H&quot;, &quot;NWP-V&quot;, &quot;RKSJ-H&quot;, &quot;RKSJ-V&quot;, &quot;Roman&quot;, &quot;UniCNS-UCS2-H&quot;, &quot;UniCNS-UCS2-V&quot;, &quot;UniCNS-UTF16-H&quot;, &quot;UniCNS-UTF16-V&quot;, &quot;UniCNS-UTF32-H&quot;, &quot;UniCNS-UTF32-V&quot;, &quot;UniCNS-UTF8-H&quot;, &quot;UniCNS-UTF8-V&quot;, &quot;UniGB-UCS2-H&quot;, &quot;UniGB-UCS2-V&quot;, &quot;UniGB-UTF16-H&quot;, &quot;UniGB-UTF16-V&quot;, &quot;UniGB-UTF32-H&quot;, &quot;UniGB-UTF32-V&quot;, &quot;UniGB-UTF8-H&quot;, &quot;UniGB-UTF8-V&quot;, &quot;UniJIS-UCS2-H&quot;, &quot;UniJIS-UCS2-HW-H&quot;, &quot;UniJIS-UCS2-HW-V&quot;, &quot;UniJIS-UCS2-V&quot;, &quot;UniJIS-UTF16-H&quot;, &quot;UniJIS-UTF16-V&quot;, &quot;UniJIS-UTF32-H&quot;, &quot;UniJIS-UTF32-V&quot;, &quot;UniJIS-UTF8-H&quot;, &quot;UniJIS-UTF8-V&quot;, &quot;UniJIS2004-UTF16-H&quot;, &quot;UniJIS2004-UTF16-V&quot;, &quot;UniJIS2004-UTF32-H&quot;, &quot;UniJIS2004-UTF32-V&quot;, &quot;UniJIS2004-UTF8-H&quot;, &quot;UniJIS2004-UTF8-V&quot;, &quot;UniJISPro-UCS2-HW-V&quot;, &quot;UniJISPro-UCS2-V&quot;, &quot;UniJISPro-UTF8-V&quot;, &quot;UniJISX0213-UTF32-H&quot;, &quot;UniJISX0213-UTF32-V&quot;, &quot;UniJISX02132004-UTF32-H&quot;, &quot;UniJISX02132004-UTF32-V&quot;, &quot;UniKS-UCS2-H&quot;, &quot;UniKS-UCS2-V&quot;, &quot;UniKS-UTF16-H&quot;, &quot;UniKS-UTF16-V&quot;, &quot;UniKS-UTF32-H&quot;, &quot;UniKS-UTF32-V&quot;, &quot;UniKS-UTF8-H&quot;, &quot;UniKS-UTF8-V&quot;, &quot;V&quot;, &quot;WP-Symbol&quot;]; const MAX_MAP_RANGE = 2 ** 24 - 1; class CMap { constructor(builtInCMap = false) { this.codespaceRanges = [[], [], [], []]; this.numCodespaceRanges = 0; this._map = []; this.name = &quot;&quot;; this.vertical = false; this.useCMap = null; this.builtInCMap = builtInCMap; } addCodespaceRange(n, low, high) { this.codespaceRanges[n - 1].push(low, high); this.numCodespaceRanges++; } mapCidRange(low, high, dstLow) { if (high - low &gt; MAX_MAP_RANGE) { throw new Error(&quot;mapCidRange - ignoring data above MAX_MAP_RANGE.&quot;); } while (low &lt;= high) { this._map[low++] = dstLow++; } } mapBfRange(low, high, dstLow) { if (high - low &gt; MAX_MAP_RANGE) { throw new Error(&quot;mapBfRange - ignoring data above MAX_MAP_RANGE.&quot;); } const lastByte = dstLow.length - 1; while (low &lt;= high) { this._map[low++] = dstLow; const nextCharCode = dstLow.charCodeAt(lastByte) + 1; if (nextCharCode &gt; 0xff) { dstLow = dstLow.substring(0, lastByte - 1) + String.fromCharCode(dstLow.charCodeAt(lastByte - 1) + 1) + &quot;\\x00&quot;; continue; } dstLow = dstLow.substring(0, lastByte) + String.fromCharCode(nextCharCode); } } mapBfRangeToArray(low, high, array) { if (high - low &gt; MAX_MAP_RANGE) { throw new Error(&quot;mapBfRangeToArray - ignoring data above MAX_MAP_RANGE.&quot;); } const ii = array.length; let i = 0; while (low &lt;= high &amp;&amp; i &lt; ii) { this._map[low] = array[i++]; ++low; } } mapOne(src, dst) { this._map[src] = dst; } lookup(code) { return this._map[code]; } contains(code) { return this._map[code] !== undefined; } forEach(callback) { const map = this._map; const length = map.length; if (length &lt;= 0x10000) { for (let i = 0; i &lt; length; i++) { if (map[i] !== undefined) { callback(i, map[i]); } } } else { for (const i in map) { callback(i, map[i]); } } } charCodeOf(value) { const map = this._map; if (map.length &lt;= 0x10000) { return map.indexOf(value); } for (const charCode in map) { if (map[charCode] === value) { return charCode | 0; } } return -1; } getMap() { return this._map; } readCharCode(str, offset, out) { let c = 0; const codespaceRanges = this.codespaceRanges; for (let n = 0, nn = codespaceRanges.length; n &lt; nn; n++) { c = (c &lt;&lt; 8 | str.charCodeAt(offset + n)) &gt;&gt;&gt; 0; const codespaceRange = codespaceRanges[n]; for (let k = 0, kk = codespaceRange.length; k &lt; kk;) { const low = codespaceRange[k++]; const high = codespaceRange[k++]; if (c &gt;= low &amp;&amp; c &lt;= high) { out.charcode = c; out.length = n + 1; return; } } } out.charcode = 0; out.length = 1; } getCharCodeLength(charCode) { const codespaceRanges = this.codespaceRanges; for (let n = 0, nn = codespaceRanges.length; n &lt; nn; n++) { const codespaceRange = codespaceRanges[n]; for (let k = 0, kk = codespaceRange.length; k &lt; kk;) { const low = codespaceRange[k++]; const high = codespaceRange[k++]; if (charCode &gt;= low &amp;&amp; charCode &lt;= high) { return n + 1; } } } return 1; } get length() { return this._map.length; } get isIdentityCMap() { if (!(this.name === &quot;Identity-H&quot; || this.name === &quot;Identity-V&quot;)) { return false; } if (this._map.length !== 0x10000) { return false; } for (let i = 0; i &lt; 0x10000; i++) { if (this._map[i] !== i) { return false; } } return true; } } exports.CMap = CMap; class IdentityCMap extends CMap { constructor(vertical, n) { super(); this.vertical = vertical; this.addCodespaceRange(n, 0, 0xffff); } mapCidRange(low, high, dstLow) { (0, _util.unreachable)(&quot;should not call mapCidRange&quot;); } mapBfRange(low, high, dstLow) { (0, _util.unreachable)(&quot;should not call mapBfRange&quot;); } mapBfRangeToArray(low, high, array) { (0, _util.unreachable)(&quot;should not call mapBfRangeToArray&quot;); } mapOne(src, dst) { (0, _util.unreachable)(&quot;should not call mapCidOne&quot;); } lookup(code) { return Number.isInteger(code) &amp;&amp; code &lt;= 0xffff ? code : undefined; } contains(code) { return Number.isInteger(code) &amp;&amp; code &lt;= 0xffff; } forEach(callback) { for (let i = 0; i &lt;= 0xffff; i++) { callback(i, i); } } charCodeOf(value) { return Number.isInteger(value) &amp;&amp; value &lt;= 0xffff ? value : -1; } getMap() { const map = new Array(0x10000); for (let i = 0; i &lt;= 0xffff; i++) { map[i] = i; } return map; } get length() { return 0x10000; } get isIdentityCMap() { (0, _util.unreachable)(&quot;should not access .isIdentityCMap&quot;); } } exports.IdentityCMap = IdentityCMap; const BinaryCMapReader = function BinaryCMapReaderClosure() { function hexToInt(a, size) { let n = 0; for (let i = 0; i &lt;= size; i++) { n = n &lt;&lt; 8 | a[i]; } return n &gt;&gt;&gt; 0; } function hexToStr(a, size) { if (size === 1) { return String.fromCharCode(a[0], a[1]); } if (size === 3) { return String.fromCharCode(a[0], a[1], a[2], a[3]); } return String.fromCharCode.apply(null, a.subarray(0, size + 1)); } function addHex(a, b, size) { let c = 0; for (let i = size; i &gt;= 0; i--) { c += a[i] + b[i]; a[i] = c &amp; 255; c &gt;&gt;= 8; } } function incHex(a, size) { let c = 1; for (let i = size; i &gt;= 0 &amp;&amp; c &gt; 0; i--) { c += a[i]; a[i] = c &amp; 255; c &gt;&gt;= 8; } } const MAX_NUM_SIZE = 16; const MAX_ENCODED_NUM_SIZE = 19; class BinaryCMapStream { constructor(data) { this.buffer = data; this.pos = 0; this.end = data.length; this.tmpBuf = new Uint8Array(MAX_ENCODED_NUM_SIZE); } readByte() { if (this.pos &gt;= this.end) { return -1; } return this.buffer[this.pos++]; } readNumber() { let n = 0; let last; do { const b = this.readByte(); if (b &lt; 0) { throw new _util.FormatError(&quot;unexpected EOF in bcmap&quot;); } last = !(b &amp; 0x80); n = n &lt;&lt; 7 | b &amp; 0x7f; } while (!last); return n; } readSigned() { const n = this.readNumber(); return n &amp; 1 ? ~(n &gt;&gt;&gt; 1) : n &gt;&gt;&gt; 1; } readHex(num, size) { num.set(this.buffer.subarray(this.pos, this.pos + size + 1)); this.pos += size + 1; } readHexNumber(num, size) { let last; const stack = this.tmpBuf; let sp = 0; do { const b = this.readByte(); if (b &lt; 0) { throw new _util.FormatError(&quot;unexpected EOF in bcmap&quot;); } last = !(b &amp; 0x80); stack[sp++] = b &amp; 0x7f; } while (!last); let i = size, buffer = 0, bufferSize = 0; while (i &gt;= 0) { while (bufferSize &lt; 8 &amp;&amp; stack.length &gt; 0) { buffer |= stack[--sp] &lt;&lt; bufferSize; bufferSize += 7; } num[i] = buffer &amp; 255; i--; buffer &gt;&gt;= 8; bufferSize -= 8; } } readHexSigned(num, size) { this.readHexNumber(num, size); const sign = num[size] &amp; 1 ? 255 : 0; let c = 0; for (let i = 0; i &lt;= size; i++) { c = (c &amp; 1) &lt;&lt; 8 | num[i]; num[i] = c &gt;&gt; 1 ^ sign; } } readString() { const len = this.readNumber(); let s = &quot;&quot;; for (let i = 0; i &lt; len; i++) { s += String.fromCharCode(this.readNumber()); } return s; } } class BinaryCMapReader { async process(data, cMap, extend) { const stream = new BinaryCMapStream(data); const header = stream.readByte(); cMap.vertical = !!(header &amp; 1); let useCMap = null; const start = new Uint8Array(MAX_NUM_SIZE); const end = new Uint8Array(MAX_NUM_SIZE); const char = new Uint8Array(MAX_NUM_SIZE); const charCode = new Uint8Array(MAX_NUM_SIZE); const tmp = new Uint8Array(MAX_NUM_SIZE); let code; let b; while ((b = stream.readByte()) &gt;= 0) { const type = b &gt;&gt; 5; if (type === 7) { switch (b &amp; 0x1f) { case 0: stream.readString(); break; case 1: useCMap = stream.readString(); break; } continue; } const sequence = !!(b &amp; 0x10); const dataSize = b &amp; 15; if (dataSize + 1 &gt; MAX_NUM_SIZE) { throw new Error(&quot;BinaryCMapReader.process: Invalid dataSize.&quot;); } const ucs2DataSize = 1; const subitemsCount = stream.readNumber(); switch (type) { case 0: stream.readHex(start, dataSize); stream.readHexNumber(end, dataSize); addHex(end, start, dataSize); cMap.addCodespaceRange(dataSize + 1, hexToInt(start, dataSize), hexToInt(end, dataSize)); for (let i = 1; i &lt; subitemsCount; i++) { incHex(end, dataSize); stream.readHexNumber(start, dataSize); addHex(start, end, dataSize); stream.readHexNumber(end, dataSize); addHex(end, start, dataSize); cMap.addCodespaceRange(dataSize + 1, hexToInt(start, dataSize), hexToInt(end, dataSize)); } break; case 1: stream.readHex(start, dataSize); stream.readHexNumber(end, dataSize); addHex(end, start, dataSize); stream.readNumber(); for (let i = 1; i &lt; subitemsCount; i++) { incHex(end, dataSize); stream.readHexNumber(start, dataSize); addHex(start, end, dataSize); stream.readHexNumber(end, dataSize); addHex(end, start, dataSize); stream.readNumber(); } break; case 2: stream.readHex(char, dataSize); code = stream.readNumber(); cMap.mapOne(hexToInt(char, dataSize), code); for (let i = 1; i &lt; subitemsCount; i++) { incHex(char, dataSize); if (!sequence) { stream.readHexNumber(tmp, dataSize); addHex(char, tmp, dataSize); } code = stream.readSigned() + (code + 1); cMap.mapOne(hexToInt(char, dataSize), code); } break; case 3: stream.readHex(start, dataSize); stream.readHexNumber(end, dataSize); addHex(end, start, dataSize); code = stream.readNumber(); cMap.mapCidRange(hexToInt(start, dataSize), hexToInt(end, dataSize), code); for (let i = 1; i &lt; subitemsCount; i++) { incHex(end, dataSize); if (!sequence) { stream.readHexNumber(start, dataSize); addHex(start, end, dataSize); } else { start.set(end); } stream.readHexNumber(end, dataSize); addHex(end, start, dataSize); code = stream.readNumber(); cMap.mapCidRange(hexToInt(start, dataSize), hexToInt(end, dataSize), code); } break; case 4: stream.readHex(char, ucs2DataSize); stream.readHex(charCode, dataSize); cMap.mapOne(hexToInt(char, ucs2DataSize), hexToStr(charCode, dataSize)); for (let i = 1; i &lt; subitemsCount; i++) { incHex(char, ucs2DataSize); if (!sequence) { stream.readHexNumber(tmp, ucs2DataSize); addHex(char, tmp, ucs2DataSize); } incHex(charCode, dataSize); stream.readHexSigned(tmp, dataSize); addHex(charCode, tmp, dataSize); cMap.mapOne(hexToInt(char, ucs2DataSize), hexToStr(charCode, dataSize)); } break; case 5: stream.readHex(start, ucs2DataSize); stream.readHexNumber(end, ucs2DataSize); addHex(end, start, ucs2DataSize); stream.readHex(charCode, dataSize); cMap.mapBfRange(hexToInt(start, ucs2DataSize), hexToInt(end, ucs2DataSize), hexToStr(charCode, dataSize)); for (let i = 1; i &lt; subitemsCount; i++) { incHex(end, ucs2DataSize); if (!sequence) { stream.readHexNumber(start, ucs2DataSize); addHex(start, end, ucs2DataSize); } else { start.set(end); } stream.readHexNumber(end, ucs2DataSize); addHex(end, start, ucs2DataSize); stream.readHex(charCode, dataSize); cMap.mapBfRange(hexToInt(start, ucs2DataSize), hexToInt(end, ucs2DataSize), hexToStr(charCode, dataSize)); } break; default: throw new Error(`BinaryCMapReader.process - unknown type: ${type}`); } } if (useCMap) { return extend(useCMap); } return cMap; } } return BinaryCMapReader; }(); const CMapFactory = function CMapFactoryClosure() { function strToInt(str) { let a = 0; for (let i = 0; i &lt; str.length; i++) { a = a &lt;&lt; 8 | str.charCodeAt(i); } return a &gt;&gt;&gt; 0; } function expectString(obj) { if (typeof obj !== &quot;string&quot;) { throw new _util.FormatError(&quot;Malformed CMap: expected string.&quot;); } } function expectInt(obj) { if (!Number.isInteger(obj)) { throw new _util.FormatError(&quot;Malformed CMap: expected int.&quot;); } } function parseBfChar(cMap, lexer) { while (true) { let obj = lexer.getObj(); if (obj === _primitives.EOF) { break; } if ((0, _primitives.isCmd)(obj, &quot;endbfchar&quot;)) { return; } expectString(obj); const src = strToInt(obj); obj = lexer.getObj(); expectString(obj); const dst = obj; cMap.mapOne(src, dst); } } function parseBfRange(cMap, lexer) { while (true) { let obj = lexer.getObj(); if (obj === _primitives.EOF) { break; } if ((0, _primitives.isCmd)(obj, &quot;endbfrange&quot;)) { return; } expectString(obj); const low = strToInt(obj); obj = lexer.getObj(); expectString(obj); const high = strToInt(obj); obj = lexer.getObj(); if (Number.isInteger(obj) || typeof obj === &quot;string&quot;) { const dstLow = Number.isInteger(obj) ? String.fromCharCode(obj) : obj; cMap.mapBfRange(low, high, dstLow); } else if ((0, _primitives.isCmd)(obj, &quot;[&quot;)) { obj = lexer.getObj(); const array = []; while (!(0, _primitives.isCmd)(obj, &quot;]&quot;) &amp;&amp; obj !== _primitives.EOF) { array.push(obj); obj = lexer.getObj(); } cMap.mapBfRangeToArray(low, high, array); } else { break; } } throw new _util.FormatError(&quot;Invalid bf range.&quot;); } function parseCidChar(cMap, lexer) { while (true) { let obj = lexer.getObj(); if (obj === _primitives.EOF) { break; } if ((0, _primitives.isCmd)(obj, &quot;endcidchar&quot;)) { return; } expectString(obj); const src = strToInt(obj); obj = lexer.getObj(); expectInt(obj); const dst = obj; cMap.mapOne(src, dst); } } function parseCidRange(cMap, lexer) { while (true) { let obj = lexer.getObj(); if (obj === _primitives.EOF) { break; } if ((0, _primitives.isCmd)(obj, &quot;endcidrange&quot;)) { return; } expectString(obj); const low = strToInt(obj); obj = lexer.getObj(); expectString(obj); const high = strToInt(obj); obj = lexer.getObj(); expectInt(obj); const dstLow = obj; cMap.mapCidRange(low, high, dstLow); } } function parseCodespaceRange(cMap, lexer) { while (true) { let obj = lexer.getObj(); if (obj === _primitives.EOF) { break; } if ((0, _primitives.isCmd)(obj, &quot;endcodespacerange&quot;)) { return; } if (typeof obj !== &quot;string&quot;) { break; } const low = strToInt(obj); obj = lexer.getObj(); if (typeof obj !== &quot;string&quot;) { break; } const high = strToInt(obj); cMap.addCodespaceRange(obj.length, low, high); } throw new _util.FormatError(&quot;Invalid codespace range.&quot;); } function parseWMode(cMap, lexer) { const obj = lexer.getObj(); if (Number.isInteger(obj)) { cMap.vertical = !!obj; } } function parseCMapName(cMap, lexer) { const obj = lexer.getObj(); if (obj instanceof _primitives.Name) { cMap.name = obj.name; } } async function parseCMap(cMap, lexer, fetchBuiltInCMap, useCMap) { let previous, embeddedUseCMap; objLoop: while (true) { try { const obj = lexer.getObj(); if (obj === _primitives.EOF) { break; } else if (obj instanceof _primitives.Name) { if (obj.name === &quot;WMode&quot;) { parseWMode(cMap, lexer); } else if (obj.name === &quot;CMapName&quot;) { parseCMapName(cMap, lexer); } previous = obj; } else if (obj instanceof _primitives.Cmd) { switch (obj.cmd) { case &quot;endcmap&quot;: break objLoop; case &quot;usecmap&quot;: if (previous instanceof _primitives.Name) { embeddedUseCMap = previous.name; } break; case &quot;begincodespacerange&quot;: parseCodespaceRange(cMap, lexer); break; case &quot;beginbfchar&quot;: parseBfChar(cMap, lexer); break; case &quot;begincidchar&quot;: parseCidChar(cMap, lexer); break; case &quot;beginbfrange&quot;: parseBfRange(cMap, lexer); break; case &quot;begincidrange&quot;: parseCidRange(cMap, lexer); break; } } } catch (ex) { if (ex instanceof _core_utils.MissingDataException) { throw ex; } (0, _util.warn)(&quot;Invalid cMap data: &quot; + ex); continue; } } if (!useCMap &amp;&amp; embeddedUseCMap) { useCMap = embeddedUseCMap; } if (useCMap) { return extendCMap(cMap, fetchBuiltInCMap, useCMap); } return cMap; } async function extendCMap(cMap, fetchBuiltInCMap, useCMap) { cMap.useCMap = await createBuiltInCMap(useCMap, fetchBuiltInCMap); if (cMap.numCodespaceRanges === 0) { const useCodespaceRanges = cMap.useCMap.codespaceRanges; for (let i = 0; i &lt; useCodespaceRanges.length; i++) { cMap.codespaceRanges[i] = useCodespaceRanges[i].slice(); } cMap.numCodespaceRanges = cMap.useCMap.numCodespaceRanges; } cMap.useCMap.forEach(function (key, value) { if (!cMap.contains(key)) { cMap.mapOne(key, cMap.useCMap.lookup(key)); } }); return cMap; } async function createBuiltInCMap(name, fetchBuiltInCMap) { if (name === &quot;Identity-H&quot;) { return new IdentityCMap(false, 2); } else if (name === &quot;Identity-V&quot;) { return new IdentityCMap(true, 2); } if (!BUILT_IN_CMAPS.includes(name)) { throw new Error(&quot;Unknown CMap name: &quot; + name); } if (!fetchBuiltInCMap) { throw new Error(&quot;Built-in CMap parameters are not provided.&quot;); } const { cMapData, compressionType } = await fetchBuiltInCMap(name); const cMap = new CMap(true); if (compressionType === _util.CMapCompressionType.BINARY) { return new BinaryCMapReader().process(cMapData, cMap, useCMap =&gt; { return extendCMap(cMap, fetchBuiltInCMap, useCMap); }); } if (compressionType === _util.CMapCompressionType.NONE) { const lexer = new _parser.Lexer(new _stream.Stream(cMapData)); return parseCMap(cMap, lexer, fetchBuiltInCMap, null); } throw new Error(`Invalid CMap &quot;compressionType&quot; value: ${compressionType}`); } return { async create(params) { const encoding = params.encoding; const fetchBuiltInCMap = params.fetchBuiltInCMap; const useCMap = params.useCMap; if (encoding instanceof _primitives.Name) { return createBuiltInCMap(encoding.name, fetchBuiltInCMap); } else if (encoding instanceof _base_stream.BaseStream) { const parsedCMap = await parseCMap(new CMap(), new _parser.Lexer(encoding), fetchBuiltInCMap, useCMap); if (parsedCMap.isIdentityCMap) { return createBuiltInCMap(parsedCMap.name, fetchBuiltInCMap); } return parsedCMap; } throw new Error(&quot;Encoding required.&quot;); } }; }(); exports.CMapFactory = CMapFactory; /***/ }), /* 15 */ /***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) =&gt; { Object.defineProperty(exports, &quot;__esModule&quot;, ({ value: true })); exports.Parser = exports.Linearization = exports.Lexer = void 0; var _util = __w_pdfjs_require__(2); var _primitives = __w_pdfjs_require__(3); var _core_utils = __w_pdfjs_require__(4); var _ascii_85_stream = __w_pdfjs_require__(16); var _ascii_hex_stream = __w_pdfjs_require__(18); var _ccitt_stream = __w_pdfjs_require__(19); var _flate_stream = __w_pdfjs_require__(21); var _jbig2_stream = __w_pdfjs_require__(22); var _jpeg_stream = __w_pdfjs_require__(25); var _jpx_stream = __w_pdfjs_require__(27); var _lzw_stream = __w_pdfjs_require__(29); var _stream = __w_pdfjs_require__(8); var _predictor_stream = __w_pdfjs_require__(30); var _run_length_stream = __w_pdfjs_require__(31); const MAX_LENGTH_TO_CACHE = 1000; const MAX_ADLER32_LENGTH = 5552; function computeAdler32(bytes) { const bytesLength = bytes.length; let a = 1, b = 0; for (let i = 0; i &lt; bytesLength; ++i) { a += bytes[i] &amp; 0xff; b += a; } return b % 65521 &lt;&lt; 16 | a % 65521; } class Parser { constructor({ lexer, xref, allowStreams = false, recoveryMode = false }) { this.lexer = lexer; this.xref = xref; this.allowStreams = allowStreams; this.recoveryMode = recoveryMode; this.imageCache = Object.create(null); this.refill(); } refill() { this.buf1 = this.lexer.getObj(); this.buf2 = this.lexer.getObj(); } shift() { if (this.buf2 instanceof _primitives.Cmd &amp;&amp; this.buf2.cmd === &quot;ID&quot;) { this.buf1 = this.buf2; this.buf2 = null; } else { this.buf1 = this.buf2; this.buf2 = this.lexer.getObj(); } } tryShift() { try { this.shift(); return true; } catch (e) { if (e instanceof _core_utils.MissingDataException) { throw e; } return false; } } getObj(cipherTransform = null) { const buf1 = this.buf1; this.shift(); if (buf1 instanceof _primitives.Cmd) { switch (buf1.cmd) { case &quot;BI&quot;: return this.makeInlineImage(cipherTransform); case &quot;[&quot;: const array = []; while (!(0, _primitives.isCmd)(this.buf1, &quot;]&quot;) &amp;&amp; this.buf1 !== _primitives.EOF) { array.push(this.getObj(cipherTransform)); } if (this.buf1 === _primitives.EOF) { if (this.recoveryMode) { return array; } throw new _core_utils.ParserEOFException(&quot;End of file inside array.&quot;); } this.shift(); return array; case &quot;&lt;&lt;&quot;: const dict = new _primitives.Dict(this.xref); while (!(0, _primitives.isCmd)(this.buf1, &quot;&gt;&gt;&quot;) &amp;&amp; this.buf1 !== _primitives.EOF) { if (!(this.buf1 instanceof _primitives.Name)) { (0, _util.info)(&quot;Malformed dictionary: key must be a name object&quot;); this.shift(); continue; } const key = this.buf1.name; this.shift(); if (this.buf1 === _primitives.EOF) { break; } dict.set(key, this.getObj(cipherTransform)); } if (this.buf1 === _primitives.EOF) { if (this.recoveryMode) { return dict; } throw new _core_utils.ParserEOFException(&quot;End of file inside dictionary.&quot;); } if ((0, _primitives.isCmd)(this.buf2, &quot;stream&quot;)) { return this.allowStreams ? this.makeStream(dict, cipherTransform) : dict; } this.shift(); return dict; default: return buf1; } } if (Number.isInteger(buf1)) { if (Number.isInteger(this.buf1) &amp;&amp; (0, _primitives.isCmd)(this.buf2, &quot;R&quot;)) { const ref = _primitives.Ref.get(buf1, this.buf1); this.shift(); this.shift(); return ref; } return buf1; } if (typeof buf1 === &quot;string&quot;) { if (cipherTransform) { return cipherTransform.decryptString(buf1); } return buf1; } return buf1; } findDefaultInlineStreamEnd(stream) { const E = 0x45, I = 0x49, SPACE = 0x20, LF = 0xa, CR = 0xd, NUL = 0x0; const lexer = this.lexer, startPos = stream.pos, n = 10; let state = 0, ch, maybeEIPos; while ((ch = stream.getByte()) !== -1) { if (state === 0) { state = ch === E ? 1 : 0; } else if (state === 1) { state = ch === I ? 2 : 0; } else { (0, _util.assert)(state === 2, &quot;findDefaultInlineStreamEnd - invalid state.&quot;); if (ch === SPACE || ch === LF || ch === CR) { maybeEIPos = stream.pos; const followingBytes = stream.peekBytes(n); for (let i = 0, ii = followingBytes.length; i &lt; ii; i++) { ch = followingBytes[i]; if (ch === NUL &amp;&amp; followingBytes[i + 1] !== NUL) { continue; } if (ch !== LF &amp;&amp; ch !== CR &amp;&amp; (ch &lt; SPACE || ch &gt; 0x7f)) { state = 0; break; } } if (state !== 2) { continue; } if (lexer.knownCommands) { const nextObj = lexer.peekObj(); if (nextObj instanceof _primitives.Cmd &amp;&amp; !lexer.knownCommands[nextObj.cmd]) { state = 0; } } else { (0, _util.warn)(&quot;findDefaultInlineStreamEnd - `lexer.knownCommands` is undefined.&quot;); } if (state === 2) { break; } } else { state = 0; } } } if (ch === -1) { (0, _util.warn)(&quot;findDefaultInlineStreamEnd: &quot; + &quot;Reached the end of the stream without finding a valid EI marker&quot;); if (maybeEIPos) { (0, _util.warn)(&apos;... trying to recover by using the last &quot;EI&quot; occurrence.&apos;); stream.skip(-(stream.pos - maybeEIPos)); } } let endOffset = 4; stream.skip(-endOffset); ch = stream.peekByte(); stream.skip(endOffset); if (!(0, _core_utils.isWhiteSpace)(ch)) { endOffset--; } return stream.pos - endOffset - startPos; } findDCTDecodeInlineStreamEnd(stream) { const startPos = stream.pos; let foundEOI = false, b, markerLength; while ((b = stream.getByte()) !== -1) { if (b !== 0xff) { continue; } switch (stream.getByte()) { case 0x00: break; case 0xff: stream.skip(-1); break; case 0xd9: foundEOI = true; break; case 0xc0: case 0xc1: case 0xc2: case 0xc3: case 0xc5: case 0xc6: case 0xc7: case 0xc9: case 0xca: case 0xcb: case 0xcd: case 0xce: case 0xcf: case 0xc4: case 0xcc: case 0xda: case 0xdb: case 0xdc: case 0xdd: case 0xde: case 0xdf: case 0xe0: case 0xe1: case 0xe2: case 0xe3: case 0xe4: case 0xe5: case 0xe6: case 0xe7: case 0xe8: case 0xe9: case 0xea: case 0xeb: case 0xec: case 0xed: case 0xee: case 0xef: case 0xfe: markerLength = stream.getUint16(); if (markerLength &gt; 2) { stream.skip(markerLength - 2); } else { stream.skip(-2); } break; } if (foundEOI) { break; } } const length = stream.pos - startPos; if (b === -1) { (0, _util.warn)(&quot;Inline DCTDecode image stream: &quot; + &quot;EOI marker not found, searching for /EI/ instead.&quot;); stream.skip(-length); return this.findDefaultInlineStreamEnd(stream); } this.inlineStreamSkipEI(stream); return length; } findASCII85DecodeInlineStreamEnd(stream) { const TILDE = 0x7e, GT = 0x3e; const startPos = stream.pos; let ch; while ((ch = stream.getByte()) !== -1) { if (ch === TILDE) { const tildePos = stream.pos; ch = stream.peekByte(); while ((0, _core_utils.isWhiteSpace)(ch)) { stream.skip(); ch = stream.peekByte(); } if (ch === GT) { stream.skip(); break; } if (stream.pos &gt; tildePos) { const maybeEI = stream.peekBytes(2); if (maybeEI[0] === 0x45 &amp;&amp; maybeEI[1] === 0x49) { break; } } } } const length = stream.pos - startPos; if (ch === -1) { (0, _util.warn)(&quot;Inline ASCII85Decode image stream: &quot; + &quot;EOD marker not found, searching for /EI/ instead.&quot;); stream.skip(-length); return this.findDefaultInlineStreamEnd(stream); } this.inlineStreamSkipEI(stream); return length; } findASCIIHexDecodeInlineStreamEnd(stream) { const GT = 0x3e; const startPos = stream.pos; let ch; while ((ch = stream.getByte()) !== -1) { if (ch === GT) { break; } } const length = stream.pos - startPos; if (ch === -1) { (0, _util.warn)(&quot;Inline ASCIIHexDecode image stream: &quot; + &quot;EOD marker not found, searching for /EI/ instead.&quot;); stream.skip(-length); return this.findDefaultInlineStreamEnd(stream); } this.inlineStreamSkipEI(stream); return length; } inlineStreamSkipEI(stream) { const E = 0x45, I = 0x49; let state = 0, ch; while ((ch = stream.getByte()) !== -1) { if (state === 0) { state = ch === E ? 1 : 0; } else if (state === 1) { state = ch === I ? 2 : 0; } else if (state === 2) { break; } } } makeInlineImage(cipherTransform) { const lexer = this.lexer; const stream = lexer.stream; const dict = new _primitives.Dict(this.xref); let dictLength; while (!(0, _primitives.isCmd)(this.buf1, &quot;ID&quot;) &amp;&amp; this.buf1 !== _primitives.EOF) { if (!(this.buf1 instanceof _primitives.Name)) { throw new _util.FormatError(&quot;Dictionary key must be a name object&quot;); } const key = this.buf1.name; this.shift(); if (this.buf1 === _primitives.EOF) { break; } dict.set(key, this.getObj(cipherTransform)); } if (lexer.beginInlineImagePos !== -1) { dictLength = stream.pos - lexer.beginInlineImagePos; } const filter = dict.get(&quot;F&quot;, &quot;Filter&quot;); let filterName; if (filter instanceof _primitives.Name) { filterName = filter.name; } else if (Array.isArray(filter)) { const filterZero = this.xref.fetchIfRef(filter[0]); if (filterZero instanceof _primitives.Name) { filterName = filterZero.name; } } const startPos = stream.pos; let length; switch (filterName) { case &quot;DCT&quot;: case &quot;DCTDecode&quot;: length = this.findDCTDecodeInlineStreamEnd(stream); break; case &quot;A85&quot;: case &quot;ASCII85Decode&quot;: length = this.findASCII85DecodeInlineStreamEnd(stream); break; case &quot;AHx&quot;: case &quot;ASCIIHexDecode&quot;: length = this.findASCIIHexDecodeInlineStreamEnd(stream); break; default: length = this.findDefaultInlineStreamEnd(stream); } let imageStream = stream.makeSubStream(startPos, length, dict); let cacheKey; if (length &lt; MAX_LENGTH_TO_CACHE &amp;&amp; dictLength &lt; MAX_ADLER32_LENGTH) { const imageBytes = imageStream.getBytes(); imageStream.reset(); const initialStreamPos = stream.pos; stream.pos = lexer.beginInlineImagePos; const dictBytes = stream.getBytes(dictLength); stream.pos = initialStreamPos; cacheKey = computeAdler32(imageBytes) + &quot;_&quot; + computeAdler32(dictBytes); const cacheEntry = this.imageCache[cacheKey]; if (cacheEntry !== undefined) { this.buf2 = _primitives.Cmd.get(&quot;EI&quot;); this.shift(); cacheEntry.reset(); return cacheEntry; } } if (cipherTransform) { imageStream = cipherTransform.createStream(imageStream, length); } imageStream = this.filter(imageStream, dict, length); imageStream.dict = dict; if (cacheKey !== undefined) { imageStream.cacheKey = `inline_${length}_${cacheKey}`; this.imageCache[cacheKey] = imageStream; } this.buf2 = _primitives.Cmd.get(&quot;EI&quot;); this.shift(); return imageStream; } _findStreamLength(startPos, signature) { const { stream } = this.lexer; stream.pos = startPos; const SCAN_BLOCK_LENGTH = 2048; const signatureLength = signature.length; while (stream.pos &lt; stream.end) { const scanBytes = stream.peekBytes(SCAN_BLOCK_LENGTH); const scanLength = scanBytes.length - signatureLength; if (scanLength &lt;= 0) { break; } let pos = 0; while (pos &lt; scanLength) { let j = 0; while (j &lt; signatureLength &amp;&amp; scanBytes[pos + j] === signature[j]) { j++; } if (j &gt;= signatureLength) { stream.pos += pos; return stream.pos - startPos; } pos++; } stream.pos += scanLength; } return -1; } makeStream(dict, cipherTransform) { const lexer = this.lexer; let stream = lexer.stream; lexer.skipToNextLine(); const startPos = stream.pos - 1; let length = dict.get(&quot;Length&quot;); if (!Number.isInteger(length)) { (0, _util.info)(`Bad length &quot;${length &amp;&amp; length.toString()}&quot; in stream.`); length = 0; } stream.pos = startPos + length; lexer.nextChar(); if (this.tryShift() &amp;&amp; (0, _primitives.isCmd)(this.buf2, &quot;endstream&quot;)) { this.shift(); } else { const ENDSTREAM_SIGNATURE = new Uint8Array([0x65, 0x6e, 0x64, 0x73, 0x74, 0x72, 0x65, 0x61, 0x6d]); let actualLength = this._findStreamLength(startPos, ENDSTREAM_SIGNATURE); if (actualLength &lt; 0) { const MAX_TRUNCATION = 1; for (let i = 1; i &lt;= MAX_TRUNCATION; i++) { const end = ENDSTREAM_SIGNATURE.length - i; const TRUNCATED_SIGNATURE = ENDSTREAM_SIGNATURE.slice(0, end); const maybeLength = this._findStreamLength(startPos, TRUNCATED_SIGNATURE); if (maybeLength &gt;= 0) { const lastByte = stream.peekBytes(end + 1)[end]; if (!(0, _core_utils.isWhiteSpace)(lastByte)) { break; } (0, _util.info)(`Found &quot;${(0, _util.bytesToString)(TRUNCATED_SIGNATURE)}&quot; when ` + &quot;searching for endstream command.&quot;); actualLength = maybeLength; break; } } if (actualLength &lt; 0) { throw new _util.FormatError(&quot;Missing endstream command.&quot;); } } length = actualLength; lexer.nextChar(); this.shift(); this.shift(); } this.shift(); stream = stream.makeSubStream(startPos, length, dict); if (cipherTransform) { stream = cipherTransform.createStream(stream, length); } stream = this.filter(stream, dict, length); stream.dict = dict; return stream; } filter(stream, dict, length) { let filter = dict.get(&quot;F&quot;, &quot;Filter&quot;); let params = dict.get(&quot;DP&quot;, &quot;DecodeParms&quot;); if (filter instanceof _primitives.Name) { if (Array.isArray(params)) { (0, _util.warn)(&quot;/DecodeParms should not be an Array, when /Filter is a Name.&quot;); } return this.makeFilter(stream, filter.name, length, params); } let maybeLength = length; if (Array.isArray(filter)) { const filterArray = filter; const paramsArray = params; for (let i = 0, ii = filterArray.length; i &lt; ii; ++i) { filter = this.xref.fetchIfRef(filterArray[i]); if (!(filter instanceof _primitives.Name)) { throw new _util.FormatError(`Bad filter name &quot;${filter}&quot;`); } params = null; if (Array.isArray(paramsArray) &amp;&amp; i in paramsArray) { params = this.xref.fetchIfRef(paramsArray[i]); } stream = this.makeFilter(stream, filter.name, maybeLength, params); maybeLength = null; } } return stream; } makeFilter(stream, name, maybeLength, params) { if (maybeLength === 0) { (0, _util.warn)(`Empty &quot;${name}&quot; stream.`); return new _stream.NullStream(); } const xrefStats = this.xref.stats; try { switch (name) { case &quot;Fl&quot;: case &quot;FlateDecode&quot;: xrefStats.addStreamType(_util.StreamType.FLATE); if (params) { return new _predictor_stream.PredictorStream(new _flate_stream.FlateStream(stream, maybeLength), maybeLength, params); } return new _flate_stream.FlateStream(stream, maybeLength); case &quot;LZW&quot;: case &quot;LZWDecode&quot;: xrefStats.addStreamType(_util.StreamType.LZW); let earlyChange = 1; if (params) { if (params.has(&quot;EarlyChange&quot;)) { earlyChange = params.get(&quot;EarlyChange&quot;); } return new _predictor_stream.PredictorStream(new _lzw_stream.LZWStream(stream, maybeLength, earlyChange), maybeLength, params); } return new _lzw_stream.LZWStream(stream, maybeLength, earlyChange); case &quot;DCT&quot;: case &quot;DCTDecode&quot;: xrefStats.addStreamType(_util.StreamType.DCT); return new _jpeg_stream.JpegStream(stream, maybeLength, params); case &quot;JPX&quot;: case &quot;JPXDecode&quot;: xrefStats.addStreamType(_util.StreamType.JPX); return new _jpx_stream.JpxStream(stream, maybeLength, params); case &quot;A85&quot;: case &quot;ASCII85Decode&quot;: xrefStats.addStreamType(_util.StreamType.A85); return new _ascii_85_stream.Ascii85Stream(stream, maybeLength); case &quot;AHx&quot;: case &quot;ASCIIHexDecode&quot;: xrefStats.addStreamType(_util.StreamType.AHX); return new _ascii_hex_stream.AsciiHexStream(stream, maybeLength); case &quot;CCF&quot;: case &quot;CCITTFaxDecode&quot;: xrefStats.addStreamType(_util.StreamType.CCF); return new _ccitt_stream.CCITTFaxStream(stream, maybeLength, params); case &quot;RL&quot;: case &quot;RunLengthDecode&quot;: xrefStats.addStreamType(_util.StreamType.RLX); return new _run_length_stream.RunLengthStream(stream, maybeLength); case &quot;JBIG2Decode&quot;: xrefStats.addStreamType(_util.StreamType.JBIG); return new _jbig2_stream.Jbig2Stream(stream, maybeLength, params); } (0, _util.warn)(`Filter &quot;${name}&quot; is not supported.`); return stream; } catch (ex) { if (ex instanceof _core_utils.MissingDataException) { throw ex; } (0, _util.warn)(`Invalid stream: &quot;${ex}&quot;`); return new _stream.NullStream(); } } } exports.Parser = Parser; const specialChars = [1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 2, 0, 0, 2, 2, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]; function toHexDigit(ch) { if (ch &gt;= 0x30 &amp;&amp; ch &lt;= 0x39) { return ch &amp; 0x0f; } if (ch &gt;= 0x41 &amp;&amp; ch &lt;= 0x46 || ch &gt;= 0x61 &amp;&amp; ch &lt;= 0x66) { return (ch &amp; 0x0f) + 9; } return -1; } class Lexer { constructor(stream, knownCommands = null) { this.stream = stream; this.nextChar(); this.strBuf = []; this.knownCommands = knownCommands; this._hexStringNumWarn = 0; this.beginInlineImagePos = -1; } nextChar() { return this.currentChar = this.stream.getByte(); } peekChar() { return this.stream.peekByte(); } getNumber() { let ch = this.currentChar; let eNotation = false; let divideBy = 0; let sign = 0; if (ch === 0x2d) { sign = -1; ch = this.nextChar(); if (ch === 0x2d) { ch = this.nextChar(); } } else if (ch === 0x2b) { sign = 1; ch = this.nextChar(); } if (ch === 0x0a || ch === 0x0d) { do { ch = this.nextChar(); } while (ch === 0x0a || ch === 0x0d); } if (ch === 0x2e) { divideBy = 10; ch = this.nextChar(); } if (ch &lt; 0x30 || ch &gt; 0x39) { const msg = `Invalid number: ${String.fromCharCode(ch)} (charCode ${ch})`; if ((0, _core_utils.isWhiteSpace)(ch) || ch === -1) { (0, _util.info)(`Lexer.getNumber - &quot;${msg}&quot;.`); return 0; } throw new _util.FormatError(msg); } sign = sign || 1; let baseValue = ch - 0x30; let powerValue = 0; let powerValueSign = 1; while ((ch = this.nextChar()) &gt;= 0) { if (ch &gt;= 0x30 &amp;&amp; ch &lt;= 0x39) { const currentDigit = ch - 0x30; if (eNotation) { powerValue = powerValue * 10 + currentDigit; } else { if (divideBy !== 0) { divideBy *= 10; } baseValue = baseValue * 10 + currentDigit; } } else if (ch === 0x2e) { if (divideBy === 0) { divideBy = 1; } else { break; } } else if (ch === 0x2d) { (0, _util.warn)(&quot;Badly formatted number: minus sign in the middle&quot;); } else if (ch === 0x45 || ch === 0x65) { ch = this.peekChar(); if (ch === 0x2b || ch === 0x2d) { powerValueSign = ch === 0x2d ? -1 : 1; this.nextChar(); } else if (ch &lt; 0x30 || ch &gt; 0x39) { break; } eNotation = true; } else { break; } } if (divideBy !== 0) { baseValue /= divideBy; } if (eNotation) { baseValue *= 10 ** (powerValueSign * powerValue); } return sign * baseValue; } getString() { let numParen = 1; let done = false; const strBuf = this.strBuf; strBuf.length = 0; let ch = this.nextChar(); while (true) { let charBuffered = false; switch (ch | 0) { case -1: (0, _util.warn)(&quot;Unterminated string&quot;); done = true; break; case 0x28: ++numParen; strBuf.push(&quot;(&quot;); break; case 0x29: if (--numParen === 0) { this.nextChar(); done = true; } else { strBuf.push(&quot;)&quot;); } break; case 0x5c: ch = this.nextChar(); switch (ch) { case -1: (0, _util.warn)(&quot;Unterminated string&quot;); done = true; break; case 0x6e: strBuf.push(&quot;\\n&quot;); break; case 0x72: strBuf.push(&quot;\\r&quot;); break; case 0x74: strBuf.push(&quot;\\t&quot;); break; case 0x62: strBuf.push(&quot;\\b&quot;); break; case 0x66: strBuf.push(&quot;\\f&quot;); break; case 0x5c: case 0x28: case 0x29: strBuf.push(String.fromCharCode(ch)); break; case 0x30: case 0x31: case 0x32: case 0x33: case 0x34: case 0x35: case 0x36: case 0x37: let x = ch &amp; 0x0f; ch = this.nextChar(); charBuffered = true; if (ch &gt;= 0x30 &amp;&amp; ch &lt;= 0x37) { x = (x &lt;&lt; 3) + (ch &amp; 0x0f); ch = this.nextChar(); if (ch &gt;= 0x30 &amp;&amp; ch &lt;= 0x37) { charBuffered = false; x = (x &lt;&lt; 3) + (ch &amp; 0x0f); } } strBuf.push(String.fromCharCode(x)); break; case 0x0d: if (this.peekChar() === 0x0a) { this.nextChar(); } break; case 0x0a: break; default: strBuf.push(String.fromCharCode(ch)); break; } break; default: strBuf.push(String.fromCharCode(ch)); break; } if (done) { break; } if (!charBuffered) { ch = this.nextChar(); } } return strBuf.join(&quot;&quot;); } getName() { let ch, previousCh; const strBuf = this.strBuf; strBuf.length = 0; while ((ch = this.nextChar()) &gt;= 0 &amp;&amp; !specialChars[ch]) { if (ch === 0x23) { ch = this.nextChar(); if (specialChars[ch]) { (0, _util.warn)(&quot;Lexer_getName: &quot; + &quot;NUMBER SIGN (#) should be followed by a hexadecimal number.&quot;); strBuf.push(&quot;#&quot;); break; } const x = toHexDigit(ch); if (x !== -1) { previousCh = ch; ch = this.nextChar(); const x2 = toHexDigit(ch); if (x2 === -1) { (0, _util.warn)(`Lexer_getName: Illegal digit (${String.fromCharCode(ch)}) ` + &quot;in hexadecimal number.&quot;); strBuf.push(&quot;#&quot;, String.fromCharCode(previousCh)); if (specialChars[ch]) { break; } strBuf.push(String.fromCharCode(ch)); continue; } strBuf.push(String.fromCharCode(x &lt;&lt; 4 | x2)); } else { strBuf.push(&quot;#&quot;, String.fromCharCode(ch)); } } else { strBuf.push(String.fromCharCode(ch)); } } if (strBuf.length &gt; 127) { (0, _util.warn)(`Name token is longer than allowed by the spec: ${strBuf.length}`); } return _primitives.Name.get(strBuf.join(&quot;&quot;)); } _hexStringWarn(ch) { const MAX_HEX_STRING_NUM_WARN = 5; if (this._hexStringNumWarn++ === MAX_HEX_STRING_NUM_WARN) { (0, _util.warn)(&quot;getHexString - ignoring additional invalid characters.&quot;); return; } if (this._hexStringNumWarn &gt; MAX_HEX_STRING_NUM_WARN) { return; } (0, _util.warn)(`getHexString - ignoring invalid character: ${ch}`); } getHexString() { const strBuf = this.strBuf; strBuf.length = 0; let ch = this.currentChar; let isFirstHex = true; let firstDigit, secondDigit; this._hexStringNumWarn = 0; while (true) { if (ch &lt; 0) { (0, _util.warn)(&quot;Unterminated hex string&quot;); break; } else if (ch === 0x3e) { this.nextChar(); break; } else if (specialChars[ch] === 1) { ch = this.nextChar(); continue; } else { if (isFirstHex) { firstDigit = toHexDigit(ch); if (firstDigit === -1) { this._hexStringWarn(ch); ch = this.nextChar(); continue; } } else { secondDigit = toHexDigit(ch); if (secondDigit === -1) { this._hexStringWarn(ch); ch = this.nextChar(); continue; } strBuf.push(String.fromCharCode(firstDigit &lt;&lt; 4 | secondDigit)); } isFirstHex = !isFirstHex; ch = this.nextChar(); } } return strBuf.join(&quot;&quot;); } getObj() { let comment = false; let ch = this.currentChar; while (true) { if (ch &lt; 0) { return _primitives.EOF; } if (comment) { if (ch === 0x0a || ch === 0x0d) { comment = false; } } else if (ch === 0x25) { comment = true; } else if (specialChars[ch] !== 1) { break; } ch = this.nextChar(); } switch (ch | 0) { case 0x30: case 0x31: case 0x32: case 0x33: case 0x34: case 0x35: case 0x36: case 0x37: case 0x38: case 0x39: case 0x2b: case 0x2d: case 0x2e: return this.getNumber(); case 0x28: return this.getString(); case 0x2f: return this.getName(); case 0x5b: this.nextChar(); return _primitives.Cmd.get(&quot;[&quot;); case 0x5d: this.nextChar(); return _primitives.Cmd.get(&quot;]&quot;); case 0x3c: ch = this.nextChar(); if (ch === 0x3c) { this.nextChar(); return _primitives.Cmd.get(&quot;&lt;&lt;&quot;); } return this.getHexString(); case 0x3e: ch = this.nextChar(); if (ch === 0x3e) { this.nextChar(); return _primitives.Cmd.get(&quot;&gt;&gt;&quot;); } return _primitives.Cmd.get(&quot;&gt;&quot;); case 0x7b: this.nextChar(); return _primitives.Cmd.get(&quot;{&quot;); case 0x7d: this.nextChar(); return _primitives.Cmd.get(&quot;}&quot;); case 0x29: this.nextChar(); throw new _util.FormatError(`Illegal character: ${ch}`); } let str = String.fromCharCode(ch); if (ch &lt; 0x20 || ch &gt; 0x7f) { const nextCh = this.peekChar(); if (nextCh &gt;= 0x20 &amp;&amp; nextCh &lt;= 0x7f) { this.nextChar(); return _primitives.Cmd.get(str); } } const knownCommands = this.knownCommands; let knownCommandFound = knownCommands &amp;&amp; knownCommands[str] !== undefined; while ((ch = this.nextChar()) &gt;= 0 &amp;&amp; !specialChars[ch]) { const possibleCommand = str + String.fromCharCode(ch); if (knownCommandFound &amp;&amp; knownCommands[possibleCommand] === undefined) { break; } if (str.length === 128) { throw new _util.FormatError(`Command token too long: ${str.length}`); } str = possibleCommand; knownCommandFound = knownCommands &amp;&amp; knownCommands[str] !== undefined; } if (str === &quot;true&quot;) { return true; } if (str === &quot;false&quot;) { return false; } if (str === &quot;null&quot;) { return null; } if (str === &quot;BI&quot;) { this.beginInlineImagePos = this.stream.pos; } return _primitives.Cmd.get(str); } peekObj() { const streamPos = this.stream.pos, currentChar = this.currentChar, beginInlineImagePos = this.beginInlineImagePos; let nextObj; try { nextObj = this.getObj(); } catch (ex) { if (ex instanceof _core_utils.MissingDataException) { throw ex; } (0, _util.warn)(`peekObj: ${ex}`); } this.stream.pos = streamPos; this.currentChar = currentChar; this.beginInlineImagePos = beginInlineImagePos; return nextObj; } skipToNextLine() { let ch = this.currentChar; while (ch &gt;= 0) { if (ch === 0x0d) { ch = this.nextChar(); if (ch === 0x0a) { this.nextChar(); } break; } else if (ch === 0x0a) { this.nextChar(); break; } ch = this.nextChar(); } } } exports.Lexer = Lexer; class Linearization { static create(stream) { function getInt(linDict, name, allowZeroValue = false) { const obj = linDict.get(name); if (Number.isInteger(obj) &amp;&amp; (allowZeroValue ? obj &gt;= 0 : obj &gt; 0)) { return obj; } throw new Error(`The &quot;${name}&quot; parameter in the linearization ` + &quot;dictionary is invalid.&quot;); } function getHints(linDict) { const hints = linDict.get(&quot;H&quot;); let hintsLength; if (Array.isArray(hints) &amp;&amp; ((hintsLength = hints.length) === 2 || hintsLength === 4)) { for (let index = 0; index &lt; hintsLength; index++) { const hint = hints[index]; if (!(Number.isInteger(hint) &amp;&amp; hint &gt; 0)) { throw new Error(`Hint (${index}) in the linearization dictionary is invalid.`); } } return hints; } throw new Error(&quot;Hint array in the linearization dictionary is invalid.&quot;); } const parser = new Parser({ lexer: new Lexer(stream), xref: null }); const obj1 = parser.getObj(); const obj2 = parser.getObj(); const obj3 = parser.getObj(); const linDict = parser.getObj(); let obj, length; if (!(Number.isInteger(obj1) &amp;&amp; Number.isInteger(obj2) &amp;&amp; (0, _primitives.isCmd)(obj3, &quot;obj&quot;) &amp;&amp; linDict instanceof _primitives.Dict &amp;&amp; typeof (obj = linDict.get(&quot;Linearized&quot;)) === &quot;number&quot; &amp;&amp; obj &gt; 0)) { return null; } else if ((length = getInt(linDict, &quot;L&quot;)) !== stream.length) { throw new Error(&apos;The &quot;L&quot; parameter in the linearization dictionary &apos; + &quot;does not equal the stream length.&quot;); } return { length, hints: getHints(linDict), objectNumberFirst: getInt(linDict, &quot;O&quot;), endFirst: getInt(linDict, &quot;E&quot;), numPages: getInt(linDict, &quot;N&quot;), mainXRefEntriesOffset: getInt(linDict, &quot;T&quot;), pageFirst: linDict.has(&quot;P&quot;) ? getInt(linDict, &quot;P&quot;, true) : 0 }; } } exports.Linearization = Linearization; /***/ }), /* 16 */ /***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) =&gt; { Object.defineProperty(exports, &quot;__esModule&quot;, ({ value: true })); exports.Ascii85Stream = void 0; var _decode_stream = __w_pdfjs_require__(17); var _core_utils = __w_pdfjs_require__(4); class Ascii85Stream extends _decode_stream.DecodeStream { constructor(str, maybeLength) { if (maybeLength) { maybeLength *= 0.8; } super(maybeLength); this.str = str; this.dict = str.dict; this.input = new Uint8Array(5); } readBlock() { const TILDA_CHAR = 0x7e; const Z_LOWER_CHAR = 0x7a; const EOF = -1; const str = this.str; let c = str.getByte(); while ((0, _core_utils.isWhiteSpace)(c)) { c = str.getByte(); } if (c === EOF || c === TILDA_CHAR) { this.eof = true; return; } const bufferLength = this.bufferLength; let buffer, i; if (c === Z_LOWER_CHAR) { buffer = this.ensureBuffer(bufferLength + 4); for (i = 0; i &lt; 4; ++i) { buffer[bufferLength + i] = 0; } this.bufferLength += 4; } else { const input = this.input; input[0] = c; for (i = 1; i &lt; 5; ++i) { c = str.getByte(); while ((0, _core_utils.isWhiteSpace)(c)) { c = str.getByte(); } input[i] = c; if (c === EOF || c === TILDA_CHAR) { break; } } buffer = this.ensureBuffer(bufferLength + i - 1); this.bufferLength += i - 1; if (i &lt; 5) { for (; i &lt; 5; ++i) { input[i] = 0x21 + 84; } this.eof = true; } let t = 0; for (i = 0; i &lt; 5; ++i) { t = t * 85 + (input[i] - 0x21); } for (i = 3; i &gt;= 0; --i) { buffer[bufferLength + i] = t &amp; 0xff; t &gt;&gt;= 8; } } } } exports.Ascii85Stream = Ascii85Stream; /***/ }), /* 17 */ /***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) =&gt; { Object.defineProperty(exports, &quot;__esModule&quot;, ({ value: true })); exports.StreamsSequenceStream = exports.DecodeStream = void 0; var _base_stream = __w_pdfjs_require__(5); var _stream = __w_pdfjs_require__(8); const emptyBuffer = new Uint8Array(0); class DecodeStream extends _base_stream.BaseStream { constructor(maybeMinBufferLength) { super(); this._rawMinBufferLength = maybeMinBufferLength || 0; this.pos = 0; this.bufferLength = 0; this.eof = false; this.buffer = emptyBuffer; this.minBufferLength = 512; if (maybeMinBufferLength) { while (this.minBufferLength &lt; maybeMinBufferLength) { this.minBufferLength *= 2; } } } get isEmpty() { while (!this.eof &amp;&amp; this.bufferLength === 0) { this.readBlock(); } return this.bufferLength === 0; } ensureBuffer(requested) { const buffer = this.buffer; if (requested &lt;= buffer.byteLength) { return buffer; } let size = this.minBufferLength; while (size &lt; requested) { size *= 2; } const buffer2 = new Uint8Array(size); buffer2.set(buffer); return this.buffer = buffer2; } getByte() { const pos = this.pos; while (this.bufferLength &lt;= pos) { if (this.eof) { return -1; } this.readBlock(); } return this.buffer[this.pos++]; } getBytes(length) { const pos = this.pos; let end; if (length) { this.ensureBuffer(pos + length); end = pos + length; while (!this.eof &amp;&amp; this.bufferLength &lt; end) { this.readBlock(); } const bufEnd = this.bufferLength; if (end &gt; bufEnd) { end = bufEnd; } } else { while (!this.eof) { this.readBlock(); } end = this.bufferLength; } this.pos = end; return this.buffer.subarray(pos, end); } reset() { this.pos = 0; } makeSubStream(start, length, dict = null) { if (length === undefined) { while (!this.eof) { this.readBlock(); } } else { const end = start + length; while (this.bufferLength &lt;= end &amp;&amp; !this.eof) { this.readBlock(); } } return new _stream.Stream(this.buffer, start, length, dict); } getBaseStreams() { return this.str ? this.str.getBaseStreams() : null; } } exports.DecodeStream = DecodeStream; class StreamsSequenceStream extends DecodeStream { constructor(streams, onError = null) { let maybeLength = 0; for (const stream of streams) { maybeLength += stream instanceof DecodeStream ? stream._rawMinBufferLength : stream.length; } super(maybeLength); this.streams = streams; this._onError = onError; } readBlock() { const streams = this.streams; if (streams.length === 0) { this.eof = true; return; } const stream = streams.shift(); let chunk; try { chunk = stream.getBytes(); } catch (reason) { if (this._onError) { this._onError(reason, stream.dict &amp;&amp; stream.dict.objId); return; } throw reason; } const bufferLength = this.bufferLength; const newLength = bufferLength + chunk.length; const buffer = this.ensureBuffer(newLength); buffer.set(chunk, bufferLength); this.bufferLength = newLength; } getBaseStreams() { const baseStreamsBuf = []; for (const stream of this.streams) { const baseStreams = stream.getBaseStreams(); if (baseStreams) { baseStreamsBuf.push(...baseStreams); } } return baseStreamsBuf.length &gt; 0 ? baseStreamsBuf : null; } } exports.StreamsSequenceStream = StreamsSequenceStream; /***/ }), /* 18 */ /***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) =&gt; { Object.defineProperty(exports, &quot;__esModule&quot;, ({ value: true })); exports.AsciiHexStream = void 0; var _decode_stream = __w_pdfjs_require__(17); class AsciiHexStream extends _decode_stream.DecodeStream { constructor(str, maybeLength) { if (maybeLength) { maybeLength *= 0.5; } super(maybeLength); this.str = str; this.dict = str.dict; this.firstDigit = -1; } readBlock() { const UPSTREAM_BLOCK_SIZE = 8000; const bytes = this.str.getBytes(UPSTREAM_BLOCK_SIZE); if (!bytes.length) { this.eof = true; return; } const maxDecodeLength = bytes.length + 1 &gt;&gt; 1; const buffer = this.ensureBuffer(this.bufferLength + maxDecodeLength); let bufferLength = this.bufferLength; let firstDigit = this.firstDigit; for (const ch of bytes) { let digit; if (ch &gt;= 0x30 &amp;&amp; ch &lt;= 0x39) { digit = ch &amp; 0x0f; } else if (ch &gt;= 0x41 &amp;&amp; ch &lt;= 0x46 || ch &gt;= 0x61 &amp;&amp; ch &lt;= 0x66) { digit = (ch &amp; 0x0f) + 9; } else if (ch === 0x3e) { this.eof = true; break; } else { continue; } if (firstDigit &lt; 0) { firstDigit = digit; } else { buffer[bufferLength++] = firstDigit &lt;&lt; 4 | digit; firstDigit = -1; } } if (firstDigit &gt;= 0 &amp;&amp; this.eof) { buffer[bufferLength++] = firstDigit &lt;&lt; 4; firstDigit = -1; } this.firstDigit = firstDigit; this.bufferLength = bufferLength; } } exports.AsciiHexStream = AsciiHexStream; /***/ }), /* 19 */ /***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) =&gt; { Object.defineProperty(exports, &quot;__esModule&quot;, ({ value: true })); exports.CCITTFaxStream = void 0; var _ccitt = __w_pdfjs_require__(20); var _decode_stream = __w_pdfjs_require__(17); var _primitives = __w_pdfjs_require__(3); class CCITTFaxStream extends _decode_stream.DecodeStream { constructor(str, maybeLength, params) { super(maybeLength); this.str = str; this.dict = str.dict; if (!(params instanceof _primitives.Dict)) { params = _primitives.Dict.empty; } const source = { next() { return str.getByte(); } }; this.ccittFaxDecoder = new _ccitt.CCITTFaxDecoder(source, { K: params.get(&quot;K&quot;), EndOfLine: params.get(&quot;EndOfLine&quot;), EncodedByteAlign: params.get(&quot;EncodedByteAlign&quot;), Columns: params.get(&quot;Columns&quot;), Rows: params.get(&quot;Rows&quot;), EndOfBlock: params.get(&quot;EndOfBlock&quot;), BlackIs1: params.get(&quot;BlackIs1&quot;) }); } readBlock() { while (!this.eof) { const c = this.ccittFaxDecoder.readNextChar(); if (c === -1) { this.eof = true; return; } this.ensureBuffer(this.bufferLength + 1); this.buffer[this.bufferLength++] = c; } } } exports.CCITTFaxStream = CCITTFaxStream; /***/ }), /* 20 */ /***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) =&gt; { Object.defineProperty(exports, &quot;__esModule&quot;, ({ value: true })); exports.CCITTFaxDecoder = void 0; var _util = __w_pdfjs_require__(2); const ccittEOL = -2; const ccittEOF = -1; const twoDimPass = 0; const twoDimHoriz = 1; const twoDimVert0 = 2; const twoDimVertR1 = 3; const twoDimVertL1 = 4; const twoDimVertR2 = 5; const twoDimVertL2 = 6; const twoDimVertR3 = 7; const twoDimVertL3 = 8; const twoDimTable = [[-1, -1], [-1, -1], [7, twoDimVertL3], [7, twoDimVertR3], [6, twoDimVertL2], [6, twoDimVertL2], [6, twoDimVertR2], [6, twoDimVertR2], [4, twoDimPass], [4, twoDimPass], [4, twoDimPass], [4, twoDimPass], [4, twoDimPass], [4, twoDimPass], [4, twoDimPass], [4, twoDimPass], [3, twoDimHoriz], [3, twoDimHoriz], [3, twoDimHoriz], [3, twoDimHoriz], [3, twoDimHoriz], [3, twoDimHoriz], [3, twoDimHoriz], [3, twoDimHoriz], [3, twoDimHoriz], [3, twoDimHoriz], [3, twoDimHoriz], [3, twoDimHoriz], [3, twoDimHoriz], [3, twoDimHoriz], [3, twoDimHoriz], [3, twoDimHoriz], [3, twoDimVertL1], [3, twoDimVertL1], [3, twoDimVertL1], [3, twoDimVertL1], [3, twoDimVertL1], [3, twoDimVertL1], [3, twoDimVertL1], [3, twoDimVertL1], [3, twoDimVertL1], [3, twoDimVertL1], [3, twoDimVertL1], [3, twoDimVertL1], [3, twoDimVertL1], [3, twoDimVertL1], [3, twoDimVertL1], [3, twoDimVertL1], [3, twoDimVertR1], [3, twoDimVertR1], [3, twoDimVertR1], [3, twoDimVertR1], [3, twoDimVertR1], [3, twoDimVertR1], [3, twoDimVertR1], [3, twoDimVertR1], [3, twoDimVertR1], [3, twoDimVertR1], [3, twoDimVertR1], [3, twoDimVertR1], [3, twoDimVertR1], [3, twoDimVertR1], [3, twoDimVertR1], [3, twoDimVertR1], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0]]; const whiteTable1 = [[-1, -1], [12, ccittEOL], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [11, 1792], [11, 1792], [12, 1984], [12, 2048], [12, 2112], [12, 2176], [12, 2240], [12, 2304], [11, 1856], [11, 1856], [11, 1920], [11, 1920], [12, 2368], [12, 2432], [12, 2496], [12, 2560]]; const whiteTable2 = [[-1, -1], [-1, -1], [-1, -1], [-1, -1], [8, 29], [8, 29], [8, 30], [8, 30], [8, 45], [8, 45], [8, 46], [8, 46], [7, 22], [7, 22], [7, 22], [7, 22], [7, 23], [7, 23], [7, 23], [7, 23], [8, 47], [8, 47], [8, 48], [8, 48], [6, 13], [6, 13], [6, 13], [6, 13], [6, 13], [6, 13], [6, 13], [6, 13], [7, 20], [7, 20], [7, 20], [7, 20], [8, 33], [8, 33], [8, 34], [8, 34], [8, 35], [8, 35], [8, 36], [8, 36], [8, 37], [8, 37], [8, 38], [8, 38], [7, 19], [7, 19], [7, 19], [7, 19], [8, 31], [8, 31], [8, 32], [8, 32], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 12], [6, 12], [6, 12], [6, 12], [6, 12], [6, 12], [6, 12], [6, 12], [8, 53], [8, 53], [8, 54], [8, 54], [7, 26], [7, 26], [7, 26], [7, 26], [8, 39], [8, 39], [8, 40], [8, 40], [8, 41], [8, 41], [8, 42], [8, 42], [8, 43], [8, 43], [8, 44], [8, 44], [7, 21], [7, 21], [7, 21], [7, 21], [7, 28], [7, 28], [7, 28], [7, 28], [8, 61], [8, 61], [8, 62], [8, 62], [8, 63], [8, 63], [8, 0], [8, 0], [8, 320], [8, 320], [8, 384], [8, 384], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [7, 27], [7, 27], [7, 27], [7, 27], [8, 59], [8, 59], [8, 60], [8, 60], [9, 1472], [9, 1536], [9, 1600], [9, 1728], [7, 18], [7, 18], [7, 18], [7, 18], [7, 24], [7, 24], [7, 24], [7, 24], [8, 49], [8, 49], [8, 50], [8, 50], [8, 51], [8, 51], [8, 52], [8, 52], [7, 25], [7, 25], [7, 25], [7, 25], [8, 55], [8, 55], [8, 56], [8, 56], [8, 57], [8, 57], [8, 58], [8, 58], [6, 192], [6, 192], [6, 192], [6, 192], [6, 192], [6, 192], [6, 192], [6, 192], [6, 1664], [6, 1664], [6, 1664], [6, 1664], [6, 1664], [6, 1664], [6, 1664], [6, 1664], [8, 448], [8, 448], [8, 512], [8, 512], [9, 704], [9, 768], [8, 640], [8, 640], [8, 576], [8, 576], [9, 832], [9, 896], [9, 960], [9, 1024], [9, 1088], [9, 1152], [9, 1216], [9, 1280], [9, 1344], [9, 1408], [7, 256], [7, 256], [7, 256], [7, 256], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [6, 16], [6, 16], [6, 16], [6, 16], [6, 16], [6, 16], [6, 16], [6, 16], [6, 17], [6, 17], [6, 17], [6, 17], [6, 17], [6, 17], [6, 17], [6, 17], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [6, 14], [6, 14], [6, 14], [6, 14], [6, 14], [6, 14], [6, 14], [6, 14], [6, 15], [6, 15], [6, 15], [6, 15], [6, 15], [6, 15], [6, 15], [6, 15], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7]]; const blackTable1 = [[-1, -1], [-1, -1], [12, ccittEOL], [12, ccittEOL], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [11, 1792], [11, 1792], [11, 1792], [11, 1792], [12, 1984], [12, 1984], [12, 2048], [12, 2048], [12, 2112], [12, 2112], [12, 2176], [12, 2176], [12, 2240], [12, 2240], [12, 2304], [12, 2304], [11, 1856], [11, 1856], [11, 1856], [11, 1856], [11, 1920], [11, 1920], [11, 1920], [11, 1920], [12, 2368], [12, 2368], [12, 2432], [12, 2432], [12, 2496], [12, 2496], [12, 2560], [12, 2560], [10, 18], [10, 18], [10, 18], [10, 18], [10, 18], [10, 18], [10, 18], [10, 18], [12, 52], [12, 52], [13, 640], [13, 704], [13, 768], [13, 832], [12, 55], [12, 55], [12, 56], [12, 56], [13, 1280], [13, 1344], [13, 1408], [13, 1472], [12, 59], [12, 59], [12, 60], [12, 60], [13, 1536], [13, 1600], [11, 24], [11, 24], [11, 24], [11, 24], [11, 25], [11, 25], [11, 25], [11, 25], [13, 1664], [13, 1728], [12, 320], [12, 320], [12, 384], [12, 384], [12, 448], [12, 448], [13, 512], [13, 576], [12, 53], [12, 53], [12, 54], [12, 54], [13, 896], [13, 960], [13, 1024], [13, 1088], [13, 1152], [13, 1216], [10, 64], [10, 64], [10, 64], [10, 64], [10, 64], [10, 64], [10, 64], [10, 64]]; const blackTable2 = [[8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [11, 23], [11, 23], [12, 50], [12, 51], [12, 44], [12, 45], [12, 46], [12, 47], [12, 57], [12, 58], [12, 61], [12, 256], [10, 16], [10, 16], [10, 16], [10, 16], [10, 17], [10, 17], [10, 17], [10, 17], [12, 48], [12, 49], [12, 62], [12, 63], [12, 30], [12, 31], [12, 32], [12, 33], [12, 40], [12, 41], [11, 22], [11, 22], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [9, 15], [9, 15], [9, 15], [9, 15], [9, 15], [9, 15], [9, 15], [9, 15], [12, 128], [12, 192], [12, 26], [12, 27], [12, 28], [12, 29], [11, 19], [11, 19], [11, 20], [11, 20], [12, 34], [12, 35], [12, 36], [12, 37], [12, 38], [12, 39], [11, 21], [11, 21], [12, 42], [12, 43], [10, 0], [10, 0], [10, 0], [10, 0], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12]]; const blackTable3 = [[-1, -1], [-1, -1], [-1, -1], [-1, -1], [6, 9], [6, 8], [5, 7], [5, 7], [4, 6], [4, 6], [4, 6], [4, 6], [4, 5], [4, 5], [4, 5], [4, 5], [3, 1], [3, 1], [3, 1], [3, 1], [3, 1], [3, 1], [3, 1], [3, 1], [3, 4], [3, 4], [3, 4], [3, 4], [3, 4], [3, 4], [3, 4], [3, 4], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2]]; class CCITTFaxDecoder { constructor(source, options = {}) { if (!source || typeof source.next !== &quot;function&quot;) { throw new Error(&apos;CCITTFaxDecoder - invalid &quot;source&quot; parameter.&apos;); } this.source = source; this.eof = false; this.encoding = options.K || 0; this.eoline = options.EndOfLine || false; this.byteAlign = options.EncodedByteAlign || false; this.columns = options.Columns || 1728; this.rows = options.Rows || 0; let eoblock = options.EndOfBlock; if (eoblock === null || eoblock === undefined) { eoblock = true; } this.eoblock = eoblock; this.black = options.BlackIs1 || false; this.codingLine = new Uint32Array(this.columns + 1); this.refLine = new Uint32Array(this.columns + 2); this.codingLine[0] = this.columns; this.codingPos = 0; this.row = 0; this.nextLine2D = this.encoding &lt; 0; this.inputBits = 0; this.inputBuf = 0; this.outputBits = 0; this.rowsDone = false; let code1; while ((code1 = this._lookBits(12)) === 0) { this._eatBits(1); } if (code1 === 1) { this._eatBits(12); } if (this.encoding &gt; 0) { this.nextLine2D = !this._lookBits(1); this._eatBits(1); } } readNextChar() { if (this.eof) { return -1; } const refLine = this.refLine; const codingLine = this.codingLine; const columns = this.columns; let refPos, blackPixels, bits, i; if (this.outputBits === 0) { if (this.rowsDone) { this.eof = true; } if (this.eof) { return -1; } this.err = false; let code1, code2, code3; if (this.nextLine2D) { for (i = 0; codingLine[i] &lt; columns; ++i) { refLine[i] = codingLine[i]; } refLine[i++] = columns; refLine[i] = columns; codingLine[0] = 0; this.codingPos = 0; refPos = 0; blackPixels = 0; while (codingLine[this.codingPos] &lt; columns) { code1 = this._getTwoDimCode(); switch (code1) { case twoDimPass: this._addPixels(refLine[refPos + 1], blackPixels); if (refLine[refPos + 1] &lt; columns) { refPos += 2; } break; case twoDimHoriz: code1 = code2 = 0; if (blackPixels) { do { code1 += code3 = this._getBlackCode(); } while (code3 &gt;= 64); do { code2 += code3 = this._getWhiteCode(); } while (code3 &gt;= 64); } else { do { code1 += code3 = this._getWhiteCode(); } while (code3 &gt;= 64); do { code2 += code3 = this._getBlackCode(); } while (code3 &gt;= 64); } this._addPixels(codingLine[this.codingPos] + code1, blackPixels); if (codingLine[this.codingPos] &lt; columns) { this._addPixels(codingLine[this.codingPos] + code2, blackPixels ^ 1); } while (refLine[refPos] &lt;= codingLine[this.codingPos] &amp;&amp; refLine[refPos] &lt; columns) { refPos += 2; } break; case twoDimVertR3: this._addPixels(refLine[refPos] + 3, blackPixels); blackPixels ^= 1; if (codingLine[this.codingPos] &lt; columns) { ++refPos; while (refLine[refPos] &lt;= codingLine[this.codingPos] &amp;&amp; refLine[refPos] &lt; columns) { refPos += 2; } } break; case twoDimVertR2: this._addPixels(refLine[refPos] + 2, blackPixels); blackPixels ^= 1; if (codingLine[this.codingPos] &lt; columns) { ++refPos; while (refLine[refPos] &lt;= codingLine[this.codingPos] &amp;&amp; refLine[refPos] &lt; columns) { refPos += 2; } } break; case twoDimVertR1: this._addPixels(refLine[refPos] + 1, blackPixels); blackPixels ^= 1; if (codingLine[this.codingPos] &lt; columns) { ++refPos; while (refLine[refPos] &lt;= codingLine[this.codingPos] &amp;&amp; refLine[refPos] &lt; columns) { refPos += 2; } } break; case twoDimVert0: this._addPixels(refLine[refPos], blackPixels); blackPixels ^= 1; if (codingLine[this.codingPos] &lt; columns) { ++refPos; while (refLine[refPos] &lt;= codingLine[this.codingPos] &amp;&amp; refLine[refPos] &lt; columns) { refPos += 2; } } break; case twoDimVertL3: this._addPixelsNeg(refLine[refPos] - 3, blackPixels); blackPixels ^= 1; if (codingLine[this.codingPos] &lt; columns) { if (refPos &gt; 0) { --refPos; } else { ++refPos; } while (refLine[refPos] &lt;= codingLine[this.codingPos] &amp;&amp; refLine[refPos] &lt; columns) { refPos += 2; } } break; case twoDimVertL2: this._addPixelsNeg(refLine[refPos] - 2, blackPixels); blackPixels ^= 1; if (codingLine[this.codingPos] &lt; columns) { if (refPos &gt; 0) { --refPos; } else { ++refPos; } while (refLine[refPos] &lt;= codingLine[this.codingPos] &amp;&amp; refLine[refPos] &lt; columns) { refPos += 2; } } break; case twoDimVertL1: this._addPixelsNeg(refLine[refPos] - 1, blackPixels); blackPixels ^= 1; if (codingLine[this.codingPos] &lt; columns) { if (refPos &gt; 0) { --refPos; } else { ++refPos; } while (refLine[refPos] &lt;= codingLine[this.codingPos] &amp;&amp; refLine[refPos] &lt; columns) { refPos += 2; } } break; case ccittEOF: this._addPixels(columns, 0); this.eof = true; break; default: (0, _util.info)(&quot;bad 2d code&quot;); this._addPixels(columns, 0); this.err = true; } } } else { codingLine[0] = 0; this.codingPos = 0; blackPixels = 0; while (codingLine[this.codingPos] &lt; columns) { code1 = 0; if (blackPixels) { do { code1 += code3 = this._getBlackCode(); } while (code3 &gt;= 64); } else { do { code1 += code3 = this._getWhiteCode(); } while (code3 &gt;= 64); } this._addPixels(codingLine[this.codingPos] + code1, blackPixels); blackPixels ^= 1; } } let gotEOL = false; if (this.byteAlign) { this.inputBits &amp;= ~7; } if (!this.eoblock &amp;&amp; this.row === this.rows - 1) { this.rowsDone = true; } else { code1 = this._lookBits(12); if (this.eoline) { while (code1 !== ccittEOF &amp;&amp; code1 !== 1) { this._eatBits(1); code1 = this._lookBits(12); } } else { while (code1 === 0) { this._eatBits(1); code1 = this._lookBits(12); } } if (code1 === 1) { this._eatBits(12); gotEOL = true; } else if (code1 === ccittEOF) { this.eof = true; } } if (!this.eof &amp;&amp; this.encoding &gt; 0 &amp;&amp; !this.rowsDone) { this.nextLine2D = !this._lookBits(1); this._eatBits(1); } if (this.eoblock &amp;&amp; gotEOL &amp;&amp; this.byteAlign) { code1 = this._lookBits(12); if (code1 === 1) { this._eatBits(12); if (this.encoding &gt; 0) { this._lookBits(1); this._eatBits(1); } if (this.encoding &gt;= 0) { for (i = 0; i &lt; 4; ++i) { code1 = this._lookBits(12); if (code1 !== 1) { (0, _util.info)(&quot;bad rtc code: &quot; + code1); } this._eatBits(12); if (this.encoding &gt; 0) { this._lookBits(1); this._eatBits(1); } } } this.eof = true; } } else if (this.err &amp;&amp; this.eoline) { while (true) { code1 = this._lookBits(13); if (code1 === ccittEOF) { this.eof = true; return -1; } if (code1 &gt;&gt; 1 === 1) { break; } this._eatBits(1); } this._eatBits(12); if (this.encoding &gt; 0) { this._eatBits(1); this.nextLine2D = !(code1 &amp; 1); } } if (codingLine[0] &gt; 0) { this.outputBits = codingLine[this.codingPos = 0]; } else { this.outputBits = codingLine[this.codingPos = 1]; } this.row++; } let c; if (this.outputBits &gt;= 8) { c = this.codingPos &amp; 1 ? 0 : 0xff; this.outputBits -= 8; if (this.outputBits === 0 &amp;&amp; codingLine[this.codingPos] &lt; columns) { this.codingPos++; this.outputBits = codingLine[this.codingPos] - codingLine[this.codingPos - 1]; } } else { bits = 8; c = 0; do { if (typeof this.outputBits !== &quot;number&quot;) { throw new _util.FormatError(&apos;Invalid /CCITTFaxDecode data, &quot;outputBits&quot; must be a number.&apos;); } if (this.outputBits &gt; bits) { c &lt;&lt;= bits; if (!(this.codingPos &amp; 1)) { c |= 0xff &gt;&gt; 8 - bits; } this.outputBits -= bits; bits = 0; } else { c &lt;&lt;= this.outputBits; if (!(this.codingPos &amp; 1)) { c |= 0xff &gt;&gt; 8 - this.outputBits; } bits -= this.outputBits; this.outputBits = 0; if (codingLine[this.codingPos] &lt; columns) { this.codingPos++; this.outputBits = codingLine[this.codingPos] - codingLine[this.codingPos - 1]; } else if (bits &gt; 0) { c &lt;&lt;= bits; bits = 0; } } } while (bits); } if (this.black) { c ^= 0xff; } return c; } _addPixels(a1, blackPixels) { const codingLine = this.codingLine; let codingPos = this.codingPos; if (a1 &gt; codingLine[codingPos]) { if (a1 &gt; this.columns) { (0, _util.info)(&quot;row is wrong length&quot;); this.err = true; a1 = this.columns; } if (codingPos &amp; 1 ^ blackPixels) { ++codingPos; } codingLine[codingPos] = a1; } this.codingPos = codingPos; } _addPixelsNeg(a1, blackPixels) { const codingLine = this.codingLine; let codingPos = this.codingPos; if (a1 &gt; codingLine[codingPos]) { if (a1 &gt; this.columns) { (0, _util.info)(&quot;row is wrong length&quot;); this.err = true; a1 = this.columns; } if (codingPos &amp; 1 ^ blackPixels) { ++codingPos; } codingLine[codingPos] = a1; } else if (a1 &lt; codingLine[codingPos]) { if (a1 &lt; 0) { (0, _util.info)(&quot;invalid code&quot;); this.err = true; a1 = 0; } while (codingPos &gt; 0 &amp;&amp; a1 &lt; codingLine[codingPos - 1]) { --codingPos; } codingLine[codingPos] = a1; } this.codingPos = codingPos; } _findTableCode(start, end, table, limit) { const limitValue = limit || 0; for (let i = start; i &lt;= end; ++i) { let code = this._lookBits(i); if (code === ccittEOF) { return [true, 1, false]; } if (i &lt; end) { code &lt;&lt;= end - i; } if (!limitValue || code &gt;= limitValue) { const p = table[code - limitValue]; if (p[0] === i) { this._eatBits(i); return [true, p[1], true]; } } } return [false, 0, false]; } _getTwoDimCode() { let code = 0; let p; if (this.eoblock) { code = this._lookBits(7); p = twoDimTable[code]; if (p &amp;&amp; p[0] &gt; 0) { this._eatBits(p[0]); return p[1]; } } else { const result = this._findTableCode(1, 7, twoDimTable); if (result[0] &amp;&amp; result[2]) { return result[1]; } } (0, _util.info)(&quot;Bad two dim code&quot;); return ccittEOF; } _getWhiteCode() { let code = 0; let p; if (this.eoblock) { code = this._lookBits(12); if (code === ccittEOF) { return 1; } if (code &gt;&gt; 5 === 0) { p = whiteTable1[code]; } else { p = whiteTable2[code &gt;&gt; 3]; } if (p[0] &gt; 0) { this._eatBits(p[0]); return p[1]; } } else { let result = this._findTableCode(1, 9, whiteTable2); if (result[0]) { return result[1]; } result = this._findTableCode(11, 12, whiteTable1); if (result[0]) { return result[1]; } } (0, _util.info)(&quot;bad white code&quot;); this._eatBits(1); return 1; } _getBlackCode() { let code, p; if (this.eoblock) { code = this._lookBits(13); if (code === ccittEOF) { return 1; } if (code &gt;&gt; 7 === 0) { p = blackTable1[code]; } else if (code &gt;&gt; 9 === 0 &amp;&amp; code &gt;&gt; 7 !== 0) { p = blackTable2[(code &gt;&gt; 1) - 64]; } else { p = blackTable3[code &gt;&gt; 7]; } if (p[0] &gt; 0) { this._eatBits(p[0]); return p[1]; } } else { let result = this._findTableCode(2, 6, blackTable3); if (result[0]) { return result[1]; } result = this._findTableCode(7, 12, blackTable2, 64); if (result[0]) { return result[1]; } result = this._findTableCode(10, 13, blackTable1); if (result[0]) { return result[1]; } } (0, _util.info)(&quot;bad black code&quot;); this._eatBits(1); return 1; } _lookBits(n) { let c; while (this.inputBits &lt; n) { if ((c = this.source.next()) === -1) { if (this.inputBits === 0) { return ccittEOF; } return this.inputBuf &lt;&lt; n - this.inputBits &amp; 0xffff &gt;&gt; 16 - n; } this.inputBuf = this.inputBuf &lt;&lt; 8 | c; this.inputBits += 8; } return this.inputBuf &gt;&gt; this.inputBits - n &amp; 0xffff &gt;&gt; 16 - n; } _eatBits(n) { if ((this.inputBits -= n) &lt; 0) { this.inputBits = 0; } } } exports.CCITTFaxDecoder = CCITTFaxDecoder; /***/ }), /* 21 */ /***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) =&gt; { Object.defineProperty(exports, &quot;__esModule&quot;, ({ value: true })); exports.FlateStream = void 0; var _decode_stream = __w_pdfjs_require__(17); var _util = __w_pdfjs_require__(2); const codeLenCodeMap = new Int32Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]); const lengthDecode = new Int32Array([0x00003, 0x00004, 0x00005, 0x00006, 0x00007, 0x00008, 0x00009, 0x0000a, 0x1000b, 0x1000d, 0x1000f, 0x10011, 0x20013, 0x20017, 0x2001b, 0x2001f, 0x30023, 0x3002b, 0x30033, 0x3003b, 0x40043, 0x40053, 0x40063, 0x40073, 0x50083, 0x500a3, 0x500c3, 0x500e3, 0x00102, 0x00102, 0x00102]); const distDecode = new Int32Array([0x00001, 0x00002, 0x00003, 0x00004, 0x10005, 0x10007, 0x20009, 0x2000d, 0x30011, 0x30019, 0x40021, 0x40031, 0x50041, 0x50061, 0x60081, 0x600c1, 0x70101, 0x70181, 0x80201, 0x80301, 0x90401, 0x90601, 0xa0801, 0xa0c01, 0xb1001, 0xb1801, 0xc2001, 0xc3001, 0xd4001, 0xd6001]); const fixedLitCodeTab = [new Int32Array([0x70100, 0x80050, 0x80010, 0x80118, 0x70110, 0x80070, 0x80030, 0x900c0, 0x70108, 0x80060, 0x80020, 0x900a0, 0x80000, 0x80080, 0x80040, 0x900e0, 0x70104, 0x80058, 0x80018, 0x90090, 0x70114, 0x80078, 0x80038, 0x900d0, 0x7010c, 0x80068, 0x80028, 0x900b0, 0x80008, 0x80088, 0x80048, 0x900f0, 0x70102, 0x80054, 0x80014, 0x8011c, 0x70112, 0x80074, 0x80034, 0x900c8, 0x7010a, 0x80064, 0x80024, 0x900a8, 0x80004, 0x80084, 0x80044, 0x900e8, 0x70106, 0x8005c, 0x8001c, 0x90098, 0x70116, 0x8007c, 0x8003c, 0x900d8, 0x7010e, 0x8006c, 0x8002c, 0x900b8, 0x8000c, 0x8008c, 0x8004c, 0x900f8, 0x70101, 0x80052, 0x80012, 0x8011a, 0x70111, 0x80072, 0x80032, 0x900c4, 0x70109, 0x80062, 0x80022, 0x900a4, 0x80002, 0x80082, 0x80042, 0x900e4, 0x70105, 0x8005a, 0x8001a, 0x90094, 0x70115, 0x8007a, 0x8003a, 0x900d4, 0x7010d, 0x8006a, 0x8002a, 0x900b4, 0x8000a, 0x8008a, 0x8004a, 0x900f4, 0x70103, 0x80056, 0x80016, 0x8011e, 0x70113, 0x80076, 0x80036, 0x900cc, 0x7010b, 0x80066, 0x80026, 0x900ac, 0x80006, 0x80086, 0x80046, 0x900ec, 0x70107, 0x8005e, 0x8001e, 0x9009c, 0x70117, 0x8007e, 0x8003e, 0x900dc, 0x7010f, 0x8006e, 0x8002e, 0x900bc, 0x8000e, 0x8008e, 0x8004e, 0x900fc, 0x70100, 0x80051, 0x80011, 0x80119, 0x70110, 0x80071, 0x80031, 0x900c2, 0x70108, 0x80061, 0x80021, 0x900a2, 0x80001, 0x80081, 0x80041, 0x900e2, 0x70104, 0x80059, 0x80019, 0x90092, 0x70114, 0x80079, 0x80039, 0x900d2, 0x7010c, 0x80069, 0x80029, 0x900b2, 0x80009, 0x80089, 0x80049, 0x900f2, 0x70102, 0x80055, 0x80015, 0x8011d, 0x70112, 0x80075, 0x80035, 0x900ca, 0x7010a, 0x80065, 0x80025, 0x900aa, 0x80005, 0x80085, 0x80045, 0x900ea, 0x70106, 0x8005d, 0x8001d, 0x9009a, 0x70116, 0x8007d, 0x8003d, 0x900da, 0x7010e, 0x8006d, 0x8002d, 0x900ba, 0x8000d, 0x8008d, 0x8004d, 0x900fa, 0x70101, 0x80053, 0x80013, 0x8011b, 0x70111, 0x80073, 0x80033, 0x900c6, 0x70109, 0x80063, 0x80023, 0x900a6, 0x80003, 0x80083, 0x80043, 0x900e6, 0x70105, 0x8005b, 0x8001b, 0x90096, 0x70115, 0x8007b, 0x8003b, 0x900d6, 0x7010d, 0x8006b, 0x8002b, 0x900b6, 0x8000b, 0x8008b, 0x8004b, 0x900f6, 0x70103, 0x80057, 0x80017, 0x8011f, 0x70113, 0x80077, 0x80037, 0x900ce, 0x7010b, 0x80067, 0x80027, 0x900ae, 0x80007, 0x80087, 0x80047, 0x900ee, 0x70107, 0x8005f, 0x8001f, 0x9009e, 0x70117, 0x8007f, 0x8003f, 0x900de, 0x7010f, 0x8006f, 0x8002f, 0x900be, 0x8000f, 0x8008f, 0x8004f, 0x900fe, 0x70100, 0x80050, 0x80010, 0x80118, 0x70110, 0x80070, 0x80030, 0x900c1, 0x70108, 0x80060, 0x80020, 0x900a1, 0x80000, 0x80080, 0x80040, 0x900e1, 0x70104, 0x80058, 0x80018, 0x90091, 0x70114, 0x80078, 0x80038, 0x900d1, 0x7010c, 0x80068, 0x80028, 0x900b1, 0x80008, 0x80088, 0x80048, 0x900f1, 0x70102, 0x80054, 0x80014, 0x8011c, 0x70112, 0x80074, 0x80034, 0x900c9, 0x7010a, 0x80064, 0x80024, 0x900a9, 0x80004, 0x80084, 0x80044, 0x900e9, 0x70106, 0x8005c, 0x8001c, 0x90099, 0x70116, 0x8007c, 0x8003c, 0x900d9, 0x7010e, 0x8006c, 0x8002c, 0x900b9, 0x8000c, 0x8008c, 0x8004c, 0x900f9, 0x70101, 0x80052, 0x80012, 0x8011a, 0x70111, 0x80072, 0x80032, 0x900c5, 0x70109, 0x80062, 0x80022, 0x900a5, 0x80002, 0x80082, 0x80042, 0x900e5, 0x70105, 0x8005a, 0x8001a, 0x90095, 0x70115, 0x8007a, 0x8003a, 0x900d5, 0x7010d, 0x8006a, 0x8002a, 0x900b5, 0x8000a, 0x8008a, 0x8004a, 0x900f5, 0x70103, 0x80056, 0x80016, 0x8011e, 0x70113, 0x80076, 0x80036, 0x900cd, 0x7010b, 0x80066, 0x80026, 0x900ad, 0x80006, 0x80086, 0x80046, 0x900ed, 0x70107, 0x8005e, 0x8001e, 0x9009d, 0x70117, 0x8007e, 0x8003e, 0x900dd, 0x7010f, 0x8006e, 0x8002e, 0x900bd, 0x8000e, 0x8008e, 0x8004e, 0x900fd, 0x70100, 0x80051, 0x80011, 0x80119, 0x70110, 0x80071, 0x80031, 0x900c3, 0x70108, 0x80061, 0x80021, 0x900a3, 0x80001, 0x80081, 0x80041, 0x900e3, 0x70104, 0x80059, 0x80019, 0x90093, 0x70114, 0x80079, 0x80039, 0x900d3, 0x7010c, 0x80069, 0x80029, 0x900b3, 0x80009, 0x80089, 0x80049, 0x900f3, 0x70102, 0x80055, 0x80015, 0x8011d, 0x70112, 0x80075, 0x80035, 0x900cb, 0x7010a, 0x80065, 0x80025, 0x900ab, 0x80005, 0x80085, 0x80045, 0x900eb, 0x70106, 0x8005d, 0x8001d, 0x9009b, 0x70116, 0x8007d, 0x8003d, 0x900db, 0x7010e, 0x8006d, 0x8002d, 0x900bb, 0x8000d, 0x8008d, 0x8004d, 0x900fb, 0x70101, 0x80053, 0x80013, 0x8011b, 0x70111, 0x80073, 0x80033, 0x900c7, 0x70109, 0x80063, 0x80023, 0x900a7, 0x80003, 0x80083, 0x80043, 0x900e7, 0x70105, 0x8005b, 0x8001b, 0x90097, 0x70115, 0x8007b, 0x8003b, 0x900d7, 0x7010d, 0x8006b, 0x8002b, 0x900b7, 0x8000b, 0x8008b, 0x8004b, 0x900f7, 0x70103, 0x80057, 0x80017, 0x8011f, 0x70113, 0x80077, 0x80037, 0x900cf, 0x7010b, 0x80067, 0x80027, 0x900af, 0x80007, 0x80087, 0x80047, 0x900ef, 0x70107, 0x8005f, 0x8001f, 0x9009f, 0x70117, 0x8007f, 0x8003f, 0x900df, 0x7010f, 0x8006f, 0x8002f, 0x900bf, 0x8000f, 0x8008f, 0x8004f, 0x900ff]), 9]; const fixedDistCodeTab = [new Int32Array([0x50000, 0x50010, 0x50008, 0x50018, 0x50004, 0x50014, 0x5000c, 0x5001c, 0x50002, 0x50012, 0x5000a, 0x5001a, 0x50006, 0x50016, 0x5000e, 0x00000, 0x50001, 0x50011, 0x50009, 0x50019, 0x50005, 0x50015, 0x5000d, 0x5001d, 0x50003, 0x50013, 0x5000b, 0x5001b, 0x50007, 0x50017, 0x5000f, 0x00000]), 5]; class FlateStream extends _decode_stream.DecodeStream { constructor(str, maybeLength) { super(maybeLength); this.str = str; this.dict = str.dict; const cmf = str.getByte(); const flg = str.getByte(); if (cmf === -1 || flg === -1) { throw new _util.FormatError(`Invalid header in flate stream: ${cmf}, ${flg}`); } if ((cmf &amp; 0x0f) !== 0x08) { throw new _util.FormatError(`Unknown compression method in flate stream: ${cmf}, ${flg}`); } if (((cmf &lt;&lt; 8) + flg) % 31 !== 0) { throw new _util.FormatError(`Bad FCHECK in flate stream: ${cmf}, ${flg}`); } if (flg &amp; 0x20) { throw new _util.FormatError(`FDICT bit set in flate stream: ${cmf}, ${flg}`); } this.codeSize = 0; this.codeBuf = 0; } getBits(bits) { const str = this.str; let codeSize = this.codeSize; let codeBuf = this.codeBuf; let b; while (codeSize &lt; bits) { if ((b = str.getByte()) === -1) { throw new _util.FormatError(&quot;Bad encoding in flate stream&quot;); } codeBuf |= b &lt;&lt; codeSize; codeSize += 8; } b = codeBuf &amp; (1 &lt;&lt; bits) - 1; this.codeBuf = codeBuf &gt;&gt; bits; this.codeSize = codeSize -= bits; return b; } getCode(table) { const str = this.str; const codes = table[0]; const maxLen = table[1]; let codeSize = this.codeSize; let codeBuf = this.codeBuf; let b; while (codeSize &lt; maxLen) { if ((b = str.getByte()) === -1) { break; } codeBuf |= b &lt;&lt; codeSize; codeSize += 8; } const code = codes[codeBuf &amp; (1 &lt;&lt; maxLen) - 1]; const codeLen = code &gt;&gt; 16; const codeVal = code &amp; 0xffff; if (codeLen &lt; 1 || codeSize &lt; codeLen) { throw new _util.FormatError(&quot;Bad encoding in flate stream&quot;); } this.codeBuf = codeBuf &gt;&gt; codeLen; this.codeSize = codeSize - codeLen; return codeVal; } generateHuffmanTable(lengths) { const n = lengths.length; let maxLen = 0; let i; for (i = 0; i &lt; n; ++i) { if (lengths[i] &gt; maxLen) { maxLen = lengths[i]; } } const size = 1 &lt;&lt; maxLen; const codes = new Int32Array(size); for (let len = 1, code = 0, skip = 2; len &lt;= maxLen; ++len, code &lt;&lt;= 1, skip &lt;&lt;= 1) { for (let val = 0; val &lt; n; ++val) { if (lengths[val] === len) { let code2 = 0; let t = code; for (i = 0; i &lt; len; ++i) { code2 = code2 &lt;&lt; 1 | t &amp; 1; t &gt;&gt;= 1; } for (i = code2; i &lt; size; i += skip) { codes[i] = len &lt;&lt; 16 | val; } ++code; } } } return [codes, maxLen]; } readBlock() { let buffer, len; const str = this.str; let hdr = this.getBits(3); if (hdr &amp; 1) { this.eof = true; } hdr &gt;&gt;= 1; if (hdr === 0) { let b; if ((b = str.getByte()) === -1) { throw new _util.FormatError(&quot;Bad block header in flate stream&quot;); } let blockLen = b; if ((b = str.getByte()) === -1) { throw new _util.FormatError(&quot;Bad block header in flate stream&quot;); } blockLen |= b &lt;&lt; 8; if ((b = str.getByte()) === -1) { throw new _util.FormatError(&quot;Bad block header in flate stream&quot;); } let check = b; if ((b = str.getByte()) === -1) { throw new _util.FormatError(&quot;Bad block header in flate stream&quot;); } check |= b &lt;&lt; 8; if (check !== (~blockLen &amp; 0xffff) &amp;&amp; (blockLen !== 0 || check !== 0)) { throw new _util.FormatError(&quot;Bad uncompressed block length in flate stream&quot;); } this.codeBuf = 0; this.codeSize = 0; const bufferLength = this.bufferLength, end = bufferLength + blockLen; buffer = this.ensureBuffer(end); this.bufferLength = end; if (blockLen === 0) { if (str.peekByte() === -1) { this.eof = true; } } else { const block = str.getBytes(blockLen); buffer.set(block, bufferLength); if (block.length &lt; blockLen) { this.eof = true; } } return; } let litCodeTable; let distCodeTable; if (hdr === 1) { litCodeTable = fixedLitCodeTab; distCodeTable = fixedDistCodeTab; } else if (hdr === 2) { const numLitCodes = this.getBits(5) + 257; const numDistCodes = this.getBits(5) + 1; const numCodeLenCodes = this.getBits(4) + 4; const codeLenCodeLengths = new Uint8Array(codeLenCodeMap.length); let i; for (i = 0; i &lt; numCodeLenCodes; ++i) { codeLenCodeLengths[codeLenCodeMap[i]] = this.getBits(3); } const codeLenCodeTab = this.generateHuffmanTable(codeLenCodeLengths); len = 0; i = 0; const codes = numLitCodes + numDistCodes; const codeLengths = new Uint8Array(codes); let bitsLength, bitsOffset, what; while (i &lt; codes) { const code = this.getCode(codeLenCodeTab); if (code === 16) { bitsLength = 2; bitsOffset = 3; what = len; } else if (code === 17) { bitsLength = 3; bitsOffset = 3; what = len = 0; } else if (code === 18) { bitsLength = 7; bitsOffset = 11; what = len = 0; } else { codeLengths[i++] = len = code; continue; } let repeatLength = this.getBits(bitsLength) + bitsOffset; while (repeatLength-- &gt; 0) { codeLengths[i++] = what; } } litCodeTable = this.generateHuffmanTable(codeLengths.subarray(0, numLitCodes)); distCodeTable = this.generateHuffmanTable(codeLengths.subarray(numLitCodes, codes)); } else { throw new _util.FormatError(&quot;Unknown block type in flate stream&quot;); } buffer = this.buffer; let limit = buffer ? buffer.length : 0; let pos = this.bufferLength; while (true) { let code1 = this.getCode(litCodeTable); if (code1 &lt; 256) { if (pos + 1 &gt;= limit) { buffer = this.ensureBuffer(pos + 1); limit = buffer.length; } buffer[pos++] = code1; continue; } if (code1 === 256) { this.bufferLength = pos; return; } code1 -= 257; code1 = lengthDecode[code1]; let code2 = code1 &gt;&gt; 16; if (code2 &gt; 0) { code2 = this.getBits(code2); } len = (code1 &amp; 0xffff) + code2; code1 = this.getCode(distCodeTable); code1 = distDecode[code1]; code2 = code1 &gt;&gt; 16; if (code2 &gt; 0) { code2 = this.getBits(code2); } const dist = (code1 &amp; 0xffff) + code2; if (pos + len &gt;= limit) { buffer = this.ensureBuffer(pos + len); limit = buffer.length; } for (let k = 0; k &lt; len; ++k, ++pos) { buffer[pos] = buffer[pos - dist]; } } } } exports.FlateStream = FlateStream; /***/ }), /* 22 */ /***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) =&gt; { Object.defineProperty(exports, &quot;__esModule&quot;, ({ value: true })); exports.Jbig2Stream = void 0; var _base_stream = __w_pdfjs_require__(5); var _decode_stream = __w_pdfjs_require__(17); var _primitives = __w_pdfjs_require__(3); var _jbig = __w_pdfjs_require__(23); var _util = __w_pdfjs_require__(2); class Jbig2Stream extends _decode_stream.DecodeStream { constructor(stream, maybeLength, params) { super(maybeLength); this.stream = stream; this.dict = stream.dict; this.maybeLength = maybeLength; this.params = params; } get bytes() { return (0, _util.shadow)(this, &quot;bytes&quot;, this.stream.getBytes(this.maybeLength)); } ensureBuffer(requested) {} readBlock() { if (this.eof) { return; } const jbig2Image = new _jbig.Jbig2Image(); const chunks = []; if (this.params instanceof _primitives.Dict) { const globalsStream = this.params.get(&quot;JBIG2Globals&quot;); if (globalsStream instanceof _base_stream.BaseStream) { const globals = globalsStream.getBytes(); chunks.push({ data: globals, start: 0, end: globals.length }); } } chunks.push({ data: this.bytes, start: 0, end: this.bytes.length }); const data = jbig2Image.parseChunks(chunks); const dataLength = data.length; for (let i = 0; i &lt; dataLength; i++) { data[i] ^= 0xff; } this.buffer = data; this.bufferLength = dataLength; this.eof = true; } } exports.Jbig2Stream = Jbig2Stream; /***/ }), /* 23 */ /***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) =&gt; { Object.defineProperty(exports, &quot;__esModule&quot;, ({ value: true })); exports.Jbig2Image = void 0; var _util = __w_pdfjs_require__(2); var _core_utils = __w_pdfjs_require__(4); var _arithmetic_decoder = __w_pdfjs_require__(24); var _ccitt = __w_pdfjs_require__(20); class Jbig2Error extends _util.BaseException { constructor(msg) { super(`JBIG2 error: ${msg}`, &quot;Jbig2Error&quot;); } } class ContextCache { getContexts(id) { if (id in this) { return this[id]; } return this[id] = new Int8Array(1 &lt;&lt; 16); } } class DecodingContext { constructor(data, start, end) { this.data = data; this.start = start; this.end = end; } get decoder() { const decoder = new _arithmetic_decoder.ArithmeticDecoder(this.data, this.start, this.end); return (0, _util.shadow)(this, &quot;decoder&quot;, decoder); } get contextCache() { const cache = new ContextCache(); return (0, _util.shadow)(this, &quot;contextCache&quot;, cache); } } function decodeInteger(contextCache, procedure, decoder) { const contexts = contextCache.getContexts(procedure); let prev = 1; function readBits(length) { let v = 0; for (let i = 0; i &lt; length; i++) { const bit = decoder.readBit(contexts, prev); prev = prev &lt; 256 ? prev &lt;&lt; 1 | bit : (prev &lt;&lt; 1 | bit) &amp; 511 | 256; v = v &lt;&lt; 1 | bit; } return v &gt;&gt;&gt; 0; } const sign = readBits(1); const value = readBits(1) ? readBits(1) ? readBits(1) ? readBits(1) ? readBits(1) ? readBits(32) + 4436 : readBits(12) + 340 : readBits(8) + 84 : readBits(6) + 20 : readBits(4) + 4 : readBits(2); if (sign === 0) { return value; } else if (value &gt; 0) { return -value; } return null; } function decodeIAID(contextCache, decoder, codeLength) { const contexts = contextCache.getContexts(&quot;IAID&quot;); let prev = 1; for (let i = 0; i &lt; codeLength; i++) { const bit = decoder.readBit(contexts, prev); prev = prev &lt;&lt; 1 | bit; } if (codeLength &lt; 31) { return prev &amp; (1 &lt;&lt; codeLength) - 1; } return prev &amp; 0x7fffffff; } const SegmentTypes = [&quot;SymbolDictionary&quot;, null, null, null, &quot;IntermediateTextRegion&quot;, null, &quot;ImmediateTextRegion&quot;, &quot;ImmediateLosslessTextRegion&quot;, null, null, null, null, null, null, null, null, &quot;PatternDictionary&quot;, null, null, null, &quot;IntermediateHalftoneRegion&quot;, null, &quot;ImmediateHalftoneRegion&quot;, &quot;ImmediateLosslessHalftoneRegion&quot;, null, null, null, null, null, null, null, null, null, null, null, null, &quot;IntermediateGenericRegion&quot;, null, &quot;ImmediateGenericRegion&quot;, &quot;ImmediateLosslessGenericRegion&quot;, &quot;IntermediateGenericRefinementRegion&quot;, null, &quot;ImmediateGenericRefinementRegion&quot;, &quot;ImmediateLosslessGenericRefinementRegion&quot;, null, null, null, null, &quot;PageInformation&quot;, &quot;EndOfPage&quot;, &quot;EndOfStripe&quot;, &quot;EndOfFile&quot;, &quot;Profiles&quot;, &quot;Tables&quot;, null, null, null, null, null, null, null, null, &quot;Extension&quot;]; const CodingTemplates = [[{ x: -1, y: -2 }, { x: 0, y: -2 }, { x: 1, y: -2 }, { x: -2, y: -1 }, { x: -1, y: -1 }, { x: 0, y: -1 }, { x: 1, y: -1 }, { x: 2, y: -1 }, { x: -4, y: 0 }, { x: -3, y: 0 }, { x: -2, y: 0 }, { x: -1, y: 0 }], [{ x: -1, y: -2 }, { x: 0, y: -2 }, { x: 1, y: -2 }, { x: 2, y: -2 }, { x: -2, y: -1 }, { x: -1, y: -1 }, { x: 0, y: -1 }, { x: 1, y: -1 }, { x: 2, y: -1 }, { x: -3, y: 0 }, { x: -2, y: 0 }, { x: -1, y: 0 }], [{ x: -1, y: -2 }, { x: 0, y: -2 }, { x: 1, y: -2 }, { x: -2, y: -1 }, { x: -1, y: -1 }, { x: 0, y: -1 }, { x: 1, y: -1 }, { x: -2, y: 0 }, { x: -1, y: 0 }], [{ x: -3, y: -1 }, { x: -2, y: -1 }, { x: -1, y: -1 }, { x: 0, y: -1 }, { x: 1, y: -1 }, { x: -4, y: 0 }, { x: -3, y: 0 }, { x: -2, y: 0 }, { x: -1, y: 0 }]]; const RefinementTemplates = [{ coding: [{ x: 0, y: -1 }, { x: 1, y: -1 }, { x: -1, y: 0 }], reference: [{ x: 0, y: -1 }, { x: 1, y: -1 }, { x: -1, y: 0 }, { x: 0, y: 0 }, { x: 1, y: 0 }, { x: -1, y: 1 }, { x: 0, y: 1 }, { x: 1, y: 1 }] }, { coding: [{ x: -1, y: -1 }, { x: 0, y: -1 }, { x: 1, y: -1 }, { x: -1, y: 0 }], reference: [{ x: 0, y: -1 }, { x: -1, y: 0 }, { x: 0, y: 0 }, { x: 1, y: 0 }, { x: 0, y: 1 }, { x: 1, y: 1 }] }]; const ReusedContexts = [0x9b25, 0x0795, 0x00e5, 0x0195]; const RefinementReusedContexts = [0x0020, 0x0008]; function decodeBitmapTemplate0(width, height, decodingContext) { const decoder = decodingContext.decoder; const contexts = decodingContext.contextCache.getContexts(&quot;GB&quot;); const bitmap = []; let contextLabel, i, j, pixel, row, row1, row2; const OLD_PIXEL_MASK = 0x7bf7; for (i = 0; i &lt; height; i++) { row = bitmap[i] = new Uint8Array(width); row1 = i &lt; 1 ? row : bitmap[i - 1]; row2 = i &lt; 2 ? row : bitmap[i - 2]; contextLabel = row2[0] &lt;&lt; 13 | row2[1] &lt;&lt; 12 | row2[2] &lt;&lt; 11 | row1[0] &lt;&lt; 7 | row1[1] &lt;&lt; 6 | row1[2] &lt;&lt; 5 | row1[3] &lt;&lt; 4; for (j = 0; j &lt; width; j++) { row[j] = pixel = decoder.readBit(contexts, contextLabel); contextLabel = (contextLabel &amp; OLD_PIXEL_MASK) &lt;&lt; 1 | (j + 3 &lt; width ? row2[j + 3] &lt;&lt; 11 : 0) | (j + 4 &lt; width ? row1[j + 4] &lt;&lt; 4 : 0) | pixel; } } return bitmap; } function decodeBitmap(mmr, width, height, templateIndex, prediction, skip, at, decodingContext) { if (mmr) { const input = new Reader(decodingContext.data, decodingContext.start, decodingContext.end); return decodeMMRBitmap(input, width, height, false); } if (templateIndex === 0 &amp;&amp; !skip &amp;&amp; !prediction &amp;&amp; at.length === 4 &amp;&amp; at[0].x === 3 &amp;&amp; at[0].y === -1 &amp;&amp; at[1].x === -3 &amp;&amp; at[1].y === -1 &amp;&amp; at[2].x === 2 &amp;&amp; at[2].y === -2 &amp;&amp; at[3].x === -2 &amp;&amp; at[3].y === -2) { return decodeBitmapTemplate0(width, height, decodingContext); } const useskip = !!skip; const template = CodingTemplates[templateIndex].concat(at); template.sort(function (a, b) { return a.y - b.y || a.x - b.x; }); const templateLength = template.length; const templateX = new Int8Array(templateLength); const templateY = new Int8Array(templateLength); const changingTemplateEntries = []; let reuseMask = 0, minX = 0, maxX = 0, minY = 0; let c, k; for (k = 0; k &lt; templateLength; k++) { templateX[k] = template[k].x; templateY[k] = template[k].y; minX = Math.min(minX, template[k].x); maxX = Math.max(maxX, template[k].x); minY = Math.min(minY, template[k].y); if (k &lt; templateLength - 1 &amp;&amp; template[k].y === template[k + 1].y &amp;&amp; template[k].x === template[k + 1].x - 1) { reuseMask |= 1 &lt;&lt; templateLength - 1 - k; } else { changingTemplateEntries.push(k); } } const changingEntriesLength = changingTemplateEntries.length; const changingTemplateX = new Int8Array(changingEntriesLength); const changingTemplateY = new Int8Array(changingEntriesLength); const changingTemplateBit = new Uint16Array(changingEntriesLength); for (c = 0; c &lt; changingEntriesLength; c++) { k = changingTemplateEntries[c]; changingTemplateX[c] = template[k].x; changingTemplateY[c] = template[k].y; changingTemplateBit[c] = 1 &lt;&lt; templateLength - 1 - k; } const sbb_left = -minX; const sbb_top = -minY; const sbb_right = width - maxX; const pseudoPixelContext = ReusedContexts[templateIndex]; let row = new Uint8Array(width); const bitmap = []; const decoder = decodingContext.decoder; const contexts = decodingContext.contextCache.getContexts(&quot;GB&quot;); let ltp = 0, j, i0, j0, contextLabel = 0, bit, shift; for (let i = 0; i &lt; height; i++) { if (prediction) { const sltp = decoder.readBit(contexts, pseudoPixelContext); ltp ^= sltp; if (ltp) { bitmap.push(row); continue; } } row = new Uint8Array(row); bitmap.push(row); for (j = 0; j &lt; width; j++) { if (useskip &amp;&amp; skip[i][j]) { row[j] = 0; continue; } if (j &gt;= sbb_left &amp;&amp; j &lt; sbb_right &amp;&amp; i &gt;= sbb_top) { contextLabel = contextLabel &lt;&lt; 1 &amp; reuseMask; for (k = 0; k &lt; changingEntriesLength; k++) { i0 = i + changingTemplateY[k]; j0 = j + changingTemplateX[k]; bit = bitmap[i0][j0]; if (bit) { bit = changingTemplateBit[k]; contextLabel |= bit; } } } else { contextLabel = 0; shift = templateLength - 1; for (k = 0; k &lt; templateLength; k++, shift--) { j0 = j + templateX[k]; if (j0 &gt;= 0 &amp;&amp; j0 &lt; width) { i0 = i + templateY[k]; if (i0 &gt;= 0) { bit = bitmap[i0][j0]; if (bit) { contextLabel |= bit &lt;&lt; shift; } } } } } const pixel = decoder.readBit(contexts, contextLabel); row[j] = pixel; } } return bitmap; } function decodeRefinement(width, height, templateIndex, referenceBitmap, offsetX, offsetY, prediction, at, decodingContext) { let codingTemplate = RefinementTemplates[templateIndex].coding; if (templateIndex === 0) { codingTemplate = codingTemplate.concat([at[0]]); } const codingTemplateLength = codingTemplate.length; const codingTemplateX = new Int32Array(codingTemplateLength); const codingTemplateY = new Int32Array(codingTemplateLength); let k; for (k = 0; k &lt; codingTemplateLength; k++) { codingTemplateX[k] = codingTemplate[k].x; codingTemplateY[k] = codingTemplate[k].y; } let referenceTemplate = RefinementTemplates[templateIndex].reference; if (templateIndex === 0) { referenceTemplate = referenceTemplate.concat([at[1]]); } const referenceTemplateLength = referenceTemplate.length; const referenceTemplateX = new Int32Array(referenceTemplateLength); const referenceTemplateY = new Int32Array(referenceTemplateLength); for (k = 0; k &lt; referenceTemplateLength; k++) { referenceTemplateX[k] = referenceTemplate[k].x; referenceTemplateY[k] = referenceTemplate[k].y; } const referenceWidth = referenceBitmap[0].length; const referenceHeight = referenceBitmap.length; const pseudoPixelContext = RefinementReusedContexts[templateIndex]; const bitmap = []; const decoder = decodingContext.decoder; const contexts = decodingContext.contextCache.getContexts(&quot;GR&quot;); let ltp = 0; for (let i = 0; i &lt; height; i++) { if (prediction) { const sltp = decoder.readBit(contexts, pseudoPixelContext); ltp ^= sltp; if (ltp) { throw new Jbig2Error(&quot;prediction is not supported&quot;); } } const row = new Uint8Array(width); bitmap.push(row); for (let j = 0; j &lt; width; j++) { let i0, j0; let contextLabel = 0; for (k = 0; k &lt; codingTemplateLength; k++) { i0 = i + codingTemplateY[k]; j0 = j + codingTemplateX[k]; if (i0 &lt; 0 || j0 &lt; 0 || j0 &gt;= width) { contextLabel &lt;&lt;= 1; } else { contextLabel = contextLabel &lt;&lt; 1 | bitmap[i0][j0]; } } for (k = 0; k &lt; referenceTemplateLength; k++) { i0 = i + referenceTemplateY[k] - offsetY; j0 = j + referenceTemplateX[k] - offsetX; if (i0 &lt; 0 || i0 &gt;= referenceHeight || j0 &lt; 0 || j0 &gt;= referenceWidth) { contextLabel &lt;&lt;= 1; } else { contextLabel = contextLabel &lt;&lt; 1 | referenceBitmap[i0][j0]; } } const pixel = decoder.readBit(contexts, contextLabel); row[j] = pixel; } } return bitmap; } function decodeSymbolDictionary(huffman, refinement, symbols, numberOfNewSymbols, numberOfExportedSymbols, huffmanTables, templateIndex, at, refinementTemplateIndex, refinementAt, decodingContext, huffmanInput) { if (huffman &amp;&amp; refinement) { throw new Jbig2Error(&quot;symbol refinement with Huffman is not supported&quot;); } const newSymbols = []; let currentHeight = 0; let symbolCodeLength = (0, _core_utils.log2)(symbols.length + numberOfNewSymbols); const decoder = decodingContext.decoder; const contextCache = decodingContext.contextCache; let tableB1, symbolWidths; if (huffman) { tableB1 = getStandardTable(1); symbolWidths = []; symbolCodeLength = Math.max(symbolCodeLength, 1); } while (newSymbols.length &lt; numberOfNewSymbols) { const deltaHeight = huffman ? huffmanTables.tableDeltaHeight.decode(huffmanInput) : decodeInteger(contextCache, &quot;IADH&quot;, decoder); currentHeight += deltaHeight; let currentWidth = 0, totalWidth = 0; const firstSymbol = huffman ? symbolWidths.length : 0; while (true) { const deltaWidth = huffman ? huffmanTables.tableDeltaWidth.decode(huffmanInput) : decodeInteger(contextCache, &quot;IADW&quot;, decoder); if (deltaWidth === null) { break; } currentWidth += deltaWidth; totalWidth += currentWidth; let bitmap; if (refinement) { const numberOfInstances = decodeInteger(contextCache, &quot;IAAI&quot;, decoder); if (numberOfInstances &gt; 1) { bitmap = decodeTextRegion(huffman, refinement, currentWidth, currentHeight, 0, numberOfInstances, 1, symbols.concat(newSymbols), symbolCodeLength, 0, 0, 1, 0, huffmanTables, refinementTemplateIndex, refinementAt, decodingContext, 0, huffmanInput); } else { const symbolId = decodeIAID(contextCache, decoder, symbolCodeLength); const rdx = decodeInteger(contextCache, &quot;IARDX&quot;, decoder); const rdy = decodeInteger(contextCache, &quot;IARDY&quot;, decoder); const symbol = symbolId &lt; symbols.length ? symbols[symbolId] : newSymbols[symbolId - symbols.length]; bitmap = decodeRefinement(currentWidth, currentHeight, refinementTemplateIndex, symbol, rdx, rdy, false, refinementAt, decodingContext); } newSymbols.push(bitmap); } else if (huffman) { symbolWidths.push(currentWidth); } else { bitmap = decodeBitmap(false, currentWidth, currentHeight, templateIndex, false, null, at, decodingContext); newSymbols.push(bitmap); } } if (huffman &amp;&amp; !refinement) { const bitmapSize = huffmanTables.tableBitmapSize.decode(huffmanInput); huffmanInput.byteAlign(); let collectiveBitmap; if (bitmapSize === 0) { collectiveBitmap = readUncompressedBitmap(huffmanInput, totalWidth, currentHeight); } else { const originalEnd = huffmanInput.end; const bitmapEnd = huffmanInput.position + bitmapSize; huffmanInput.end = bitmapEnd; collectiveBitmap = decodeMMRBitmap(huffmanInput, totalWidth, currentHeight, false); huffmanInput.end = originalEnd; huffmanInput.position = bitmapEnd; } const numberOfSymbolsDecoded = symbolWidths.length; if (firstSymbol === numberOfSymbolsDecoded - 1) { newSymbols.push(collectiveBitmap); } else { let i, y, xMin = 0, xMax, bitmapWidth, symbolBitmap; for (i = firstSymbol; i &lt; numberOfSymbolsDecoded; i++) { bitmapWidth = symbolWidths[i]; xMax = xMin + bitmapWidth; symbolBitmap = []; for (y = 0; y &lt; currentHeight; y++) { symbolBitmap.push(collectiveBitmap[y].subarray(xMin, xMax)); } newSymbols.push(symbolBitmap); xMin = xMax; } } } } const exportedSymbols = [], flags = []; let currentFlag = false, i, ii; const totalSymbolsLength = symbols.length + numberOfNewSymbols; while (flags.length &lt; totalSymbolsLength) { let runLength = huffman ? tableB1.decode(huffmanInput) : decodeInteger(contextCache, &quot;IAEX&quot;, decoder); while (runLength--) { flags.push(currentFlag); } currentFlag = !currentFlag; } for (i = 0, ii = symbols.length; i &lt; ii; i++) { if (flags[i]) { exportedSymbols.push(symbols[i]); } } for (let j = 0; j &lt; numberOfNewSymbols; i++, j++) { if (flags[i]) { exportedSymbols.push(newSymbols[j]); } } return exportedSymbols; } function decodeTextRegion(huffman, refinement, width, height, defaultPixelValue, numberOfSymbolInstances, stripSize, inputSymbols, symbolCodeLength, transposed, dsOffset, referenceCorner, combinationOperator, huffmanTables, refinementTemplateIndex, refinementAt, decodingContext, logStripSize, huffmanInput) { if (huffman &amp;&amp; refinement) { throw new Jbig2Error(&quot;refinement with Huffman is not supported&quot;); } const bitmap = []; let i, row; for (i = 0; i &lt; height; i++) { row = new Uint8Array(width); if (defaultPixelValue) { for (let j = 0; j &lt; width; j++) { row[j] = defaultPixelValue; } } bitmap.push(row); } const decoder = decodingContext.decoder; const contextCache = decodingContext.contextCache; let stripT = huffman ? -huffmanTables.tableDeltaT.decode(huffmanInput) : -decodeInteger(contextCache, &quot;IADT&quot;, decoder); let firstS = 0; i = 0; while (i &lt; numberOfSymbolInstances) { const deltaT = huffman ? huffmanTables.tableDeltaT.decode(huffmanInput) : decodeInteger(contextCache, &quot;IADT&quot;, decoder); stripT += deltaT; const deltaFirstS = huffman ? huffmanTables.tableFirstS.decode(huffmanInput) : decodeInteger(contextCache, &quot;IAFS&quot;, decoder); firstS += deltaFirstS; let currentS = firstS; do { let currentT = 0; if (stripSize &gt; 1) { currentT = huffman ? huffmanInput.readBits(logStripSize) : decodeInteger(contextCache, &quot;IAIT&quot;, decoder); } const t = stripSize * stripT + currentT; const symbolId = huffman ? huffmanTables.symbolIDTable.decode(huffmanInput) : decodeIAID(contextCache, decoder, symbolCodeLength); const applyRefinement = refinement &amp;&amp; (huffman ? huffmanInput.readBit() : decodeInteger(contextCache, &quot;IARI&quot;, decoder)); let symbolBitmap = inputSymbols[symbolId]; let symbolWidth = symbolBitmap[0].length; let symbolHeight = symbolBitmap.length; if (applyRefinement) { const rdw = decodeInteger(contextCache, &quot;IARDW&quot;, decoder); const rdh = decodeInteger(contextCache, &quot;IARDH&quot;, decoder); const rdx = decodeInteger(contextCache, &quot;IARDX&quot;, decoder); const rdy = decodeInteger(contextCache, &quot;IARDY&quot;, decoder); symbolWidth += rdw; symbolHeight += rdh; symbolBitmap = decodeRefinement(symbolWidth, symbolHeight, refinementTemplateIndex, symbolBitmap, (rdw &gt;&gt; 1) + rdx, (rdh &gt;&gt; 1) + rdy, false, refinementAt, decodingContext); } const offsetT = t - (referenceCorner &amp; 1 ? 0 : symbolHeight - 1); const offsetS = currentS - (referenceCorner &amp; 2 ? symbolWidth - 1 : 0); let s2, t2, symbolRow; if (transposed) { for (s2 = 0; s2 &lt; symbolHeight; s2++) { row = bitmap[offsetS + s2]; if (!row) { continue; } symbolRow = symbolBitmap[s2]; const maxWidth = Math.min(width - offsetT, symbolWidth); switch (combinationOperator) { case 0: for (t2 = 0; t2 &lt; maxWidth; t2++) { row[offsetT + t2] |= symbolRow[t2]; } break; case 2: for (t2 = 0; t2 &lt; maxWidth; t2++) { row[offsetT + t2] ^= symbolRow[t2]; } break; default: throw new Jbig2Error(`operator ${combinationOperator} is not supported`); } } currentS += symbolHeight - 1; } else { for (t2 = 0; t2 &lt; symbolHeight; t2++) { row = bitmap[offsetT + t2]; if (!row) { continue; } symbolRow = symbolBitmap[t2]; switch (combinationOperator) { case 0: for (s2 = 0; s2 &lt; symbolWidth; s2++) { row[offsetS + s2] |= symbolRow[s2]; } break; case 2: for (s2 = 0; s2 &lt; symbolWidth; s2++) { row[offsetS + s2] ^= symbolRow[s2]; } break; default: throw new Jbig2Error(`operator ${combinationOperator} is not supported`); } } currentS += symbolWidth - 1; } i++; const deltaS = huffman ? huffmanTables.tableDeltaS.decode(huffmanInput) : decodeInteger(contextCache, &quot;IADS&quot;, decoder); if (deltaS === null) { break; } currentS += deltaS + dsOffset; } while (true); } return bitmap; } function decodePatternDictionary(mmr, patternWidth, patternHeight, maxPatternIndex, template, decodingContext) { const at = []; if (!mmr) { at.push({ x: -patternWidth, y: 0 }); if (template === 0) { at.push({ x: -3, y: -1 }, { x: 2, y: -2 }, { x: -2, y: -2 }); } } const collectiveWidth = (maxPatternIndex + 1) * patternWidth; const collectiveBitmap = decodeBitmap(mmr, collectiveWidth, patternHeight, template, false, null, at, decodingContext); const patterns = []; for (let i = 0; i &lt;= maxPatternIndex; i++) { const patternBitmap = []; const xMin = patternWidth * i; const xMax = xMin + patternWidth; for (let y = 0; y &lt; patternHeight; y++) { patternBitmap.push(collectiveBitmap[y].subarray(xMin, xMax)); } patterns.push(patternBitmap); } return patterns; } function decodeHalftoneRegion(mmr, patterns, template, regionWidth, regionHeight, defaultPixelValue, enableSkip, combinationOperator, gridWidth, gridHeight, gridOffsetX, gridOffsetY, gridVectorX, gridVectorY, decodingContext) { const skip = null; if (enableSkip) { throw new Jbig2Error(&quot;skip is not supported&quot;); } if (combinationOperator !== 0) { throw new Jbig2Error(`operator &quot;${combinationOperator}&quot; is not supported in halftone region`); } const regionBitmap = []; let i, j, row; for (i = 0; i &lt; regionHeight; i++) { row = new Uint8Array(regionWidth); if (defaultPixelValue) { for (j = 0; j &lt; regionWidth; j++) { row[j] = defaultPixelValue; } } regionBitmap.push(row); } const numberOfPatterns = patterns.length; const pattern0 = patterns[0]; const patternWidth = pattern0[0].length, patternHeight = pattern0.length; const bitsPerValue = (0, _core_utils.log2)(numberOfPatterns); const at = []; if (!mmr) { at.push({ x: template &lt;= 1 ? 3 : 2, y: -1 }); if (template === 0) { at.push({ x: -3, y: -1 }, { x: 2, y: -2 }, { x: -2, y: -2 }); } } const grayScaleBitPlanes = []; let mmrInput, bitmap; if (mmr) { mmrInput = new Reader(decodingContext.data, decodingContext.start, decodingContext.end); } for (i = bitsPerValue - 1; i &gt;= 0; i--) { if (mmr) { bitmap = decodeMMRBitmap(mmrInput, gridWidth, gridHeight, true); } else { bitmap = decodeBitmap(false, gridWidth, gridHeight, template, false, skip, at, decodingContext); } grayScaleBitPlanes[i] = bitmap; } let mg, ng, bit, patternIndex, patternBitmap, x, y, patternRow, regionRow; for (mg = 0; mg &lt; gridHeight; mg++) { for (ng = 0; ng &lt; gridWidth; ng++) { bit = 0; patternIndex = 0; for (j = bitsPerValue - 1; j &gt;= 0; j--) { bit ^= grayScaleBitPlanes[j][mg][ng]; patternIndex |= bit &lt;&lt; j; } patternBitmap = patterns[patternIndex]; x = gridOffsetX + mg * gridVectorY + ng * gridVectorX &gt;&gt; 8; y = gridOffsetY + mg * gridVectorX - ng * gridVectorY &gt;&gt; 8; if (x &gt;= 0 &amp;&amp; x + patternWidth &lt;= regionWidth &amp;&amp; y &gt;= 0 &amp;&amp; y + patternHeight &lt;= regionHeight) { for (i = 0; i &lt; patternHeight; i++) { regionRow = regionBitmap[y + i]; patternRow = patternBitmap[i]; for (j = 0; j &lt; patternWidth; j++) { regionRow[x + j] |= patternRow[j]; } } } else { let regionX, regionY; for (i = 0; i &lt; patternHeight; i++) { regionY = y + i; if (regionY &lt; 0 || regionY &gt;= regionHeight) { continue; } regionRow = regionBitmap[regionY]; patternRow = patternBitmap[i]; for (j = 0; j &lt; patternWidth; j++) { regionX = x + j; if (regionX &gt;= 0 &amp;&amp; regionX &lt; regionWidth) { regionRow[regionX] |= patternRow[j]; } } } } } } return regionBitmap; } function readSegmentHeader(data, start) { const segmentHeader = {}; segmentHeader.number = (0, _core_utils.readUint32)(data, start); const flags = data[start + 4]; const segmentType = flags &amp; 0x3f; if (!SegmentTypes[segmentType]) { throw new Jbig2Error(&quot;invalid segment type: &quot; + segmentType); } segmentHeader.type = segmentType; segmentHeader.typeName = SegmentTypes[segmentType]; segmentHeader.deferredNonRetain = !!(flags &amp; 0x80); const pageAssociationFieldSize = !!(flags &amp; 0x40); const referredFlags = data[start + 5]; let referredToCount = referredFlags &gt;&gt; 5 &amp; 7; const retainBits = [referredFlags &amp; 31]; let position = start + 6; if (referredFlags === 7) { referredToCount = (0, _core_utils.readUint32)(data, position - 1) &amp; 0x1fffffff; position += 3; let bytes = referredToCount + 7 &gt;&gt; 3; retainBits[0] = data[position++]; while (--bytes &gt; 0) { retainBits.push(data[position++]); } } else if (referredFlags === 5 || referredFlags === 6) { throw new Jbig2Error(&quot;invalid referred-to flags&quot;); } segmentHeader.retainBits = retainBits; let referredToSegmentNumberSize = 4; if (segmentHeader.number &lt;= 256) { referredToSegmentNumberSize = 1; } else if (segmentHeader.number &lt;= 65536) { referredToSegmentNumberSize = 2; } const referredTo = []; let i, ii; for (i = 0; i &lt; referredToCount; i++) { let number; if (referredToSegmentNumberSize === 1) { number = data[position]; } else if (referredToSegmentNumberSize === 2) { number = (0, _core_utils.readUint16)(data, position); } else { number = (0, _core_utils.readUint32)(data, position); } referredTo.push(number); position += referredToSegmentNumberSize; } segmentHeader.referredTo = referredTo; if (!pageAssociationFieldSize) { segmentHeader.pageAssociation = data[position++]; } else { segmentHeader.pageAssociation = (0, _core_utils.readUint32)(data, position); position += 4; } segmentHeader.length = (0, _core_utils.readUint32)(data, position); position += 4; if (segmentHeader.length === 0xffffffff) { if (segmentType === 38) { const genericRegionInfo = readRegionSegmentInformation(data, position); const genericRegionSegmentFlags = data[position + RegionSegmentInformationFieldLength]; const genericRegionMmr = !!(genericRegionSegmentFlags &amp; 1); const searchPatternLength = 6; const searchPattern = new Uint8Array(searchPatternLength); if (!genericRegionMmr) { searchPattern[0] = 0xff; searchPattern[1] = 0xac; } searchPattern[2] = genericRegionInfo.height &gt;&gt;&gt; 24 &amp; 0xff; searchPattern[3] = genericRegionInfo.height &gt;&gt; 16 &amp; 0xff; searchPattern[4] = genericRegionInfo.height &gt;&gt; 8 &amp; 0xff; searchPattern[5] = genericRegionInfo.height &amp; 0xff; for (i = position, ii = data.length; i &lt; ii; i++) { let j = 0; while (j &lt; searchPatternLength &amp;&amp; searchPattern[j] === data[i + j]) { j++; } if (j === searchPatternLength) { segmentHeader.length = i + searchPatternLength; break; } } if (segmentHeader.length === 0xffffffff) { throw new Jbig2Error(&quot;segment end was not found&quot;); } } else { throw new Jbig2Error(&quot;invalid unknown segment length&quot;); } } segmentHeader.headerEnd = position; return segmentHeader; } function readSegments(header, data, start, end) { const segments = []; let position = start; while (position &lt; end) { const segmentHeader = readSegmentHeader(data, position); position = segmentHeader.headerEnd; const segment = { header: segmentHeader, data }; if (!header.randomAccess) { segment.start = position; position += segmentHeader.length; segment.end = position; } segments.push(segment); if (segmentHeader.type === 51) { break; } } if (header.randomAccess) { for (let i = 0, ii = segments.length; i &lt; ii; i++) { segments[i].start = position; position += segments[i].header.length; segments[i].end = position; } } return segments; } function readRegionSegmentInformation(data, start) { return { width: (0, _core_utils.readUint32)(data, start), height: (0, _core_utils.readUint32)(data, start + 4), x: (0, _core_utils.readUint32)(data, start + 8), y: (0, _core_utils.readUint32)(data, start + 12), combinationOperator: data[start + 16] &amp; 7 }; } const RegionSegmentInformationFieldLength = 17; function processSegment(segment, visitor) { const header = segment.header; const data = segment.data, end = segment.end; let position = segment.start; let args, at, i, atLength; switch (header.type) { case 0: const dictionary = {}; const dictionaryFlags = (0, _core_utils.readUint16)(data, position); dictionary.huffman = !!(dictionaryFlags &amp; 1); dictionary.refinement = !!(dictionaryFlags &amp; 2); dictionary.huffmanDHSelector = dictionaryFlags &gt;&gt; 2 &amp; 3; dictionary.huffmanDWSelector = dictionaryFlags &gt;&gt; 4 &amp; 3; dictionary.bitmapSizeSelector = dictionaryFlags &gt;&gt; 6 &amp; 1; dictionary.aggregationInstancesSelector = dictionaryFlags &gt;&gt; 7 &amp; 1; dictionary.bitmapCodingContextUsed = !!(dictionaryFlags &amp; 256); dictionary.bitmapCodingContextRetained = !!(dictionaryFlags &amp; 512); dictionary.template = dictionaryFlags &gt;&gt; 10 &amp; 3; dictionary.refinementTemplate = dictionaryFlags &gt;&gt; 12 &amp; 1; position += 2; if (!dictionary.huffman) { atLength = dictionary.template === 0 ? 4 : 1; at = []; for (i = 0; i &lt; atLength; i++) { at.push({ x: (0, _core_utils.readInt8)(data, position), y: (0, _core_utils.readInt8)(data, position + 1) }); position += 2; } dictionary.at = at; } if (dictionary.refinement &amp;&amp; !dictionary.refinementTemplate) { at = []; for (i = 0; i &lt; 2; i++) { at.push({ x: (0, _core_utils.readInt8)(data, position), y: (0, _core_utils.readInt8)(data, position + 1) }); position += 2; } dictionary.refinementAt = at; } dictionary.numberOfExportedSymbols = (0, _core_utils.readUint32)(data, position); position += 4; dictionary.numberOfNewSymbols = (0, _core_utils.readUint32)(data, position); position += 4; args = [dictionary, header.number, header.referredTo, data, position, end]; break; case 6: case 7: const textRegion = {}; textRegion.info = readRegionSegmentInformation(data, position); position += RegionSegmentInformationFieldLength; const textRegionSegmentFlags = (0, _core_utils.readUint16)(data, position); position += 2; textRegion.huffman = !!(textRegionSegmentFlags &amp; 1); textRegion.refinement = !!(textRegionSegmentFlags &amp; 2); textRegion.logStripSize = textRegionSegmentFlags &gt;&gt; 2 &amp; 3; textRegion.stripSize = 1 &lt;&lt; textRegion.logStripSize; textRegion.referenceCorner = textRegionSegmentFlags &gt;&gt; 4 &amp; 3; textRegion.transposed = !!(textRegionSegmentFlags &amp; 64); textRegion.combinationOperator = textRegionSegmentFlags &gt;&gt; 7 &amp; 3; textRegion.defaultPixelValue = textRegionSegmentFlags &gt;&gt; 9 &amp; 1; textRegion.dsOffset = textRegionSegmentFlags &lt;&lt; 17 &gt;&gt; 27; textRegion.refinementTemplate = textRegionSegmentFlags &gt;&gt; 15 &amp; 1; if (textRegion.huffman) { const textRegionHuffmanFlags = (0, _core_utils.readUint16)(data, position); position += 2; textRegion.huffmanFS = textRegionHuffmanFlags &amp; 3; textRegion.huffmanDS = textRegionHuffmanFlags &gt;&gt; 2 &amp; 3; textRegion.huffmanDT = textRegionHuffmanFlags &gt;&gt; 4 &amp; 3; textRegion.huffmanRefinementDW = textRegionHuffmanFlags &gt;&gt; 6 &amp; 3; textRegion.huffmanRefinementDH = textRegionHuffmanFlags &gt;&gt; 8 &amp; 3; textRegion.huffmanRefinementDX = textRegionHuffmanFlags &gt;&gt; 10 &amp; 3; textRegion.huffmanRefinementDY = textRegionHuffmanFlags &gt;&gt; 12 &amp; 3; textRegion.huffmanRefinementSizeSelector = !!(textRegionHuffmanFlags &amp; 0x4000); } if (textRegion.refinement &amp;&amp; !textRegion.refinementTemplate) { at = []; for (i = 0; i &lt; 2; i++) { at.push({ x: (0, _core_utils.readInt8)(data, position), y: (0, _core_utils.readInt8)(data, position + 1) }); position += 2; } textRegion.refinementAt = at; } textRegion.numberOfSymbolInstances = (0, _core_utils.readUint32)(data, position); position += 4; args = [textRegion, header.referredTo, data, position, end]; break; case 16: const patternDictionary = {}; const patternDictionaryFlags = data[position++]; patternDictionary.mmr = !!(patternDictionaryFlags &amp; 1); patternDictionary.template = patternDictionaryFlags &gt;&gt; 1 &amp; 3; patternDictionary.patternWidth = data[position++]; patternDictionary.patternHeight = data[position++]; patternDictionary.maxPatternIndex = (0, _core_utils.readUint32)(data, position); position += 4; args = [patternDictionary, header.number, data, position, end]; break; case 22: case 23: const halftoneRegion = {}; halftoneRegion.info = readRegionSegmentInformation(data, position); position += RegionSegmentInformationFieldLength; const halftoneRegionFlags = data[position++]; halftoneRegion.mmr = !!(halftoneRegionFlags &amp; 1); halftoneRegion.template = halftoneRegionFlags &gt;&gt; 1 &amp; 3; halftoneRegion.enableSkip = !!(halftoneRegionFlags &amp; 8); halftoneRegion.combinationOperator = halftoneRegionFlags &gt;&gt; 4 &amp; 7; halftoneRegion.defaultPixelValue = halftoneRegionFlags &gt;&gt; 7 &amp; 1; halftoneRegion.gridWidth = (0, _core_utils.readUint32)(data, position); position += 4; halftoneRegion.gridHeight = (0, _core_utils.readUint32)(data, position); position += 4; halftoneRegion.gridOffsetX = (0, _core_utils.readUint32)(data, position) &amp; 0xffffffff; position += 4; halftoneRegion.gridOffsetY = (0, _core_utils.readUint32)(data, position) &amp; 0xffffffff; position += 4; halftoneRegion.gridVectorX = (0, _core_utils.readUint16)(data, position); position += 2; halftoneRegion.gridVectorY = (0, _core_utils.readUint16)(data, position); position += 2; args = [halftoneRegion, header.referredTo, data, position, end]; break; case 38: case 39: const genericRegion = {}; genericRegion.info = readRegionSegmentInformation(data, position); position += RegionSegmentInformationFieldLength; const genericRegionSegmentFlags = data[position++]; genericRegion.mmr = !!(genericRegionSegmentFlags &amp; 1); genericRegion.template = genericRegionSegmentFlags &gt;&gt; 1 &amp; 3; genericRegion.prediction = !!(genericRegionSegmentFlags &amp; 8); if (!genericRegion.mmr) { atLength = genericRegion.template === 0 ? 4 : 1; at = []; for (i = 0; i &lt; atLength; i++) { at.push({ x: (0, _core_utils.readInt8)(data, position), y: (0, _core_utils.readInt8)(data, position + 1) }); position += 2; } genericRegion.at = at; } args = [genericRegion, data, position, end]; break; case 48: const pageInfo = { width: (0, _core_utils.readUint32)(data, position), height: (0, _core_utils.readUint32)(data, position + 4), resolutionX: (0, _core_utils.readUint32)(data, position + 8), resolutionY: (0, _core_utils.readUint32)(data, position + 12) }; if (pageInfo.height === 0xffffffff) { delete pageInfo.height; } const pageSegmentFlags = data[position + 16]; (0, _core_utils.readUint16)(data, position + 17); pageInfo.lossless = !!(pageSegmentFlags &amp; 1); pageInfo.refinement = !!(pageSegmentFlags &amp; 2); pageInfo.defaultPixelValue = pageSegmentFlags &gt;&gt; 2 &amp; 1; pageInfo.combinationOperator = pageSegmentFlags &gt;&gt; 3 &amp; 3; pageInfo.requiresBuffer = !!(pageSegmentFlags &amp; 32); pageInfo.combinationOperatorOverride = !!(pageSegmentFlags &amp; 64); args = [pageInfo]; break; case 49: break; case 50: break; case 51: break; case 53: args = [header.number, data, position, end]; break; case 62: break; default: throw new Jbig2Error(`segment type ${header.typeName}(${header.type}) is not implemented`); } const callbackName = &quot;on&quot; + header.typeName; if (callbackName in visitor) { visitor[callbackName].apply(visitor, args); } } function processSegments(segments, visitor) { for (let i = 0, ii = segments.length; i &lt; ii; i++) { processSegment(segments[i], visitor); } } function parseJbig2Chunks(chunks) { const visitor = new SimpleSegmentVisitor(); for (let i = 0, ii = chunks.length; i &lt; ii; i++) { const chunk = chunks[i]; const segments = readSegments({}, chunk.data, chunk.start, chunk.end); processSegments(segments, visitor); } return visitor.buffer; } function parseJbig2(data) { throw new Error(&quot;Not implemented: parseJbig2&quot;); } class SimpleSegmentVisitor { onPageInformation(info) { this.currentPageInfo = info; const rowSize = info.width + 7 &gt;&gt; 3; const buffer = new Uint8ClampedArray(rowSize * info.height); if (info.defaultPixelValue) { buffer.fill(0xff); } this.buffer = buffer; } drawBitmap(regionInfo, bitmap) { const pageInfo = this.currentPageInfo; const width = regionInfo.width, height = regionInfo.height; const rowSize = pageInfo.width + 7 &gt;&gt; 3; const combinationOperator = pageInfo.combinationOperatorOverride ? regionInfo.combinationOperator : pageInfo.combinationOperator; const buffer = this.buffer; const mask0 = 128 &gt;&gt; (regionInfo.x &amp; 7); let offset0 = regionInfo.y * rowSize + (regionInfo.x &gt;&gt; 3); let i, j, mask, offset; switch (combinationOperator) { case 0: for (i = 0; i &lt; height; i++) { mask = mask0; offset = offset0; for (j = 0; j &lt; width; j++) { if (bitmap[i][j]) { buffer[offset] |= mask; } mask &gt;&gt;= 1; if (!mask) { mask = 128; offset++; } } offset0 += rowSize; } break; case 2: for (i = 0; i &lt; height; i++) { mask = mask0; offset = offset0; for (j = 0; j &lt; width; j++) { if (bitmap[i][j]) { buffer[offset] ^= mask; } mask &gt;&gt;= 1; if (!mask) { mask = 128; offset++; } } offset0 += rowSize; } break; default: throw new Jbig2Error(`operator ${combinationOperator} is not supported`); } } onImmediateGenericRegion(region, data, start, end) { const regionInfo = region.info; const decodingContext = new DecodingContext(data, start, end); const bitmap = decodeBitmap(region.mmr, regionInfo.width, regionInfo.height, region.template, region.prediction, null, region.at, decodingContext); this.drawBitmap(regionInfo, bitmap); } onImmediateLosslessGenericRegion() { this.onImmediateGenericRegion(...arguments); } onSymbolDictionary(dictionary, currentSegment, referredSegments, data, start, end) { let huffmanTables, huffmanInput; if (dictionary.huffman) { huffmanTables = getSymbolDictionaryHuffmanTables(dictionary, referredSegments, this.customTables); huffmanInput = new Reader(data, start, end); } let symbols = this.symbols; if (!symbols) { this.symbols = symbols = {}; } const inputSymbols = []; for (const referredSegment of referredSegments) { const referredSymbols = symbols[referredSegment]; if (referredSymbols) { inputSymbols.push(...referredSymbols); } } const decodingContext = new DecodingContext(data, start, end); symbols[currentSegment] = decodeSymbolDictionary(dictionary.huffman, dictionary.refinement, inputSymbols, dictionary.numberOfNewSymbols, dictionary.numberOfExportedSymbols, huffmanTables, dictionary.template, dictionary.at, dictionary.refinementTemplate, dictionary.refinementAt, decodingContext, huffmanInput); } onImmediateTextRegion(region, referredSegments, data, start, end) { const regionInfo = region.info; let huffmanTables, huffmanInput; const symbols = this.symbols; const inputSymbols = []; for (const referredSegment of referredSegments) { const referredSymbols = symbols[referredSegment]; if (referredSymbols) { inputSymbols.push(...referredSymbols); } } const symbolCodeLength = (0, _core_utils.log2)(inputSymbols.length); if (region.huffman) { huffmanInput = new Reader(data, start, end); huffmanTables = getTextRegionHuffmanTables(region, referredSegments, this.customTables, inputSymbols.length, huffmanInput); } const decodingContext = new DecodingContext(data, start, end); const bitmap = decodeTextRegion(region.huffman, region.refinement, regionInfo.width, regionInfo.height, region.defaultPixelValue, region.numberOfSymbolInstances, region.stripSize, inputSymbols, symbolCodeLength, region.transposed, region.dsOffset, region.referenceCorner, region.combinationOperator, huffmanTables, region.refinementTemplate, region.refinementAt, decodingContext, region.logStripSize, huffmanInput); this.drawBitmap(regionInfo, bitmap); } onImmediateLosslessTextRegion() { this.onImmediateTextRegion(...arguments); } onPatternDictionary(dictionary, currentSegment, data, start, end) { let patterns = this.patterns; if (!patterns) { this.patterns = patterns = {}; } const decodingContext = new DecodingContext(data, start, end); patterns[currentSegment] = decodePatternDictionary(dictionary.mmr, dictionary.patternWidth, dictionary.patternHeight, dictionary.maxPatternIndex, dictionary.template, decodingContext); } onImmediateHalftoneRegion(region, referredSegments, data, start, end) { const patterns = this.patterns[referredSegments[0]]; const regionInfo = region.info; const decodingContext = new DecodingContext(data, start, end); const bitmap = decodeHalftoneRegion(region.mmr, patterns, region.template, regionInfo.width, regionInfo.height, region.defaultPixelValue, region.enableSkip, region.combinationOperator, region.gridWidth, region.gridHeight, region.gridOffsetX, region.gridOffsetY, region.gridVectorX, region.gridVectorY, decodingContext); this.drawBitmap(regionInfo, bitmap); } onImmediateLosslessHalftoneRegion() { this.onImmediateHalftoneRegion(...arguments); } onTables(currentSegment, data, start, end) { let customTables = this.customTables; if (!customTables) { this.customTables = customTables = {}; } customTables[currentSegment] = decodeTablesSegment(data, start, end); } } class HuffmanLine { constructor(lineData) { if (lineData.length === 2) { this.isOOB = true; this.rangeLow = 0; this.prefixLength = lineData[0]; this.rangeLength = 0; this.prefixCode = lineData[1]; this.isLowerRange = false; } else { this.isOOB = false; this.rangeLow = lineData[0]; this.prefixLength = lineData[1]; this.rangeLength = lineData[2]; this.prefixCode = lineData[3]; this.isLowerRange = lineData[4] === &quot;lower&quot;; } } } class HuffmanTreeNode { constructor(line) { this.children = []; if (line) { this.isLeaf = true; this.rangeLength = line.rangeLength; this.rangeLow = line.rangeLow; this.isLowerRange = line.isLowerRange; this.isOOB = line.isOOB; } else { this.isLeaf = false; } } buildTree(line, shift) { const bit = line.prefixCode &gt;&gt; shift &amp; 1; if (shift &lt;= 0) { this.children[bit] = new HuffmanTreeNode(line); } else { let node = this.children[bit]; if (!node) { this.children[bit] = node = new HuffmanTreeNode(null); } node.buildTree(line, shift - 1); } } decodeNode(reader) { if (this.isLeaf) { if (this.isOOB) { return null; } const htOffset = reader.readBits(this.rangeLength); return this.rangeLow + (this.isLowerRange ? -htOffset : htOffset); } const node = this.children[reader.readBit()]; if (!node) { throw new Jbig2Error(&quot;invalid Huffman data&quot;); } return node.decodeNode(reader); } } class HuffmanTable { constructor(lines, prefixCodesDone) { if (!prefixCodesDone) { this.assignPrefixCodes(lines); } this.rootNode = new HuffmanTreeNode(null); for (let i = 0, ii = lines.length; i &lt; ii; i++) { const line = lines[i]; if (line.prefixLength &gt; 0) { this.rootNode.buildTree(line, line.prefixLength - 1); } } } decode(reader) { return this.rootNode.decodeNode(reader); } assignPrefixCodes(lines) { const linesLength = lines.length; let prefixLengthMax = 0; for (let i = 0; i &lt; linesLength; i++) { prefixLengthMax = Math.max(prefixLengthMax, lines[i].prefixLength); } const histogram = new Uint32Array(prefixLengthMax + 1); for (let i = 0; i &lt; linesLength; i++) { histogram[lines[i].prefixLength]++; } let currentLength = 1, firstCode = 0, currentCode, currentTemp, line; histogram[0] = 0; while (currentLength &lt;= prefixLengthMax) { firstCode = firstCode + histogram[currentLength - 1] &lt;&lt; 1; currentCode = firstCode; currentTemp = 0; while (currentTemp &lt; linesLength) { line = lines[currentTemp]; if (line.prefixLength === currentLength) { line.prefixCode = currentCode; currentCode++; } currentTemp++; } currentLength++; } } } function decodeTablesSegment(data, start, end) { const flags = data[start]; const lowestValue = (0, _core_utils.readUint32)(data, start + 1) &amp; 0xffffffff; const highestValue = (0, _core_utils.readUint32)(data, start + 5) &amp; 0xffffffff; const reader = new Reader(data, start + 9, end); const prefixSizeBits = (flags &gt;&gt; 1 &amp; 7) + 1; const rangeSizeBits = (flags &gt;&gt; 4 &amp; 7) + 1; const lines = []; let prefixLength, rangeLength, currentRangeLow = lowestValue; do { prefixLength = reader.readBits(prefixSizeBits); rangeLength = reader.readBits(rangeSizeBits); lines.push(new HuffmanLine([currentRangeLow, prefixLength, rangeLength, 0])); currentRangeLow += 1 &lt;&lt; rangeLength; } while (currentRangeLow &lt; highestValue); prefixLength = reader.readBits(prefixSizeBits); lines.push(new HuffmanLine([lowestValue - 1, prefixLength, 32, 0, &quot;lower&quot;])); prefixLength = reader.readBits(prefixSizeBits); lines.push(new HuffmanLine([highestValue, prefixLength, 32, 0])); if (flags &amp; 1) { prefixLength = reader.readBits(prefixSizeBits); lines.push(new HuffmanLine([prefixLength, 0])); } return new HuffmanTable(lines, false); } const standardTablesCache = {}; function getStandardTable(number) { let table = standardTablesCache[number]; if (table) { return table; } let lines; switch (number) { case 1: lines = [[0, 1, 4, 0x0], [16, 2, 8, 0x2], [272, 3, 16, 0x6], [65808, 3, 32, 0x7]]; break; case 2: lines = [[0, 1, 0, 0x0], [1, 2, 0, 0x2], [2, 3, 0, 0x6], [3, 4, 3, 0xe], [11, 5, 6, 0x1e], [75, 6, 32, 0x3e], [6, 0x3f]]; break; case 3: lines = [[-256, 8, 8, 0xfe], [0, 1, 0, 0x0], [1, 2, 0, 0x2], [2, 3, 0, 0x6], [3, 4, 3, 0xe], [11, 5, 6, 0x1e], [-257, 8, 32, 0xff, &quot;lower&quot;], [75, 7, 32, 0x7e], [6, 0x3e]]; break; case 4: lines = [[1, 1, 0, 0x0], [2, 2, 0, 0x2], [3, 3, 0, 0x6], [4, 4, 3, 0xe], [12, 5, 6, 0x1e], [76, 5, 32, 0x1f]]; break; case 5: lines = [[-255, 7, 8, 0x7e], [1, 1, 0, 0x0], [2, 2, 0, 0x2], [3, 3, 0, 0x6], [4, 4, 3, 0xe], [12, 5, 6, 0x1e], [-256, 7, 32, 0x7f, &quot;lower&quot;], [76, 6, 32, 0x3e]]; break; case 6: lines = [[-2048, 5, 10, 0x1c], [-1024, 4, 9, 0x8], [-512, 4, 8, 0x9], [-256, 4, 7, 0xa], [-128, 5, 6, 0x1d], [-64, 5, 5, 0x1e], [-32, 4, 5, 0xb], [0, 2, 7, 0x0], [128, 3, 7, 0x2], [256, 3, 8, 0x3], [512, 4, 9, 0xc], [1024, 4, 10, 0xd], [-2049, 6, 32, 0x3e, &quot;lower&quot;], [2048, 6, 32, 0x3f]]; break; case 7: lines = [[-1024, 4, 9, 0x8], [-512, 3, 8, 0x0], [-256, 4, 7, 0x9], [-128, 5, 6, 0x1a], [-64, 5, 5, 0x1b], [-32, 4, 5, 0xa], [0, 4, 5, 0xb], [32, 5, 5, 0x1c], [64, 5, 6, 0x1d], [128, 4, 7, 0xc], [256, 3, 8, 0x1], [512, 3, 9, 0x2], [1024, 3, 10, 0x3], [-1025, 5, 32, 0x1e, &quot;lower&quot;], [2048, 5, 32, 0x1f]]; break; case 8: lines = [[-15, 8, 3, 0xfc], [-7, 9, 1, 0x1fc], [-5, 8, 1, 0xfd], [-3, 9, 0, 0x1fd], [-2, 7, 0, 0x7c], [-1, 4, 0, 0xa], [0, 2, 1, 0x0], [2, 5, 0, 0x1a], [3, 6, 0, 0x3a], [4, 3, 4, 0x4], [20, 6, 1, 0x3b], [22, 4, 4, 0xb], [38, 4, 5, 0xc], [70, 5, 6, 0x1b], [134, 5, 7, 0x1c], [262, 6, 7, 0x3c], [390, 7, 8, 0x7d], [646, 6, 10, 0x3d], [-16, 9, 32, 0x1fe, &quot;lower&quot;], [1670, 9, 32, 0x1ff], [2, 0x1]]; break; case 9: lines = [[-31, 8, 4, 0xfc], [-15, 9, 2, 0x1fc], [-11, 8, 2, 0xfd], [-7, 9, 1, 0x1fd], [-5, 7, 1, 0x7c], [-3, 4, 1, 0xa], [-1, 3, 1, 0x2], [1, 3, 1, 0x3], [3, 5, 1, 0x1a], [5, 6, 1, 0x3a], [7, 3, 5, 0x4], [39, 6, 2, 0x3b], [43, 4, 5, 0xb], [75, 4, 6, 0xc], [139, 5, 7, 0x1b], [267, 5, 8, 0x1c], [523, 6, 8, 0x3c], [779, 7, 9, 0x7d], [1291, 6, 11, 0x3d], [-32, 9, 32, 0x1fe, &quot;lower&quot;], [3339, 9, 32, 0x1ff], [2, 0x0]]; break; case 10: lines = [[-21, 7, 4, 0x7a], [-5, 8, 0, 0xfc], [-4, 7, 0, 0x7b], [-3, 5, 0, 0x18], [-2, 2, 2, 0x0], [2, 5, 0, 0x19], [3, 6, 0, 0x36], [4, 7, 0, 0x7c], [5, 8, 0, 0xfd], [6, 2, 6, 0x1], [70, 5, 5, 0x1a], [102, 6, 5, 0x37], [134, 6, 6, 0x38], [198, 6, 7, 0x39], [326, 6, 8, 0x3a], [582, 6, 9, 0x3b], [1094, 6, 10, 0x3c], [2118, 7, 11, 0x7d], [-22, 8, 32, 0xfe, &quot;lower&quot;], [4166, 8, 32, 0xff], [2, 0x2]]; break; case 11: lines = [[1, 1, 0, 0x0], [2, 2, 1, 0x2], [4, 4, 0, 0xc], [5, 4, 1, 0xd], [7, 5, 1, 0x1c], [9, 5, 2, 0x1d], [13, 6, 2, 0x3c], [17, 7, 2, 0x7a], [21, 7, 3, 0x7b], [29, 7, 4, 0x7c], [45, 7, 5, 0x7d], [77, 7, 6, 0x7e], [141, 7, 32, 0x7f]]; break; case 12: lines = [[1, 1, 0, 0x0], [2, 2, 0, 0x2], [3, 3, 1, 0x6], [5, 5, 0, 0x1c], [6, 5, 1, 0x1d], [8, 6, 1, 0x3c], [10, 7, 0, 0x7a], [11, 7, 1, 0x7b], [13, 7, 2, 0x7c], [17, 7, 3, 0x7d], [25, 7, 4, 0x7e], [41, 8, 5, 0xfe], [73, 8, 32, 0xff]]; break; case 13: lines = [[1, 1, 0, 0x0], [2, 3, 0, 0x4], [3, 4, 0, 0xc], [4, 5, 0, 0x1c], [5, 4, 1, 0xd], [7, 3, 3, 0x5], [15, 6, 1, 0x3a], [17, 6, 2, 0x3b], [21, 6, 3, 0x3c], [29, 6, 4, 0x3d], [45, 6, 5, 0x3e], [77, 7, 6, 0x7e], [141, 7, 32, 0x7f]]; break; case 14: lines = [[-2, 3, 0, 0x4], [-1, 3, 0, 0x5], [0, 1, 0, 0x0], [1, 3, 0, 0x6], [2, 3, 0, 0x7]]; break; case 15: lines = [[-24, 7, 4, 0x7c], [-8, 6, 2, 0x3c], [-4, 5, 1, 0x1c], [-2, 4, 0, 0xc], [-1, 3, 0, 0x4], [0, 1, 0, 0x0], [1, 3, 0, 0x5], [2, 4, 0, 0xd], [3, 5, 1, 0x1d], [5, 6, 2, 0x3d], [9, 7, 4, 0x7d], [-25, 7, 32, 0x7e, &quot;lower&quot;], [25, 7, 32, 0x7f]]; break; default: throw new Jbig2Error(`standard table B.${number} does not exist`); } for (let i = 0, ii = lines.length; i &lt; ii; i++) { lines[i] = new HuffmanLine(lines[i]); } table = new HuffmanTable(lines, true); standardTablesCache[number] = table; return table; } class Reader { constructor(data, start, end) { this.data = data; this.start = start; this.end = end; this.position = start; this.shift = -1; this.currentByte = 0; } readBit() { if (this.shift &lt; 0) { if (this.position &gt;= this.end) { throw new Jbig2Error(&quot;end of data while reading bit&quot;); } this.currentByte = this.data[this.position++]; this.shift = 7; } const bit = this.currentByte &gt;&gt; this.shift &amp; 1; this.shift--; return bit; } readBits(numBits) { let result = 0, i; for (i = numBits - 1; i &gt;= 0; i--) { result |= this.readBit() &lt;&lt; i; } return result; } byteAlign() { this.shift = -1; } next() { if (this.position &gt;= this.end) { return -1; } return this.data[this.position++]; } } function getCustomHuffmanTable(index, referredTo, customTables) { let currentIndex = 0; for (let i = 0, ii = referredTo.length; i &lt; ii; i++) { const table = customTables[referredTo[i]]; if (table) { if (index === currentIndex) { return table; } currentIndex++; } } throw new Jbig2Error(&quot;can&apos;t find custom Huffman table&quot;); } function getTextRegionHuffmanTables(textRegion, referredTo, customTables, numberOfSymbols, reader) { const codes = []; for (let i = 0; i &lt;= 34; i++) { const codeLength = reader.readBits(4); codes.push(new HuffmanLine([i, codeLength, 0, 0])); } const runCodesTable = new HuffmanTable(codes, false); codes.length = 0; for (let i = 0; i &lt; numberOfSymbols;) { const codeLength = runCodesTable.decode(reader); if (codeLength &gt;= 32) { let repeatedLength, numberOfRepeats, j; switch (codeLength) { case 32: if (i === 0) { throw new Jbig2Error(&quot;no previous value in symbol ID table&quot;); } numberOfRepeats = reader.readBits(2) + 3; repeatedLength = codes[i - 1].prefixLength; break; case 33: numberOfRepeats = reader.readBits(3) + 3; repeatedLength = 0; break; case 34: numberOfRepeats = reader.readBits(7) + 11; repeatedLength = 0; break; default: throw new Jbig2Error(&quot;invalid code length in symbol ID table&quot;); } for (j = 0; j &lt; numberOfRepeats; j++) { codes.push(new HuffmanLine([i, repeatedLength, 0, 0])); i++; } } else { codes.push(new HuffmanLine([i, codeLength, 0, 0])); i++; } } reader.byteAlign(); const symbolIDTable = new HuffmanTable(codes, false); let customIndex = 0, tableFirstS, tableDeltaS, tableDeltaT; switch (textRegion.huffmanFS) { case 0: case 1: tableFirstS = getStandardTable(textRegion.huffmanFS + 6); break; case 3: tableFirstS = getCustomHuffmanTable(customIndex, referredTo, customTables); customIndex++; break; default: throw new Jbig2Error(&quot;invalid Huffman FS selector&quot;); } switch (textRegion.huffmanDS) { case 0: case 1: case 2: tableDeltaS = getStandardTable(textRegion.huffmanDS + 8); break; case 3: tableDeltaS = getCustomHuffmanTable(customIndex, referredTo, customTables); customIndex++; break; default: throw new Jbig2Error(&quot;invalid Huffman DS selector&quot;); } switch (textRegion.huffmanDT) { case 0: case 1: case 2: tableDeltaT = getStandardTable(textRegion.huffmanDT + 11); break; case 3: tableDeltaT = getCustomHuffmanTable(customIndex, referredTo, customTables); customIndex++; break; default: throw new Jbig2Error(&quot;invalid Huffman DT selector&quot;); } if (textRegion.refinement) { throw new Jbig2Error(&quot;refinement with Huffman is not supported&quot;); } return { symbolIDTable, tableFirstS, tableDeltaS, tableDeltaT }; } function getSymbolDictionaryHuffmanTables(dictionary, referredTo, customTables) { let customIndex = 0, tableDeltaHeight, tableDeltaWidth; switch (dictionary.huffmanDHSelector) { case 0: case 1: tableDeltaHeight = getStandardTable(dictionary.huffmanDHSelector + 4); break; case 3: tableDeltaHeight = getCustomHuffmanTable(customIndex, referredTo, customTables); customIndex++; break; default: throw new Jbig2Error(&quot;invalid Huffman DH selector&quot;); } switch (dictionary.huffmanDWSelector) { case 0: case 1: tableDeltaWidth = getStandardTable(dictionary.huffmanDWSelector + 2); break; case 3: tableDeltaWidth = getCustomHuffmanTable(customIndex, referredTo, customTables); customIndex++; break; default: throw new Jbig2Error(&quot;invalid Huffman DW selector&quot;); } let tableBitmapSize, tableAggregateInstances; if (dictionary.bitmapSizeSelector) { tableBitmapSize = getCustomHuffmanTable(customIndex, referredTo, customTables); customIndex++; } else { tableBitmapSize = getStandardTable(1); } if (dictionary.aggregationInstancesSelector) { tableAggregateInstances = getCustomHuffmanTable(customIndex, referredTo, customTables); } else { tableAggregateInstances = getStandardTable(1); } return { tableDeltaHeight, tableDeltaWidth, tableBitmapSize, tableAggregateInstances }; } function readUncompressedBitmap(reader, width, height) { const bitmap = []; for (let y = 0; y &lt; height; y++) { const row = new Uint8Array(width); bitmap.push(row); for (let x = 0; x &lt; width; x++) { row[x] = reader.readBit(); } reader.byteAlign(); } return bitmap; } function decodeMMRBitmap(input, width, height, endOfBlock) { const params = { K: -1, Columns: width, Rows: height, BlackIs1: true, EndOfBlock: endOfBlock }; const decoder = new _ccitt.CCITTFaxDecoder(input, params); const bitmap = []; let currentByte, eof = false; for (let y = 0; y &lt; height; y++) { const row = new Uint8Array(width); bitmap.push(row); let shift = -1; for (let x = 0; x &lt; width; x++) { if (shift &lt; 0) { currentByte = decoder.readNextChar(); if (currentByte === -1) { currentByte = 0; eof = true; } shift = 7; } row[x] = currentByte &gt;&gt; shift &amp; 1; shift--; } } if (endOfBlock &amp;&amp; !eof) { const lookForEOFLimit = 5; for (let i = 0; i &lt; lookForEOFLimit; i++) { if (decoder.readNextChar() === -1) { break; } } } return bitmap; } class Jbig2Image { parseChunks(chunks) { return parseJbig2Chunks(chunks); } parse(data) { throw new Error(&quot;Not implemented: Jbig2Image.parse&quot;); } } exports.Jbig2Image = Jbig2Image; /***/ }), /* 24 */ /***/ ((__unused_webpack_module, exports) =&gt; { Object.defineProperty(exports, &quot;__esModule&quot;, ({ value: true })); exports.ArithmeticDecoder = void 0; const QeTable = [{ qe: 0x5601, nmps: 1, nlps: 1, switchFlag: 1 }, { qe: 0x3401, nmps: 2, nlps: 6, switchFlag: 0 }, { qe: 0x1801, nmps: 3, nlps: 9, switchFlag: 0 }, { qe: 0x0ac1, nmps: 4, nlps: 12, switchFlag: 0 }, { qe: 0x0521, nmps: 5, nlps: 29, switchFlag: 0 }, { qe: 0x0221, nmps: 38, nlps: 33, switchFlag: 0 }, { qe: 0x5601, nmps: 7, nlps: 6, switchFlag: 1 }, { qe: 0x5401, nmps: 8, nlps: 14, switchFlag: 0 }, { qe: 0x4801, nmps: 9, nlps: 14, switchFlag: 0 }, { qe: 0x3801, nmps: 10, nlps: 14, switchFlag: 0 }, { qe: 0x3001, nmps: 11, nlps: 17, switchFlag: 0 }, { qe: 0x2401, nmps: 12, nlps: 18, switchFlag: 0 }, { qe: 0x1c01, nmps: 13, nlps: 20, switchFlag: 0 }, { qe: 0x1601, nmps: 29, nlps: 21, switchFlag: 0 }, { qe: 0x5601, nmps: 15, nlps: 14, switchFlag: 1 }, { qe: 0x5401, nmps: 16, nlps: 14, switchFlag: 0 }, { qe: 0x5101, nmps: 17, nlps: 15, switchFlag: 0 }, { qe: 0x4801, nmps: 18, nlps: 16, switchFlag: 0 }, { qe: 0x3801, nmps: 19, nlps: 17, switchFlag: 0 }, { qe: 0x3401, nmps: 20, nlps: 18, switchFlag: 0 }, { qe: 0x3001, nmps: 21, nlps: 19, switchFlag: 0 }, { qe: 0x2801, nmps: 22, nlps: 19, switchFlag: 0 }, { qe: 0x2401, nmps: 23, nlps: 20, switchFlag: 0 }, { qe: 0x2201, nmps: 24, nlps: 21, switchFlag: 0 }, { qe: 0x1c01, nmps: 25, nlps: 22, switchFlag: 0 }, { qe: 0x1801, nmps: 26, nlps: 23, switchFlag: 0 }, { qe: 0x1601, nmps: 27, nlps: 24, switchFlag: 0 }, { qe: 0x1401, nmps: 28, nlps: 25, switchFlag: 0 }, { qe: 0x1201, nmps: 29, nlps: 26, switchFlag: 0 }, { qe: 0x1101, nmps: 30, nlps: 27, switchFlag: 0 }, { qe: 0x0ac1, nmps: 31, nlps: 28, switchFlag: 0 }, { qe: 0x09c1, nmps: 32, nlps: 29, switchFlag: 0 }, { qe: 0x08a1, nmps: 33, nlps: 30, switchFlag: 0 }, { qe: 0x0521, nmps: 34, nlps: 31, switchFlag: 0 }, { qe: 0x0441, nmps: 35, nlps: 32, switchFlag: 0 }, { qe: 0x02a1, nmps: 36, nlps: 33, switchFlag: 0 }, { qe: 0x0221, nmps: 37, nlps: 34, switchFlag: 0 }, { qe: 0x0141, nmps: 38, nlps: 35, switchFlag: 0 }, { qe: 0x0111, nmps: 39, nlps: 36, switchFlag: 0 }, { qe: 0x0085, nmps: 40, nlps: 37, switchFlag: 0 }, { qe: 0x0049, nmps: 41, nlps: 38, switchFlag: 0 }, { qe: 0x0025, nmps: 42, nlps: 39, switchFlag: 0 }, { qe: 0x0015, nmps: 43, nlps: 40, switchFlag: 0 }, { qe: 0x0009, nmps: 44, nlps: 41, switchFlag: 0 }, { qe: 0x0005, nmps: 45, nlps: 42, switchFlag: 0 }, { qe: 0x0001, nmps: 45, nlps: 43, switchFlag: 0 }, { qe: 0x5601, nmps: 46, nlps: 46, switchFlag: 0 }]; class ArithmeticDecoder { constructor(data, start, end) { this.data = data; this.bp = start; this.dataEnd = end; this.chigh = data[start]; this.clow = 0; this.byteIn(); this.chigh = this.chigh &lt;&lt; 7 &amp; 0xffff | this.clow &gt;&gt; 9 &amp; 0x7f; this.clow = this.clow &lt;&lt; 7 &amp; 0xffff; this.ct -= 7; this.a = 0x8000; } byteIn() { const data = this.data; let bp = this.bp; if (data[bp] === 0xff) { if (data[bp + 1] &gt; 0x8f) { this.clow += 0xff00; this.ct = 8; } else { bp++; this.clow += data[bp] &lt;&lt; 9; this.ct = 7; this.bp = bp; } } else { bp++; this.clow += bp &lt; this.dataEnd ? data[bp] &lt;&lt; 8 : 0xff00; this.ct = 8; this.bp = bp; } if (this.clow &gt; 0xffff) { this.chigh += this.clow &gt;&gt; 16; this.clow &amp;= 0xffff; } } readBit(contexts, pos) { let cx_index = contexts[pos] &gt;&gt; 1, cx_mps = contexts[pos] &amp; 1; const qeTableIcx = QeTable[cx_index]; const qeIcx = qeTableIcx.qe; let d; let a = this.a - qeIcx; if (this.chigh &lt; qeIcx) { if (a &lt; qeIcx) { a = qeIcx; d = cx_mps; cx_index = qeTableIcx.nmps; } else { a = qeIcx; d = 1 ^ cx_mps; if (qeTableIcx.switchFlag === 1) { cx_mps = d; } cx_index = qeTableIcx.nlps; } } else { this.chigh -= qeIcx; if ((a &amp; 0x8000) !== 0) { this.a = a; return cx_mps; } if (a &lt; qeIcx) { d = 1 ^ cx_mps; if (qeTableIcx.switchFlag === 1) { cx_mps = d; } cx_index = qeTableIcx.nlps; } else { d = cx_mps; cx_index = qeTableIcx.nmps; } } do { if (this.ct === 0) { this.byteIn(); } a &lt;&lt;= 1; this.chigh = this.chigh &lt;&lt; 1 &amp; 0xffff | this.clow &gt;&gt; 15 &amp; 1; this.clow = this.clow &lt;&lt; 1 &amp; 0xffff; this.ct--; } while ((a &amp; 0x8000) === 0); this.a = a; contexts[pos] = cx_index &lt;&lt; 1 | cx_mps; return d; } } exports.ArithmeticDecoder = ArithmeticDecoder; /***/ }), /* 25 */ /***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) =&gt; { Object.defineProperty(exports, &quot;__esModule&quot;, ({ value: true })); exports.JpegStream = void 0; var _decode_stream = __w_pdfjs_require__(17); var _primitives = __w_pdfjs_require__(3); var _jpg = __w_pdfjs_require__(26); var _util = __w_pdfjs_require__(2); class JpegStream extends _decode_stream.DecodeStream { constructor(stream, maybeLength, params) { let ch; while ((ch = stream.getByte()) !== -1) { if (ch === 0xff) { stream.skip(-1); break; } } super(maybeLength); this.stream = stream; this.dict = stream.dict; this.maybeLength = maybeLength; this.params = params; } get bytes() { return (0, _util.shadow)(this, &quot;bytes&quot;, this.stream.getBytes(this.maybeLength)); } ensureBuffer(requested) {} readBlock() { if (this.eof) { return; } const jpegOptions = { decodeTransform: undefined, colorTransform: undefined }; const decodeArr = this.dict.getArray(&quot;D&quot;, &quot;Decode&quot;); if (this.forceRGB &amp;&amp; Array.isArray(decodeArr)) { const bitsPerComponent = this.dict.get(&quot;BPC&quot;, &quot;BitsPerComponent&quot;) || 8; const decodeArrLength = decodeArr.length; const transform = new Int32Array(decodeArrLength); let transformNeeded = false; const maxValue = (1 &lt;&lt; bitsPerComponent) - 1; for (let i = 0; i &lt; decodeArrLength; i += 2) { transform[i] = (decodeArr[i + 1] - decodeArr[i]) * 256 | 0; transform[i + 1] = decodeArr[i] * maxValue | 0; if (transform[i] !== 256 || transform[i + 1] !== 0) { transformNeeded = true; } } if (transformNeeded) { jpegOptions.decodeTransform = transform; } } if (this.params instanceof _primitives.Dict) { const colorTransform = this.params.get(&quot;ColorTransform&quot;); if (Number.isInteger(colorTransform)) { jpegOptions.colorTransform = colorTransform; } } const jpegImage = new _jpg.JpegImage(jpegOptions); jpegImage.parse(this.bytes); const data = jpegImage.getData({ width: this.drawWidth, height: this.drawHeight, forceRGB: this.forceRGB, isSourcePDF: true }); this.buffer = data; this.bufferLength = data.length; this.eof = true; } } exports.JpegStream = JpegStream; /***/ }), /* 26 */ /***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) =&gt; { Object.defineProperty(exports, &quot;__esModule&quot;, ({ value: true })); exports.JpegImage = void 0; var _util = __w_pdfjs_require__(2); var _core_utils = __w_pdfjs_require__(4); class JpegError extends _util.BaseException { constructor(msg) { super(`JPEG error: ${msg}`, &quot;JpegError&quot;); } } class DNLMarkerError extends _util.BaseException { constructor(message, scanLines) { super(message, &quot;DNLMarkerError&quot;); this.scanLines = scanLines; } } class EOIMarkerError extends _util.BaseException { constructor(msg) { super(msg, &quot;EOIMarkerError&quot;); } } const dctZigZag = new Uint8Array([0, 1, 8, 16, 9, 2, 3, 10, 17, 24, 32, 25, 18, 11, 4, 5, 12, 19, 26, 33, 40, 48, 41, 34, 27, 20, 13, 6, 7, 14, 21, 28, 35, 42, 49, 56, 57, 50, 43, 36, 29, 22, 15, 23, 30, 37, 44, 51, 58, 59, 52, 45, 38, 31, 39, 46, 53, 60, 61, 54, 47, 55, 62, 63]); const dctCos1 = 4017; const dctSin1 = 799; const dctCos3 = 3406; const dctSin3 = 2276; const dctCos6 = 1567; const dctSin6 = 3784; const dctSqrt2 = 5793; const dctSqrt1d2 = 2896; function buildHuffmanTable(codeLengths, values) { let k = 0, i, j, length = 16; while (length &gt; 0 &amp;&amp; !codeLengths[length - 1]) { length--; } const code = [{ children: [], index: 0 }]; let p = code[0], q; for (i = 0; i &lt; length; i++) { for (j = 0; j &lt; codeLengths[i]; j++) { p = code.pop(); p.children[p.index] = values[k]; while (p.index &gt; 0) { p = code.pop(); } p.index++; code.push(p); while (code.length &lt;= i) { code.push(q = { children: [], index: 0 }); p.children[p.index] = q.children; p = q; } k++; } if (i + 1 &lt; length) { code.push(q = { children: [], index: 0 }); p.children[p.index] = q.children; p = q; } } return code[0].children; } function getBlockBufferOffset(component, row, col) { return 64 * ((component.blocksPerLine + 1) * row + col); } function decodeScan(data, offset, frame, components, resetInterval, spectralStart, spectralEnd, successivePrev, successive, parseDNLMarker = false) { const mcusPerLine = frame.mcusPerLine; const progressive = frame.progressive; const startOffset = offset; let bitsData = 0, bitsCount = 0; function readBit() { if (bitsCount &gt; 0) { bitsCount--; return bitsData &gt;&gt; bitsCount &amp; 1; } bitsData = data[offset++]; if (bitsData === 0xff) { const nextByte = data[offset++]; if (nextByte) { if (nextByte === 0xdc &amp;&amp; parseDNLMarker) { offset += 2; const scanLines = (0, _core_utils.readUint16)(data, offset); offset += 2; if (scanLines &gt; 0 &amp;&amp; scanLines !== frame.scanLines) { throw new DNLMarkerError(&quot;Found DNL marker (0xFFDC) while parsing scan data&quot;, scanLines); } } else if (nextByte === 0xd9) { if (parseDNLMarker) { const maybeScanLines = blockRow * (frame.precision === 8 ? 8 : 0); if (maybeScanLines &gt; 0 &amp;&amp; Math.round(frame.scanLines / maybeScanLines) &gt;= 5) { throw new DNLMarkerError(&quot;Found EOI marker (0xFFD9) while parsing scan data, &quot; + &quot;possibly caused by incorrect `scanLines` parameter&quot;, maybeScanLines); } } throw new EOIMarkerError(&quot;Found EOI marker (0xFFD9) while parsing scan data&quot;); } throw new JpegError(`unexpected marker ${(bitsData &lt;&lt; 8 | nextByte).toString(16)}`); } } bitsCount = 7; return bitsData &gt;&gt;&gt; 7; } function decodeHuffman(tree) { let node = tree; while (true) { node = node[readBit()]; switch (typeof node) { case &quot;number&quot;: return node; case &quot;object&quot;: continue; } throw new JpegError(&quot;invalid huffman sequence&quot;); } } function receive(length) { let n = 0; while (length &gt; 0) { n = n &lt;&lt; 1 | readBit(); length--; } return n; } function receiveAndExtend(length) { if (length === 1) { return readBit() === 1 ? 1 : -1; } const n = receive(length); if (n &gt;= 1 &lt;&lt; length - 1) { return n; } return n + (-1 &lt;&lt; length) + 1; } function decodeBaseline(component, blockOffset) { const t = decodeHuffman(component.huffmanTableDC); const diff = t === 0 ? 0 : receiveAndExtend(t); component.blockData[blockOffset] = component.pred += diff; let k = 1; while (k &lt; 64) { const rs = decodeHuffman(component.huffmanTableAC); const s = rs &amp; 15, r = rs &gt;&gt; 4; if (s === 0) { if (r &lt; 15) { break; } k += 16; continue; } k += r; const z = dctZigZag[k]; component.blockData[blockOffset + z] = receiveAndExtend(s); k++; } } function decodeDCFirst(component, blockOffset) { const t = decodeHuffman(component.huffmanTableDC); const diff = t === 0 ? 0 : receiveAndExtend(t) &lt;&lt; successive; component.blockData[blockOffset] = component.pred += diff; } function decodeDCSuccessive(component, blockOffset) { component.blockData[blockOffset] |= readBit() &lt;&lt; successive; } let eobrun = 0; function decodeACFirst(component, blockOffset) { if (eobrun &gt; 0) { eobrun--; return; } let k = spectralStart; const e = spectralEnd; while (k &lt;= e) { const rs = decodeHuffman(component.huffmanTableAC); const s = rs &amp; 15, r = rs &gt;&gt; 4; if (s === 0) { if (r &lt; 15) { eobrun = receive(r) + (1 &lt;&lt; r) - 1; break; } k += 16; continue; } k += r; const z = dctZigZag[k]; component.blockData[blockOffset + z] = receiveAndExtend(s) * (1 &lt;&lt; successive); k++; } } let successiveACState = 0, successiveACNextValue; function decodeACSuccessive(component, blockOffset) { let k = spectralStart; const e = spectralEnd; let r = 0; let s; let rs; while (k &lt;= e) { const offsetZ = blockOffset + dctZigZag[k]; const sign = component.blockData[offsetZ] &lt; 0 ? -1 : 1; switch (successiveACState) { case 0: rs = decodeHuffman(component.huffmanTableAC); s = rs &amp; 15; r = rs &gt;&gt; 4; if (s === 0) { if (r &lt; 15) { eobrun = receive(r) + (1 &lt;&lt; r); successiveACState = 4; } else { r = 16; successiveACState = 1; } } else { if (s !== 1) { throw new JpegError(&quot;invalid ACn encoding&quot;); } successiveACNextValue = receiveAndExtend(s); successiveACState = r ? 2 : 3; } continue; case 1: case 2: if (component.blockData[offsetZ]) { component.blockData[offsetZ] += sign * (readBit() &lt;&lt; successive); } else { r--; if (r === 0) { successiveACState = successiveACState === 2 ? 3 : 0; } } break; case 3: if (component.blockData[offsetZ]) { component.blockData[offsetZ] += sign * (readBit() &lt;&lt; successive); } else { component.blockData[offsetZ] = successiveACNextValue &lt;&lt; successive; successiveACState = 0; } break; case 4: if (component.blockData[offsetZ]) { component.blockData[offsetZ] += sign * (readBit() &lt;&lt; successive); } break; } k++; } if (successiveACState === 4) { eobrun--; if (eobrun === 0) { successiveACState = 0; } } } let blockRow = 0; function decodeMcu(component, decode, mcu, row, col) { const mcuRow = mcu / mcusPerLine | 0; const mcuCol = mcu % mcusPerLine; blockRow = mcuRow * component.v + row; const blockCol = mcuCol * component.h + col; const blockOffset = getBlockBufferOffset(component, blockRow, blockCol); decode(component, blockOffset); } function decodeBlock(component, decode, mcu) { blockRow = mcu / component.blocksPerLine | 0; const blockCol = mcu % component.blocksPerLine; const blockOffset = getBlockBufferOffset(component, blockRow, blockCol); decode(component, blockOffset); } const componentsLength = components.length; let component, i, j, k, n; let decodeFn; if (progressive) { if (spectralStart === 0) { decodeFn = successivePrev === 0 ? decodeDCFirst : decodeDCSuccessive; } else { decodeFn = successivePrev === 0 ? decodeACFirst : decodeACSuccessive; } } else { decodeFn = decodeBaseline; } let mcu = 0, fileMarker; let mcuExpected; if (componentsLength === 1) { mcuExpected = components[0].blocksPerLine * components[0].blocksPerColumn; } else { mcuExpected = mcusPerLine * frame.mcusPerColumn; } let h, v; while (mcu &lt;= mcuExpected) { const mcuToRead = resetInterval ? Math.min(mcuExpected - mcu, resetInterval) : mcuExpected; if (mcuToRead &gt; 0) { for (i = 0; i &lt; componentsLength; i++) { components[i].pred = 0; } eobrun = 0; if (componentsLength === 1) { component = components[0]; for (n = 0; n &lt; mcuToRead; n++) { decodeBlock(component, decodeFn, mcu); mcu++; } } else { for (n = 0; n &lt; mcuToRead; n++) { for (i = 0; i &lt; componentsLength; i++) { component = components[i]; h = component.h; v = component.v; for (j = 0; j &lt; v; j++) { for (k = 0; k &lt; h; k++) { decodeMcu(component, decodeFn, mcu, j, k); } } } mcu++; } } } bitsCount = 0; fileMarker = findNextFileMarker(data, offset); if (!fileMarker) { break; } if (fileMarker.invalid) { const partialMsg = mcuToRead &gt; 0 ? &quot;unexpected&quot; : &quot;excessive&quot;; (0, _util.warn)(`decodeScan - ${partialMsg} MCU data, current marker is: ${fileMarker.invalid}`); offset = fileMarker.offset; } if (fileMarker.marker &gt;= 0xffd0 &amp;&amp; fileMarker.marker &lt;= 0xffd7) { offset += 2; } else { break; } } return offset - startOffset; } function quantizeAndInverse(component, blockBufferOffset, p) { const qt = component.quantizationTable, blockData = component.blockData; let v0, v1, v2, v3, v4, v5, v6, v7; let p0, p1, p2, p3, p4, p5, p6, p7; let t; if (!qt) { throw new JpegError(&quot;missing required Quantization Table.&quot;); } for (let row = 0; row &lt; 64; row += 8) { p0 = blockData[blockBufferOffset + row]; p1 = blockData[blockBufferOffset + row + 1]; p2 = blockData[blockBufferOffset + row + 2]; p3 = blockData[blockBufferOffset + row + 3]; p4 = blockData[blockBufferOffset + row + 4]; p5 = blockData[blockBufferOffset + row + 5]; p6 = blockData[blockBufferOffset + row + 6]; p7 = blockData[blockBufferOffset + row + 7]; p0 *= qt[row]; if ((p1 | p2 | p3 | p4 | p5 | p6 | p7) === 0) { t = dctSqrt2 * p0 + 512 &gt;&gt; 10; p[row] = t; p[row + 1] = t; p[row + 2] = t; p[row + 3] = t; p[row + 4] = t; p[row + 5] = t; p[row + 6] = t; p[row + 7] = t; continue; } p1 *= qt[row + 1]; p2 *= qt[row + 2]; p3 *= qt[row + 3]; p4 *= qt[row + 4]; p5 *= qt[row + 5]; p6 *= qt[row + 6]; p7 *= qt[row + 7]; v0 = dctSqrt2 * p0 + 128 &gt;&gt; 8; v1 = dctSqrt2 * p4 + 128 &gt;&gt; 8; v2 = p2; v3 = p6; v4 = dctSqrt1d2 * (p1 - p7) + 128 &gt;&gt; 8; v7 = dctSqrt1d2 * (p1 + p7) + 128 &gt;&gt; 8; v5 = p3 &lt;&lt; 4; v6 = p5 &lt;&lt; 4; v0 = v0 + v1 + 1 &gt;&gt; 1; v1 = v0 - v1; t = v2 * dctSin6 + v3 * dctCos6 + 128 &gt;&gt; 8; v2 = v2 * dctCos6 - v3 * dctSin6 + 128 &gt;&gt; 8; v3 = t; v4 = v4 + v6 + 1 &gt;&gt; 1; v6 = v4 - v6; v7 = v7 + v5 + 1 &gt;&gt; 1; v5 = v7 - v5; v0 = v0 + v3 + 1 &gt;&gt; 1; v3 = v0 - v3; v1 = v1 + v2 + 1 &gt;&gt; 1; v2 = v1 - v2; t = v4 * dctSin3 + v7 * dctCos3 + 2048 &gt;&gt; 12; v4 = v4 * dctCos3 - v7 * dctSin3 + 2048 &gt;&gt; 12; v7 = t; t = v5 * dctSin1 + v6 * dctCos1 + 2048 &gt;&gt; 12; v5 = v5 * dctCos1 - v6 * dctSin1 + 2048 &gt;&gt; 12; v6 = t; p[row] = v0 + v7; p[row + 7] = v0 - v7; p[row + 1] = v1 + v6; p[row + 6] = v1 - v6; p[row + 2] = v2 + v5; p[row + 5] = v2 - v5; p[row + 3] = v3 + v4; p[row + 4] = v3 - v4; } for (let col = 0; col &lt; 8; ++col) { p0 = p[col]; p1 = p[col + 8]; p2 = p[col + 16]; p3 = p[col + 24]; p4 = p[col + 32]; p5 = p[col + 40]; p6 = p[col + 48]; p7 = p[col + 56]; if ((p1 | p2 | p3 | p4 | p5 | p6 | p7) === 0) { t = dctSqrt2 * p0 + 8192 &gt;&gt; 14; if (t &lt; -2040) { t = 0; } else if (t &gt;= 2024) { t = 255; } else { t = t + 2056 &gt;&gt; 4; } blockData[blockBufferOffset + col] = t; blockData[blockBufferOffset + col + 8] = t; blockData[blockBufferOffset + col + 16] = t; blockData[blockBufferOffset + col + 24] = t; blockData[blockBufferOffset + col + 32] = t; blockData[blockBufferOffset + col + 40] = t; blockData[blockBufferOffset + col + 48] = t; blockData[blockBufferOffset + col + 56] = t; continue; } v0 = dctSqrt2 * p0 + 2048 &gt;&gt; 12; v1 = dctSqrt2 * p4 + 2048 &gt;&gt; 12; v2 = p2; v3 = p6; v4 = dctSqrt1d2 * (p1 - p7) + 2048 &gt;&gt; 12; v7 = dctSqrt1d2 * (p1 + p7) + 2048 &gt;&gt; 12; v5 = p3; v6 = p5; v0 = (v0 + v1 + 1 &gt;&gt; 1) + 4112; v1 = v0 - v1; t = v2 * dctSin6 + v3 * dctCos6 + 2048 &gt;&gt; 12; v2 = v2 * dctCos6 - v3 * dctSin6 + 2048 &gt;&gt; 12; v3 = t; v4 = v4 + v6 + 1 &gt;&gt; 1; v6 = v4 - v6; v7 = v7 + v5 + 1 &gt;&gt; 1; v5 = v7 - v5; v0 = v0 + v3 + 1 &gt;&gt; 1; v3 = v0 - v3; v1 = v1 + v2 + 1 &gt;&gt; 1; v2 = v1 - v2; t = v4 * dctSin3 + v7 * dctCos3 + 2048 &gt;&gt; 12; v4 = v4 * dctCos3 - v7 * dctSin3 + 2048 &gt;&gt; 12; v7 = t; t = v5 * dctSin1 + v6 * dctCos1 + 2048 &gt;&gt; 12; v5 = v5 * dctCos1 - v6 * dctSin1 + 2048 &gt;&gt; 12; v6 = t; p0 = v0 + v7; p7 = v0 - v7; p1 = v1 + v6; p6 = v1 - v6; p2 = v2 + v5; p5 = v2 - v5; p3 = v3 + v4; p4 = v3 - v4; if (p0 &lt; 16) { p0 = 0; } else if (p0 &gt;= 4080) { p0 = 255; } else { p0 &gt;&gt;= 4; } if (p1 &lt; 16) { p1 = 0; } else if (p1 &gt;= 4080) { p1 = 255; } else { p1 &gt;&gt;= 4; } if (p2 &lt; 16) { p2 = 0; } else if (p2 &gt;= 4080) { p2 = 255; } else { p2 &gt;&gt;= 4; } if (p3 &lt; 16) { p3 = 0; } else if (p3 &gt;= 4080) { p3 = 255; } else { p3 &gt;&gt;= 4; } if (p4 &lt; 16) { p4 = 0; } else if (p4 &gt;= 4080) { p4 = 255; } else { p4 &gt;&gt;= 4; } if (p5 &lt; 16) { p5 = 0; } else if (p5 &gt;= 4080) { p5 = 255; } else { p5 &gt;&gt;= 4; } if (p6 &lt; 16) { p6 = 0; } else if (p6 &gt;= 4080) { p6 = 255; } else { p6 &gt;&gt;= 4; } if (p7 &lt; 16) { p7 = 0; } else if (p7 &gt;= 4080) { p7 = 255; } else { p7 &gt;&gt;= 4; } blockData[blockBufferOffset + col] = p0; blockData[blockBufferOffset + col + 8] = p1; blockData[blockBufferOffset + col + 16] = p2; blockData[blockBufferOffset + col + 24] = p3; blockData[blockBufferOffset + col + 32] = p4; blockData[blockBufferOffset + col + 40] = p5; blockData[blockBufferOffset + col + 48] = p6; blockData[blockBufferOffset + col + 56] = p7; } } function buildComponentData(frame, component) { const blocksPerLine = component.blocksPerLine; const blocksPerColumn = component.blocksPerColumn; const computationBuffer = new Int16Array(64); for (let blockRow = 0; blockRow &lt; blocksPerColumn; blockRow++) { for (let blockCol = 0; blockCol &lt; blocksPerLine; blockCol++) { const offset = getBlockBufferOffset(component, blockRow, blockCol); quantizeAndInverse(component, offset, computationBuffer); } } return component.blockData; } function findNextFileMarker(data, currentPos, startPos = currentPos) { const maxPos = data.length - 1; let newPos = startPos &lt; currentPos ? startPos : currentPos; if (currentPos &gt;= maxPos) { return null; } const currentMarker = (0, _core_utils.readUint16)(data, currentPos); if (currentMarker &gt;= 0xffc0 &amp;&amp; currentMarker &lt;= 0xfffe) { return { invalid: null, marker: currentMarker, offset: currentPos }; } let newMarker = (0, _core_utils.readUint16)(data, newPos); while (!(newMarker &gt;= 0xffc0 &amp;&amp; newMarker &lt;= 0xfffe)) { if (++newPos &gt;= maxPos) { return null; } newMarker = (0, _core_utils.readUint16)(data, newPos); } return { invalid: currentMarker.toString(16), marker: newMarker, offset: newPos }; } class JpegImage { constructor({ decodeTransform = null, colorTransform = -1 } = {}) { this._decodeTransform = decodeTransform; this._colorTransform = colorTransform; } parse(data, { dnlScanLines = null } = {}) { function readDataBlock() { const length = (0, _core_utils.readUint16)(data, offset); offset += 2; let endOffset = offset + length - 2; const fileMarker = findNextFileMarker(data, endOffset, offset); if (fileMarker &amp;&amp; fileMarker.invalid) { (0, _util.warn)(&quot;readDataBlock - incorrect length, current marker is: &quot; + fileMarker.invalid); endOffset = fileMarker.offset; } const array = data.subarray(offset, endOffset); offset += array.length; return array; } function prepareComponents(frame) { const mcusPerLine = Math.ceil(frame.samplesPerLine / 8 / frame.maxH); const mcusPerColumn = Math.ceil(frame.scanLines / 8 / frame.maxV); for (const component of frame.components) { const blocksPerLine = Math.ceil(Math.ceil(frame.samplesPerLine / 8) * component.h / frame.maxH); const blocksPerColumn = Math.ceil(Math.ceil(frame.scanLines / 8) * component.v / frame.maxV); const blocksPerLineForMcu = mcusPerLine * component.h; const blocksPerColumnForMcu = mcusPerColumn * component.v; const blocksBufferSize = 64 * blocksPerColumnForMcu * (blocksPerLineForMcu + 1); component.blockData = new Int16Array(blocksBufferSize); component.blocksPerLine = blocksPerLine; component.blocksPerColumn = blocksPerColumn; } frame.mcusPerLine = mcusPerLine; frame.mcusPerColumn = mcusPerColumn; } let offset = 0; let jfif = null; let adobe = null; let frame, resetInterval; let numSOSMarkers = 0; const quantizationTables = []; const huffmanTablesAC = [], huffmanTablesDC = []; let fileMarker = (0, _core_utils.readUint16)(data, offset); offset += 2; if (fileMarker !== 0xffd8) { throw new JpegError(&quot;SOI not found&quot;); } fileMarker = (0, _core_utils.readUint16)(data, offset); offset += 2; markerLoop: while (fileMarker !== 0xffd9) { let i, j, l; switch (fileMarker) { case 0xffe0: case 0xffe1: case 0xffe2: case 0xffe3: case 0xffe4: case 0xffe5: case 0xffe6: case 0xffe7: case 0xffe8: case 0xffe9: case 0xffea: case 0xffeb: case 0xffec: case 0xffed: case 0xffee: case 0xffef: case 0xfffe: const appData = readDataBlock(); if (fileMarker === 0xffe0) { if (appData[0] === 0x4a &amp;&amp; appData[1] === 0x46 &amp;&amp; appData[2] === 0x49 &amp;&amp; appData[3] === 0x46 &amp;&amp; appData[4] === 0) { jfif = { version: { major: appData[5], minor: appData[6] }, densityUnits: appData[7], xDensity: appData[8] &lt;&lt; 8 | appData[9], yDensity: appData[10] &lt;&lt; 8 | appData[11], thumbWidth: appData[12], thumbHeight: appData[13], thumbData: appData.subarray(14, 14 + 3 * appData[12] * appData[13]) }; } } if (fileMarker === 0xffee) { if (appData[0] === 0x41 &amp;&amp; appData[1] === 0x64 &amp;&amp; appData[2] === 0x6f &amp;&amp; appData[3] === 0x62 &amp;&amp; appData[4] === 0x65) { adobe = { version: appData[5] &lt;&lt; 8 | appData[6], flags0: appData[7] &lt;&lt; 8 | appData[8], flags1: appData[9] &lt;&lt; 8 | appData[10], transformCode: appData[11] }; } } break; case 0xffdb: const quantizationTablesLength = (0, _core_utils.readUint16)(data, offset); offset += 2; const quantizationTablesEnd = quantizationTablesLength + offset - 2; let z; while (offset &lt; quantizationTablesEnd) { const quantizationTableSpec = data[offset++]; const tableData = new Uint16Array(64); if (quantizationTableSpec &gt;&gt; 4 === 0) { for (j = 0; j &lt; 64; j++) { z = dctZigZag[j]; tableData[z] = data[offset++]; } } else if (quantizationTableSpec &gt;&gt; 4 === 1) { for (j = 0; j &lt; 64; j++) { z = dctZigZag[j]; tableData[z] = (0, _core_utils.readUint16)(data, offset); offset += 2; } } else { throw new JpegError(&quot;DQT - invalid table spec&quot;); } quantizationTables[quantizationTableSpec &amp; 15] = tableData; } break; case 0xffc0: case 0xffc1: case 0xffc2: if (frame) { throw new JpegError(&quot;Only single frame JPEGs supported&quot;); } offset += 2; frame = {}; frame.extended = fileMarker === 0xffc1; frame.progressive = fileMarker === 0xffc2; frame.precision = data[offset++]; const sofScanLines = (0, _core_utils.readUint16)(data, offset); offset += 2; frame.scanLines = dnlScanLines || sofScanLines; frame.samplesPerLine = (0, _core_utils.readUint16)(data, offset); offset += 2; frame.components = []; frame.componentIds = {}; const componentsCount = data[offset++]; let maxH = 0, maxV = 0; for (i = 0; i &lt; componentsCount; i++) { const componentId = data[offset]; const h = data[offset + 1] &gt;&gt; 4; const v = data[offset + 1] &amp; 15; if (maxH &lt; h) { maxH = h; } if (maxV &lt; v) { maxV = v; } const qId = data[offset + 2]; l = frame.components.push({ h, v, quantizationId: qId, quantizationTable: null }); frame.componentIds[componentId] = l - 1; offset += 3; } frame.maxH = maxH; frame.maxV = maxV; prepareComponents(frame); break; case 0xffc4: const huffmanLength = (0, _core_utils.readUint16)(data, offset); offset += 2; for (i = 2; i &lt; huffmanLength;) { const huffmanTableSpec = data[offset++]; const codeLengths = new Uint8Array(16); let codeLengthSum = 0; for (j = 0; j &lt; 16; j++, offset++) { codeLengthSum += codeLengths[j] = data[offset]; } const huffmanValues = new Uint8Array(codeLengthSum); for (j = 0; j &lt; codeLengthSum; j++, offset++) { huffmanValues[j] = data[offset]; } i += 17 + codeLengthSum; (huffmanTableSpec &gt;&gt; 4 === 0 ? huffmanTablesDC : huffmanTablesAC)[huffmanTableSpec &amp; 15] = buildHuffmanTable(codeLengths, huffmanValues); } break; case 0xffdd: offset += 2; resetInterval = (0, _core_utils.readUint16)(data, offset); offset += 2; break; case 0xffda: const parseDNLMarker = ++numSOSMarkers === 1 &amp;&amp; !dnlScanLines; offset += 2; const selectorsCount = data[offset++], components = []; for (i = 0; i &lt; selectorsCount; i++) { const index = data[offset++]; const componentIndex = frame.componentIds[index]; const component = frame.components[componentIndex]; component.index = index; const tableSpec = data[offset++]; component.huffmanTableDC = huffmanTablesDC[tableSpec &gt;&gt; 4]; component.huffmanTableAC = huffmanTablesAC[tableSpec &amp; 15]; components.push(component); } const spectralStart = data[offset++], spectralEnd = data[offset++], successiveApproximation = data[offset++]; try { const processed = decodeScan(data, offset, frame, components, resetInterval, spectralStart, spectralEnd, successiveApproximation &gt;&gt; 4, successiveApproximation &amp; 15, parseDNLMarker); offset += processed; } catch (ex) { if (ex instanceof DNLMarkerError) { (0, _util.warn)(`${ex.message} -- attempting to re-parse the JPEG image.`); return this.parse(data, { dnlScanLines: ex.scanLines }); } else if (ex instanceof EOIMarkerError) { (0, _util.warn)(`${ex.message} -- ignoring the rest of the image data.`); break markerLoop; } throw ex; } break; case 0xffdc: offset += 4; break; case 0xffff: if (data[offset] !== 0xff) { offset--; } break; default: const nextFileMarker = findNextFileMarker(data, offset - 2, offset - 3); if (nextFileMarker &amp;&amp; nextFileMarker.invalid) { (0, _util.warn)(&quot;JpegImage.parse - unexpected data, current marker is: &quot; + nextFileMarker.invalid); offset = nextFileMarker.offset; break; } if (!nextFileMarker || offset &gt;= data.length - 1) { (0, _util.warn)(&quot;JpegImage.parse - reached the end of the image data &quot; + &quot;without finding an EOI marker (0xFFD9).&quot;); break markerLoop; } throw new JpegError(&quot;JpegImage.parse - unknown marker: &quot; + fileMarker.toString(16)); } fileMarker = (0, _core_utils.readUint16)(data, offset); offset += 2; } this.width = frame.samplesPerLine; this.height = frame.scanLines; this.jfif = jfif; this.adobe = adobe; this.components = []; for (const component of frame.components) { const quantizationTable = quantizationTables[component.quantizationId]; if (quantizationTable) { component.quantizationTable = quantizationTable; } this.components.push({ index: component.index, output: buildComponentData(frame, component), scaleX: component.h / frame.maxH, scaleY: component.v / frame.maxV, blocksPerLine: component.blocksPerLine, blocksPerColumn: component.blocksPerColumn }); } this.numComponents = this.components.length; return undefined; } _getLinearizedBlockData(width, height, isSourcePDF = false) { const scaleX = this.width / width, scaleY = this.height / height; let component, componentScaleX, componentScaleY, blocksPerScanline; let x, y, i, j, k; let index; let offset = 0; let output; const numComponents = this.components.length; const dataLength = width * height * numComponents; const data = new Uint8ClampedArray(dataLength); const xScaleBlockOffset = new Uint32Array(width); const mask3LSB = 0xfffffff8; let lastComponentScaleX; for (i = 0; i &lt; numComponents; i++) { component = this.components[i]; componentScaleX = component.scaleX * scaleX; componentScaleY = component.scaleY * scaleY; offset = i; output = component.output; blocksPerScanline = component.blocksPerLine + 1 &lt;&lt; 3; if (componentScaleX !== lastComponentScaleX) { for (x = 0; x &lt; width; x++) { j = 0 | x * componentScaleX; xScaleBlockOffset[x] = (j &amp; mask3LSB) &lt;&lt; 3 | j &amp; 7; } lastComponentScaleX = componentScaleX; } for (y = 0; y &lt; height; y++) { j = 0 | y * componentScaleY; index = blocksPerScanline * (j &amp; mask3LSB) | (j &amp; 7) &lt;&lt; 3; for (x = 0; x &lt; width; x++) { data[offset] = output[index + xScaleBlockOffset[x]]; offset += numComponents; } } } let transform = this._decodeTransform; if (!isSourcePDF &amp;&amp; numComponents === 4 &amp;&amp; !transform) { transform = new Int32Array([-256, 255, -256, 255, -256, 255, -256, 255]); } if (transform) { for (i = 0; i &lt; dataLength;) { for (j = 0, k = 0; j &lt; numComponents; j++, i++, k += 2) { data[i] = (data[i] * transform[k] &gt;&gt; 8) + transform[k + 1]; } } } return data; } get _isColorConversionNeeded() { if (this.adobe) { return !!this.adobe.transformCode; } if (this.numComponents === 3) { if (this._colorTransform === 0) { return false; } else if (this.components[0].index === 0x52 &amp;&amp; this.components[1].index === 0x47 &amp;&amp; this.components[2].index === 0x42) { return false; } return true; } if (this._colorTransform === 1) { return true; } return false; } _convertYccToRgb(data) { let Y, Cb, Cr; for (let i = 0, length = data.length; i &lt; length; i += 3) { Y = data[i]; Cb = data[i + 1]; Cr = data[i + 2]; data[i] = Y - 179.456 + 1.402 * Cr; data[i + 1] = Y + 135.459 - 0.344 * Cb - 0.714 * Cr; data[i + 2] = Y - 226.816 + 1.772 * Cb; } return data; } _convertYcckToRgb(data) { let Y, Cb, Cr, k; let offset = 0; for (let i = 0, length = data.length; i &lt; length; i += 4) { Y = data[i]; Cb = data[i + 1]; Cr = data[i + 2]; k = data[i + 3]; data[offset++] = -122.67195406894 + Cb * (-6.60635669420364e-5 * Cb + 0.000437130475926232 * Cr - 5.4080610064599e-5 * Y + 0.00048449797120281 * k - 0.154362151871126) + Cr * (-0.000957964378445773 * Cr + 0.000817076911346625 * Y - 0.00477271405408747 * k + 1.53380253221734) + Y * (0.000961250184130688 * Y - 0.00266257332283933 * k + 0.48357088451265) + k * (-0.000336197177618394 * k + 0.484791561490776); data[offset++] = 107.268039397724 + Cb * (2.19927104525741e-5 * Cb - 0.000640992018297945 * Cr + 0.000659397001245577 * Y + 0.000426105652938837 * k - 0.176491792462875) + Cr * (-0.000778269941513683 * Cr + 0.00130872261408275 * Y + 0.000770482631801132 * k - 0.151051492775562) + Y * (0.00126935368114843 * Y - 0.00265090189010898 * k + 0.25802910206845) + k * (-0.000318913117588328 * k - 0.213742400323665); data[offset++] = -20.810012546947 + Cb * (-0.000570115196973677 * Cb - 2.63409051004589e-5 * Cr + 0.0020741088115012 * Y - 0.00288260236853442 * k + 0.814272968359295) + Cr * (-1.53496057440975e-5 * Cr - 0.000132689043961446 * Y + 0.000560833691242812 * k - 0.195152027534049) + Y * (0.00174418132927582 * Y - 0.00255243321439347 * k + 0.116935020465145) + k * (-0.000343531996510555 * k + 0.24165260232407); } return data.subarray(0, offset); } _convertYcckToCmyk(data) { let Y, Cb, Cr; for (let i = 0, length = data.length; i &lt; length; i += 4) { Y = data[i]; Cb = data[i + 1]; Cr = data[i + 2]; data[i] = 434.456 - Y - 1.402 * Cr; data[i + 1] = 119.541 - Y + 0.344 * Cb + 0.714 * Cr; data[i + 2] = 481.816 - Y - 1.772 * Cb; } return data; } _convertCmykToRgb(data) { let c, m, y, k; let offset = 0; for (let i = 0, length = data.length; i &lt; length; i += 4) { c = data[i]; m = data[i + 1]; y = data[i + 2]; k = data[i + 3]; data[offset++] = 255 + c * (-0.00006747147073602441 * c + 0.0008379262121013727 * m + 0.0002894718188643294 * y + 0.003264231057537806 * k - 1.1185611867203937) + m * (0.000026374107616089405 * m - 0.00008626949158638572 * y - 0.0002748769067499491 * k - 0.02155688794978967) + y * (-0.00003878099212869363 * y - 0.0003267808279485286 * k + 0.0686742238595345) - k * (0.0003361971776183937 * k + 0.7430659151342254); data[offset++] = 255 + c * (0.00013596372813588848 * c + 0.000924537132573585 * m + 0.00010567359618683593 * y + 0.0004791864687436512 * k - 0.3109689587515875) + m * (-0.00023545346108370344 * m + 0.0002702845253534714 * y + 0.0020200308977307156 * k - 0.7488052167015494) + y * (0.00006834815998235662 * y + 0.00015168452363460973 * k - 0.09751927774728933) - k * (0.0003189131175883281 * k + 0.7364883807733168); data[offset++] = 255 + c * (0.000013598650411385307 * c + 0.00012423956175490851 * m + 0.0004751985097583589 * y - 0.0000036729317476630422 * k - 0.05562186980264034) + m * (0.00016141380598724676 * m + 0.0009692239130725186 * y + 0.0007782692450036253 * k - 0.44015232367526463) + y * (5.068882914068769e-7 * y + 0.0017778369011375071 * k - 0.7591454649749609) - k * (0.0003435319965105553 * k + 0.7063770186160144); } return data.subarray(0, offset); } getData({ width, height, forceRGB = false, isSourcePDF = false }) { if (this.numComponents &gt; 4) { throw new JpegError(&quot;Unsupported color mode&quot;); } const data = this._getLinearizedBlockData(width, height, isSourcePDF); if (this.numComponents === 1 &amp;&amp; forceRGB) { const rgbData = new Uint8ClampedArray(data.length * 3); let offset = 0; for (const grayColor of data) { rgbData[offset++] = grayColor; rgbData[offset++] = grayColor; rgbData[offset++] = grayColor; } return rgbData; } else if (this.numComponents === 3 &amp;&amp; this._isColorConversionNeeded) { return this._convertYccToRgb(data); } else if (this.numComponents === 4) { if (this._isColorConversionNeeded) { if (forceRGB) { return this._convertYcckToRgb(data); } return this._convertYcckToCmyk(data); } else if (forceRGB) { return this._convertCmykToRgb(data); } } return data; } } exports.JpegImage = JpegImage; /***/ }), /* 27 */ /***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) =&gt; { Object.defineProperty(exports, &quot;__esModule&quot;, ({ value: true })); exports.JpxStream = void 0; var _decode_stream = __w_pdfjs_require__(17); var _jpx = __w_pdfjs_require__(28); var _util = __w_pdfjs_require__(2); class JpxStream extends _decode_stream.DecodeStream { constructor(stream, maybeLength, params) { super(maybeLength); this.stream = stream; this.dict = stream.dict; this.maybeLength = maybeLength; this.params = params; } get bytes() { return (0, _util.shadow)(this, &quot;bytes&quot;, this.stream.getBytes(this.maybeLength)); } ensureBuffer(requested) {} readBlock() { if (this.eof) { return; } const jpxImage = new _jpx.JpxImage(); jpxImage.parse(this.bytes); const width = jpxImage.width; const height = jpxImage.height; const componentsCount = jpxImage.componentsCount; const tileCount = jpxImage.tiles.length; if (tileCount === 1) { this.buffer = jpxImage.tiles[0].items; } else { const data = new Uint8ClampedArray(width * height * componentsCount); for (let k = 0; k &lt; tileCount; k++) { const tileComponents = jpxImage.tiles[k]; const tileWidth = tileComponents.width; const tileHeight = tileComponents.height; const tileLeft = tileComponents.left; const tileTop = tileComponents.top; const src = tileComponents.items; let srcPosition = 0; let dataPosition = (width * tileTop + tileLeft) * componentsCount; const imgRowSize = width * componentsCount; const tileRowSize = tileWidth * componentsCount; for (let j = 0; j &lt; tileHeight; j++) { const rowBytes = src.subarray(srcPosition, srcPosition + tileRowSize); data.set(rowBytes, dataPosition); srcPosition += tileRowSize; dataPosition += imgRowSize; } } this.buffer = data; } this.bufferLength = this.buffer.length; this.eof = true; } } exports.JpxStream = JpxStream; /***/ }), /* 28 */ /***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) =&gt; { Object.defineProperty(exports, &quot;__esModule&quot;, ({ value: true })); exports.JpxImage = void 0; var _util = __w_pdfjs_require__(2); var _core_utils = __w_pdfjs_require__(4); var _arithmetic_decoder = __w_pdfjs_require__(24); class JpxError extends _util.BaseException { constructor(msg) { super(`JPX error: ${msg}`, &quot;JpxError&quot;); } } const SubbandsGainLog2 = { LL: 0, LH: 1, HL: 1, HH: 2 }; class JpxImage { constructor() { this.failOnCorruptedImage = false; } parse(data) { const head = (0, _core_utils.readUint16)(data, 0); if (head === 0xff4f) { this.parseCodestream(data, 0, data.length); return; } const length = data.length; let position = 0; while (position &lt; length) { let headerSize = 8; let lbox = (0, _core_utils.readUint32)(data, position); const tbox = (0, _core_utils.readUint32)(data, position + 4); position += headerSize; if (lbox === 1) { lbox = (0, _core_utils.readUint32)(data, position) * 4294967296 + (0, _core_utils.readUint32)(data, position + 4); position += 8; headerSize += 8; } if (lbox === 0) { lbox = length - position + headerSize; } if (lbox &lt; headerSize) { throw new JpxError(&quot;Invalid box field size&quot;); } const dataLength = lbox - headerSize; let jumpDataLength = true; switch (tbox) { case 0x6a703268: jumpDataLength = false; break; case 0x636f6c72: const method = data[position]; if (method === 1) { const colorspace = (0, _core_utils.readUint32)(data, position + 3); switch (colorspace) { case 16: case 17: case 18: break; default: (0, _util.warn)(&quot;Unknown colorspace &quot; + colorspace); break; } } else if (method === 2) { (0, _util.info)(&quot;ICC profile not supported&quot;); } break; case 0x6a703263: this.parseCodestream(data, position, position + dataLength); break; case 0x6a502020: if ((0, _core_utils.readUint32)(data, position) !== 0x0d0a870a) { (0, _util.warn)(&quot;Invalid JP2 signature&quot;); } break; case 0x6a501a1a: case 0x66747970: case 0x72726571: case 0x72657320: case 0x69686472: break; default: const headerType = String.fromCharCode(tbox &gt;&gt; 24 &amp; 0xff, tbox &gt;&gt; 16 &amp; 0xff, tbox &gt;&gt; 8 &amp; 0xff, tbox &amp; 0xff); (0, _util.warn)(`Unsupported header type ${tbox} (${headerType}).`); break; } if (jumpDataLength) { position += dataLength; } } } parseImageProperties(stream) { let newByte = stream.getByte(); while (newByte &gt;= 0) { const oldByte = newByte; newByte = stream.getByte(); const code = oldByte &lt;&lt; 8 | newByte; if (code === 0xff51) { stream.skip(4); const Xsiz = stream.getInt32() &gt;&gt;&gt; 0; const Ysiz = stream.getInt32() &gt;&gt;&gt; 0; const XOsiz = stream.getInt32() &gt;&gt;&gt; 0; const YOsiz = stream.getInt32() &gt;&gt;&gt; 0; stream.skip(16); const Csiz = stream.getUint16(); this.width = Xsiz - XOsiz; this.height = Ysiz - YOsiz; this.componentsCount = Csiz; this.bitsPerComponent = 8; return; } } throw new JpxError(&quot;No size marker found in JPX stream&quot;); } parseCodestream(data, start, end) { const context = {}; let doNotRecover = false; try { let position = start; while (position + 1 &lt; end) { const code = (0, _core_utils.readUint16)(data, position); position += 2; let length = 0, j, sqcd, spqcds, spqcdSize, scalarExpounded, tile; switch (code) { case 0xff4f: context.mainHeader = true; break; case 0xffd9: break; case 0xff51: length = (0, _core_utils.readUint16)(data, position); const siz = {}; siz.Xsiz = (0, _core_utils.readUint32)(data, position + 4); siz.Ysiz = (0, _core_utils.readUint32)(data, position + 8); siz.XOsiz = (0, _core_utils.readUint32)(data, position + 12); siz.YOsiz = (0, _core_utils.readUint32)(data, position + 16); siz.XTsiz = (0, _core_utils.readUint32)(data, position + 20); siz.YTsiz = (0, _core_utils.readUint32)(data, position + 24); siz.XTOsiz = (0, _core_utils.readUint32)(data, position + 28); siz.YTOsiz = (0, _core_utils.readUint32)(data, position + 32); const componentsCount = (0, _core_utils.readUint16)(data, position + 36); siz.Csiz = componentsCount; const components = []; j = position + 38; for (let i = 0; i &lt; componentsCount; i++) { const component = { precision: (data[j] &amp; 0x7f) + 1, isSigned: !!(data[j] &amp; 0x80), XRsiz: data[j + 1], YRsiz: data[j + 2] }; j += 3; calculateComponentDimensions(component, siz); components.push(component); } context.SIZ = siz; context.components = components; calculateTileGrids(context, components); context.QCC = []; context.COC = []; break; case 0xff5c: length = (0, _core_utils.readUint16)(data, position); const qcd = {}; j = position + 2; sqcd = data[j++]; switch (sqcd &amp; 0x1f) { case 0: spqcdSize = 8; scalarExpounded = true; break; case 1: spqcdSize = 16; scalarExpounded = false; break; case 2: spqcdSize = 16; scalarExpounded = true; break; default: throw new Error(&quot;Invalid SQcd value &quot; + sqcd); } qcd.noQuantization = spqcdSize === 8; qcd.scalarExpounded = scalarExpounded; qcd.guardBits = sqcd &gt;&gt; 5; spqcds = []; while (j &lt; length + position) { const spqcd = {}; if (spqcdSize === 8) { spqcd.epsilon = data[j++] &gt;&gt; 3; spqcd.mu = 0; } else { spqcd.epsilon = data[j] &gt;&gt; 3; spqcd.mu = (data[j] &amp; 0x7) &lt;&lt; 8 | data[j + 1]; j += 2; } spqcds.push(spqcd); } qcd.SPqcds = spqcds; if (context.mainHeader) { context.QCD = qcd; } else { context.currentTile.QCD = qcd; context.currentTile.QCC = []; } break; case 0xff5d: length = (0, _core_utils.readUint16)(data, position); const qcc = {}; j = position + 2; let cqcc; if (context.SIZ.Csiz &lt; 257) { cqcc = data[j++]; } else { cqcc = (0, _core_utils.readUint16)(data, j); j += 2; } sqcd = data[j++]; switch (sqcd &amp; 0x1f) { case 0: spqcdSize = 8; scalarExpounded = true; break; case 1: spqcdSize = 16; scalarExpounded = false; break; case 2: spqcdSize = 16; scalarExpounded = true; break; default: throw new Error(&quot;Invalid SQcd value &quot; + sqcd); } qcc.noQuantization = spqcdSize === 8; qcc.scalarExpounded = scalarExpounded; qcc.guardBits = sqcd &gt;&gt; 5; spqcds = []; while (j &lt; length + position) { const spqcd = {}; if (spqcdSize === 8) { spqcd.epsilon = data[j++] &gt;&gt; 3; spqcd.mu = 0; } else { spqcd.epsilon = data[j] &gt;&gt; 3; spqcd.mu = (data[j] &amp; 0x7) &lt;&lt; 8 | data[j + 1]; j += 2; } spqcds.push(spqcd); } qcc.SPqcds = spqcds; if (context.mainHeader) { context.QCC[cqcc] = qcc; } else { context.currentTile.QCC[cqcc] = qcc; } break; case 0xff52: length = (0, _core_utils.readUint16)(data, position); const cod = {}; j = position + 2; const scod = data[j++]; cod.entropyCoderWithCustomPrecincts = !!(scod &amp; 1); cod.sopMarkerUsed = !!(scod &amp; 2); cod.ephMarkerUsed = !!(scod &amp; 4); cod.progressionOrder = data[j++]; cod.layersCount = (0, _core_utils.readUint16)(data, j); j += 2; cod.multipleComponentTransform = data[j++]; cod.decompositionLevelsCount = data[j++]; cod.xcb = (data[j++] &amp; 0xf) + 2; cod.ycb = (data[j++] &amp; 0xf) + 2; const blockStyle = data[j++]; cod.selectiveArithmeticCodingBypass = !!(blockStyle &amp; 1); cod.resetContextProbabilities = !!(blockStyle &amp; 2); cod.terminationOnEachCodingPass = !!(blockStyle &amp; 4); cod.verticallyStripe = !!(blockStyle &amp; 8); cod.predictableTermination = !!(blockStyle &amp; 16); cod.segmentationSymbolUsed = !!(blockStyle &amp; 32); cod.reversibleTransformation = data[j++]; if (cod.entropyCoderWithCustomPrecincts) { const precinctsSizes = []; while (j &lt; length + position) { const precinctsSize = data[j++]; precinctsSizes.push({ PPx: precinctsSize &amp; 0xf, PPy: precinctsSize &gt;&gt; 4 }); } cod.precinctsSizes = precinctsSizes; } const unsupported = []; if (cod.selectiveArithmeticCodingBypass) { unsupported.push(&quot;selectiveArithmeticCodingBypass&quot;); } if (cod.terminationOnEachCodingPass) { unsupported.push(&quot;terminationOnEachCodingPass&quot;); } if (cod.verticallyStripe) { unsupported.push(&quot;verticallyStripe&quot;); } if (cod.predictableTermination) { unsupported.push(&quot;predictableTermination&quot;); } if (unsupported.length &gt; 0) { doNotRecover = true; (0, _util.warn)(`JPX: Unsupported COD options (${unsupported.join(&quot;, &quot;)}).`); } if (context.mainHeader) { context.COD = cod; } else { context.currentTile.COD = cod; context.currentTile.COC = []; } break; case 0xff90: length = (0, _core_utils.readUint16)(data, position); tile = {}; tile.index = (0, _core_utils.readUint16)(data, position + 2); tile.length = (0, _core_utils.readUint32)(data, position + 4); tile.dataEnd = tile.length + position - 2; tile.partIndex = data[position + 8]; tile.partsCount = data[position + 9]; context.mainHeader = false; if (tile.partIndex === 0) { tile.COD = context.COD; tile.COC = context.COC.slice(0); tile.QCD = context.QCD; tile.QCC = context.QCC.slice(0); } context.currentTile = tile; break; case 0xff93: tile = context.currentTile; if (tile.partIndex === 0) { initializeTile(context, tile.index); buildPackets(context); } length = tile.dataEnd - position; parseTilePackets(context, data, position, length); break; case 0xff53: (0, _util.warn)(&quot;JPX: Codestream code 0xFF53 (COC) is not implemented.&quot;); case 0xff55: case 0xff57: case 0xff58: case 0xff64: length = (0, _core_utils.readUint16)(data, position); break; default: throw new Error(&quot;Unknown codestream code: &quot; + code.toString(16)); } position += length; } } catch (e) { if (doNotRecover || this.failOnCorruptedImage) { throw new JpxError(e.message); } else { (0, _util.warn)(`JPX: Trying to recover from: &quot;${e.message}&quot;.`); } } this.tiles = transformComponents(context); this.width = context.SIZ.Xsiz - context.SIZ.XOsiz; this.height = context.SIZ.Ysiz - context.SIZ.YOsiz; this.componentsCount = context.SIZ.Csiz; } } exports.JpxImage = JpxImage; function calculateComponentDimensions(component, siz) { component.x0 = Math.ceil(siz.XOsiz / component.XRsiz); component.x1 = Math.ceil(siz.Xsiz / component.XRsiz); component.y0 = Math.ceil(siz.YOsiz / component.YRsiz); component.y1 = Math.ceil(siz.Ysiz / component.YRsiz); component.width = component.x1 - component.x0; component.height = component.y1 - component.y0; } function calculateTileGrids(context, components) { const siz = context.SIZ; const tiles = []; let tile; const numXtiles = Math.ceil((siz.Xsiz - siz.XTOsiz) / siz.XTsiz); const numYtiles = Math.ceil((siz.Ysiz - siz.YTOsiz) / siz.YTsiz); for (let q = 0; q &lt; numYtiles; q++) { for (let p = 0; p &lt; numXtiles; p++) { tile = {}; tile.tx0 = Math.max(siz.XTOsiz + p * siz.XTsiz, siz.XOsiz); tile.ty0 = Math.max(siz.YTOsiz + q * siz.YTsiz, siz.YOsiz); tile.tx1 = Math.min(siz.XTOsiz + (p + 1) * siz.XTsiz, siz.Xsiz); tile.ty1 = Math.min(siz.YTOsiz + (q + 1) * siz.YTsiz, siz.Ysiz); tile.width = tile.tx1 - tile.tx0; tile.height = tile.ty1 - tile.ty0; tile.components = []; tiles.push(tile); } } context.tiles = tiles; const componentsCount = siz.Csiz; for (let i = 0, ii = componentsCount; i &lt; ii; i++) { const component = components[i]; for (let j = 0, jj = tiles.length; j &lt; jj; j++) { const tileComponent = {}; tile = tiles[j]; tileComponent.tcx0 = Math.ceil(tile.tx0 / component.XRsiz); tileComponent.tcy0 = Math.ceil(tile.ty0 / component.YRsiz); tileComponent.tcx1 = Math.ceil(tile.tx1 / component.XRsiz); tileComponent.tcy1 = Math.ceil(tile.ty1 / component.YRsiz); tileComponent.width = tileComponent.tcx1 - tileComponent.tcx0; tileComponent.height = tileComponent.tcy1 - tileComponent.tcy0; tile.components[i] = tileComponent; } } } function getBlocksDimensions(context, component, r) { const codOrCoc = component.codingStyleParameters; const result = {}; if (!codOrCoc.entropyCoderWithCustomPrecincts) { result.PPx = 15; result.PPy = 15; } else { result.PPx = codOrCoc.precinctsSizes[r].PPx; result.PPy = codOrCoc.precinctsSizes[r].PPy; } result.xcb_ = r &gt; 0 ? Math.min(codOrCoc.xcb, result.PPx - 1) : Math.min(codOrCoc.xcb, result.PPx); result.ycb_ = r &gt; 0 ? Math.min(codOrCoc.ycb, result.PPy - 1) : Math.min(codOrCoc.ycb, result.PPy); return result; } function buildPrecincts(context, resolution, dimensions) { const precinctWidth = 1 &lt;&lt; dimensions.PPx; const precinctHeight = 1 &lt;&lt; dimensions.PPy; const isZeroRes = resolution.resLevel === 0; const precinctWidthInSubband = 1 &lt;&lt; dimensions.PPx + (isZeroRes ? 0 : -1); const precinctHeightInSubband = 1 &lt;&lt; dimensions.PPy + (isZeroRes ? 0 : -1); const numprecinctswide = resolution.trx1 &gt; resolution.trx0 ? Math.ceil(resolution.trx1 / precinctWidth) - Math.floor(resolution.trx0 / precinctWidth) : 0; const numprecinctshigh = resolution.try1 &gt; resolution.try0 ? Math.ceil(resolution.try1 / precinctHeight) - Math.floor(resolution.try0 / precinctHeight) : 0; const numprecincts = numprecinctswide * numprecinctshigh; resolution.precinctParameters = { precinctWidth, precinctHeight, numprecinctswide, numprecinctshigh, numprecincts, precinctWidthInSubband, precinctHeightInSubband }; } function buildCodeblocks(context, subband, dimensions) { const xcb_ = dimensions.xcb_; const ycb_ = dimensions.ycb_; const codeblockWidth = 1 &lt;&lt; xcb_; const codeblockHeight = 1 &lt;&lt; ycb_; const cbx0 = subband.tbx0 &gt;&gt; xcb_; const cby0 = subband.tby0 &gt;&gt; ycb_; const cbx1 = subband.tbx1 + codeblockWidth - 1 &gt;&gt; xcb_; const cby1 = subband.tby1 + codeblockHeight - 1 &gt;&gt; ycb_; const precinctParameters = subband.resolution.precinctParameters; const codeblocks = []; const precincts = []; let i, j, codeblock, precinctNumber; for (j = cby0; j &lt; cby1; j++) { for (i = cbx0; i &lt; cbx1; i++) { codeblock = { cbx: i, cby: j, tbx0: codeblockWidth * i, tby0: codeblockHeight * j, tbx1: codeblockWidth * (i + 1), tby1: codeblockHeight * (j + 1) }; codeblock.tbx0_ = Math.max(subband.tbx0, codeblock.tbx0); codeblock.tby0_ = Math.max(subband.tby0, codeblock.tby0); codeblock.tbx1_ = Math.min(subband.tbx1, codeblock.tbx1); codeblock.tby1_ = Math.min(subband.tby1, codeblock.tby1); const pi = Math.floor((codeblock.tbx0_ - subband.tbx0) / precinctParameters.precinctWidthInSubband); const pj = Math.floor((codeblock.tby0_ - subband.tby0) / precinctParameters.precinctHeightInSubband); precinctNumber = pi + pj * precinctParameters.numprecinctswide; codeblock.precinctNumber = precinctNumber; codeblock.subbandType = subband.type; codeblock.Lblock = 3; if (codeblock.tbx1_ &lt;= codeblock.tbx0_ || codeblock.tby1_ &lt;= codeblock.tby0_) { continue; } codeblocks.push(codeblock); let precinct = precincts[precinctNumber]; if (precinct !== undefined) { if (i &lt; precinct.cbxMin) { precinct.cbxMin = i; } else if (i &gt; precinct.cbxMax) { precinct.cbxMax = i; } if (j &lt; precinct.cbyMin) { precinct.cbxMin = j; } else if (j &gt; precinct.cbyMax) { precinct.cbyMax = j; } } else { precincts[precinctNumber] = precinct = { cbxMin: i, cbyMin: j, cbxMax: i, cbyMax: j }; } codeblock.precinct = precinct; } } subband.codeblockParameters = { codeblockWidth: xcb_, codeblockHeight: ycb_, numcodeblockwide: cbx1 - cbx0 + 1, numcodeblockhigh: cby1 - cby0 + 1 }; subband.codeblocks = codeblocks; subband.precincts = precincts; } function createPacket(resolution, precinctNumber, layerNumber) { const precinctCodeblocks = []; const subbands = resolution.subbands; for (let i = 0, ii = subbands.length; i &lt; ii; i++) { const subband = subbands[i]; const codeblocks = subband.codeblocks; for (let j = 0, jj = codeblocks.length; j &lt; jj; j++) { const codeblock = codeblocks[j]; if (codeblock.precinctNumber !== precinctNumber) { continue; } precinctCodeblocks.push(codeblock); } } return { layerNumber, codeblocks: precinctCodeblocks }; } function LayerResolutionComponentPositionIterator(context) { const siz = context.SIZ; const tileIndex = context.currentTile.index; const tile = context.tiles[tileIndex]; const layersCount = tile.codingStyleDefaultParameters.layersCount; const componentsCount = siz.Csiz; let maxDecompositionLevelsCount = 0; for (let q = 0; q &lt; componentsCount; q++) { maxDecompositionLevelsCount = Math.max(maxDecompositionLevelsCount, tile.components[q].codingStyleParameters.decompositionLevelsCount); } let l = 0, r = 0, i = 0, k = 0; this.nextPacket = function JpxImage_nextPacket() { for (; l &lt; layersCount; l++) { for (; r &lt;= maxDecompositionLevelsCount; r++) { for (; i &lt; componentsCount; i++) { const component = tile.components[i]; if (r &gt; component.codingStyleParameters.decompositionLevelsCount) { continue; } const resolution = component.resolutions[r]; const numprecincts = resolution.precinctParameters.numprecincts; for (; k &lt; numprecincts;) { const packet = createPacket(resolution, k, l); k++; return packet; } k = 0; } i = 0; } r = 0; } throw new JpxError(&quot;Out of packets&quot;); }; } function ResolutionLayerComponentPositionIterator(context) { const siz = context.SIZ; const tileIndex = context.currentTile.index; const tile = context.tiles[tileIndex]; const layersCount = tile.codingStyleDefaultParameters.layersCount; const componentsCount = siz.Csiz; let maxDecompositionLevelsCount = 0; for (let q = 0; q &lt; componentsCount; q++) { maxDecompositionLevelsCount = Math.max(maxDecompositionLevelsCount, tile.components[q].codingStyleParameters.decompositionLevelsCount); } let r = 0, l = 0, i = 0, k = 0; this.nextPacket = function JpxImage_nextPacket() { for (; r &lt;= maxDecompositionLevelsCount; r++) { for (; l &lt; layersCount; l++) { for (; i &lt; componentsCount; i++) { const component = tile.components[i]; if (r &gt; component.codingStyleParameters.decompositionLevelsCount) { continue; } const resolution = component.resolutions[r]; const numprecincts = resolution.precinctParameters.numprecincts; for (; k &lt; numprecincts;) { const packet = createPacket(resolution, k, l); k++; return packet; } k = 0; } i = 0; } l = 0; } throw new JpxError(&quot;Out of packets&quot;); }; } function ResolutionPositionComponentLayerIterator(context) { const siz = context.SIZ; const tileIndex = context.currentTile.index; const tile = context.tiles[tileIndex]; const layersCount = tile.codingStyleDefaultParameters.layersCount; const componentsCount = siz.Csiz; let l, r, c, p; let maxDecompositionLevelsCount = 0; for (c = 0; c &lt; componentsCount; c++) { const component = tile.components[c]; maxDecompositionLevelsCount = Math.max(maxDecompositionLevelsCount, component.codingStyleParameters.decompositionLevelsCount); } const maxNumPrecinctsInLevel = new Int32Array(maxDecompositionLevelsCount + 1); for (r = 0; r &lt;= maxDecompositionLevelsCount; ++r) { let maxNumPrecincts = 0; for (c = 0; c &lt; componentsCount; ++c) { const resolutions = tile.components[c].resolutions; if (r &lt; resolutions.length) { maxNumPrecincts = Math.max(maxNumPrecincts, resolutions[r].precinctParameters.numprecincts); } } maxNumPrecinctsInLevel[r] = maxNumPrecincts; } l = 0; r = 0; c = 0; p = 0; this.nextPacket = function JpxImage_nextPacket() { for (; r &lt;= maxDecompositionLevelsCount; r++) { for (; p &lt; maxNumPrecinctsInLevel[r]; p++) { for (; c &lt; componentsCount; c++) { const component = tile.components[c]; if (r &gt; component.codingStyleParameters.decompositionLevelsCount) { continue; } const resolution = component.resolutions[r]; const numprecincts = resolution.precinctParameters.numprecincts; if (p &gt;= numprecincts) { continue; } for (; l &lt; layersCount;) { const packet = createPacket(resolution, p, l); l++; return packet; } l = 0; } c = 0; } p = 0; } throw new JpxError(&quot;Out of packets&quot;); }; } function PositionComponentResolutionLayerIterator(context) { const siz = context.SIZ; const tileIndex = context.currentTile.index; const tile = context.tiles[tileIndex]; const layersCount = tile.codingStyleDefaultParameters.layersCount; const componentsCount = siz.Csiz; const precinctsSizes = getPrecinctSizesInImageScale(tile); const precinctsIterationSizes = precinctsSizes; let l = 0, r = 0, c = 0, px = 0, py = 0; this.nextPacket = function JpxImage_nextPacket() { for (; py &lt; precinctsIterationSizes.maxNumHigh; py++) { for (; px &lt; precinctsIterationSizes.maxNumWide; px++) { for (; c &lt; componentsCount; c++) { const component = tile.components[c]; const decompositionLevelsCount = component.codingStyleParameters.decompositionLevelsCount; for (; r &lt;= decompositionLevelsCount; r++) { const resolution = component.resolutions[r]; const sizeInImageScale = precinctsSizes.components[c].resolutions[r]; const k = getPrecinctIndexIfExist(px, py, sizeInImageScale, precinctsIterationSizes, resolution); if (k === null) { continue; } for (; l &lt; layersCount;) { const packet = createPacket(resolution, k, l); l++; return packet; } l = 0; } r = 0; } c = 0; } px = 0; } throw new JpxError(&quot;Out of packets&quot;); }; } function ComponentPositionResolutionLayerIterator(context) { const siz = context.SIZ; const tileIndex = context.currentTile.index; const tile = context.tiles[tileIndex]; const layersCount = tile.codingStyleDefaultParameters.layersCount; const componentsCount = siz.Csiz; const precinctsSizes = getPrecinctSizesInImageScale(tile); let l = 0, r = 0, c = 0, px = 0, py = 0; this.nextPacket = function JpxImage_nextPacket() { for (; c &lt; componentsCount; ++c) { const component = tile.components[c]; const precinctsIterationSizes = precinctsSizes.components[c]; const decompositionLevelsCount = component.codingStyleParameters.decompositionLevelsCount; for (; py &lt; precinctsIterationSizes.maxNumHigh; py++) { for (; px &lt; precinctsIterationSizes.maxNumWide; px++) { for (; r &lt;= decompositionLevelsCount; r++) { const resolution = component.resolutions[r]; const sizeInImageScale = precinctsIterationSizes.resolutions[r]; const k = getPrecinctIndexIfExist(px, py, sizeInImageScale, precinctsIterationSizes, resolution); if (k === null) { continue; } for (; l &lt; layersCount;) { const packet = createPacket(resolution, k, l); l++; return packet; } l = 0; } r = 0; } px = 0; } py = 0; } throw new JpxError(&quot;Out of packets&quot;); }; } function getPrecinctIndexIfExist(pxIndex, pyIndex, sizeInImageScale, precinctIterationSizes, resolution) { const posX = pxIndex * precinctIterationSizes.minWidth; const posY = pyIndex * precinctIterationSizes.minHeight; if (posX % sizeInImageScale.width !== 0 || posY % sizeInImageScale.height !== 0) { return null; } const startPrecinctRowIndex = posY / sizeInImageScale.width * resolution.precinctParameters.numprecinctswide; return posX / sizeInImageScale.height + startPrecinctRowIndex; } function getPrecinctSizesInImageScale(tile) { const componentsCount = tile.components.length; let minWidth = Number.MAX_VALUE; let minHeight = Number.MAX_VALUE; let maxNumWide = 0; let maxNumHigh = 0; const sizePerComponent = new Array(componentsCount); for (let c = 0; c &lt; componentsCount; c++) { const component = tile.components[c]; const decompositionLevelsCount = component.codingStyleParameters.decompositionLevelsCount; const sizePerResolution = new Array(decompositionLevelsCount + 1); let minWidthCurrentComponent = Number.MAX_VALUE; let minHeightCurrentComponent = Number.MAX_VALUE; let maxNumWideCurrentComponent = 0; let maxNumHighCurrentComponent = 0; let scale = 1; for (let r = decompositionLevelsCount; r &gt;= 0; --r) { const resolution = component.resolutions[r]; const widthCurrentResolution = scale * resolution.precinctParameters.precinctWidth; const heightCurrentResolution = scale * resolution.precinctParameters.precinctHeight; minWidthCurrentComponent = Math.min(minWidthCurrentComponent, widthCurrentResolution); minHeightCurrentComponent = Math.min(minHeightCurrentComponent, heightCurrentResolution); maxNumWideCurrentComponent = Math.max(maxNumWideCurrentComponent, resolution.precinctParameters.numprecinctswide); maxNumHighCurrentComponent = Math.max(maxNumHighCurrentComponent, resolution.precinctParameters.numprecinctshigh); sizePerResolution[r] = { width: widthCurrentResolution, height: heightCurrentResolution }; scale &lt;&lt;= 1; } minWidth = Math.min(minWidth, minWidthCurrentComponent); minHeight = Math.min(minHeight, minHeightCurrentComponent); maxNumWide = Math.max(maxNumWide, maxNumWideCurrentComponent); maxNumHigh = Math.max(maxNumHigh, maxNumHighCurrentComponent); sizePerComponent[c] = { resolutions: sizePerResolution, minWidth: minWidthCurrentComponent, minHeight: minHeightCurrentComponent, maxNumWide: maxNumWideCurrentComponent, maxNumHigh: maxNumHighCurrentComponent }; } return { components: sizePerComponent, minWidth, minHeight, maxNumWide, maxNumHigh }; } function buildPackets(context) { const siz = context.SIZ; const tileIndex = context.currentTile.index; const tile = context.tiles[tileIndex]; const componentsCount = siz.Csiz; for (let c = 0; c &lt; componentsCount; c++) { const component = tile.components[c]; const decompositionLevelsCount = component.codingStyleParameters.decompositionLevelsCount; const resolutions = []; const subbands = []; for (let r = 0; r &lt;= decompositionLevelsCount; r++) { const blocksDimensions = getBlocksDimensions(context, component, r); const resolution = {}; const scale = 1 &lt;&lt; decompositionLevelsCount - r; resolution.trx0 = Math.ceil(component.tcx0 / scale); resolution.try0 = Math.ceil(component.tcy0 / scale); resolution.trx1 = Math.ceil(component.tcx1 / scale); resolution.try1 = Math.ceil(component.tcy1 / scale); resolution.resLevel = r; buildPrecincts(context, resolution, blocksDimensions); resolutions.push(resolution); let subband; if (r === 0) { subband = {}; subband.type = &quot;LL&quot;; subband.tbx0 = Math.ceil(component.tcx0 / scale); subband.tby0 = Math.ceil(component.tcy0 / scale); subband.tbx1 = Math.ceil(component.tcx1 / scale); subband.tby1 = Math.ceil(component.tcy1 / scale); subband.resolution = resolution; buildCodeblocks(context, subband, blocksDimensions); subbands.push(subband); resolution.subbands = [subband]; } else { const bscale = 1 &lt;&lt; decompositionLevelsCount - r + 1; const resolutionSubbands = []; subband = {}; subband.type = &quot;HL&quot;; subband.tbx0 = Math.ceil(component.tcx0 / bscale - 0.5); subband.tby0 = Math.ceil(component.tcy0 / bscale); subband.tbx1 = Math.ceil(component.tcx1 / bscale - 0.5); subband.tby1 = Math.ceil(component.tcy1 / bscale); subband.resolution = resolution; buildCodeblocks(context, subband, blocksDimensions); subbands.push(subband); resolutionSubbands.push(subband); subband = {}; subband.type = &quot;LH&quot;; subband.tbx0 = Math.ceil(component.tcx0 / bscale); subband.tby0 = Math.ceil(component.tcy0 / bscale - 0.5); subband.tbx1 = Math.ceil(component.tcx1 / bscale); subband.tby1 = Math.ceil(component.tcy1 / bscale - 0.5); subband.resolution = resolution; buildCodeblocks(context, subband, blocksDimensions); subbands.push(subband); resolutionSubbands.push(subband); subband = {}; subband.type = &quot;HH&quot;; subband.tbx0 = Math.ceil(component.tcx0 / bscale - 0.5); subband.tby0 = Math.ceil(component.tcy0 / bscale - 0.5); subband.tbx1 = Math.ceil(component.tcx1 / bscale - 0.5); subband.tby1 = Math.ceil(component.tcy1 / bscale - 0.5); subband.resolution = resolution; buildCodeblocks(context, subband, blocksDimensions); subbands.push(subband); resolutionSubbands.push(subband); resolution.subbands = resolutionSubbands; } } component.resolutions = resolutions; component.subbands = subbands; } const progressionOrder = tile.codingStyleDefaultParameters.progressionOrder; switch (progressionOrder) { case 0: tile.packetsIterator = new LayerResolutionComponentPositionIterator(context); break; case 1: tile.packetsIterator = new ResolutionLayerComponentPositionIterator(context); break; case 2: tile.packetsIterator = new ResolutionPositionComponentLayerIterator(context); break; case 3: tile.packetsIterator = new PositionComponentResolutionLayerIterator(context); break; case 4: tile.packetsIterator = new ComponentPositionResolutionLayerIterator(context); break; default: throw new JpxError(`Unsupported progression order ${progressionOrder}`); } } function parseTilePackets(context, data, offset, dataLength) { let position = 0; let buffer, bufferSize = 0, skipNextBit = false; function readBits(count) { while (bufferSize &lt; count) { const b = data[offset + position]; position++; if (skipNextBit) { buffer = buffer &lt;&lt; 7 | b; bufferSize += 7; skipNextBit = false; } else { buffer = buffer &lt;&lt; 8 | b; bufferSize += 8; } if (b === 0xff) { skipNextBit = true; } } bufferSize -= count; return buffer &gt;&gt;&gt; bufferSize &amp; (1 &lt;&lt; count) - 1; } function skipMarkerIfEqual(value) { if (data[offset + position - 1] === 0xff &amp;&amp; data[offset + position] === value) { skipBytes(1); return true; } else if (data[offset + position] === 0xff &amp;&amp; data[offset + position + 1] === value) { skipBytes(2); return true; } return false; } function skipBytes(count) { position += count; } function alignToByte() { bufferSize = 0; if (skipNextBit) { position++; skipNextBit = false; } } function readCodingpasses() { if (readBits(1) === 0) { return 1; } if (readBits(1) === 0) { return 2; } let value = readBits(2); if (value &lt; 3) { return value + 3; } value = readBits(5); if (value &lt; 31) { return value + 6; } value = readBits(7); return value + 37; } const tileIndex = context.currentTile.index; const tile = context.tiles[tileIndex]; const sopMarkerUsed = context.COD.sopMarkerUsed; const ephMarkerUsed = context.COD.ephMarkerUsed; const packetsIterator = tile.packetsIterator; while (position &lt; dataLength) { alignToByte(); if (sopMarkerUsed &amp;&amp; skipMarkerIfEqual(0x91)) { skipBytes(4); } const packet = packetsIterator.nextPacket(); if (!readBits(1)) { continue; } const layerNumber = packet.layerNumber, queue = []; let codeblock; for (let i = 0, ii = packet.codeblocks.length; i &lt; ii; i++) { codeblock = packet.codeblocks[i]; let precinct = codeblock.precinct; const codeblockColumn = codeblock.cbx - precinct.cbxMin; const codeblockRow = codeblock.cby - precinct.cbyMin; let codeblockIncluded = false; let firstTimeInclusion = false; let valueReady, zeroBitPlanesTree; if (codeblock.included !== undefined) { codeblockIncluded = !!readBits(1); } else { precinct = codeblock.precinct; let inclusionTree; if (precinct.inclusionTree !== undefined) { inclusionTree = precinct.inclusionTree; } else { const width = precinct.cbxMax - precinct.cbxMin + 1; const height = precinct.cbyMax - precinct.cbyMin + 1; inclusionTree = new InclusionTree(width, height, layerNumber); zeroBitPlanesTree = new TagTree(width, height); precinct.inclusionTree = inclusionTree; precinct.zeroBitPlanesTree = zeroBitPlanesTree; for (let l = 0; l &lt; layerNumber; l++) { if (readBits(1) !== 0) { throw new JpxError(&quot;Invalid tag tree&quot;); } } } if (inclusionTree.reset(codeblockColumn, codeblockRow, layerNumber)) { while (true) { if (readBits(1)) { valueReady = !inclusionTree.nextLevel(); if (valueReady) { codeblock.included = true; codeblockIncluded = firstTimeInclusion = true; break; } } else { inclusionTree.incrementValue(layerNumber); break; } } } } if (!codeblockIncluded) { continue; } if (firstTimeInclusion) { zeroBitPlanesTree = precinct.zeroBitPlanesTree; zeroBitPlanesTree.reset(codeblockColumn, codeblockRow); while (true) { if (readBits(1)) { valueReady = !zeroBitPlanesTree.nextLevel(); if (valueReady) { break; } } else { zeroBitPlanesTree.incrementValue(); } } codeblock.zeroBitPlanes = zeroBitPlanesTree.value; } const codingpasses = readCodingpasses(); while (readBits(1)) { codeblock.Lblock++; } const codingpassesLog2 = (0, _core_utils.log2)(codingpasses); const bits = (codingpasses &lt; 1 &lt;&lt; codingpassesLog2 ? codingpassesLog2 - 1 : codingpassesLog2) + codeblock.Lblock; const codedDataLength = readBits(bits); queue.push({ codeblock, codingpasses, dataLength: codedDataLength }); } alignToByte(); if (ephMarkerUsed) { skipMarkerIfEqual(0x92); } while (queue.length &gt; 0) { const packetItem = queue.shift(); codeblock = packetItem.codeblock; if (codeblock.data === undefined) { codeblock.data = []; } codeblock.data.push({ data, start: offset + position, end: offset + position + packetItem.dataLength, codingpasses: packetItem.codingpasses }); position += packetItem.dataLength; } } return position; } function copyCoefficients(coefficients, levelWidth, levelHeight, subband, delta, mb, reversible, segmentationSymbolUsed, resetContextProbabilities) { const x0 = subband.tbx0; const y0 = subband.tby0; const width = subband.tbx1 - subband.tbx0; const codeblocks = subband.codeblocks; const right = subband.type.charAt(0) === &quot;H&quot; ? 1 : 0; const bottom = subband.type.charAt(1) === &quot;H&quot; ? levelWidth : 0; for (let i = 0, ii = codeblocks.length; i &lt; ii; ++i) { const codeblock = codeblocks[i]; const blockWidth = codeblock.tbx1_ - codeblock.tbx0_; const blockHeight = codeblock.tby1_ - codeblock.tby0_; if (blockWidth === 0 || blockHeight === 0) { continue; } if (codeblock.data === undefined) { continue; } const bitModel = new BitModel(blockWidth, blockHeight, codeblock.subbandType, codeblock.zeroBitPlanes, mb); let currentCodingpassType = 2; const data = codeblock.data; let totalLength = 0, codingpasses = 0; let j, jj, dataItem; for (j = 0, jj = data.length; j &lt; jj; j++) { dataItem = data[j]; totalLength += dataItem.end - dataItem.start; codingpasses += dataItem.codingpasses; } const encodedData = new Uint8Array(totalLength); let position = 0; for (j = 0, jj = data.length; j &lt; jj; j++) { dataItem = data[j]; const chunk = dataItem.data.subarray(dataItem.start, dataItem.end); encodedData.set(chunk, position); position += chunk.length; } const decoder = new _arithmetic_decoder.ArithmeticDecoder(encodedData, 0, totalLength); bitModel.setDecoder(decoder); for (j = 0; j &lt; codingpasses; j++) { switch (currentCodingpassType) { case 0: bitModel.runSignificancePropagationPass(); break; case 1: bitModel.runMagnitudeRefinementPass(); break; case 2: bitModel.runCleanupPass(); if (segmentationSymbolUsed) { bitModel.checkSegmentationSymbol(); } break; } if (resetContextProbabilities) { bitModel.reset(); } currentCodingpassType = (currentCodingpassType + 1) % 3; } let offset = codeblock.tbx0_ - x0 + (codeblock.tby0_ - y0) * width; const sign = bitModel.coefficentsSign; const magnitude = bitModel.coefficentsMagnitude; const bitsDecoded = bitModel.bitsDecoded; const magnitudeCorrection = reversible ? 0 : 0.5; let k, n, nb; position = 0; const interleave = subband.type !== &quot;LL&quot;; for (j = 0; j &lt; blockHeight; j++) { const row = offset / width | 0; const levelOffset = 2 * row * (levelWidth - width) + right + bottom; for (k = 0; k &lt; blockWidth; k++) { n = magnitude[position]; if (n !== 0) { n = (n + magnitudeCorrection) * delta; if (sign[position] !== 0) { n = -n; } nb = bitsDecoded[position]; const pos = interleave ? levelOffset + (offset &lt;&lt; 1) : offset; if (reversible &amp;&amp; nb &gt;= mb) { coefficients[pos] = n; } else { coefficients[pos] = n * (1 &lt;&lt; mb - nb); } } offset++; position++; } offset += width - blockWidth; } } } function transformTile(context, tile, c) { const component = tile.components[c]; const codingStyleParameters = component.codingStyleParameters; const quantizationParameters = component.quantizationParameters; const decompositionLevelsCount = codingStyleParameters.decompositionLevelsCount; const spqcds = quantizationParameters.SPqcds; const scalarExpounded = quantizationParameters.scalarExpounded; const guardBits = quantizationParameters.guardBits; const segmentationSymbolUsed = codingStyleParameters.segmentationSymbolUsed; const resetContextProbabilities = codingStyleParameters.resetContextProbabilities; const precision = context.components[c].precision; const reversible = codingStyleParameters.reversibleTransformation; const transform = reversible ? new ReversibleTransform() : new IrreversibleTransform(); const subbandCoefficients = []; let b = 0; for (let i = 0; i &lt;= decompositionLevelsCount; i++) { const resolution = component.resolutions[i]; const width = resolution.trx1 - resolution.trx0; const height = resolution.try1 - resolution.try0; const coefficients = new Float32Array(width * height); for (let j = 0, jj = resolution.subbands.length; j &lt; jj; j++) { let mu, epsilon; if (!scalarExpounded) { mu = spqcds[0].mu; epsilon = spqcds[0].epsilon + (i &gt; 0 ? 1 - i : 0); } else { mu = spqcds[b].mu; epsilon = spqcds[b].epsilon; b++; } const subband = resolution.subbands[j]; const gainLog2 = SubbandsGainLog2[subband.type]; const delta = reversible ? 1 : 2 ** (precision + gainLog2 - epsilon) * (1 + mu / 2048); const mb = guardBits + epsilon - 1; copyCoefficients(coefficients, width, height, subband, delta, mb, reversible, segmentationSymbolUsed, resetContextProbabilities); } subbandCoefficients.push({ width, height, items: coefficients }); } const result = transform.calculate(subbandCoefficients, component.tcx0, component.tcy0); return { left: component.tcx0, top: component.tcy0, width: result.width, height: result.height, items: result.items }; } function transformComponents(context) { const siz = context.SIZ; const components = context.components; const componentsCount = siz.Csiz; const resultImages = []; for (let i = 0, ii = context.tiles.length; i &lt; ii; i++) { const tile = context.tiles[i]; const transformedTiles = []; for (let c = 0; c &lt; componentsCount; c++) { transformedTiles[c] = transformTile(context, tile, c); } const tile0 = transformedTiles[0]; const out = new Uint8ClampedArray(tile0.items.length * componentsCount); const result = { left: tile0.left, top: tile0.top, width: tile0.width, height: tile0.height, items: out }; let shift, offset; let pos = 0, j, jj, y0, y1, y2; if (tile.codingStyleDefaultParameters.multipleComponentTransform) { const fourComponents = componentsCount === 4; const y0items = transformedTiles[0].items; const y1items = transformedTiles[1].items; const y2items = transformedTiles[2].items; const y3items = fourComponents ? transformedTiles[3].items : null; shift = components[0].precision - 8; offset = (128 &lt;&lt; shift) + 0.5; const component0 = tile.components[0]; const alpha01 = componentsCount - 3; jj = y0items.length; if (!component0.codingStyleParameters.reversibleTransformation) { for (j = 0; j &lt; jj; j++, pos += alpha01) { y0 = y0items[j] + offset; y1 = y1items[j]; y2 = y2items[j]; out[pos++] = y0 + 1.402 * y2 &gt;&gt; shift; out[pos++] = y0 - 0.34413 * y1 - 0.71414 * y2 &gt;&gt; shift; out[pos++] = y0 + 1.772 * y1 &gt;&gt; shift; } } else { for (j = 0; j &lt; jj; j++, pos += alpha01) { y0 = y0items[j] + offset; y1 = y1items[j]; y2 = y2items[j]; const g = y0 - (y2 + y1 &gt;&gt; 2); out[pos++] = g + y2 &gt;&gt; shift; out[pos++] = g &gt;&gt; shift; out[pos++] = g + y1 &gt;&gt; shift; } } if (fourComponents) { for (j = 0, pos = 3; j &lt; jj; j++, pos += 4) { out[pos] = y3items[j] + offset &gt;&gt; shift; } } } else { for (let c = 0; c &lt; componentsCount; c++) { const items = transformedTiles[c].items; shift = components[c].precision - 8; offset = (128 &lt;&lt; shift) + 0.5; for (pos = c, j = 0, jj = items.length; j &lt; jj; j++) { out[pos] = items[j] + offset &gt;&gt; shift; pos += componentsCount; } } } resultImages.push(result); } return resultImages; } function initializeTile(context, tileIndex) { const siz = context.SIZ; const componentsCount = siz.Csiz; const tile = context.tiles[tileIndex]; for (let c = 0; c &lt; componentsCount; c++) { const component = tile.components[c]; const qcdOrQcc = context.currentTile.QCC[c] !== undefined ? context.currentTile.QCC[c] : context.currentTile.QCD; component.quantizationParameters = qcdOrQcc; const codOrCoc = context.currentTile.COC[c] !== undefined ? context.currentTile.COC[c] : context.currentTile.COD; component.codingStyleParameters = codOrCoc; } tile.codingStyleDefaultParameters = context.currentTile.COD; } class TagTree { constructor(width, height) { const levelsLength = (0, _core_utils.log2)(Math.max(width, height)) + 1; this.levels = []; for (let i = 0; i &lt; levelsLength; i++) { const level = { width, height, items: [] }; this.levels.push(level); width = Math.ceil(width / 2); height = Math.ceil(height / 2); } } reset(i, j) { let currentLevel = 0, value = 0, level; while (currentLevel &lt; this.levels.length) { level = this.levels[currentLevel]; const index = i + j * level.width; if (level.items[index] !== undefined) { value = level.items[index]; break; } level.index = index; i &gt;&gt;= 1; j &gt;&gt;= 1; currentLevel++; } currentLevel--; level = this.levels[currentLevel]; level.items[level.index] = value; this.currentLevel = currentLevel; delete this.value; } incrementValue() { const level = this.levels[this.currentLevel]; level.items[level.index]++; } nextLevel() { let currentLevel = this.currentLevel; let level = this.levels[currentLevel]; const value = level.items[level.index]; currentLevel--; if (currentLevel &lt; 0) { this.value = value; return false; } this.currentLevel = currentLevel; level = this.levels[currentLevel]; level.items[level.index] = value; return true; } } class InclusionTree { constructor(width, height, defaultValue) { const levelsLength = (0, _core_utils.log2)(Math.max(width, height)) + 1; this.levels = []; for (let i = 0; i &lt; levelsLength; i++) { const items = new Uint8Array(width * height); for (let j = 0, jj = items.length; j &lt; jj; j++) { items[j] = defaultValue; } const level = { width, height, items }; this.levels.push(level); width = Math.ceil(width / 2); height = Math.ceil(height / 2); } } reset(i, j, stopValue) { let currentLevel = 0; while (currentLevel &lt; this.levels.length) { const level = this.levels[currentLevel]; const index = i + j * level.width; level.index = index; const value = level.items[index]; if (value === 0xff) { break; } if (value &gt; stopValue) { this.currentLevel = currentLevel; this.propagateValues(); return false; } i &gt;&gt;= 1; j &gt;&gt;= 1; currentLevel++; } this.currentLevel = currentLevel - 1; return true; } incrementValue(stopValue) { const level = this.levels[this.currentLevel]; level.items[level.index] = stopValue + 1; this.propagateValues(); } propagateValues() { let levelIndex = this.currentLevel; let level = this.levels[levelIndex]; const currentValue = level.items[level.index]; while (--levelIndex &gt;= 0) { level = this.levels[levelIndex]; level.items[level.index] = currentValue; } } nextLevel() { let currentLevel = this.currentLevel; let level = this.levels[currentLevel]; const value = level.items[level.index]; level.items[level.index] = 0xff; currentLevel--; if (currentLevel &lt; 0) { return false; } this.currentLevel = currentLevel; level = this.levels[currentLevel]; level.items[level.index] = value; return true; } } const BitModel = function BitModelClosure() { const UNIFORM_CONTEXT = 17; const RUNLENGTH_CONTEXT = 18; const LLAndLHContextsLabel = new Uint8Array([0, 5, 8, 0, 3, 7, 8, 0, 4, 7, 8, 0, 0, 0, 0, 0, 1, 6, 8, 0, 3, 7, 8, 0, 4, 7, 8, 0, 0, 0, 0, 0, 2, 6, 8, 0, 3, 7, 8, 0, 4, 7, 8, 0, 0, 0, 0, 0, 2, 6, 8, 0, 3, 7, 8, 0, 4, 7, 8, 0, 0, 0, 0, 0, 2, 6, 8, 0, 3, 7, 8, 0, 4, 7, 8]); const HLContextLabel = new Uint8Array([0, 3, 4, 0, 5, 7, 7, 0, 8, 8, 8, 0, 0, 0, 0, 0, 1, 3, 4, 0, 6, 7, 7, 0, 8, 8, 8, 0, 0, 0, 0, 0, 2, 3, 4, 0, 6, 7, 7, 0, 8, 8, 8, 0, 0, 0, 0, 0, 2, 3, 4, 0, 6, 7, 7, 0, 8, 8, 8, 0, 0, 0, 0, 0, 2, 3, 4, 0, 6, 7, 7, 0, 8, 8, 8]); const HHContextLabel = new Uint8Array([0, 1, 2, 0, 1, 2, 2, 0, 2, 2, 2, 0, 0, 0, 0, 0, 3, 4, 5, 0, 4, 5, 5, 0, 5, 5, 5, 0, 0, 0, 0, 0, 6, 7, 7, 0, 7, 7, 7, 0, 7, 7, 7, 0, 0, 0, 0, 0, 8, 8, 8, 0, 8, 8, 8, 0, 8, 8, 8, 0, 0, 0, 0, 0, 8, 8, 8, 0, 8, 8, 8, 0, 8, 8, 8]); class BitModel { constructor(width, height, subband, zeroBitPlanes, mb) { this.width = width; this.height = height; let contextLabelTable; if (subband === &quot;HH&quot;) { contextLabelTable = HHContextLabel; } else if (subband === &quot;HL&quot;) { contextLabelTable = HLContextLabel; } else { contextLabelTable = LLAndLHContextsLabel; } this.contextLabelTable = contextLabelTable; const coefficientCount = width * height; this.neighborsSignificance = new Uint8Array(coefficientCount); this.coefficentsSign = new Uint8Array(coefficientCount); let coefficentsMagnitude; if (mb &gt; 14) { coefficentsMagnitude = new Uint32Array(coefficientCount); } else if (mb &gt; 6) { coefficentsMagnitude = new Uint16Array(coefficientCount); } else { coefficentsMagnitude = new Uint8Array(coefficientCount); } this.coefficentsMagnitude = coefficentsMagnitude; this.processingFlags = new Uint8Array(coefficientCount); const bitsDecoded = new Uint8Array(coefficientCount); if (zeroBitPlanes !== 0) { for (let i = 0; i &lt; coefficientCount; i++) { bitsDecoded[i] = zeroBitPlanes; } } this.bitsDecoded = bitsDecoded; this.reset(); } setDecoder(decoder) { this.decoder = decoder; } reset() { this.contexts = new Int8Array(19); this.contexts[0] = 4 &lt;&lt; 1 | 0; this.contexts[UNIFORM_CONTEXT] = 46 &lt;&lt; 1 | 0; this.contexts[RUNLENGTH_CONTEXT] = 3 &lt;&lt; 1 | 0; } setNeighborsSignificance(row, column, index) { const neighborsSignificance = this.neighborsSignificance; const width = this.width, height = this.height; const left = column &gt; 0; const right = column + 1 &lt; width; let i; if (row &gt; 0) { i = index - width; if (left) { neighborsSignificance[i - 1] += 0x10; } if (right) { neighborsSignificance[i + 1] += 0x10; } neighborsSignificance[i] += 0x04; } if (row + 1 &lt; height) { i = index + width; if (left) { neighborsSignificance[i - 1] += 0x10; } if (right) { neighborsSignificance[i + 1] += 0x10; } neighborsSignificance[i] += 0x04; } if (left) { neighborsSignificance[index - 1] += 0x01; } if (right) { neighborsSignificance[index + 1] += 0x01; } neighborsSignificance[index] |= 0x80; } runSignificancePropagationPass() { const decoder = this.decoder; const width = this.width, height = this.height; const coefficentsMagnitude = this.coefficentsMagnitude; const coefficentsSign = this.coefficentsSign; const neighborsSignificance = this.neighborsSignificance; const processingFlags = this.processingFlags; const contexts = this.contexts; const labels = this.contextLabelTable; const bitsDecoded = this.bitsDecoded; const processedInverseMask = ~1; const processedMask = 1; const firstMagnitudeBitMask = 2; for (let i0 = 0; i0 &lt; height; i0 += 4) { for (let j = 0; j &lt; width; j++) { let index = i0 * width + j; for (let i1 = 0; i1 &lt; 4; i1++, index += width) { const i = i0 + i1; if (i &gt;= height) { break; } processingFlags[index] &amp;= processedInverseMask; if (coefficentsMagnitude[index] || !neighborsSignificance[index]) { continue; } const contextLabel = labels[neighborsSignificance[index]]; const decision = decoder.readBit(contexts, contextLabel); if (decision) { const sign = this.decodeSignBit(i, j, index); coefficentsSign[index] = sign; coefficentsMagnitude[index] = 1; this.setNeighborsSignificance(i, j, index); processingFlags[index] |= firstMagnitudeBitMask; } bitsDecoded[index]++; processingFlags[index] |= processedMask; } } } } decodeSignBit(row, column, index) { const width = this.width, height = this.height; const coefficentsMagnitude = this.coefficentsMagnitude; const coefficentsSign = this.coefficentsSign; let contribution, sign0, sign1, significance1; let contextLabel, decoded; significance1 = column &gt; 0 &amp;&amp; coefficentsMagnitude[index - 1] !== 0; if (column + 1 &lt; width &amp;&amp; coefficentsMagnitude[index + 1] !== 0) { sign1 = coefficentsSign[index + 1]; if (significance1) { sign0 = coefficentsSign[index - 1]; contribution = 1 - sign1 - sign0; } else { contribution = 1 - sign1 - sign1; } } else if (significance1) { sign0 = coefficentsSign[index - 1]; contribution = 1 - sign0 - sign0; } else { contribution = 0; } const horizontalContribution = 3 * contribution; significance1 = row &gt; 0 &amp;&amp; coefficentsMagnitude[index - width] !== 0; if (row + 1 &lt; height &amp;&amp; coefficentsMagnitude[index + width] !== 0) { sign1 = coefficentsSign[index + width]; if (significance1) { sign0 = coefficentsSign[index - width]; contribution = 1 - sign1 - sign0 + horizontalContribution; } else { contribution = 1 - sign1 - sign1 + horizontalContribution; } } else if (significance1) { sign0 = coefficentsSign[index - width]; contribution = 1 - sign0 - sign0 + horizontalContribution; } else { contribution = horizontalContribution; } if (contribution &gt;= 0) { contextLabel = 9 + contribution; decoded = this.decoder.readBit(this.contexts, contextLabel); } else { contextLabel = 9 - contribution; decoded = this.decoder.readBit(this.contexts, contextLabel) ^ 1; } return decoded; } runMagnitudeRefinementPass() { const decoder = this.decoder; const width = this.width, height = this.height; const coefficentsMagnitude = this.coefficentsMagnitude; const neighborsSignificance = this.neighborsSignificance; const contexts = this.contexts; const bitsDecoded = this.bitsDecoded; const processingFlags = this.processingFlags; const processedMask = 1; const firstMagnitudeBitMask = 2; const length = width * height; const width4 = width * 4; for (let index0 = 0, indexNext; index0 &lt; length; index0 = indexNext) { indexNext = Math.min(length, index0 + width4); for (let j = 0; j &lt; width; j++) { for (let index = index0 + j; index &lt; indexNext; index += width) { if (!coefficentsMagnitude[index] || (processingFlags[index] &amp; processedMask) !== 0) { continue; } let contextLabel = 16; if ((processingFlags[index] &amp; firstMagnitudeBitMask) !== 0) { processingFlags[index] ^= firstMagnitudeBitMask; const significance = neighborsSignificance[index] &amp; 127; contextLabel = significance === 0 ? 15 : 14; } const bit = decoder.readBit(contexts, contextLabel); coefficentsMagnitude[index] = coefficentsMagnitude[index] &lt;&lt; 1 | bit; bitsDecoded[index]++; processingFlags[index] |= processedMask; } } } } runCleanupPass() { const decoder = this.decoder; const width = this.width, height = this.height; const neighborsSignificance = this.neighborsSignificance; const coefficentsMagnitude = this.coefficentsMagnitude; const coefficentsSign = this.coefficentsSign; const contexts = this.contexts; const labels = this.contextLabelTable; const bitsDecoded = this.bitsDecoded; const processingFlags = this.processingFlags; const processedMask = 1; const firstMagnitudeBitMask = 2; const oneRowDown = width; const twoRowsDown = width * 2; const threeRowsDown = width * 3; let iNext; for (let i0 = 0; i0 &lt; height; i0 = iNext) { iNext = Math.min(i0 + 4, height); const indexBase = i0 * width; const checkAllEmpty = i0 + 3 &lt; height; for (let j = 0; j &lt; width; j++) { const index0 = indexBase + j; const allEmpty = checkAllEmpty &amp;&amp; processingFlags[index0] === 0 &amp;&amp; processingFlags[index0 + oneRowDown] === 0 &amp;&amp; processingFlags[index0 + twoRowsDown] === 0 &amp;&amp; processingFlags[index0 + threeRowsDown] === 0 &amp;&amp; neighborsSignificance[index0] === 0 &amp;&amp; neighborsSignificance[index0 + oneRowDown] === 0 &amp;&amp; neighborsSignificance[index0 + twoRowsDown] === 0 &amp;&amp; neighborsSignificance[index0 + threeRowsDown] === 0; let i1 = 0, index = index0; let i = i0, sign; if (allEmpty) { const hasSignificantCoefficent = decoder.readBit(contexts, RUNLENGTH_CONTEXT); if (!hasSignificantCoefficent) { bitsDecoded[index0]++; bitsDecoded[index0 + oneRowDown]++; bitsDecoded[index0 + twoRowsDown]++; bitsDecoded[index0 + threeRowsDown]++; continue; } i1 = decoder.readBit(contexts, UNIFORM_CONTEXT) &lt;&lt; 1 | decoder.readBit(contexts, UNIFORM_CONTEXT); if (i1 !== 0) { i = i0 + i1; index += i1 * width; } sign = this.decodeSignBit(i, j, index); coefficentsSign[index] = sign; coefficentsMagnitude[index] = 1; this.setNeighborsSignificance(i, j, index); processingFlags[index] |= firstMagnitudeBitMask; index = index0; for (let i2 = i0; i2 &lt;= i; i2++, index += width) { bitsDecoded[index]++; } i1++; } for (i = i0 + i1; i &lt; iNext; i++, index += width) { if (coefficentsMagnitude[index] || (processingFlags[index] &amp; processedMask) !== 0) { continue; } const contextLabel = labels[neighborsSignificance[index]]; const decision = decoder.readBit(contexts, contextLabel); if (decision === 1) { sign = this.decodeSignBit(i, j, index); coefficentsSign[index] = sign; coefficentsMagnitude[index] = 1; this.setNeighborsSignificance(i, j, index); processingFlags[index] |= firstMagnitudeBitMask; } bitsDecoded[index]++; } } } } checkSegmentationSymbol() { const decoder = this.decoder; const contexts = this.contexts; const symbol = decoder.readBit(contexts, UNIFORM_CONTEXT) &lt;&lt; 3 | decoder.readBit(contexts, UNIFORM_CONTEXT) &lt;&lt; 2 | decoder.readBit(contexts, UNIFORM_CONTEXT) &lt;&lt; 1 | decoder.readBit(contexts, UNIFORM_CONTEXT); if (symbol !== 0xa) { throw new JpxError(&quot;Invalid segmentation symbol&quot;); } } } return BitModel; }(); class Transform { constructor() { if (this.constructor === Transform) { (0, _util.unreachable)(&quot;Cannot initialize Transform.&quot;); } } calculate(subbands, u0, v0) { let ll = subbands[0]; for (let i = 1, ii = subbands.length; i &lt; ii; i++) { ll = this.iterate(ll, subbands[i], u0, v0); } return ll; } extend(buffer, offset, size) { let i1 = offset - 1, j1 = offset + 1; let i2 = offset + size - 2, j2 = offset + size; buffer[i1--] = buffer[j1++]; buffer[j2++] = buffer[i2--]; buffer[i1--] = buffer[j1++]; buffer[j2++] = buffer[i2--]; buffer[i1--] = buffer[j1++]; buffer[j2++] = buffer[i2--]; buffer[i1] = buffer[j1]; buffer[j2] = buffer[i2]; } filter(x, offset, length) { (0, _util.unreachable)(&quot;Abstract method `filter` called&quot;); } iterate(ll, hl_lh_hh, u0, v0) { const llWidth = ll.width, llHeight = ll.height; let llItems = ll.items; const width = hl_lh_hh.width; const height = hl_lh_hh.height; const items = hl_lh_hh.items; let i, j, k, l, u, v; for (k = 0, i = 0; i &lt; llHeight; i++) { l = i * 2 * width; for (j = 0; j &lt; llWidth; j++, k++, l += 2) { items[l] = llItems[k]; } } llItems = ll.items = null; const bufferPadding = 4; const rowBuffer = new Float32Array(width + 2 * bufferPadding); if (width === 1) { if ((u0 &amp; 1) !== 0) { for (v = 0, k = 0; v &lt; height; v++, k += width) { items[k] *= 0.5; } } } else { for (v = 0, k = 0; v &lt; height; v++, k += width) { rowBuffer.set(items.subarray(k, k + width), bufferPadding); this.extend(rowBuffer, bufferPadding, width); this.filter(rowBuffer, bufferPadding, width); items.set(rowBuffer.subarray(bufferPadding, bufferPadding + width), k); } } let numBuffers = 16; const colBuffers = []; for (i = 0; i &lt; numBuffers; i++) { colBuffers.push(new Float32Array(height + 2 * bufferPadding)); } let b, currentBuffer = 0; ll = bufferPadding + height; if (height === 1) { if ((v0 &amp; 1) !== 0) { for (u = 0; u &lt; width; u++) { items[u] *= 0.5; } } } else { for (u = 0; u &lt; width; u++) { if (currentBuffer === 0) { numBuffers = Math.min(width - u, numBuffers); for (k = u, l = bufferPadding; l &lt; ll; k += width, l++) { for (b = 0; b &lt; numBuffers; b++) { colBuffers[b][l] = items[k + b]; } } currentBuffer = numBuffers; } currentBuffer--; const buffer = colBuffers[currentBuffer]; this.extend(buffer, bufferPadding, height); this.filter(buffer, bufferPadding, height); if (currentBuffer === 0) { k = u - numBuffers + 1; for (l = bufferPadding; l &lt; ll; k += width, l++) { for (b = 0; b &lt; numBuffers; b++) { items[k + b] = colBuffers[b][l]; } } } } } return { width, height, items }; } } class IrreversibleTransform extends Transform { filter(x, offset, length) { const len = length &gt;&gt; 1; offset |= 0; let j, n, current, next; const alpha = -1.586134342059924; const beta = -0.052980118572961; const gamma = 0.882911075530934; const delta = 0.443506852043971; const K = 1.230174104914001; const K_ = 1 / K; j = offset - 3; for (n = len + 4; n--; j += 2) { x[j] *= K_; } j = offset - 2; current = delta * x[j - 1]; for (n = len + 3; n--; j += 2) { next = delta * x[j + 1]; x[j] = K * x[j] - current - next; if (n--) { j += 2; current = delta * x[j + 1]; x[j] = K * x[j] - current - next; } else { break; } } j = offset - 1; current = gamma * x[j - 1]; for (n = len + 2; n--; j += 2) { next = gamma * x[j + 1]; x[j] -= current + next; if (n--) { j += 2; current = gamma * x[j + 1]; x[j] -= current + next; } else { break; } } j = offset; current = beta * x[j - 1]; for (n = len + 1; n--; j += 2) { next = beta * x[j + 1]; x[j] -= current + next; if (n--) { j += 2; current = beta * x[j + 1]; x[j] -= current + next; } else { break; } } if (len !== 0) { j = offset + 1; current = alpha * x[j - 1]; for (n = len; n--; j += 2) { next = alpha * x[j + 1]; x[j] -= current + next; if (n--) { j += 2; current = alpha * x[j + 1]; x[j] -= current + next; } else { break; } } } } } class ReversibleTransform extends Transform { filter(x, offset, length) { const len = length &gt;&gt; 1; offset |= 0; let j, n; for (j = offset, n = len + 1; n--; j += 2) { x[j] -= x[j - 1] + x[j + 1] + 2 &gt;&gt; 2; } for (j = offset + 1, n = len; n--; j += 2) { x[j] += x[j - 1] + x[j + 1] &gt;&gt; 1; } } } /***/ }), /* 29 */ /***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) =&gt; { Object.defineProperty(exports, &quot;__esModule&quot;, ({ value: true })); exports.LZWStream = void 0; var _decode_stream = __w_pdfjs_require__(17); class LZWStream extends _decode_stream.DecodeStream { constructor(str, maybeLength, earlyChange) { super(maybeLength); this.str = str; this.dict = str.dict; this.cachedData = 0; this.bitsCached = 0; const maxLzwDictionarySize = 4096; const lzwState = { earlyChange, codeLength: 9, nextCode: 258, dictionaryValues: new Uint8Array(maxLzwDictionarySize), dictionaryLengths: new Uint16Array(maxLzwDictionarySize), dictionaryPrevCodes: new Uint16Array(maxLzwDictionarySize), currentSequence: new Uint8Array(maxLzwDictionarySize), currentSequenceLength: 0 }; for (let i = 0; i &lt; 256; ++i) { lzwState.dictionaryValues[i] = i; lzwState.dictionaryLengths[i] = 1; } this.lzwState = lzwState; } readBits(n) { let bitsCached = this.bitsCached; let cachedData = this.cachedData; while (bitsCached &lt; n) { const c = this.str.getByte(); if (c === -1) { this.eof = true; return null; } cachedData = cachedData &lt;&lt; 8 | c; bitsCached += 8; } this.bitsCached = bitsCached -= n; this.cachedData = cachedData; this.lastCode = null; return cachedData &gt;&gt;&gt; bitsCached &amp; (1 &lt;&lt; n) - 1; } readBlock() { const blockSize = 512, decodedSizeDelta = blockSize; let estimatedDecodedSize = blockSize * 2; let i, j, q; const lzwState = this.lzwState; if (!lzwState) { return; } const earlyChange = lzwState.earlyChange; let nextCode = lzwState.nextCode; const dictionaryValues = lzwState.dictionaryValues; const dictionaryLengths = lzwState.dictionaryLengths; const dictionaryPrevCodes = lzwState.dictionaryPrevCodes; let codeLength = lzwState.codeLength; let prevCode = lzwState.prevCode; const currentSequence = lzwState.currentSequence; let currentSequenceLength = lzwState.currentSequenceLength; let decodedLength = 0; let currentBufferLength = this.bufferLength; let buffer = this.ensureBuffer(this.bufferLength + estimatedDecodedSize); for (i = 0; i &lt; blockSize; i++) { const code = this.readBits(codeLength); const hasPrev = currentSequenceLength &gt; 0; if (code &lt; 256) { currentSequence[0] = code; currentSequenceLength = 1; } else if (code &gt;= 258) { if (code &lt; nextCode) { currentSequenceLength = dictionaryLengths[code]; for (j = currentSequenceLength - 1, q = code; j &gt;= 0; j--) { currentSequence[j] = dictionaryValues[q]; q = dictionaryPrevCodes[q]; } } else { currentSequence[currentSequenceLength++] = currentSequence[0]; } } else if (code === 256) { codeLength = 9; nextCode = 258; currentSequenceLength = 0; continue; } else { this.eof = true; delete this.lzwState; break; } if (hasPrev) { dictionaryPrevCodes[nextCode] = prevCode; dictionaryLengths[nextCode] = dictionaryLengths[prevCode] + 1; dictionaryValues[nextCode] = currentSequence[0]; nextCode++; codeLength = nextCode + earlyChange &amp; nextCode + earlyChange - 1 ? codeLength : Math.min(Math.log(nextCode + earlyChange) / 0.6931471805599453 + 1, 12) | 0; } prevCode = code; decodedLength += currentSequenceLength; if (estimatedDecodedSize &lt; decodedLength) { do { estimatedDecodedSize += decodedSizeDelta; } while (estimatedDecodedSize &lt; decodedLength); buffer = this.ensureBuffer(this.bufferLength + estimatedDecodedSize); } for (j = 0; j &lt; currentSequenceLength; j++) { buffer[currentBufferLength++] = currentSequence[j]; } } lzwState.nextCode = nextCode; lzwState.codeLength = codeLength; lzwState.prevCode = prevCode; lzwState.currentSequenceLength = currentSequenceLength; this.bufferLength = currentBufferLength; } } exports.LZWStream = LZWStream; /***/ }), /* 30 */ /***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) =&gt; { Object.defineProperty(exports, &quot;__esModule&quot;, ({ value: true })); exports.PredictorStream = void 0; var _decode_stream = __w_pdfjs_require__(17); var _primitives = __w_pdfjs_require__(3); var _util = __w_pdfjs_require__(2); class PredictorStream extends _decode_stream.DecodeStream { constructor(str, maybeLength, params) { super(maybeLength); if (!(params instanceof _primitives.Dict)) { return str; } const predictor = this.predictor = params.get(&quot;Predictor&quot;) || 1; if (predictor &lt;= 1) { return str; } if (predictor !== 2 &amp;&amp; (predictor &lt; 10 || predictor &gt; 15)) { throw new _util.FormatError(`Unsupported predictor: ${predictor}`); } if (predictor === 2) { this.readBlock = this.readBlockTiff; } else { this.readBlock = this.readBlockPng; } this.str = str; this.dict = str.dict; const colors = this.colors = params.get(&quot;Colors&quot;) || 1; const bits = this.bits = params.get(&quot;BPC&quot;, &quot;BitsPerComponent&quot;) || 8; const columns = this.columns = params.get(&quot;Columns&quot;) || 1; this.pixBytes = colors * bits + 7 &gt;&gt; 3; this.rowBytes = columns * colors * bits + 7 &gt;&gt; 3; return this; } readBlockTiff() { const rowBytes = this.rowBytes; const bufferLength = this.bufferLength; const buffer = this.ensureBuffer(bufferLength + rowBytes); const bits = this.bits; const colors = this.colors; const rawBytes = this.str.getBytes(rowBytes); this.eof = !rawBytes.length; if (this.eof) { return; } let inbuf = 0, outbuf = 0; let inbits = 0, outbits = 0; let pos = bufferLength; let i; if (bits === 1 &amp;&amp; colors === 1) { for (i = 0; i &lt; rowBytes; ++i) { let c = rawBytes[i] ^ inbuf; c ^= c &gt;&gt; 1; c ^= c &gt;&gt; 2; c ^= c &gt;&gt; 4; inbuf = (c &amp; 1) &lt;&lt; 7; buffer[pos++] = c; } } else if (bits === 8) { for (i = 0; i &lt; colors; ++i) { buffer[pos++] = rawBytes[i]; } for (; i &lt; rowBytes; ++i) { buffer[pos] = buffer[pos - colors] + rawBytes[i]; pos++; } } else if (bits === 16) { const bytesPerPixel = colors * 2; for (i = 0; i &lt; bytesPerPixel; ++i) { buffer[pos++] = rawBytes[i]; } for (; i &lt; rowBytes; i += 2) { const sum = ((rawBytes[i] &amp; 0xff) &lt;&lt; 8) + (rawBytes[i + 1] &amp; 0xff) + ((buffer[pos - bytesPerPixel] &amp; 0xff) &lt;&lt; 8) + (buffer[pos - bytesPerPixel + 1] &amp; 0xff); buffer[pos++] = sum &gt;&gt; 8 &amp; 0xff; buffer[pos++] = sum &amp; 0xff; } } else { const compArray = new Uint8Array(colors + 1); const bitMask = (1 &lt;&lt; bits) - 1; let j = 0, k = bufferLength; const columns = this.columns; for (i = 0; i &lt; columns; ++i) { for (let kk = 0; kk &lt; colors; ++kk) { if (inbits &lt; bits) { inbuf = inbuf &lt;&lt; 8 | rawBytes[j++] &amp; 0xff; inbits += 8; } compArray[kk] = compArray[kk] + (inbuf &gt;&gt; inbits - bits) &amp; bitMask; inbits -= bits; outbuf = outbuf &lt;&lt; bits | compArray[kk]; outbits += bits; if (outbits &gt;= 8) { buffer[k++] = outbuf &gt;&gt; outbits - 8 &amp; 0xff; outbits -= 8; } } } if (outbits &gt; 0) { buffer[k++] = (outbuf &lt;&lt; 8 - outbits) + (inbuf &amp; (1 &lt;&lt; 8 - outbits) - 1); } } this.bufferLength += rowBytes; } readBlockPng() { const rowBytes = this.rowBytes; const pixBytes = this.pixBytes; const predictor = this.str.getByte(); const rawBytes = this.str.getBytes(rowBytes); this.eof = !rawBytes.length; if (this.eof) { return; } const bufferLength = this.bufferLength; const buffer = this.ensureBuffer(bufferLength + rowBytes); let prevRow = buffer.subarray(bufferLength - rowBytes, bufferLength); if (prevRow.length === 0) { prevRow = new Uint8Array(rowBytes); } let i, j = bufferLength, up, c; switch (predictor) { case 0: for (i = 0; i &lt; rowBytes; ++i) { buffer[j++] = rawBytes[i]; } break; case 1: for (i = 0; i &lt; pixBytes; ++i) { buffer[j++] = rawBytes[i]; } for (; i &lt; rowBytes; ++i) { buffer[j] = buffer[j - pixBytes] + rawBytes[i] &amp; 0xff; j++; } break; case 2: for (i = 0; i &lt; rowBytes; ++i) { buffer[j++] = prevRow[i] + rawBytes[i] &amp; 0xff; } break; case 3: for (i = 0; i &lt; pixBytes; ++i) { buffer[j++] = (prevRow[i] &gt;&gt; 1) + rawBytes[i]; } for (; i &lt; rowBytes; ++i) { buffer[j] = (prevRow[i] + buffer[j - pixBytes] &gt;&gt; 1) + rawBytes[i] &amp; 0xff; j++; } break; case 4: for (i = 0; i &lt; pixBytes; ++i) { up = prevRow[i]; c = rawBytes[i]; buffer[j++] = up + c; } for (; i &lt; rowBytes; ++i) { up = prevRow[i]; const upLeft = prevRow[i - pixBytes]; const left = buffer[j - pixBytes]; const p = left + up - upLeft; let pa = p - left; if (pa &lt; 0) { pa = -pa; } let pb = p - up; if (pb &lt; 0) { pb = -pb; } let pc = p - upLeft; if (pc &lt; 0) { pc = -pc; } c = rawBytes[i]; if (pa &lt;= pb &amp;&amp; pa &lt;= pc) { buffer[j++] = left + c; } else if (pb &lt;= pc) { buffer[j++] = up + c; } else { buffer[j++] = upLeft + c; } } break; default: throw new _util.FormatError(`Unsupported predictor: ${predictor}`); } this.bufferLength += rowBytes; } } exports.PredictorStream = PredictorStream; /***/ }), /* 31 */ /***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) =&gt; { Object.defineProperty(exports, &quot;__esModule&quot;, ({ value: true })); exports.RunLengthStream = void 0; var _decode_stream = __w_pdfjs_require__(17); class RunLengthStream extends _decode_stream.DecodeStream { constructor(str, maybeLength) { super(maybeLength); this.str = str; this.dict = str.dict; } readBlock() { const repeatHeader = this.str.getBytes(2); if (!repeatHeader || repeatHeader.length &lt; 2 || repeatHeader[0] === 128) { this.eof = true; return; } let buffer; let bufferLength = this.bufferLength; let n = repeatHeader[0]; if (n &lt; 128) { buffer = this.ensureBuffer(bufferLength + n + 1); buffer[bufferLength++] = repeatHeader[1]; if (n &gt; 0) { const source = this.str.getBytes(n); buffer.set(source, bufferLength); bufferLength += n; } } else { n = 257 - n; const b = repeatHeader[1]; buffer = this.ensureBuffer(bufferLength + n + 1); for (let i = 0; i &lt; n; i++) { buffer[bufferLength++] = b; } } this.bufferLength = bufferLength; } } exports.RunLengthStream = RunLengthStream; /***/ }), /* 32 */ /***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) =&gt; { Object.defineProperty(exports, &quot;__esModule&quot;, ({ value: true })); exports.Font = exports.ErrorFont = void 0; var _util = __w_pdfjs_require__(2); var _cff_parser = __w_pdfjs_require__(33); var _fonts_utils = __w_pdfjs_require__(36); var _unicode = __w_pdfjs_require__(38); var _glyphlist = __w_pdfjs_require__(37); var _encodings = __w_pdfjs_require__(35); var _standard_fonts = __w_pdfjs_require__(39); var _to_unicode_map = __w_pdfjs_require__(40); var _cff_font = __w_pdfjs_require__(41); var _font_renderer = __w_pdfjs_require__(42); var _metrics = __w_pdfjs_require__(43); var _glyf = __w_pdfjs_require__(44); var _cmap = __w_pdfjs_require__(14); var _opentype_file_builder = __w_pdfjs_require__(45); var _core_utils = __w_pdfjs_require__(4); var _stream = __w_pdfjs_require__(8); var _type1_font = __w_pdfjs_require__(46); const PRIVATE_USE_AREAS = [[0xe000, 0xf8ff], [0x100000, 0x10fffd]]; const PDF_GLYPH_SPACE_UNITS = 1000; const EXPORT_DATA_PROPERTIES = [&quot;ascent&quot;, &quot;bbox&quot;, &quot;black&quot;, &quot;bold&quot;, &quot;charProcOperatorList&quot;, &quot;composite&quot;, &quot;cssFontInfo&quot;, &quot;data&quot;, &quot;defaultVMetrics&quot;, &quot;defaultWidth&quot;, &quot;descent&quot;, &quot;fallbackName&quot;, &quot;fontMatrix&quot;, &quot;fontType&quot;, &quot;isType3Font&quot;, &quot;italic&quot;, &quot;loadedName&quot;, &quot;mimetype&quot;, &quot;missingFile&quot;, &quot;name&quot;, &quot;remeasure&quot;, &quot;subtype&quot;, &quot;type&quot;, &quot;vertical&quot;]; const EXPORT_DATA_EXTRA_PROPERTIES = [&quot;cMap&quot;, &quot;defaultEncoding&quot;, &quot;differences&quot;, &quot;isMonospace&quot;, &quot;isSerifFont&quot;, &quot;isSymbolicFont&quot;, &quot;seacMap&quot;, &quot;toFontChar&quot;, &quot;toUnicode&quot;, &quot;vmetrics&quot;, &quot;widths&quot;]; function adjustWidths(properties) { if (!properties.fontMatrix) { return; } if (properties.fontMatrix[0] === _util.FONT_IDENTITY_MATRIX[0]) { return; } const scale = 0.001 / properties.fontMatrix[0]; const glyphsWidths = properties.widths; for (const glyph in glyphsWidths) { glyphsWidths[glyph] *= scale; } properties.defaultWidth *= scale; } function adjustToUnicode(properties, builtInEncoding) { if (properties.isInternalFont) { return; } if (properties.hasIncludedToUnicodeMap) { return; } if (builtInEncoding === properties.defaultEncoding) { return; } if (properties.toUnicode instanceof _to_unicode_map.IdentityToUnicodeMap) { return; } const toUnicode = [], glyphsUnicodeMap = (0, _glyphlist.getGlyphsUnicode)(); for (const charCode in builtInEncoding) { if (properties.hasEncoding) { if (properties.differences.length === 0 || properties.differences[charCode] !== undefined) { continue; } } const glyphName = builtInEncoding[charCode]; const unicode = (0, _unicode.getUnicodeForGlyph)(glyphName, glyphsUnicodeMap); if (unicode !== -1) { toUnicode[charCode] = String.fromCharCode(unicode); } } if (toUnicode.length &gt; 0) { properties.toUnicode.amend(toUnicode); } } function amendFallbackToUnicode(properties) { if (!properties.fallbackToUnicode) { return; } if (properties.toUnicode instanceof _to_unicode_map.IdentityToUnicodeMap) { return; } const toUnicode = []; for (const charCode in properties.fallbackToUnicode) { if (properties.toUnicode.has(charCode)) { continue; } toUnicode[charCode] = properties.fallbackToUnicode[charCode]; } if (toUnicode.length &gt; 0) { properties.toUnicode.amend(toUnicode); } } class Glyph { constructor(originalCharCode, fontChar, unicode, accent, width, vmetric, operatorListId, isSpace, isInFont) { this.originalCharCode = originalCharCode; this.fontChar = fontChar; this.unicode = unicode; this.accent = accent; this.width = width; this.vmetric = vmetric; this.operatorListId = operatorListId; this.isSpace = isSpace; this.isInFont = isInFont; const category = (0, _unicode.getCharUnicodeCategory)(unicode); this.isWhitespace = category.isWhitespace; this.isZeroWidthDiacritic = category.isZeroWidthDiacritic; this.isInvisibleFormatMark = category.isInvisibleFormatMark; } } function int16(b0, b1) { return (b0 &lt;&lt; 8) + b1; } function writeSignedInt16(bytes, index, value) { bytes[index + 1] = value; bytes[index] = value &gt;&gt;&gt; 8; } function signedInt16(b0, b1) { const value = (b0 &lt;&lt; 8) + b1; return value &amp; 1 &lt;&lt; 15 ? value - 0x10000 : value; } function int32(b0, b1, b2, b3) { return (b0 &lt;&lt; 24) + (b1 &lt;&lt; 16) + (b2 &lt;&lt; 8) + b3; } function string16(value) { return String.fromCharCode(value &gt;&gt; 8 &amp; 0xff, value &amp; 0xff); } function safeString16(value) { if (value &gt; 0x7fff) { value = 0x7fff; } else if (value &lt; -0x8000) { value = -0x8000; } return String.fromCharCode(value &gt;&gt; 8 &amp; 0xff, value &amp; 0xff); } function isTrueTypeFile(file) { const header = file.peekBytes(4); return (0, _core_utils.readUint32)(header, 0) === 0x00010000 || (0, _util.bytesToString)(header) === &quot;true&quot;; } function isTrueTypeCollectionFile(file) { const header = file.peekBytes(4); return (0, _util.bytesToString)(header) === &quot;ttcf&quot;; } function isOpenTypeFile(file) { const header = file.peekBytes(4); return (0, _util.bytesToString)(header) === &quot;OTTO&quot;; } function isType1File(file) { const header = file.peekBytes(2); if (header[0] === 0x25 &amp;&amp; header[1] === 0x21) { return true; } if (header[0] === 0x80 &amp;&amp; header[1] === 0x01) { return true; } return false; } function isCFFFile(file) { const header = file.peekBytes(4); if (header[0] &gt;= 1 &amp;&amp; header[3] &gt;= 1 &amp;&amp; header[3] &lt;= 4) { return true; } return false; } function getFontFileType(file, { type, subtype, composite }) { let fileType, fileSubtype; if (isTrueTypeFile(file) || isTrueTypeCollectionFile(file)) { if (composite) { fileType = &quot;CIDFontType2&quot;; } else { fileType = &quot;TrueType&quot;; } } else if (isOpenTypeFile(file)) { if (composite) { fileType = &quot;CIDFontType2&quot;; } else { fileType = &quot;OpenType&quot;; } } else if (isType1File(file)) { if (composite) { fileType = &quot;CIDFontType0&quot;; } else { fileType = type === &quot;MMType1&quot; ? &quot;MMType1&quot; : &quot;Type1&quot;; } } else if (isCFFFile(file)) { if (composite) { fileType = &quot;CIDFontType0&quot;; fileSubtype = &quot;CIDFontType0C&quot;; } else { fileType = type === &quot;MMType1&quot; ? &quot;MMType1&quot; : &quot;Type1&quot;; fileSubtype = &quot;Type1C&quot;; } } else { (0, _util.warn)(&quot;getFontFileType: Unable to detect correct font file Type/Subtype.&quot;); fileType = type; fileSubtype = subtype; } return [fileType, fileSubtype]; } function applyStandardFontGlyphMap(map, glyphMap) { for (const charCode in glyphMap) { map[+charCode] = glyphMap[charCode]; } } function buildToFontChar(encoding, glyphsUnicodeMap, differences) { const toFontChar = []; let unicode; for (let i = 0, ii = encoding.length; i &lt; ii; i++) { unicode = (0, _unicode.getUnicodeForGlyph)(encoding[i], glyphsUnicodeMap); if (unicode !== -1) { toFontChar[i] = unicode; } } for (const charCode in differences) { unicode = (0, _unicode.getUnicodeForGlyph)(differences[charCode], glyphsUnicodeMap); if (unicode !== -1) { toFontChar[+charCode] = unicode; } } return toFontChar; } function convertCidString(charCode, cid, shouldThrow = false) { switch (cid.length) { case 1: return cid.charCodeAt(0); case 2: return cid.charCodeAt(0) &lt;&lt; 8 | cid.charCodeAt(1); } const msg = `Unsupported CID string (charCode ${charCode}): &quot;${cid}&quot;.`; if (shouldThrow) { throw new _util.FormatError(msg); } (0, _util.warn)(msg); return cid; } function adjustMapping(charCodeToGlyphId, hasGlyph, newGlyphZeroId, toUnicode) { const newMap = Object.create(null); const toUnicodeExtraMap = new Map(); const toFontChar = []; const usedGlyphIds = new Set(); let privateUseAreaIndex = 0; const privateUseOffetStart = PRIVATE_USE_AREAS[privateUseAreaIndex][0]; let nextAvailableFontCharCode = privateUseOffetStart; let privateUseOffetEnd = PRIVATE_USE_AREAS[privateUseAreaIndex][1]; for (let originalCharCode in charCodeToGlyphId) { originalCharCode |= 0; let glyphId = charCodeToGlyphId[originalCharCode]; if (!hasGlyph(glyphId)) { continue; } if (nextAvailableFontCharCode &gt; privateUseOffetEnd) { privateUseAreaIndex++; if (privateUseAreaIndex &gt;= PRIVATE_USE_AREAS.length) { (0, _util.warn)(&quot;Ran out of space in font private use area.&quot;); break; } nextAvailableFontCharCode = PRIVATE_USE_AREAS[privateUseAreaIndex][0]; privateUseOffetEnd = PRIVATE_USE_AREAS[privateUseAreaIndex][1]; } const fontCharCode = nextAvailableFontCharCode++; if (glyphId === 0) { glyphId = newGlyphZeroId; } let unicode = toUnicode.get(originalCharCode); if (typeof unicode === &quot;string&quot;) { unicode = unicode.codePointAt(0); } if (unicode &amp;&amp; unicode &lt; privateUseOffetStart &amp;&amp; !usedGlyphIds.has(glyphId)) { toUnicodeExtraMap.set(unicode, glyphId); usedGlyphIds.add(glyphId); } newMap[fontCharCode] = glyphId; toFontChar[originalCharCode] = fontCharCode; } return { toFontChar, charCodeToGlyphId: newMap, toUnicodeExtraMap, nextAvailableFontCharCode }; } function getRanges(glyphs, toUnicodeExtraMap, numGlyphs) { const codes = []; for (const charCode in glyphs) { if (glyphs[charCode] &gt;= numGlyphs) { continue; } codes.push({ fontCharCode: charCode | 0, glyphId: glyphs[charCode] }); } if (toUnicodeExtraMap) { for (const [unicode, glyphId] of toUnicodeExtraMap) { if (glyphId &gt;= numGlyphs) { continue; } codes.push({ fontCharCode: unicode, glyphId }); } } if (codes.length === 0) { codes.push({ fontCharCode: 0, glyphId: 0 }); } codes.sort(function fontGetRangesSort(a, b) { return a.fontCharCode - b.fontCharCode; }); const ranges = []; const length = codes.length; for (let n = 0; n &lt; length;) { const start = codes[n].fontCharCode; const codeIndices = [codes[n].glyphId]; ++n; let end = start; while (n &lt; length &amp;&amp; end + 1 === codes[n].fontCharCode) { codeIndices.push(codes[n].glyphId); ++end; ++n; if (end === 0xffff) { break; } } ranges.push([start, end, codeIndices]); } return ranges; } function createCmapTable(glyphs, toUnicodeExtraMap, numGlyphs) { const ranges = getRanges(glyphs, toUnicodeExtraMap, numGlyphs); const numTables = ranges.at(-1)[1] &gt; 0xffff ? 2 : 1; let cmap = &quot;\\x00\\x00&quot; + string16(numTables) + &quot;\\x00\\x03&quot; + &quot;\\x00\\x01&quot; + (0, _util.string32)(4 + numTables * 8); let i, ii, j, jj; for (i = ranges.length - 1; i &gt;= 0; --i) { if (ranges[i][0] &lt;= 0xffff) { break; } } const bmpLength = i + 1; if (ranges[i][0] &lt; 0xffff &amp;&amp; ranges[i][1] === 0xffff) { ranges[i][1] = 0xfffe; } const trailingRangesCount = ranges[i][1] &lt; 0xffff ? 1 : 0; const segCount = bmpLength + trailingRangesCount; const searchParams = _opentype_file_builder.OpenTypeFileBuilder.getSearchParams(segCount, 2); let startCount = &quot;&quot;; let endCount = &quot;&quot;; let idDeltas = &quot;&quot;; let idRangeOffsets = &quot;&quot;; let glyphsIds = &quot;&quot;; let bias = 0; let range, start, end, codes; for (i = 0, ii = bmpLength; i &lt; ii; i++) { range = ranges[i]; start = range[0]; end = range[1]; startCount += string16(start); endCount += string16(end); codes = range[2]; let contiguous = true; for (j = 1, jj = codes.length; j &lt; jj; ++j) { if (codes[j] !== codes[j - 1] + 1) { contiguous = false; break; } } if (!contiguous) { const offset = (segCount - i) * 2 + bias * 2; bias += end - start + 1; idDeltas += string16(0); idRangeOffsets += string16(offset); for (j = 0, jj = codes.length; j &lt; jj; ++j) { glyphsIds += string16(codes[j]); } } else { const startCode = codes[0]; idDeltas += string16(startCode - start &amp; 0xffff); idRangeOffsets += string16(0); } } if (trailingRangesCount &gt; 0) { endCount += &quot;\\xFF\\xFF&quot;; startCount += &quot;\\xFF\\xFF&quot;; idDeltas += &quot;\\x00\\x01&quot;; idRangeOffsets += &quot;\\x00\\x00&quot;; } const format314 = &quot;\\x00\\x00&quot; + string16(2 * segCount) + string16(searchParams.range) + string16(searchParams.entry) + string16(searchParams.rangeShift) + endCount + &quot;\\x00\\x00&quot; + startCount + idDeltas + idRangeOffsets + glyphsIds; let format31012 = &quot;&quot;; let header31012 = &quot;&quot;; if (numTables &gt; 1) { cmap += &quot;\\x00\\x03&quot; + &quot;\\x00\\x0A&quot; + (0, _util.string32)(4 + numTables * 8 + 4 + format314.length); format31012 = &quot;&quot;; for (i = 0, ii = ranges.length; i &lt; ii; i++) { range = ranges[i]; start = range[0]; codes = range[2]; let code = codes[0]; for (j = 1, jj = codes.length; j &lt; jj; ++j) { if (codes[j] !== codes[j - 1] + 1) { end = range[0] + j - 1; format31012 += (0, _util.string32)(start) + (0, _util.string32)(end) + (0, _util.string32)(code); start = end + 1; code = codes[j]; } } format31012 += (0, _util.string32)(start) + (0, _util.string32)(range[1]) + (0, _util.string32)(code); } header31012 = &quot;\\x00\\x0C&quot; + &quot;\\x00\\x00&quot; + (0, _util.string32)(format31012.length + 16) + &quot;\\x00\\x00\\x00\\x00&quot; + (0, _util.string32)(format31012.length / 12); } return cmap + &quot;\\x00\\x04&quot; + string16(format314.length + 4) + format314 + header31012 + format31012; } function validateOS2Table(os2, file) { file.pos = (file.start || 0) + os2.offset; const version = file.getUint16(); file.skip(60); const selection = file.getUint16(); if (version &lt; 4 &amp;&amp; selection &amp; 0x0300) { return false; } const firstChar = file.getUint16(); const lastChar = file.getUint16(); if (firstChar &gt; lastChar) { return false; } file.skip(6); const usWinAscent = file.getUint16(); if (usWinAscent === 0) { return false; } os2.data[8] = os2.data[9] = 0; return true; } function createOS2Table(properties, charstrings, override) { override = override || { unitsPerEm: 0, yMax: 0, yMin: 0, ascent: 0, descent: 0 }; let ulUnicodeRange1 = 0; let ulUnicodeRange2 = 0; let ulUnicodeRange3 = 0; let ulUnicodeRange4 = 0; let firstCharIndex = null; let lastCharIndex = 0; if (charstrings) { for (let code in charstrings) { code |= 0; if (firstCharIndex &gt; code || !firstCharIndex) { firstCharIndex = code; } if (lastCharIndex &lt; code) { lastCharIndex = code; } const position = (0, _unicode.getUnicodeRangeFor)(code); if (position &lt; 32) { ulUnicodeRange1 |= 1 &lt;&lt; position; } else if (position &lt; 64) { ulUnicodeRange2 |= 1 &lt;&lt; position - 32; } else if (position &lt; 96) { ulUnicodeRange3 |= 1 &lt;&lt; position - 64; } else if (position &lt; 123) { ulUnicodeRange4 |= 1 &lt;&lt; position - 96; } else { throw new _util.FormatError(&quot;Unicode ranges Bits &gt; 123 are reserved for internal usage&quot;); } } if (lastCharIndex &gt; 0xffff) { lastCharIndex = 0xffff; } } else { firstCharIndex = 0; lastCharIndex = 255; } const bbox = properties.bbox || [0, 0, 0, 0]; const unitsPerEm = override.unitsPerEm || 1 / (properties.fontMatrix || _util.FONT_IDENTITY_MATRIX)[0]; const scale = properties.ascentScaled ? 1.0 : unitsPerEm / PDF_GLYPH_SPACE_UNITS; const typoAscent = override.ascent || Math.round(scale * (properties.ascent || bbox[3])); let typoDescent = override.descent || Math.round(scale * (properties.descent || bbox[1])); if (typoDescent &gt; 0 &amp;&amp; properties.descent &gt; 0 &amp;&amp; bbox[1] &lt; 0) { typoDescent = -typoDescent; } const winAscent = override.yMax || typoAscent; const winDescent = -override.yMin || -typoDescent; return &quot;\\x00\\x03&quot; + &quot;\\x02\\x24&quot; + &quot;\\x01\\xF4&quot; + &quot;\\x00\\x05&quot; + &quot;\\x00\\x00&quot; + &quot;\\x02\\x8A&quot; + &quot;\\x02\\xBB&quot; + &quot;\\x00\\x00&quot; + &quot;\\x00\\x8C&quot; + &quot;\\x02\\x8A&quot; + &quot;\\x02\\xBB&quot; + &quot;\\x00\\x00&quot; + &quot;\\x01\\xDF&quot; + &quot;\\x00\\x31&quot; + &quot;\\x01\\x02&quot; + &quot;\\x00\\x00&quot; + &quot;\\x00\\x00\\x06&quot; + String.fromCharCode(properties.fixedPitch ? 0x09 : 0x00) + &quot;\\x00\\x00\\x00\\x00\\x00\\x00&quot; + (0, _util.string32)(ulUnicodeRange1) + (0, _util.string32)(ulUnicodeRange2) + (0, _util.string32)(ulUnicodeRange3) + (0, _util.string32)(ulUnicodeRange4) + &quot;\\x2A\\x32\\x31\\x2A&quot; + string16(properties.italicAngle ? 1 : 0) + string16(firstCharIndex || properties.firstChar) + string16(lastCharIndex || properties.lastChar) + string16(typoAscent) + string16(typoDescent) + &quot;\\x00\\x64&quot; + string16(winAscent) + string16(winDescent) + &quot;\\x00\\x00\\x00\\x00&quot; + &quot;\\x00\\x00\\x00\\x00&quot; + string16(properties.xHeight) + string16(properties.capHeight) + string16(0) + string16(firstCharIndex || properties.firstChar) + &quot;\\x00\\x03&quot;; } function createPostTable(properties) { const angle = Math.floor(properties.italicAngle * 2 ** 16); return &quot;\\x00\\x03\\x00\\x00&quot; + (0, _util.string32)(angle) + &quot;\\x00\\x00&quot; + &quot;\\x00\\x00&quot; + (0, _util.string32)(properties.fixedPitch ? 1 : 0) + &quot;\\x00\\x00\\x00\\x00&quot; + &quot;\\x00\\x00\\x00\\x00&quot; + &quot;\\x00\\x00\\x00\\x00&quot; + &quot;\\x00\\x00\\x00\\x00&quot;; } function createPostscriptName(name) { return name.replace(/[^\\x21-\\x7E]|[[\\](){}&lt;&gt;/%]/g, &quot;&quot;).slice(0, 63); } function createNameTable(name, proto) { if (!proto) { proto = [[], []]; } const strings = [proto[0][0] || &quot;Original licence&quot;, proto[0][1] || name, proto[0][2] || &quot;Unknown&quot;, proto[0][3] || &quot;uniqueID&quot;, proto[0][4] || name, proto[0][5] || &quot;Version 0.11&quot;, proto[0][6] || createPostscriptName(name), proto[0][7] || &quot;Unknown&quot;, proto[0][8] || &quot;Unknown&quot;, proto[0][9] || &quot;Unknown&quot;]; const stringsUnicode = []; let i, ii, j, jj, str; for (i = 0, ii = strings.length; i &lt; ii; i++) { str = proto[1][i] || strings[i]; const strBufUnicode = []; for (j = 0, jj = str.length; j &lt; jj; j++) { strBufUnicode.push(string16(str.charCodeAt(j))); } stringsUnicode.push(strBufUnicode.join(&quot;&quot;)); } const names = [strings, stringsUnicode]; const platforms = [&quot;\\x00\\x01&quot;, &quot;\\x00\\x03&quot;]; const encodings = [&quot;\\x00\\x00&quot;, &quot;\\x00\\x01&quot;]; const languages = [&quot;\\x00\\x00&quot;, &quot;\\x04\\x09&quot;]; const namesRecordCount = strings.length * platforms.length; let nameTable = &quot;\\x00\\x00&quot; + string16(namesRecordCount) + string16(namesRecordCount * 12 + 6); let strOffset = 0; for (i = 0, ii = platforms.length; i &lt; ii; i++) { const strs = names[i]; for (j = 0, jj = strs.length; j &lt; jj; j++) { str = strs[j]; const nameRecord = platforms[i] + encodings[i] + languages[i] + string16(j) + string16(str.length) + string16(strOffset); nameTable += nameRecord; strOffset += str.length; } } nameTable += strings.join(&quot;&quot;) + stringsUnicode.join(&quot;&quot;); return nameTable; } class Font { constructor(name, file, properties) { this.name = name; this.psName = null; this.mimetype = null; this.disableFontFace = false; this.loadedName = properties.loadedName; this.isType3Font = properties.isType3Font; this.missingFile = false; this.cssFontInfo = properties.cssFontInfo; this._charsCache = Object.create(null); this._glyphCache = Object.create(null); let isSerifFont = !!(properties.flags &amp; _fonts_utils.FontFlags.Serif); if (!isSerifFont &amp;&amp; !properties.isSimulatedFlags) { const baseName = name.replace(/[,_]/g, &quot;-&quot;).split(&quot;-&quot;)[0], serifFonts = (0, _standard_fonts.getSerifFonts)(); for (const namePart of baseName.split(&quot;+&quot;)) { if (serifFonts[namePart]) { isSerifFont = true; break; } } } this.isSerifFont = isSerifFont; this.isSymbolicFont = !!(properties.flags &amp; _fonts_utils.FontFlags.Symbolic); this.isMonospace = !!(properties.flags &amp; _fonts_utils.FontFlags.FixedPitch); let type = properties.type; let subtype = properties.subtype; this.type = type; this.subtype = subtype; let fallbackName = &quot;sans-serif&quot;; if (this.isMonospace) { fallbackName = &quot;monospace&quot;; } else if (this.isSerifFont) { fallbackName = &quot;serif&quot;; } this.fallbackName = fallbackName; this.differences = properties.differences; this.widths = properties.widths; this.defaultWidth = properties.defaultWidth; this.composite = properties.composite; this.cMap = properties.cMap; this.capHeight = properties.capHeight / PDF_GLYPH_SPACE_UNITS; this.ascent = properties.ascent / PDF_GLYPH_SPACE_UNITS; this.descent = properties.descent / PDF_GLYPH_SPACE_UNITS; this.lineHeight = this.ascent - this.descent; this.fontMatrix = properties.fontMatrix; this.bbox = properties.bbox; this.defaultEncoding = properties.defaultEncoding; this.toUnicode = properties.toUnicode; this.toFontChar = []; if (properties.type === &quot;Type3&quot;) { for (let charCode = 0; charCode &lt; 256; charCode++) { this.toFontChar[charCode] = this.differences[charCode] || properties.defaultEncoding[charCode]; } this.fontType = _util.FontType.TYPE3; return; } this.cidEncoding = properties.cidEncoding || &quot;&quot;; this.vertical = !!properties.vertical; if (this.vertical) { this.vmetrics = properties.vmetrics; this.defaultVMetrics = properties.defaultVMetrics; } if (!file || file.isEmpty) { if (file) { (0, _util.warn)(&apos;Font file is empty in &quot;&apos; + name + &apos;&quot; (&apos; + this.loadedName + &quot;)&quot;); } this.fallbackToSystemFont(properties); return; } [type, subtype] = getFontFileType(file, properties); if (type !== this.type || subtype !== this.subtype) { (0, _util.info)(&quot;Inconsistent font file Type/SubType, expected: &quot; + `${this.type}/${this.subtype} but found: ${type}/${subtype}.`); } let data; try { switch (type) { case &quot;MMType1&quot;: (0, _util.info)(&quot;MMType1 font (&quot; + name + &quot;), falling back to Type1.&quot;); case &quot;Type1&quot;: case &quot;CIDFontType0&quot;: this.mimetype = &quot;font/opentype&quot;; const cff = subtype === &quot;Type1C&quot; || subtype === &quot;CIDFontType0C&quot; ? new _cff_font.CFFFont(file, properties) : new _type1_font.Type1Font(name, file, properties); adjustWidths(properties); data = this.convert(name, cff, properties); break; case &quot;OpenType&quot;: case &quot;TrueType&quot;: case &quot;CIDFontType2&quot;: this.mimetype = &quot;font/opentype&quot;; data = this.checkAndRepair(name, file, properties); if (this.isOpenType) { adjustWidths(properties); type = &quot;OpenType&quot;; } break; default: throw new _util.FormatError(`Font ${type} is not supported`); } } catch (e) { (0, _util.warn)(e); this.fallbackToSystemFont(properties); return; } amendFallbackToUnicode(properties); this.data = data; this.fontType = (0, _fonts_utils.getFontType)(type, subtype, properties.isStandardFont); this.fontMatrix = properties.fontMatrix; this.widths = properties.widths; this.defaultWidth = properties.defaultWidth; this.toUnicode = properties.toUnicode; this.seacMap = properties.seacMap; } get renderer() { const renderer = _font_renderer.FontRendererFactory.create(this, _fonts_utils.SEAC_ANALYSIS_ENABLED); return (0, _util.shadow)(this, &quot;renderer&quot;, renderer); } exportData(extraProperties = false) { const exportDataProperties = extraProperties ? [...EXPORT_DATA_PROPERTIES, ...EXPORT_DATA_EXTRA_PROPERTIES] : EXPORT_DATA_PROPERTIES; const data = Object.create(null); let property, value; for (property of exportDataProperties) { value = this[property]; if (value !== undefined) { data[property] = value; } } return data; } fallbackToSystemFont(properties) { this.missingFile = true; const name = this.name; const type = this.type; const subtype = this.subtype; let fontName = (0, _fonts_utils.normalizeFontName)(name); const stdFontMap = (0, _standard_fonts.getStdFontMap)(), nonStdFontMap = (0, _standard_fonts.getNonStdFontMap)(); const isStandardFont = !!stdFontMap[fontName]; const isMappedToStandardFont = !!(nonStdFontMap[fontName] &amp;&amp; stdFontMap[nonStdFontMap[fontName]]); fontName = stdFontMap[fontName] || nonStdFontMap[fontName] || fontName; const fontBasicMetricsMap = (0, _metrics.getFontBasicMetrics)(); const metrics = fontBasicMetricsMap[fontName]; if (metrics) { if (isNaN(this.ascent)) { this.ascent = metrics.ascent / PDF_GLYPH_SPACE_UNITS; } if (isNaN(this.descent)) { this.descent = metrics.descent / PDF_GLYPH_SPACE_UNITS; } if (isNaN(this.capHeight)) { this.capHeight = metrics.capHeight / PDF_GLYPH_SPACE_UNITS; } } this.bold = /bold/gi.test(fontName); this.italic = /oblique|italic/gi.test(fontName); this.black = /Black/g.test(name); const isNarrow = /Narrow/g.test(name); this.remeasure = (!isStandardFont || isNarrow) &amp;&amp; Object.keys(this.widths).length &gt; 0; if ((isStandardFont || isMappedToStandardFont) &amp;&amp; type === &quot;CIDFontType2&quot; &amp;&amp; this.cidEncoding.startsWith(&quot;Identity-&quot;)) { const cidToGidMap = properties.cidToGidMap; const map = []; applyStandardFontGlyphMap(map, (0, _standard_fonts.getGlyphMapForStandardFonts)()); if (/Arial-?Black/i.test(name)) { applyStandardFontGlyphMap(map, (0, _standard_fonts.getSupplementalGlyphMapForArialBlack)()); } else if (/Calibri/i.test(name)) { applyStandardFontGlyphMap(map, (0, _standard_fonts.getSupplementalGlyphMapForCalibri)()); } if (cidToGidMap) { for (const charCode in map) { const cid = map[charCode]; if (cidToGidMap[cid] !== undefined) { map[+charCode] = cidToGidMap[cid]; } } if (cidToGidMap.length !== this.toUnicode.length &amp;&amp; properties.hasIncludedToUnicodeMap &amp;&amp; this.toUnicode instanceof _to_unicode_map.IdentityToUnicodeMap) { this.toUnicode.forEach(function (charCode, unicodeCharCode) { const cid = map[charCode]; if (cidToGidMap[cid] === undefined) { map[+charCode] = unicodeCharCode; } }); } } if (!(this.toUnicode instanceof _to_unicode_map.IdentityToUnicodeMap)) { this.toUnicode.forEach(function (charCode, unicodeCharCode) { map[+charCode] = unicodeCharCode; }); } this.toFontChar = map; this.toUnicode = new _to_unicode_map.ToUnicodeMap(map); } else if (/Symbol/i.test(fontName)) { this.toFontChar = buildToFontChar(_encodings.SymbolSetEncoding, (0, _glyphlist.getGlyphsUnicode)(), this.differences); } else if (/Dingbats/i.test(fontName)) { if (/Wingdings/i.test(name)) { (0, _util.warn)(&quot;Non-embedded Wingdings font, falling back to ZapfDingbats.&quot;); } this.toFontChar = buildToFontChar(_encodings.ZapfDingbatsEncoding, (0, _glyphlist.getDingbatsGlyphsUnicode)(), this.differences); } else if (isStandardFont) { const map = buildToFontChar(this.defaultEncoding, (0, _glyphlist.getGlyphsUnicode)(), this.differences); if (type === &quot;CIDFontType2&quot; &amp;&amp; !this.cidEncoding.startsWith(&quot;Identity-&quot;) &amp;&amp; !(this.toUnicode instanceof _to_unicode_map.IdentityToUnicodeMap)) { this.toUnicode.forEach(function (charCode, unicodeCharCode) { map[+charCode] = unicodeCharCode; }); } this.toFontChar = map; } else { const glyphsUnicodeMap = (0, _glyphlist.getGlyphsUnicode)(); const map = []; this.toUnicode.forEach((charCode, unicodeCharCode) =&gt; { if (!this.composite) { const glyphName = this.differences[charCode] || this.defaultEncoding[charCode]; const unicode = (0, _unicode.getUnicodeForGlyph)(glyphName, glyphsUnicodeMap); if (unicode !== -1) { unicodeCharCode = unicode; } } map[+charCode] = unicodeCharCode; }); if (this.composite &amp;&amp; this.toUnicode instanceof _to_unicode_map.IdentityToUnicodeMap) { if (/Verdana/i.test(name)) { applyStandardFontGlyphMap(map, (0, _standard_fonts.getGlyphMapForStandardFonts)()); } } this.toFontChar = map; } amendFallbackToUnicode(properties); this.loadedName = fontName.split(&quot;-&quot;)[0]; this.fontType = (0, _fonts_utils.getFontType)(type, subtype, properties.isStandardFont); } checkAndRepair(name, font, properties) { const VALID_TABLES = [&quot;OS/2&quot;, &quot;cmap&quot;, &quot;head&quot;, &quot;hhea&quot;, &quot;hmtx&quot;, &quot;maxp&quot;, &quot;name&quot;, &quot;post&quot;, &quot;loca&quot;, &quot;glyf&quot;, &quot;fpgm&quot;, &quot;prep&quot;, &quot;cvt &quot;, &quot;CFF &quot;]; function readTables(file, numTables) { const tables = Object.create(null); tables[&quot;OS/2&quot;] = null; tables.cmap = null; tables.head = null; tables.hhea = null; tables.hmtx = null; tables.maxp = null; tables.name = null; tables.post = null; for (let i = 0; i &lt; numTables; i++) { const table = readTableEntry(file); if (!VALID_TABLES.includes(table.tag)) { continue; } if (table.length === 0) { continue; } tables[table.tag] = table; } return tables; } function readTableEntry(file) { const tag = file.getString(4); const checksum = file.getInt32() &gt;&gt;&gt; 0; const offset = file.getInt32() &gt;&gt;&gt; 0; const length = file.getInt32() &gt;&gt;&gt; 0; const previousPosition = file.pos; file.pos = file.start || 0; file.skip(offset); const data = file.getBytes(length); file.pos = previousPosition; if (tag === &quot;head&quot;) { data[8] = data[9] = data[10] = data[11] = 0; data[17] |= 0x20; } return { tag, checksum, length, offset, data }; } function readOpenTypeHeader(ttf) { return { version: ttf.getString(4), numTables: ttf.getUint16(), searchRange: ttf.getUint16(), entrySelector: ttf.getUint16(), rangeShift: ttf.getUint16() }; } function readTrueTypeCollectionHeader(ttc) { const ttcTag = ttc.getString(4); (0, _util.assert)(ttcTag === &quot;ttcf&quot;, &quot;Must be a TrueType Collection font.&quot;); const majorVersion = ttc.getUint16(); const minorVersion = ttc.getUint16(); const numFonts = ttc.getInt32() &gt;&gt;&gt; 0; const offsetTable = []; for (let i = 0; i &lt; numFonts; i++) { offsetTable.push(ttc.getInt32() &gt;&gt;&gt; 0); } const header = { ttcTag, majorVersion, minorVersion, numFonts, offsetTable }; switch (majorVersion) { case 1: return header; case 2: header.dsigTag = ttc.getInt32() &gt;&gt;&gt; 0; header.dsigLength = ttc.getInt32() &gt;&gt;&gt; 0; header.dsigOffset = ttc.getInt32() &gt;&gt;&gt; 0; return header; } throw new _util.FormatError(`Invalid TrueType Collection majorVersion: ${majorVersion}.`); } function readTrueTypeCollectionData(ttc, fontName) { const { numFonts, offsetTable } = readTrueTypeCollectionHeader(ttc); const fontNameParts = fontName.split(&quot;+&quot;); let fallbackData; for (let i = 0; i &lt; numFonts; i++) { ttc.pos = (ttc.start || 0) + offsetTable[i]; const potentialHeader = readOpenTypeHeader(ttc); const potentialTables = readTables(ttc, potentialHeader.numTables); if (!potentialTables.name) { throw new _util.FormatError(&apos;TrueType Collection font must contain a &quot;name&quot; table.&apos;); } const nameTable = readNameTable(potentialTables.name); for (let j = 0, jj = nameTable.length; j &lt; jj; j++) { for (let k = 0, kk = nameTable[j].length; k &lt; kk; k++) { const nameEntry = nameTable[j][k] &amp;&amp; nameTable[j][k].replace(/\\s/g, &quot;&quot;); if (!nameEntry) { continue; } if (nameEntry === fontName) { return { header: potentialHeader, tables: potentialTables }; } if (fontNameParts.length &lt; 2) { continue; } for (const part of fontNameParts) { if (nameEntry === part) { fallbackData = { name: part, header: potentialHeader, tables: potentialTables }; } } } } } if (fallbackData) { (0, _util.warn)(`TrueType Collection does not contain &quot;${fontName}&quot; font, ` + `falling back to &quot;${fallbackData.name}&quot; font instead.`); return { header: fallbackData.header, tables: fallbackData.tables }; } throw new _util.FormatError(`TrueType Collection does not contain &quot;${fontName}&quot; font.`); } function readCmapTable(cmap, file, isSymbolicFont, hasEncoding) { if (!cmap) { (0, _util.warn)(&quot;No cmap table available.&quot;); return { platformId: -1, encodingId: -1, mappings: [], hasShortCmap: false }; } let segment; let start = (file.start || 0) + cmap.offset; file.pos = start; file.skip(2); const numTables = file.getUint16(); let potentialTable; let canBreak = false; for (let i = 0; i &lt; numTables; i++) { const platformId = file.getUint16(); const encodingId = file.getUint16(); const offset = file.getInt32() &gt;&gt;&gt; 0; let useTable = false; if (potentialTable &amp;&amp; potentialTable.platformId === platformId &amp;&amp; potentialTable.encodingId === encodingId) { continue; } if (platformId === 0 &amp;&amp; (encodingId === 0 || encodingId === 1 || encodingId === 3)) { useTable = true; } else if (platformId === 1 &amp;&amp; encodingId === 0) { useTable = true; } else if (platformId === 3 &amp;&amp; encodingId === 1 &amp;&amp; (hasEncoding || !potentialTable)) { useTable = true; if (!isSymbolicFont) { canBreak = true; } } else if (isSymbolicFont &amp;&amp; platformId === 3 &amp;&amp; encodingId === 0) { useTable = true; let correctlySorted = true; if (i &lt; numTables - 1) { const nextBytes = file.peekBytes(2), nextPlatformId = int16(nextBytes[0], nextBytes[1]); if (nextPlatformId &lt; platformId) { correctlySorted = false; } } if (correctlySorted) { canBreak = true; } } if (useTable) { potentialTable = { platformId, encodingId, offset }; } if (canBreak) { break; } } if (potentialTable) { file.pos = start + potentialTable.offset; } if (!potentialTable || file.peekByte() === -1) { (0, _util.warn)(&quot;Could not find a preferred cmap table.&quot;); return { platformId: -1, encodingId: -1, mappings: [], hasShortCmap: false }; } const format = file.getUint16(); let hasShortCmap = false; const mappings = []; let j, glyphId; if (format === 0) { file.skip(2 + 2); for (j = 0; j &lt; 256; j++) { const index = file.getByte(); if (!index) { continue; } mappings.push({ charCode: j, glyphId: index }); } hasShortCmap = true; } else if (format === 2) { file.skip(2 + 2); const subHeaderKeys = []; let maxSubHeaderKey = 0; for (let i = 0; i &lt; 256; i++) { const subHeaderKey = file.getUint16() &gt;&gt; 3; subHeaderKeys.push(subHeaderKey); maxSubHeaderKey = Math.max(subHeaderKey, maxSubHeaderKey); } const subHeaders = []; for (let i = 0; i &lt;= maxSubHeaderKey; i++) { subHeaders.push({ firstCode: file.getUint16(), entryCount: file.getUint16(), idDelta: signedInt16(file.getByte(), file.getByte()), idRangePos: file.pos + file.getUint16() }); } for (let i = 0; i &lt; 256; i++) { if (subHeaderKeys[i] === 0) { file.pos = subHeaders[0].idRangePos + 2 * i; glyphId = file.getUint16(); mappings.push({ charCode: i, glyphId }); } else { const s = subHeaders[subHeaderKeys[i]]; for (j = 0; j &lt; s.entryCount; j++) { const charCode = (i &lt;&lt; 8) + j + s.firstCode; file.pos = s.idRangePos + 2 * j; glyphId = file.getUint16(); if (glyphId !== 0) { glyphId = (glyphId + s.idDelta) % 65536; } mappings.push({ charCode, glyphId }); } } } } else if (format === 4) { file.skip(2 + 2); const segCount = file.getUint16() &gt;&gt; 1; file.skip(6); const segments = []; let segIndex; for (segIndex = 0; segIndex &lt; segCount; segIndex++) { segments.push({ end: file.getUint16() }); } file.skip(2); for (segIndex = 0; segIndex &lt; segCount; segIndex++) { segments[segIndex].start = file.getUint16(); } for (segIndex = 0; segIndex &lt; segCount; segIndex++) { segments[segIndex].delta = file.getUint16(); } let offsetsCount = 0, offsetIndex; for (segIndex = 0; segIndex &lt; segCount; segIndex++) { segment = segments[segIndex]; const rangeOffset = file.getUint16(); if (!rangeOffset) { segment.offsetIndex = -1; continue; } offsetIndex = (rangeOffset &gt;&gt; 1) - (segCount - segIndex); segment.offsetIndex = offsetIndex; offsetsCount = Math.max(offsetsCount, offsetIndex + segment.end - segment.start + 1); } const offsets = []; for (j = 0; j &lt; offsetsCount; j++) { offsets.push(file.getUint16()); } for (segIndex = 0; segIndex &lt; segCount; segIndex++) { segment = segments[segIndex]; start = segment.start; const end = segment.end; const delta = segment.delta; offsetIndex = segment.offsetIndex; for (j = start; j &lt;= end; j++) { if (j === 0xffff) { continue; } glyphId = offsetIndex &lt; 0 ? j : offsets[offsetIndex + j - start]; glyphId = glyphId + delta &amp; 0xffff; mappings.push({ charCode: j, glyphId }); } } } else if (format === 6) { file.skip(2 + 2); const firstCode = file.getUint16(); const entryCount = file.getUint16(); for (j = 0; j &lt; entryCount; j++) { glyphId = file.getUint16(); const charCode = firstCode + j; mappings.push({ charCode, glyphId }); } } else if (format === 12) { file.skip(2 + 4 + 4); const nGroups = file.getInt32() &gt;&gt;&gt; 0; for (j = 0; j &lt; nGroups; j++) { const startCharCode = file.getInt32() &gt;&gt;&gt; 0; const endCharCode = file.getInt32() &gt;&gt;&gt; 0; let glyphCode = file.getInt32() &gt;&gt;&gt; 0; for (let charCode = startCharCode; charCode &lt;= endCharCode; charCode++) { mappings.push({ charCode, glyphId: glyphCode++ }); } } } else { (0, _util.warn)(&quot;cmap table has unsupported format: &quot; + format); return { platformId: -1, encodingId: -1, mappings: [], hasShortCmap: false }; } mappings.sort(function (a, b) { return a.charCode - b.charCode; }); for (let i = 1; i &lt; mappings.length; i++) { if (mappings[i - 1].charCode === mappings[i].charCode) { mappings.splice(i, 1); i--; } } return { platformId: potentialTable.platformId, encodingId: potentialTable.encodingId, mappings, hasShortCmap }; } function sanitizeMetrics(file, header, metrics, headTable, numGlyphs, dupFirstEntry) { if (!header) { if (metrics) { metrics.data = null; } return; } file.pos = (file.start || 0) + header.offset; file.pos += 4; file.pos += 2; file.pos += 2; file.pos += 2; file.pos += 2; file.pos += 2; file.pos += 2; file.pos += 2; file.pos += 2; file.pos += 2; const caretOffset = file.getUint16(); file.pos += 8; file.pos += 2; let numOfMetrics = file.getUint16(); if (caretOffset !== 0) { const macStyle = int16(headTable.data[44], headTable.data[45]); if (!(macStyle &amp; 2)) { header.data[22] = 0; header.data[23] = 0; } } if (numOfMetrics &gt; numGlyphs) { (0, _util.info)(`The numOfMetrics (${numOfMetrics}) should not be ` + `greater than the numGlyphs (${numGlyphs}).`); numOfMetrics = numGlyphs; header.data[34] = (numOfMetrics &amp; 0xff00) &gt;&gt; 8; header.data[35] = numOfMetrics &amp; 0x00ff; } const numOfSidebearings = numGlyphs - numOfMetrics; const numMissing = numOfSidebearings - (metrics.length - numOfMetrics * 4 &gt;&gt; 1); if (numMissing &gt; 0) { const entries = new Uint8Array(metrics.length + numMissing * 2); entries.set(metrics.data); if (dupFirstEntry) { entries[metrics.length] = metrics.data[2]; entries[metrics.length + 1] = metrics.data[3]; } metrics.data = entries; } } function sanitizeGlyph(source, sourceStart, sourceEnd, dest, destStart, hintsValid) { const glyphProfile = { length: 0, sizeOfInstructions: 0 }; if (sourceEnd - sourceStart &lt;= 12) { return glyphProfile; } const glyf = source.subarray(sourceStart, sourceEnd); let contoursCount = signedInt16(glyf[0], glyf[1]); if (contoursCount &lt; 0) { contoursCount = -1; writeSignedInt16(glyf, 0, contoursCount); dest.set(glyf, destStart); glyphProfile.length = glyf.length; return glyphProfile; } let i, j = 10, flagsCount = 0; for (i = 0; i &lt; contoursCount; i++) { const endPoint = glyf[j] &lt;&lt; 8 | glyf[j + 1]; flagsCount = endPoint + 1; j += 2; } const instructionsStart = j; const instructionsLength = glyf[j] &lt;&lt; 8 | glyf[j + 1]; glyphProfile.sizeOfInstructions = instructionsLength; j += 2 + instructionsLength; const instructionsEnd = j; let coordinatesLength = 0; for (i = 0; i &lt; flagsCount; i++) { const flag = glyf[j++]; if (flag &amp; 0xc0) { glyf[j - 1] = flag &amp; 0x3f; } let xLength = 2; if (flag &amp; 2) { xLength = 1; } else if (flag &amp; 16) { xLength = 0; } let yLength = 2; if (flag &amp; 4) { yLength = 1; } else if (flag &amp; 32) { yLength = 0; } const xyLength = xLength + yLength; coordinatesLength += xyLength; if (flag &amp; 8) { const repeat = glyf[j++]; i += repeat; coordinatesLength += repeat * xyLength; } } if (coordinatesLength === 0) { return glyphProfile; } let glyphDataLength = j + coordinatesLength; if (glyphDataLength &gt; glyf.length) { return glyphProfile; } if (!hintsValid &amp;&amp; instructionsLength &gt; 0) { dest.set(glyf.subarray(0, instructionsStart), destStart); dest.set([0, 0], destStart + instructionsStart); dest.set(glyf.subarray(instructionsEnd, glyphDataLength), destStart + instructionsStart + 2); glyphDataLength -= instructionsLength; if (glyf.length - glyphDataLength &gt; 3) { glyphDataLength = glyphDataLength + 3 &amp; ~3; } glyphProfile.length = glyphDataLength; return glyphProfile; } if (glyf.length - glyphDataLength &gt; 3) { glyphDataLength = glyphDataLength + 3 &amp; ~3; dest.set(glyf.subarray(0, glyphDataLength), destStart); glyphProfile.length = glyphDataLength; return glyphProfile; } dest.set(glyf, destStart); glyphProfile.length = glyf.length; return glyphProfile; } function sanitizeHead(head, numGlyphs, locaLength) { const data = head.data; const version = int32(data[0], data[1], data[2], data[3]); if (version &gt;&gt; 16 !== 1) { (0, _util.info)(&quot;Attempting to fix invalid version in head table: &quot; + version); data[0] = 0; data[1] = 1; data[2] = 0; data[3] = 0; } const indexToLocFormat = int16(data[50], data[51]); if (indexToLocFormat &lt; 0 || indexToLocFormat &gt; 1) { (0, _util.info)(&quot;Attempting to fix invalid indexToLocFormat in head table: &quot; + indexToLocFormat); const numGlyphsPlusOne = numGlyphs + 1; if (locaLength === numGlyphsPlusOne &lt;&lt; 1) { data[50] = 0; data[51] = 0; } else if (locaLength === numGlyphsPlusOne &lt;&lt; 2) { data[50] = 0; data[51] = 1; } else { throw new _util.FormatError(&quot;Could not fix indexToLocFormat: &quot; + indexToLocFormat); } } } function sanitizeGlyphLocations(loca, glyf, numGlyphs, isGlyphLocationsLong, hintsValid, dupFirstEntry, maxSizeOfInstructions) { let itemSize, itemDecode, itemEncode; if (isGlyphLocationsLong) { itemSize = 4; itemDecode = function fontItemDecodeLong(data, offset) { return data[offset] &lt;&lt; 24 | data[offset + 1] &lt;&lt; 16 | data[offset + 2] &lt;&lt; 8 | data[offset + 3]; }; itemEncode = function fontItemEncodeLong(data, offset, value) { data[offset] = value &gt;&gt;&gt; 24 &amp; 0xff; data[offset + 1] = value &gt;&gt; 16 &amp; 0xff; data[offset + 2] = value &gt;&gt; 8 &amp; 0xff; data[offset + 3] = value &amp; 0xff; }; } else { itemSize = 2; itemDecode = function fontItemDecode(data, offset) { return data[offset] &lt;&lt; 9 | data[offset + 1] &lt;&lt; 1; }; itemEncode = function fontItemEncode(data, offset, value) { data[offset] = value &gt;&gt; 9 &amp; 0xff; data[offset + 1] = value &gt;&gt; 1 &amp; 0xff; }; } const numGlyphsOut = dupFirstEntry ? numGlyphs + 1 : numGlyphs; const locaDataSize = itemSize * (1 + numGlyphsOut); const locaData = new Uint8Array(locaDataSize); locaData.set(loca.data.subarray(0, locaDataSize)); loca.data = locaData; const oldGlyfData = glyf.data; const oldGlyfDataLength = oldGlyfData.length; const newGlyfData = new Uint8Array(oldGlyfDataLength); let i, j; const locaEntries = []; for (i = 0, j = 0; i &lt; numGlyphs + 1; i++, j += itemSize) { let offset = itemDecode(locaData, j); if (offset &gt; oldGlyfDataLength) { offset = oldGlyfDataLength; } locaEntries.push({ index: i, offset, endOffset: 0 }); } locaEntries.sort((a, b) =&gt; { return a.offset - b.offset; }); for (i = 0; i &lt; numGlyphs; i++) { locaEntries[i].endOffset = locaEntries[i + 1].offset; } locaEntries.sort((a, b) =&gt; { return a.index - b.index; }); for (i = 0; i &lt; numGlyphs; i++) { const { offset, endOffset } = locaEntries[i]; if (offset !== 0 || endOffset !== 0) { break; } const nextOffset = locaEntries[i + 1].offset; if (nextOffset === 0) { continue; } locaEntries[i].endOffset = nextOffset; break; } const missingGlyphs = Object.create(null); let writeOffset = 0; itemEncode(locaData, 0, writeOffset); for (i = 0, j = itemSize; i &lt; numGlyphs; i++, j += itemSize) { const glyphProfile = sanitizeGlyph(oldGlyfData, locaEntries[i].offset, locaEntries[i].endOffset, newGlyfData, writeOffset, hintsValid); const newLength = glyphProfile.length; if (newLength === 0) { missingGlyphs[i] = true; } if (glyphProfile.sizeOfInstructions &gt; maxSizeOfInstructions) { maxSizeOfInstructions = glyphProfile.sizeOfInstructions; } writeOffset += newLength; itemEncode(locaData, j, writeOffset); } if (writeOffset === 0) { const simpleGlyph = new Uint8Array([0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 49, 0]); for (i = 0, j = itemSize; i &lt; numGlyphsOut; i++, j += itemSize) { itemEncode(locaData, j, simpleGlyph.length); } glyf.data = simpleGlyph; } else if (dupFirstEntry) { const firstEntryLength = itemDecode(locaData, itemSize); if (newGlyfData.length &gt; firstEntryLength + writeOffset) { glyf.data = newGlyfData.subarray(0, firstEntryLength + writeOffset); } else { glyf.data = new Uint8Array(firstEntryLength + writeOffset); glyf.data.set(newGlyfData.subarray(0, writeOffset)); } glyf.data.set(newGlyfData.subarray(0, firstEntryLength), writeOffset); itemEncode(loca.data, locaData.length - itemSize, writeOffset + firstEntryLength); } else { glyf.data = newGlyfData.subarray(0, writeOffset); } return { missingGlyphs, maxSizeOfInstructions }; } function readPostScriptTable(post, propertiesObj, maxpNumGlyphs) { const start = (font.start || 0) + post.offset; font.pos = start; const length = post.length, end = start + length; const version = font.getInt32(); font.skip(28); let glyphNames; let valid = true; let i; switch (version) { case 0x00010000: glyphNames = _fonts_utils.MacStandardGlyphOrdering; break; case 0x00020000: const numGlyphs = font.getUint16(); if (numGlyphs !== maxpNumGlyphs) { valid = false; break; } const glyphNameIndexes = []; for (i = 0; i &lt; numGlyphs; ++i) { const index = font.getUint16(); if (index &gt;= 32768) { valid = false; break; } glyphNameIndexes.push(index); } if (!valid) { break; } const customNames = [], strBuf = []; while (font.pos &lt; end) { const stringLength = font.getByte(); strBuf.length = stringLength; for (i = 0; i &lt; stringLength; ++i) { strBuf[i] = String.fromCharCode(font.getByte()); } customNames.push(strBuf.join(&quot;&quot;)); } glyphNames = []; for (i = 0; i &lt; numGlyphs; ++i) { const j = glyphNameIndexes[i]; if (j &lt; 258) { glyphNames.push(_fonts_utils.MacStandardGlyphOrdering[j]); continue; } glyphNames.push(customNames[j - 258]); } break; case 0x00030000: break; default: (0, _util.warn)(&quot;Unknown/unsupported post table version &quot; + version); valid = false; if (propertiesObj.defaultEncoding) { glyphNames = propertiesObj.defaultEncoding; } break; } propertiesObj.glyphNames = glyphNames; return valid; } function readNameTable(nameTable) { const start = (font.start || 0) + nameTable.offset; font.pos = start; const names = [[], []]; const length = nameTable.length, end = start + length; const format = font.getUint16(); const FORMAT_0_HEADER_LENGTH = 6; if (format !== 0 || length &lt; FORMAT_0_HEADER_LENGTH) { return names; } const numRecords = font.getUint16(); const stringsStart = font.getUint16(); const records = []; const NAME_RECORD_LENGTH = 12; let i, ii; for (i = 0; i &lt; numRecords &amp;&amp; font.pos + NAME_RECORD_LENGTH &lt;= end; i++) { const r = { platform: font.getUint16(), encoding: font.getUint16(), language: font.getUint16(), name: font.getUint16(), length: font.getUint16(), offset: font.getUint16() }; if (r.platform === 1 &amp;&amp; r.encoding === 0 &amp;&amp; r.language === 0 || r.platform === 3 &amp;&amp; r.encoding === 1 &amp;&amp; r.language === 0x409) { records.push(r); } } for (i = 0, ii = records.length; i &lt; ii; i++) { const record = records[i]; if (record.length &lt;= 0) { continue; } const pos = start + stringsStart + record.offset; if (pos + record.length &gt; end) { continue; } font.pos = pos; const nameIndex = record.name; if (record.encoding) { let str = &quot;&quot;; for (let j = 0, jj = record.length; j &lt; jj; j += 2) { str += String.fromCharCode(font.getUint16()); } names[1][nameIndex] = str; } else { names[0][nameIndex] = font.getString(record.length); } } return names; } const TTOpsStackDeltas = [0, 0, 0, 0, 0, 0, 0, 0, -2, -2, -2, -2, 0, 0, -2, -5, -1, -1, -1, -1, -1, -1, -1, -1, 0, 0, -1, 0, -1, -1, -1, -1, 1, -1, -999, 0, 1, 0, -1, -2, 0, -1, -2, -1, -1, 0, -1, -1, 0, 0, -999, -999, -1, -1, -1, -1, -2, -999, -2, -2, -999, 0, -2, -2, 0, 0, -2, 0, -2, 0, 0, 0, -2, -1, -1, 1, 1, 0, 0, -1, -1, -1, -1, -1, -1, -1, 0, 0, -1, 0, -1, -1, 0, -999, -1, -1, -1, -1, -1, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -2, -999, -999, -999, -999, -999, -1, -1, -2, -2, 0, 0, 0, 0, -1, -1, -999, -2, -2, 0, 0, -1, -2, -2, 0, 0, 0, -1, -1, -1, -2]; function sanitizeTTProgram(table, ttContext) { let data = table.data; let i = 0, j, n, b, funcId, pc, lastEndf = 0, lastDeff = 0; const stack = []; const callstack = []; const functionsCalled = []; let tooComplexToFollowFunctions = ttContext.tooComplexToFollowFunctions; let inFDEF = false, ifLevel = 0, inELSE = 0; for (let ii = data.length; i &lt; ii;) { const op = data[i++]; if (op === 0x40) { n = data[i++]; if (inFDEF || inELSE) { i += n; } else { for (j = 0; j &lt; n; j++) { stack.push(data[i++]); } } } else if (op === 0x41) { n = data[i++]; if (inFDEF || inELSE) { i += n * 2; } else { for (j = 0; j &lt; n; j++) { b = data[i++]; stack.push(b &lt;&lt; 8 | data[i++]); } } } else if ((op &amp; 0xf8) === 0xb0) { n = op - 0xb0 + 1; if (inFDEF || inELSE) { i += n; } else { for (j = 0; j &lt; n; j++) { stack.push(data[i++]); } } } else if ((op &amp; 0xf8) === 0xb8) { n = op - 0xb8 + 1; if (inFDEF || inELSE) { i += n * 2; } else { for (j = 0; j &lt; n; j++) { b = data[i++]; stack.push(b &lt;&lt; 8 | data[i++]); } } } else if (op === 0x2b &amp;&amp; !tooComplexToFollowFunctions) { if (!inFDEF &amp;&amp; !inELSE) { funcId = stack.at(-1); if (isNaN(funcId)) { (0, _util.info)(&quot;TT: CALL empty stack (or invalid entry).&quot;); } else { ttContext.functionsUsed[funcId] = true; if (funcId in ttContext.functionsStackDeltas) { const newStackLength = stack.length + ttContext.functionsStackDeltas[funcId]; if (newStackLength &lt; 0) { (0, _util.warn)(&quot;TT: CALL invalid functions stack delta.&quot;); ttContext.hintsValid = false; return; } stack.length = newStackLength; } else if (funcId in ttContext.functionsDefined &amp;&amp; !functionsCalled.includes(funcId)) { callstack.push({ data, i, stackTop: stack.length - 1 }); functionsCalled.push(funcId); pc = ttContext.functionsDefined[funcId]; if (!pc) { (0, _util.warn)(&quot;TT: CALL non-existent function&quot;); ttContext.hintsValid = false; return; } data = pc.data; i = pc.i; } } } } else if (op === 0x2c &amp;&amp; !tooComplexToFollowFunctions) { if (inFDEF || inELSE) { (0, _util.warn)(&quot;TT: nested FDEFs not allowed&quot;); tooComplexToFollowFunctions = true; } inFDEF = true; lastDeff = i; funcId = stack.pop(); ttContext.functionsDefined[funcId] = { data, i }; } else if (op === 0x2d) { if (inFDEF) { inFDEF = false; lastEndf = i; } else { pc = callstack.pop(); if (!pc) { (0, _util.warn)(&quot;TT: ENDF bad stack&quot;); ttContext.hintsValid = false; return; } funcId = functionsCalled.pop(); data = pc.data; i = pc.i; ttContext.functionsStackDeltas[funcId] = stack.length - pc.stackTop; } } else if (op === 0x89) { if (inFDEF || inELSE) { (0, _util.warn)(&quot;TT: nested IDEFs not allowed&quot;); tooComplexToFollowFunctions = true; } inFDEF = true; lastDeff = i; } else if (op === 0x58) { ++ifLevel; } else if (op === 0x1b) { inELSE = ifLevel; } else if (op === 0x59) { if (inELSE === ifLevel) { inELSE = 0; } --ifLevel; } else if (op === 0x1c) { if (!inFDEF &amp;&amp; !inELSE) { const offset = stack.at(-1); if (offset &gt; 0) { i += offset - 1; } } } if (!inFDEF &amp;&amp; !inELSE) { let stackDelta = 0; if (op &lt;= 0x8e) { stackDelta = TTOpsStackDeltas[op]; } else if (op &gt;= 0xc0 &amp;&amp; op &lt;= 0xdf) { stackDelta = -1; } else if (op &gt;= 0xe0) { stackDelta = -2; } if (op &gt;= 0x71 &amp;&amp; op &lt;= 0x75) { n = stack.pop(); if (!isNaN(n)) { stackDelta = -n * 2; } } while (stackDelta &lt; 0 &amp;&amp; stack.length &gt; 0) { stack.pop(); stackDelta++; } while (stackDelta &gt; 0) { stack.push(NaN); stackDelta--; } } } ttContext.tooComplexToFollowFunctions = tooComplexToFollowFunctions; const content = [data]; if (i &gt; data.length) { content.push(new Uint8Array(i - data.length)); } if (lastDeff &gt; lastEndf) { (0, _util.warn)(&quot;TT: complementing a missing function tail&quot;); content.push(new Uint8Array([0x22, 0x2d])); } foldTTTable(table, content); } function checkInvalidFunctions(ttContext, maxFunctionDefs) { if (ttContext.tooComplexToFollowFunctions) { return; } if (ttContext.functionsDefined.length &gt; maxFunctionDefs) { (0, _util.warn)(&quot;TT: more functions defined than expected&quot;); ttContext.hintsValid = false; return; } for (let j = 0, jj = ttContext.functionsUsed.length; j &lt; jj; j++) { if (j &gt; maxFunctionDefs) { (0, _util.warn)(&quot;TT: invalid function id: &quot; + j); ttContext.hintsValid = false; return; } if (ttContext.functionsUsed[j] &amp;&amp; !ttContext.functionsDefined[j]) { (0, _util.warn)(&quot;TT: undefined function: &quot; + j); ttContext.hintsValid = false; return; } } } function foldTTTable(table, content) { if (content.length &gt; 1) { let newLength = 0; let j, jj; for (j = 0, jj = content.length; j &lt; jj; j++) { newLength += content[j].length; } newLength = newLength + 3 &amp; ~3; const result = new Uint8Array(newLength); let pos = 0; for (j = 0, jj = content.length; j &lt; jj; j++) { result.set(content[j], pos); pos += content[j].length; } table.data = result; table.length = newLength; } } function sanitizeTTPrograms(fpgm, prep, cvt, maxFunctionDefs) { const ttContext = { functionsDefined: [], functionsUsed: [], functionsStackDeltas: [], tooComplexToFollowFunctions: false, hintsValid: true }; if (fpgm) { sanitizeTTProgram(fpgm, ttContext); } if (prep) { sanitizeTTProgram(prep, ttContext); } if (fpgm) { checkInvalidFunctions(ttContext, maxFunctionDefs); } if (cvt &amp;&amp; cvt.length &amp; 1) { const cvtData = new Uint8Array(cvt.length + 1); cvtData.set(cvt.data); cvt.data = cvtData; } return ttContext.hintsValid; } font = new _stream.Stream(new Uint8Array(font.getBytes())); let header, tables; if (isTrueTypeCollectionFile(font)) { const ttcData = readTrueTypeCollectionData(font, this.name); header = ttcData.header; tables = ttcData.tables; } else { header = readOpenTypeHeader(font); tables = readTables(font, header.numTables); } let cff, cffFile; const isTrueType = !tables[&quot;CFF &quot;]; if (!isTrueType) { const isComposite = properties.composite &amp;&amp; ((properties.cidToGidMap || []).length &gt; 0 || !(properties.cMap instanceof _cmap.IdentityCMap)); if (header.version === &quot;OTTO&quot; &amp;&amp; !isComposite || !tables.head || !tables.hhea || !tables.maxp || !tables.post) { cffFile = new _stream.Stream(tables[&quot;CFF &quot;].data); cff = new _cff_font.CFFFont(cffFile, properties); adjustWidths(properties); return this.convert(name, cff, properties); } delete tables.glyf; delete tables.loca; delete tables.fpgm; delete tables.prep; delete tables[&quot;cvt &quot;]; this.isOpenType = true; } else { if (!tables.loca) { throw new _util.FormatError(&apos;Required &quot;loca&quot; table is not found&apos;); } if (!tables.glyf) { (0, _util.warn)(&apos;Required &quot;glyf&quot; table is not found -- trying to recover.&apos;); tables.glyf = { tag: &quot;glyf&quot;, data: new Uint8Array(0) }; } this.isOpenType = false; } if (!tables.maxp) { throw new _util.FormatError(&apos;Required &quot;maxp&quot; table is not found&apos;); } font.pos = (font.start || 0) + tables.maxp.offset; const version = font.getInt32(); const numGlyphs = font.getUint16(); if (properties.scaleFactors &amp;&amp; properties.scaleFactors.length === numGlyphs &amp;&amp; isTrueType) { const { scaleFactors } = properties; const isGlyphLocationsLong = int16(tables.head.data[50], tables.head.data[51]); const glyphs = new _glyf.GlyfTable({ glyfTable: tables.glyf.data, isGlyphLocationsLong, locaTable: tables.loca.data, numGlyphs }); glyphs.scale(scaleFactors); const { glyf, loca, isLocationLong } = glyphs.write(); tables.glyf.data = glyf; tables.loca.data = loca; if (isLocationLong !== !!isGlyphLocationsLong) { tables.head.data[50] = 0; tables.head.data[51] = isLocationLong ? 1 : 0; } const metrics = tables.hmtx.data; for (let i = 0; i &lt; numGlyphs; i++) { const j = 4 * i; const advanceWidth = Math.round(scaleFactors[i] * int16(metrics[j], metrics[j + 1])); metrics[j] = advanceWidth &gt;&gt; 8 &amp; 0xff; metrics[j + 1] = advanceWidth &amp; 0xff; const lsb = Math.round(scaleFactors[i] * signedInt16(metrics[j + 2], metrics[j + 3])); writeSignedInt16(metrics, j + 2, lsb); } } let numGlyphsOut = numGlyphs + 1; let dupFirstEntry = true; if (numGlyphsOut &gt; 0xffff) { dupFirstEntry = false; numGlyphsOut = numGlyphs; (0, _util.warn)(&quot;Not enough space in glyfs to duplicate first glyph.&quot;); } let maxFunctionDefs = 0; let maxSizeOfInstructions = 0; if (version &gt;= 0x00010000 &amp;&amp; tables.maxp.length &gt;= 22) { font.pos += 8; const maxZones = font.getUint16(); if (maxZones &gt; 2) { tables.maxp.data[14] = 0; tables.maxp.data[15] = 2; } font.pos += 4; maxFunctionDefs = font.getUint16(); font.pos += 4; maxSizeOfInstructions = font.getUint16(); } tables.maxp.data[4] = numGlyphsOut &gt;&gt; 8; tables.maxp.data[5] = numGlyphsOut &amp; 255; const hintsValid = sanitizeTTPrograms(tables.fpgm, tables.prep, tables[&quot;cvt &quot;], maxFunctionDefs); if (!hintsValid) { delete tables.fpgm; delete tables.prep; delete tables[&quot;cvt &quot;]; } sanitizeMetrics(font, tables.hhea, tables.hmtx, tables.head, numGlyphsOut, dupFirstEntry); if (!tables.head) { throw new _util.FormatError(&apos;Required &quot;head&quot; table is not found&apos;); } sanitizeHead(tables.head, numGlyphs, isTrueType ? tables.loca.length : 0); let missingGlyphs = Object.create(null); if (isTrueType) { const isGlyphLocationsLong = int16(tables.head.data[50], tables.head.data[51]); const glyphsInfo = sanitizeGlyphLocations(tables.loca, tables.glyf, numGlyphs, isGlyphLocationsLong, hintsValid, dupFirstEntry, maxSizeOfInstructions); missingGlyphs = glyphsInfo.missingGlyphs; if (version &gt;= 0x00010000 &amp;&amp; tables.maxp.length &gt;= 22) { tables.maxp.data[26] = glyphsInfo.maxSizeOfInstructions &gt;&gt; 8; tables.maxp.data[27] = glyphsInfo.maxSizeOfInstructions &amp; 255; } } if (!tables.hhea) { throw new _util.FormatError(&apos;Required &quot;hhea&quot; table is not found&apos;); } if (tables.hhea.data[10] === 0 &amp;&amp; tables.hhea.data[11] === 0) { tables.hhea.data[10] = 0xff; tables.hhea.data[11] = 0xff; } const metricsOverride = { unitsPerEm: int16(tables.head.data[18], tables.head.data[19]), yMax: int16(tables.head.data[42], tables.head.data[43]), yMin: signedInt16(tables.head.data[38], tables.head.data[39]), ascent: signedInt16(tables.hhea.data[4], tables.hhea.data[5]), descent: signedInt16(tables.hhea.data[6], tables.hhea.data[7]), lineGap: signedInt16(tables.hhea.data[8], tables.hhea.data[9]) }; this.ascent = metricsOverride.ascent / metricsOverride.unitsPerEm; this.descent = metricsOverride.descent / metricsOverride.unitsPerEm; this.lineGap = metricsOverride.lineGap / metricsOverride.unitsPerEm; if (this.cssFontInfo &amp;&amp; this.cssFontInfo.lineHeight) { this.lineHeight = this.cssFontInfo.metrics.lineHeight; this.lineGap = this.cssFontInfo.metrics.lineGap; } else { this.lineHeight = this.ascent - this.descent + this.lineGap; } if (tables.post) { readPostScriptTable(tables.post, properties, numGlyphs); } tables.post = { tag: &quot;post&quot;, data: createPostTable(properties) }; const charCodeToGlyphId = []; function hasGlyph(glyphId) { return !missingGlyphs[glyphId]; } if (properties.composite) { const cidToGidMap = properties.cidToGidMap || []; const isCidToGidMapEmpty = cidToGidMap.length === 0; properties.cMap.forEach(function (charCode, cid) { if (typeof cid === &quot;string&quot;) { cid = convertCidString(charCode, cid, true); } if (cid &gt; 0xffff) { throw new _util.FormatError(&quot;Max size of CID is 65,535&quot;); } let glyphId = -1; if (isCidToGidMapEmpty) { glyphId = cid; } else if (cidToGidMap[cid] !== undefined) { glyphId = cidToGidMap[cid]; } if (glyphId &gt;= 0 &amp;&amp; glyphId &lt; numGlyphs &amp;&amp; hasGlyph(glyphId)) { charCodeToGlyphId[charCode] = glyphId; } }); } else { const cmapTable = readCmapTable(tables.cmap, font, this.isSymbolicFont, properties.hasEncoding); const cmapPlatformId = cmapTable.platformId; const cmapEncodingId = cmapTable.encodingId; const cmapMappings = cmapTable.mappings; let baseEncoding = [], forcePostTable = false; if (properties.hasEncoding &amp;&amp; (properties.baseEncodingName === &quot;MacRomanEncoding&quot; || properties.baseEncodingName === &quot;WinAnsiEncoding&quot;)) { baseEncoding = (0, _encodings.getEncoding)(properties.baseEncodingName); } if (properties.hasEncoding &amp;&amp; !this.isSymbolicFont &amp;&amp; (cmapPlatformId === 3 &amp;&amp; cmapEncodingId === 1 || cmapPlatformId === 1 &amp;&amp; cmapEncodingId === 0)) { const glyphsUnicodeMap = (0, _glyphlist.getGlyphsUnicode)(); for (let charCode = 0; charCode &lt; 256; charCode++) { let glyphName; if (this.differences[charCode] !== undefined) { glyphName = this.differences[charCode]; } else if (baseEncoding.length &amp;&amp; baseEncoding[charCode] !== &quot;&quot;) { glyphName = baseEncoding[charCode]; } else { glyphName = _encodings.StandardEncoding[charCode]; } if (!glyphName) { continue; } const standardGlyphName = (0, _fonts_utils.recoverGlyphName)(glyphName, glyphsUnicodeMap); let unicodeOrCharCode; if (cmapPlatformId === 3 &amp;&amp; cmapEncodingId === 1) { unicodeOrCharCode = glyphsUnicodeMap[standardGlyphName]; } else if (cmapPlatformId === 1 &amp;&amp; cmapEncodingId === 0) { unicodeOrCharCode = _encodings.MacRomanEncoding.indexOf(standardGlyphName); } if (unicodeOrCharCode === undefined) { if (!properties.glyphNames &amp;&amp; properties.hasIncludedToUnicodeMap &amp;&amp; !(this.toUnicode instanceof _to_unicode_map.IdentityToUnicodeMap)) { const unicode = this.toUnicode.get(charCode); if (unicode) { unicodeOrCharCode = unicode.codePointAt(0); } } if (unicodeOrCharCode === undefined) { continue; } } for (const mapping of cmapMappings) { if (mapping.charCode !== unicodeOrCharCode) { continue; } charCodeToGlyphId[charCode] = mapping.glyphId; break; } } } else if (cmapPlatformId === 0) { for (const mapping of cmapMappings) { charCodeToGlyphId[mapping.charCode] = mapping.glyphId; } forcePostTable = true; } else { for (const mapping of cmapMappings) { let charCode = mapping.charCode; if (cmapPlatformId === 3 &amp;&amp; charCode &gt;= 0xf000 &amp;&amp; charCode &lt;= 0xf0ff) { charCode &amp;= 0xff; } charCodeToGlyphId[charCode] = mapping.glyphId; } } if (properties.glyphNames &amp;&amp; (baseEncoding.length || this.differences.length)) { for (let i = 0; i &lt; 256; ++i) { if (!forcePostTable &amp;&amp; charCodeToGlyphId[i] !== undefined) { continue; } const glyphName = this.differences[i] || baseEncoding[i]; if (!glyphName) { continue; } const glyphId = properties.glyphNames.indexOf(glyphName); if (glyphId &gt; 0 &amp;&amp; hasGlyph(glyphId)) { charCodeToGlyphId[i] = glyphId; } } } } if (charCodeToGlyphId.length === 0) { charCodeToGlyphId[0] = 0; } let glyphZeroId = numGlyphsOut - 1; if (!dupFirstEntry) { glyphZeroId = 0; } if (!properties.cssFontInfo) { const newMapping = adjustMapping(charCodeToGlyphId, hasGlyph, glyphZeroId, this.toUnicode); this.toFontChar = newMapping.toFontChar; tables.cmap = { tag: &quot;cmap&quot;, data: createCmapTable(newMapping.charCodeToGlyphId, newMapping.toUnicodeExtraMap, numGlyphsOut) }; if (!tables[&quot;OS/2&quot;] || !validateOS2Table(tables[&quot;OS/2&quot;], font)) { tables[&quot;OS/2&quot;] = { tag: &quot;OS/2&quot;, data: createOS2Table(properties, newMapping.charCodeToGlyphId, metricsOverride) }; } } if (!isTrueType) { try { cffFile = new _stream.Stream(tables[&quot;CFF &quot;].data); const parser = new _cff_parser.CFFParser(cffFile, properties, _fonts_utils.SEAC_ANALYSIS_ENABLED); cff = parser.parse(); cff.duplicateFirstGlyph(); const compiler = new _cff_parser.CFFCompiler(cff); tables[&quot;CFF &quot;].data = compiler.compile(); } catch (e) { (0, _util.warn)(&quot;Failed to compile font &quot; + properties.loadedName); } } if (!tables.name) { tables.name = { tag: &quot;name&quot;, data: createNameTable(this.name) }; } else { const namePrototype = readNameTable(tables.name); tables.name.data = createNameTable(name, namePrototype); this.psName = namePrototype[0][6] || null; } const builder = new _opentype_file_builder.OpenTypeFileBuilder(header.version); for (const tableTag in tables) { builder.addTable(tableTag, tables[tableTag].data); } return builder.toArray(); } convert(fontName, font, properties) { properties.fixedPitch = false; if (properties.builtInEncoding) { adjustToUnicode(properties, properties.builtInEncoding); } let glyphZeroId = 1; if (font instanceof _cff_font.CFFFont) { glyphZeroId = font.numGlyphs - 1; } const mapping = font.getGlyphMapping(properties); let newMapping = null; let newCharCodeToGlyphId = mapping; let toUnicodeExtraMap = null; if (!properties.cssFontInfo) { newMapping = adjustMapping(mapping, font.hasGlyphId.bind(font), glyphZeroId, this.toUnicode); this.toFontChar = newMapping.toFontChar; newCharCodeToGlyphId = newMapping.charCodeToGlyphId; toUnicodeExtraMap = newMapping.toUnicodeExtraMap; } const numGlyphs = font.numGlyphs; function getCharCodes(charCodeToGlyphId, glyphId) { let charCodes = null; for (const charCode in charCodeToGlyphId) { if (glyphId === charCodeToGlyphId[charCode]) { if (!charCodes) { charCodes = []; } charCodes.push(charCode | 0); } } return charCodes; } function createCharCode(charCodeToGlyphId, glyphId) { for (const charCode in charCodeToGlyphId) { if (glyphId === charCodeToGlyphId[charCode]) { return charCode | 0; } } newMapping.charCodeToGlyphId[newMapping.nextAvailableFontCharCode] = glyphId; return newMapping.nextAvailableFontCharCode++; } const seacs = font.seacs; if (newMapping &amp;&amp; _fonts_utils.SEAC_ANALYSIS_ENABLED &amp;&amp; seacs &amp;&amp; seacs.length) { const matrix = properties.fontMatrix || _util.FONT_IDENTITY_MATRIX; const charset = font.getCharset(); const seacMap = Object.create(null); for (let glyphId in seacs) { glyphId |= 0; const seac = seacs[glyphId]; const baseGlyphName = _encodings.StandardEncoding[seac[2]]; const accentGlyphName = _encodings.StandardEncoding[seac[3]]; const baseGlyphId = charset.indexOf(baseGlyphName); const accentGlyphId = charset.indexOf(accentGlyphName); if (baseGlyphId &lt; 0 || accentGlyphId &lt; 0) { continue; } const accentOffset = { x: seac[0] * matrix[0] + seac[1] * matrix[2] + matrix[4], y: seac[0] * matrix[1] + seac[1] * matrix[3] + matrix[5] }; const charCodes = getCharCodes(mapping, glyphId); if (!charCodes) { continue; } for (const charCode of charCodes) { const charCodeToGlyphId = newMapping.charCodeToGlyphId; const baseFontCharCode = createCharCode(charCodeToGlyphId, baseGlyphId); const accentFontCharCode = createCharCode(charCodeToGlyphId, accentGlyphId); seacMap[charCode] = { baseFontCharCode, accentFontCharCode, accentOffset }; } } properties.seacMap = seacMap; } const unitsPerEm = 1 / (properties.fontMatrix || _util.FONT_IDENTITY_MATRIX)[0]; const builder = new _opentype_file_builder.OpenTypeFileBuilder(&quot;\\x4F\\x54\\x54\\x4F&quot;); builder.addTable(&quot;CFF &quot;, font.data); builder.addTable(&quot;OS/2&quot;, createOS2Table(properties, newCharCodeToGlyphId)); builder.addTable(&quot;cmap&quot;, createCmapTable(newCharCodeToGlyphId, toUnicodeExtraMap, numGlyphs)); builder.addTable(&quot;head&quot;, &quot;\\x00\\x01\\x00\\x00&quot; + &quot;\\x00\\x00\\x10\\x00&quot; + &quot;\\x00\\x00\\x00\\x00&quot; + &quot;\\x5F\\x0F\\x3C\\xF5&quot; + &quot;\\x00\\x00&quot; + safeString16(unitsPerEm) + &quot;\\x00\\x00\\x00\\x00\\x9e\\x0b\\x7e\\x27&quot; + &quot;\\x00\\x00\\x00\\x00\\x9e\\x0b\\x7e\\x27&quot; + &quot;\\x00\\x00&quot; + safeString16(properties.descent) + &quot;\\x0F\\xFF&quot; + safeString16(properties.ascent) + string16(properties.italicAngle ? 2 : 0) + &quot;\\x00\\x11&quot; + &quot;\\x00\\x00&quot; + &quot;\\x00\\x00&quot; + &quot;\\x00\\x00&quot;); builder.addTable(&quot;hhea&quot;, &quot;\\x00\\x01\\x00\\x00&quot; + safeString16(properties.ascent) + safeString16(properties.descent) + &quot;\\x00\\x00&quot; + &quot;\\xFF\\xFF&quot; + &quot;\\x00\\x00&quot; + &quot;\\x00\\x00&quot; + &quot;\\x00\\x00&quot; + safeString16(properties.capHeight) + safeString16(Math.tan(properties.italicAngle) * properties.xHeight) + &quot;\\x00\\x00&quot; + &quot;\\x00\\x00&quot; + &quot;\\x00\\x00&quot; + &quot;\\x00\\x00&quot; + &quot;\\x00\\x00&quot; + &quot;\\x00\\x00&quot; + string16(numGlyphs)); builder.addTable(&quot;hmtx&quot;, function fontFieldsHmtx() { const charstrings = font.charstrings; const cffWidths = font.cff ? font.cff.widths : null; let hmtx = &quot;\\x00\\x00\\x00\\x00&quot;; for (let i = 1, ii = numGlyphs; i &lt; ii; i++) { let width = 0; if (charstrings) { const charstring = charstrings[i - 1]; width = &quot;width&quot; in charstring ? charstring.width : 0; } else if (cffWidths) { width = Math.ceil(cffWidths[i] || 0); } hmtx += string16(width) + string16(0); } return hmtx; }()); builder.addTable(&quot;maxp&quot;, &quot;\\x00\\x00\\x50\\x00&quot; + string16(numGlyphs)); builder.addTable(&quot;name&quot;, createNameTable(fontName)); builder.addTable(&quot;post&quot;, createPostTable(properties)); return builder.toArray(); } get spaceWidth() { const possibleSpaceReplacements = [&quot;space&quot;, &quot;minus&quot;, &quot;one&quot;, &quot;i&quot;, &quot;I&quot;]; let width; for (const glyphName of possibleSpaceReplacements) { if (glyphName in this.widths) { width = this.widths[glyphName]; break; } const glyphsUnicodeMap = (0, _glyphlist.getGlyphsUnicode)(); const glyphUnicode = glyphsUnicodeMap[glyphName]; let charcode = 0; if (this.composite &amp;&amp; this.cMap.contains(glyphUnicode)) { charcode = this.cMap.lookup(glyphUnicode); if (typeof charcode === &quot;string&quot;) { charcode = convertCidString(glyphUnicode, charcode); } } if (!charcode &amp;&amp; this.toUnicode) { charcode = this.toUnicode.charCodeOf(glyphUnicode); } if (charcode &lt;= 0) { charcode = glyphUnicode; } width = this.widths[charcode]; if (width) { break; } } width = width || this.defaultWidth; return (0, _util.shadow)(this, &quot;spaceWidth&quot;, width); } _charToGlyph(charcode, isSpace = false) { let glyph = this._glyphCache[charcode]; if (glyph &amp;&amp; glyph.isSpace === isSpace) { return glyph; } let fontCharCode, width, operatorListId; let widthCode = charcode; if (this.cMap &amp;&amp; this.cMap.contains(charcode)) { widthCode = this.cMap.lookup(charcode); if (typeof widthCode === &quot;string&quot;) { widthCode = convertCidString(charcode, widthCode); } } width = this.widths[widthCode]; if (typeof width !== &quot;number&quot;) { width = this.defaultWidth; } const vmetric = this.vmetrics &amp;&amp; this.vmetrics[widthCode]; let unicode = this.toUnicode.get(charcode) || charcode; if (typeof unicode === &quot;number&quot;) { unicode = String.fromCharCode(unicode); } let isInFont = this.toFontChar[charcode] !== undefined; fontCharCode = this.toFontChar[charcode] || charcode; if (this.missingFile) { const glyphName = this.differences[charcode] || this.defaultEncoding[charcode]; if ((glyphName === &quot;.notdef&quot; || glyphName === &quot;&quot;) &amp;&amp; this.type === &quot;Type1&quot;) { fontCharCode = 0x20; } fontCharCode = (0, _unicode.mapSpecialUnicodeValues)(fontCharCode); } if (this.isType3Font) { operatorListId = fontCharCode; } let accent = null; if (this.seacMap &amp;&amp; this.seacMap[charcode]) { isInFont = true; const seac = this.seacMap[charcode]; fontCharCode = seac.baseFontCharCode; accent = { fontChar: String.fromCodePoint(seac.accentFontCharCode), offset: seac.accentOffset }; } let fontChar = &quot;&quot;; if (typeof fontCharCode === &quot;number&quot;) { if (fontCharCode &lt;= 0x10ffff) { fontChar = String.fromCodePoint(fontCharCode); } else { (0, _util.warn)(`charToGlyph - invalid fontCharCode: ${fontCharCode}`); } } glyph = new Glyph(charcode, fontChar, unicode, accent, width, vmetric, operatorListId, isSpace, isInFont); return this._glyphCache[charcode] = glyph; } charsToGlyphs(chars) { let glyphs = this._charsCache[chars]; if (glyphs) { return glyphs; } glyphs = []; if (this.cMap) { const c = Object.create(null), ii = chars.length; let i = 0; while (i &lt; ii) { this.cMap.readCharCode(chars, i, c); const { charcode, length } = c; i += length; const glyph = this._charToGlyph(charcode, length === 1 &amp;&amp; chars.charCodeAt(i - 1) === 0x20); glyphs.push(glyph); } } else { for (let i = 0, ii = chars.length; i &lt; ii; ++i) { const charcode = chars.charCodeAt(i); const glyph = this._charToGlyph(charcode, charcode === 0x20); glyphs.push(glyph); } } return this._charsCache[chars] = glyphs; } getCharPositions(chars) { const positions = []; if (this.cMap) { const c = Object.create(null); let i = 0; while (i &lt; chars.length) { this.cMap.readCharCode(chars, i, c); const length = c.length; positions.push([i, i + length]); i += length; } } else { for (let i = 0, ii = chars.length; i &lt; ii; ++i) { positions.push([i, i + 1]); } } return positions; } get glyphCacheValues() { return Object.values(this._glyphCache); } encodeString(str) { const buffers = []; const currentBuf = []; const hasCurrentBufErrors = () =&gt; buffers.length % 2 === 1; const getCharCode = this.toUnicode instanceof _to_unicode_map.IdentityToUnicodeMap ? unicode =&gt; this.toUnicode.charCodeOf(unicode) : unicode =&gt; this.toUnicode.charCodeOf(String.fromCodePoint(unicode)); for (let i = 0, ii = str.length; i &lt; ii; i++) { const unicode = str.codePointAt(i); if (unicode &gt; 0xd7ff &amp;&amp; (unicode &lt; 0xe000 || unicode &gt; 0xfffd)) { i++; } if (this.toUnicode) { const charCode = getCharCode(unicode); if (charCode !== -1) { if (hasCurrentBufErrors()) { buffers.push(currentBuf.join(&quot;&quot;)); currentBuf.length = 0; } const charCodeLength = this.cMap ? this.cMap.getCharCodeLength(charCode) : 1; for (let j = charCodeLength - 1; j &gt;= 0; j--) { currentBuf.push(String.fromCharCode(charCode &gt;&gt; 8 * j &amp; 0xff)); } continue; } } if (!hasCurrentBufErrors()) { buffers.push(currentBuf.join(&quot;&quot;)); currentBuf.length = 0; } currentBuf.push(String.fromCodePoint(unicode)); } buffers.push(currentBuf.join(&quot;&quot;)); return buffers; } } exports.Font = Font; class ErrorFont { constructor(error) { this.error = error; this.loadedName = &quot;g_font_error&quot;; this.missingFile = true; } charsToGlyphs() { return []; } encodeString(chars) { return [chars]; } exportData(extraProperties = false) { return { error: this.error }; } } exports.ErrorFont = ErrorFont; /***/ }), /* 33 */ /***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) =&gt; { Object.defineProperty(exports, &quot;__esModule&quot;, ({ value: true })); exports.CFFTopDict = exports.CFFStrings = exports.CFFStandardStrings = exports.CFFPrivateDict = exports.CFFParser = exports.CFFIndex = exports.CFFHeader = exports.CFFFDSelect = exports.CFFCompiler = exports.CFFCharset = exports.CFF = void 0; var _util = __w_pdfjs_require__(2); var _charsets = __w_pdfjs_require__(34); var _encodings = __w_pdfjs_require__(35); const MAX_SUBR_NESTING = 10; const CFFStandardStrings = [&quot;.notdef&quot;, &quot;space&quot;, &quot;exclam&quot;, &quot;quotedbl&quot;, &quot;numbersign&quot;, &quot;dollar&quot;, &quot;percent&quot;, &quot;ampersand&quot;, &quot;quoteright&quot;, &quot;parenleft&quot;, &quot;parenright&quot;, &quot;asterisk&quot;, &quot;plus&quot;, &quot;comma&quot;, &quot;hyphen&quot;, &quot;period&quot;, &quot;slash&quot;, &quot;zero&quot;, &quot;one&quot;, &quot;two&quot;, &quot;three&quot;, &quot;four&quot;, &quot;five&quot;, &quot;six&quot;, &quot;seven&quot;, &quot;eight&quot;, &quot;nine&quot;, &quot;colon&quot;, &quot;semicolon&quot;, &quot;less&quot;, &quot;equal&quot;, &quot;greater&quot;, &quot;question&quot;, &quot;at&quot;, &quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;, &quot;E&quot;, &quot;F&quot;, &quot;G&quot;, &quot;H&quot;, &quot;I&quot;, &quot;J&quot;, &quot;K&quot;, &quot;L&quot;, &quot;M&quot;, &quot;N&quot;, &quot;O&quot;, &quot;P&quot;, &quot;Q&quot;, &quot;R&quot;, &quot;S&quot;, &quot;T&quot;, &quot;U&quot;, &quot;V&quot;, &quot;W&quot;, &quot;X&quot;, &quot;Y&quot;, &quot;Z&quot;, &quot;bracketleft&quot;, &quot;backslash&quot;, &quot;bracketright&quot;, &quot;asciicircum&quot;, &quot;underscore&quot;, &quot;quoteleft&quot;, &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;, &quot;f&quot;, &quot;g&quot;, &quot;h&quot;, &quot;i&quot;, &quot;j&quot;, &quot;k&quot;, &quot;l&quot;, &quot;m&quot;, &quot;n&quot;, &quot;o&quot;, &quot;p&quot;, &quot;q&quot;, &quot;r&quot;, &quot;s&quot;, &quot;t&quot;, &quot;u&quot;, &quot;v&quot;, &quot;w&quot;, &quot;x&quot;, &quot;y&quot;, &quot;z&quot;, &quot;braceleft&quot;, &quot;bar&quot;, &quot;braceright&quot;, &quot;asciitilde&quot;, &quot;exclamdown&quot;, &quot;cent&quot;, &quot;sterling&quot;, &quot;fraction&quot;, &quot;yen&quot;, &quot;florin&quot;, &quot;section&quot;, &quot;currency&quot;, &quot;quotesingle&quot;, &quot;quotedblleft&quot;, &quot;guillemotleft&quot;, &quot;guilsinglleft&quot;, &quot;guilsinglright&quot;, &quot;fi&quot;, &quot;fl&quot;, &quot;endash&quot;, &quot;dagger&quot;, &quot;daggerdbl&quot;, &quot;periodcentered&quot;, &quot;paragraph&quot;, &quot;bullet&quot;, &quot;quotesinglbase&quot;, &quot;quotedblbase&quot;, &quot;quotedblright&quot;, &quot;guillemotright&quot;, &quot;ellipsis&quot;, &quot;perthousand&quot;, &quot;questiondown&quot;, &quot;grave&quot;, &quot;acute&quot;, &quot;circumflex&quot;, &quot;tilde&quot;, &quot;macron&quot;, &quot;breve&quot;, &quot;dotaccent&quot;, &quot;dieresis&quot;, &quot;ring&quot;, &quot;cedilla&quot;, &quot;hungarumlaut&quot;, &quot;ogonek&quot;, &quot;caron&quot;, &quot;emdash&quot;, &quot;AE&quot;, &quot;ordfeminine&quot;, &quot;Lslash&quot;, &quot;Oslash&quot;, &quot;OE&quot;, &quot;ordmasculine&quot;, &quot;ae&quot;, &quot;dotlessi&quot;, &quot;lslash&quot;, &quot;oslash&quot;, &quot;oe&quot;, &quot;germandbls&quot;, &quot;onesuperior&quot;, &quot;logicalnot&quot;, &quot;mu&quot;, &quot;trademark&quot;, &quot;Eth&quot;, &quot;onehalf&quot;, &quot;plusminus&quot;, &quot;Thorn&quot;, &quot;onequarter&quot;, &quot;divide&quot;, &quot;brokenbar&quot;, &quot;degree&quot;, &quot;thorn&quot;, &quot;threequarters&quot;, &quot;twosuperior&quot;, &quot;registered&quot;, &quot;minus&quot;, &quot;eth&quot;, &quot;multiply&quot;, &quot;threesuperior&quot;, &quot;copyright&quot;, &quot;Aacute&quot;, &quot;Acircumflex&quot;, &quot;Adieresis&quot;, &quot;Agrave&quot;, &quot;Aring&quot;, &quot;Atilde&quot;, &quot;Ccedilla&quot;, &quot;Eacute&quot;, &quot;Ecircumflex&quot;, &quot;Edieresis&quot;, &quot;Egrave&quot;, &quot;Iacute&quot;, &quot;Icircumflex&quot;, &quot;Idieresis&quot;, &quot;Igrave&quot;, &quot;Ntilde&quot;, &quot;Oacute&quot;, &quot;Ocircumflex&quot;, &quot;Odieresis&quot;, &quot;Ograve&quot;, &quot;Otilde&quot;, &quot;Scaron&quot;, &quot;Uacute&quot;, &quot;Ucircumflex&quot;, &quot;Udieresis&quot;, &quot;Ugrave&quot;, &quot;Yacute&quot;, &quot;Ydieresis&quot;, &quot;Zcaron&quot;, &quot;aacute&quot;, &quot;acircumflex&quot;, &quot;adieresis&quot;, &quot;agrave&quot;, &quot;aring&quot;, &quot;atilde&quot;, &quot;ccedilla&quot;, &quot;eacute&quot;, &quot;ecircumflex&quot;, &quot;edieresis&quot;, &quot;egrave&quot;, &quot;iacute&quot;, &quot;icircumflex&quot;, &quot;idieresis&quot;, &quot;igrave&quot;, &quot;ntilde&quot;, &quot;oacute&quot;, &quot;ocircumflex&quot;, &quot;odieresis&quot;, &quot;ograve&quot;, &quot;otilde&quot;, &quot;scaron&quot;, &quot;uacute&quot;, &quot;ucircumflex&quot;, &quot;udieresis&quot;, &quot;ugrave&quot;, &quot;yacute&quot;, &quot;ydieresis&quot;, &quot;zcaron&quot;, &quot;exclamsmall&quot;, &quot;Hungarumlautsmall&quot;, &quot;dollaroldstyle&quot;, &quot;dollarsuperior&quot;, &quot;ampersandsmall&quot;, &quot;Acutesmall&quot;, &quot;parenleftsuperior&quot;, &quot;parenrightsuperior&quot;, &quot;twodotenleader&quot;, &quot;onedotenleader&quot;, &quot;zerooldstyle&quot;, &quot;oneoldstyle&quot;, &quot;twooldstyle&quot;, &quot;threeoldstyle&quot;, &quot;fouroldstyle&quot;, &quot;fiveoldstyle&quot;, &quot;sixoldstyle&quot;, &quot;sevenoldstyle&quot;, &quot;eightoldstyle&quot;, &quot;nineoldstyle&quot;, &quot;commasuperior&quot;, &quot;threequartersemdash&quot;, &quot;periodsuperior&quot;, &quot;questionsmall&quot;, &quot;asuperior&quot;, &quot;bsuperior&quot;, &quot;centsuperior&quot;, &quot;dsuperior&quot;, &quot;esuperior&quot;, &quot;isuperior&quot;, &quot;lsuperior&quot;, &quot;msuperior&quot;, &quot;nsuperior&quot;, &quot;osuperior&quot;, &quot;rsuperior&quot;, &quot;ssuperior&quot;, &quot;tsuperior&quot;, &quot;ff&quot;, &quot;ffi&quot;, &quot;ffl&quot;, &quot;parenleftinferior&quot;, &quot;parenrightinferior&quot;, &quot;Circumflexsmall&quot;, &quot;hyphensuperior&quot;, &quot;Gravesmall&quot;, &quot;Asmall&quot;, &quot;Bsmall&quot;, &quot;Csmall&quot;, &quot;Dsmall&quot;, &quot;Esmall&quot;, &quot;Fsmall&quot;, &quot;Gsmall&quot;, &quot;Hsmall&quot;, &quot;Ismall&quot;, &quot;Jsmall&quot;, &quot;Ksmall&quot;, &quot;Lsmall&quot;, &quot;Msmall&quot;, &quot;Nsmall&quot;, &quot;Osmall&quot;, &quot;Psmall&quot;, &quot;Qsmall&quot;, &quot;Rsmall&quot;, &quot;Ssmall&quot;, &quot;Tsmall&quot;, &quot;Usmall&quot;, &quot;Vsmall&quot;, &quot;Wsmall&quot;, &quot;Xsmall&quot;, &quot;Ysmall&quot;, &quot;Zsmall&quot;, &quot;colonmonetary&quot;, &quot;onefitted&quot;, &quot;rupiah&quot;, &quot;Tildesmall&quot;, &quot;exclamdownsmall&quot;, &quot;centoldstyle&quot;, &quot;Lslashsmall&quot;, &quot;Scaronsmall&quot;, &quot;Zcaronsmall&quot;, &quot;Dieresissmall&quot;, &quot;Brevesmall&quot;, &quot;Caronsmall&quot;, &quot;Dotaccentsmall&quot;, &quot;Macronsmall&quot;, &quot;figuredash&quot;, &quot;hypheninferior&quot;, &quot;Ogoneksmall&quot;, &quot;Ringsmall&quot;, &quot;Cedillasmall&quot;, &quot;questiondownsmall&quot;, &quot;oneeighth&quot;, &quot;threeeighths&quot;, &quot;fiveeighths&quot;, &quot;seveneighths&quot;, &quot;onethird&quot;, &quot;twothirds&quot;, &quot;zerosuperior&quot;, &quot;foursuperior&quot;, &quot;fivesuperior&quot;, &quot;sixsuperior&quot;, &quot;sevensuperior&quot;, &quot;eightsuperior&quot;, &quot;ninesuperior&quot;, &quot;zeroinferior&quot;, &quot;oneinferior&quot;, &quot;twoinferior&quot;, &quot;threeinferior&quot;, &quot;fourinferior&quot;, &quot;fiveinferior&quot;, &quot;sixinferior&quot;, &quot;seveninferior&quot;, &quot;eightinferior&quot;, &quot;nineinferior&quot;, &quot;centinferior&quot;, &quot;dollarinferior&quot;, &quot;periodinferior&quot;, &quot;commainferior&quot;, &quot;Agravesmall&quot;, &quot;Aacutesmall&quot;, &quot;Acircumflexsmall&quot;, &quot;Atildesmall&quot;, &quot;Adieresissmall&quot;, &quot;Aringsmall&quot;, &quot;AEsmall&quot;, &quot;Ccedillasmall&quot;, &quot;Egravesmall&quot;, &quot;Eacutesmall&quot;, &quot;Ecircumflexsmall&quot;, &quot;Edieresissmall&quot;, &quot;Igravesmall&quot;, &quot;Iacutesmall&quot;, &quot;Icircumflexsmall&quot;, &quot;Idieresissmall&quot;, &quot;Ethsmall&quot;, &quot;Ntildesmall&quot;, &quot;Ogravesmall&quot;, &quot;Oacutesmall&quot;, &quot;Ocircumflexsmall&quot;, &quot;Otildesmall&quot;, &quot;Odieresissmall&quot;, &quot;OEsmall&quot;, &quot;Oslashsmall&quot;, &quot;Ugravesmall&quot;, &quot;Uacutesmall&quot;, &quot;Ucircumflexsmall&quot;, &quot;Udieresissmall&quot;, &quot;Yacutesmall&quot;, &quot;Thornsmall&quot;, &quot;Ydieresissmall&quot;, &quot;001.000&quot;, &quot;001.001&quot;, &quot;001.002&quot;, &quot;001.003&quot;, &quot;Black&quot;, &quot;Bold&quot;, &quot;Book&quot;, &quot;Light&quot;, &quot;Medium&quot;, &quot;Regular&quot;, &quot;Roman&quot;, &quot;Semibold&quot;]; exports.CFFStandardStrings = CFFStandardStrings; const NUM_STANDARD_CFF_STRINGS = 391; const CharstringValidationData = [null, { id: &quot;hstem&quot;, min: 2, stackClearing: true, stem: true }, null, { id: &quot;vstem&quot;, min: 2, stackClearing: true, stem: true }, { id: &quot;vmoveto&quot;, min: 1, stackClearing: true }, { id: &quot;rlineto&quot;, min: 2, resetStack: true }, { id: &quot;hlineto&quot;, min: 1, resetStack: true }, { id: &quot;vlineto&quot;, min: 1, resetStack: true }, { id: &quot;rrcurveto&quot;, min: 6, resetStack: true }, null, { id: &quot;callsubr&quot;, min: 1, undefStack: true }, { id: &quot;return&quot;, min: 0, undefStack: true }, null, null, { id: &quot;endchar&quot;, min: 0, stackClearing: true }, null, null, null, { id: &quot;hstemhm&quot;, min: 2, stackClearing: true, stem: true }, { id: &quot;hintmask&quot;, min: 0, stackClearing: true }, { id: &quot;cntrmask&quot;, min: 0, stackClearing: true }, { id: &quot;rmoveto&quot;, min: 2, stackClearing: true }, { id: &quot;hmoveto&quot;, min: 1, stackClearing: true }, { id: &quot;vstemhm&quot;, min: 2, stackClearing: true, stem: true }, { id: &quot;rcurveline&quot;, min: 8, resetStack: true }, { id: &quot;rlinecurve&quot;, min: 8, resetStack: true }, { id: &quot;vvcurveto&quot;, min: 4, resetStack: true }, { id: &quot;hhcurveto&quot;, min: 4, resetStack: true }, null, { id: &quot;callgsubr&quot;, min: 1, undefStack: true }, { id: &quot;vhcurveto&quot;, min: 4, resetStack: true }, { id: &quot;hvcurveto&quot;, min: 4, resetStack: true }]; const CharstringValidationData12 = [null, null, null, { id: &quot;and&quot;, min: 2, stackDelta: -1 }, { id: &quot;or&quot;, min: 2, stackDelta: -1 }, { id: &quot;not&quot;, min: 1, stackDelta: 0 }, null, null, null, { id: &quot;abs&quot;, min: 1, stackDelta: 0 }, { id: &quot;add&quot;, min: 2, stackDelta: -1, stackFn(stack, index) { stack[index - 2] = stack[index - 2] + stack[index - 1]; } }, { id: &quot;sub&quot;, min: 2, stackDelta: -1, stackFn(stack, index) { stack[index - 2] = stack[index - 2] - stack[index - 1]; } }, { id: &quot;div&quot;, min: 2, stackDelta: -1, stackFn(stack, index) { stack[index - 2] = stack[index - 2] / stack[index - 1]; } }, null, { id: &quot;neg&quot;, min: 1, stackDelta: 0, stackFn(stack, index) { stack[index - 1] = -stack[index - 1]; } }, { id: &quot;eq&quot;, min: 2, stackDelta: -1 }, null, null, { id: &quot;drop&quot;, min: 1, stackDelta: -1 }, null, { id: &quot;put&quot;, min: 2, stackDelta: -2 }, { id: &quot;get&quot;, min: 1, stackDelta: 0 }, { id: &quot;ifelse&quot;, min: 4, stackDelta: -3 }, { id: &quot;random&quot;, min: 0, stackDelta: 1 }, { id: &quot;mul&quot;, min: 2, stackDelta: -1, stackFn(stack, index) { stack[index - 2] = stack[index - 2] * stack[index - 1]; } }, null, { id: &quot;sqrt&quot;, min: 1, stackDelta: 0 }, { id: &quot;dup&quot;, min: 1, stackDelta: 1 }, { id: &quot;exch&quot;, min: 2, stackDelta: 0 }, { id: &quot;index&quot;, min: 2, stackDelta: 0 }, { id: &quot;roll&quot;, min: 3, stackDelta: -2 }, null, null, null, { id: &quot;hflex&quot;, min: 7, resetStack: true }, { id: &quot;flex&quot;, min: 13, resetStack: true }, { id: &quot;hflex1&quot;, min: 9, resetStack: true }, { id: &quot;flex1&quot;, min: 11, resetStack: true }]; class CFFParser { constructor(file, properties, seacAnalysisEnabled) { this.bytes = file.getBytes(); this.properties = properties; this.seacAnalysisEnabled = !!seacAnalysisEnabled; } parse() { const properties = this.properties; const cff = new CFF(); this.cff = cff; const header = this.parseHeader(); const nameIndex = this.parseIndex(header.endPos); const topDictIndex = this.parseIndex(nameIndex.endPos); const stringIndex = this.parseIndex(topDictIndex.endPos); const globalSubrIndex = this.parseIndex(stringIndex.endPos); const topDictParsed = this.parseDict(topDictIndex.obj.get(0)); const topDict = this.createDict(CFFTopDict, topDictParsed, cff.strings); cff.header = header.obj; cff.names = this.parseNameIndex(nameIndex.obj); cff.strings = this.parseStringIndex(stringIndex.obj); cff.topDict = topDict; cff.globalSubrIndex = globalSubrIndex.obj; this.parsePrivateDict(cff.topDict); cff.isCIDFont = topDict.hasName(&quot;ROS&quot;); const charStringOffset = topDict.getByName(&quot;CharStrings&quot;); const charStringIndex = this.parseIndex(charStringOffset).obj; const fontMatrix = topDict.getByName(&quot;FontMatrix&quot;); if (fontMatrix) { properties.fontMatrix = fontMatrix; } const fontBBox = topDict.getByName(&quot;FontBBox&quot;); if (fontBBox) { properties.ascent = Math.max(fontBBox[3], fontBBox[1]); properties.descent = Math.min(fontBBox[1], fontBBox[3]); properties.ascentScaled = true; } let charset, encoding; if (cff.isCIDFont) { const fdArrayIndex = this.parseIndex(topDict.getByName(&quot;FDArray&quot;)).obj; for (let i = 0, ii = fdArrayIndex.count; i &lt; ii; ++i) { const dictRaw = fdArrayIndex.get(i); const fontDict = this.createDict(CFFTopDict, this.parseDict(dictRaw), cff.strings); this.parsePrivateDict(fontDict); cff.fdArray.push(fontDict); } encoding = null; charset = this.parseCharsets(topDict.getByName(&quot;charset&quot;), charStringIndex.count, cff.strings, true); cff.fdSelect = this.parseFDSelect(topDict.getByName(&quot;FDSelect&quot;), charStringIndex.count); } else { charset = this.parseCharsets(topDict.getByName(&quot;charset&quot;), charStringIndex.count, cff.strings, false); encoding = this.parseEncoding(topDict.getByName(&quot;Encoding&quot;), properties, cff.strings, charset.charset); } cff.charset = charset; cff.encoding = encoding; const charStringsAndSeacs = this.parseCharStrings({ charStrings: charStringIndex, localSubrIndex: topDict.privateDict.subrsIndex, globalSubrIndex: globalSubrIndex.obj, fdSelect: cff.fdSelect, fdArray: cff.fdArray, privateDict: topDict.privateDict }); cff.charStrings = charStringsAndSeacs.charStrings; cff.seacs = charStringsAndSeacs.seacs; cff.widths = charStringsAndSeacs.widths; return cff; } parseHeader() { let bytes = this.bytes; const bytesLength = bytes.length; let offset = 0; while (offset &lt; bytesLength &amp;&amp; bytes[offset] !== 1) { ++offset; } if (offset &gt;= bytesLength) { throw new _util.FormatError(&quot;Invalid CFF header&quot;); } if (offset !== 0) { (0, _util.info)(&quot;cff data is shifted&quot;); bytes = bytes.subarray(offset); this.bytes = bytes; } const major = bytes[0]; const minor = bytes[1]; const hdrSize = bytes[2]; const offSize = bytes[3]; const header = new CFFHeader(major, minor, hdrSize, offSize); return { obj: header, endPos: hdrSize }; } parseDict(dict) { let pos = 0; function parseOperand() { let value = dict[pos++]; if (value === 30) { return parseFloatOperand(); } else if (value === 28) { value = dict[pos++]; value = (value &lt;&lt; 24 | dict[pos++] &lt;&lt; 16) &gt;&gt; 16; return value; } else if (value === 29) { value = dict[pos++]; value = value &lt;&lt; 8 | dict[pos++]; value = value &lt;&lt; 8 | dict[pos++]; value = value &lt;&lt; 8 | dict[pos++]; return value; } else if (value &gt;= 32 &amp;&amp; value &lt;= 246) { return value - 139; } else if (value &gt;= 247 &amp;&amp; value &lt;= 250) { return (value - 247) * 256 + dict[pos++] + 108; } else if (value &gt;= 251 &amp;&amp; value &lt;= 254) { return -((value - 251) * 256) - dict[pos++] - 108; } (0, _util.warn)(&apos;CFFParser_parseDict: &quot;&apos; + value + &apos;&quot; is a reserved command.&apos;); return NaN; } function parseFloatOperand() { let str = &quot;&quot;; const eof = 15; const lookup = [&quot;0&quot;, &quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;, &quot;6&quot;, &quot;7&quot;, &quot;8&quot;, &quot;9&quot;, &quot;.&quot;, &quot;E&quot;, &quot;E-&quot;, null, &quot;-&quot;]; const length = dict.length; while (pos &lt; length) { const b = dict[pos++]; const b1 = b &gt;&gt; 4; const b2 = b &amp; 15; if (b1 === eof) { break; } str += lookup[b1]; if (b2 === eof) { break; } str += lookup[b2]; } return parseFloat(str); } let operands = []; const entries = []; pos = 0; const end = dict.length; while (pos &lt; end) { let b = dict[pos]; if (b &lt;= 21) { if (b === 12) { b = b &lt;&lt; 8 | dict[++pos]; } entries.push([b, operands]); operands = []; ++pos; } else { operands.push(parseOperand()); } } return entries; } parseIndex(pos) { const cffIndex = new CFFIndex(); const bytes = this.bytes; const count = bytes[pos++] &lt;&lt; 8 | bytes[pos++]; const offsets = []; let end = pos; let i, ii; if (count !== 0) { const offsetSize = bytes[pos++]; const startPos = pos + (count + 1) * offsetSize - 1; for (i = 0, ii = count + 1; i &lt; ii; ++i) { let offset = 0; for (let j = 0; j &lt; offsetSize; ++j) { offset &lt;&lt;= 8; offset += bytes[pos++]; } offsets.push(startPos + offset); } end = offsets[count]; } for (i = 0, ii = offsets.length - 1; i &lt; ii; ++i) { const offsetStart = offsets[i]; const offsetEnd = offsets[i + 1]; cffIndex.add(bytes.subarray(offsetStart, offsetEnd)); } return { obj: cffIndex, endPos: end }; } parseNameIndex(index) { const names = []; for (let i = 0, ii = index.count; i &lt; ii; ++i) { const name = index.get(i); names.push((0, _util.bytesToString)(name)); } return names; } parseStringIndex(index) { const strings = new CFFStrings(); for (let i = 0, ii = index.count; i &lt; ii; ++i) { const data = index.get(i); strings.add((0, _util.bytesToString)(data)); } return strings; } createDict(Type, dict, strings) { const cffDict = new Type(strings); for (const [key, value] of dict) { cffDict.setByKey(key, value); } return cffDict; } parseCharString(state, data, localSubrIndex, globalSubrIndex) { if (!data || state.callDepth &gt; MAX_SUBR_NESTING) { return false; } let stackSize = state.stackSize; const stack = state.stack; const length = data.length; for (let j = 0; j &lt; length;) { const value = data[j++]; let validationCommand = null; if (value === 12) { const q = data[j++]; if (q === 0) { data[j - 2] = 139; data[j - 1] = 22; stackSize = 0; } else { validationCommand = CharstringValidationData12[q]; } } else if (value === 28) { stack[stackSize] = (data[j] &lt;&lt; 24 | data[j + 1] &lt;&lt; 16) &gt;&gt; 16; j += 2; stackSize++; } else if (value === 14) { if (stackSize &gt;= 4) { stackSize -= 4; if (this.seacAnalysisEnabled) { state.seac = stack.slice(stackSize, stackSize + 4); return false; } } validationCommand = CharstringValidationData[value]; } else if (value &gt;= 32 &amp;&amp; value &lt;= 246) { stack[stackSize] = value - 139; stackSize++; } else if (value &gt;= 247 &amp;&amp; value &lt;= 254) { stack[stackSize] = value &lt; 251 ? (value - 247 &lt;&lt; 8) + data[j] + 108 : -(value - 251 &lt;&lt; 8) - data[j] - 108; j++; stackSize++; } else if (value === 255) { stack[stackSize] = (data[j] &lt;&lt; 24 | data[j + 1] &lt;&lt; 16 | data[j + 2] &lt;&lt; 8 | data[j + 3]) / 65536; j += 4; stackSize++; } else if (value === 19 || value === 20) { state.hints += stackSize &gt;&gt; 1; j += state.hints + 7 &gt;&gt; 3; stackSize %= 2; validationCommand = CharstringValidationData[value]; } else if (value === 10 || value === 29) { let subrsIndex; if (value === 10) { subrsIndex = localSubrIndex; } else { subrsIndex = globalSubrIndex; } if (!subrsIndex) { validationCommand = CharstringValidationData[value]; (0, _util.warn)(&quot;Missing subrsIndex for &quot; + validationCommand.id); return false; } let bias = 32768; if (subrsIndex.count &lt; 1240) { bias = 107; } else if (subrsIndex.count &lt; 33900) { bias = 1131; } const subrNumber = stack[--stackSize] + bias; if (subrNumber &lt; 0 || subrNumber &gt;= subrsIndex.count || isNaN(subrNumber)) { validationCommand = CharstringValidationData[value]; (0, _util.warn)(&quot;Out of bounds subrIndex for &quot; + validationCommand.id); return false; } state.stackSize = stackSize; state.callDepth++; const valid = this.parseCharString(state, subrsIndex.get(subrNumber), localSubrIndex, globalSubrIndex); if (!valid) { return false; } state.callDepth--; stackSize = state.stackSize; continue; } else if (value === 11) { state.stackSize = stackSize; return true; } else if (value === 0 &amp;&amp; j === data.length) { data[j - 1] = 14; validationCommand = CharstringValidationData[14]; } else { validationCommand = CharstringValidationData[value]; } if (validationCommand) { if (validationCommand.stem) { state.hints += stackSize &gt;&gt; 1; if (value === 3 || value === 23) { state.hasVStems = true; } else if (state.hasVStems &amp;&amp; (value === 1 || value === 18)) { (0, _util.warn)(&quot;CFF stem hints are in wrong order&quot;); data[j - 1] = value === 1 ? 3 : 23; } } if (&quot;min&quot; in validationCommand) { if (!state.undefStack &amp;&amp; stackSize &lt; validationCommand.min) { (0, _util.warn)(&quot;Not enough parameters for &quot; + validationCommand.id + &quot;; actual: &quot; + stackSize + &quot;, expected: &quot; + validationCommand.min); if (stackSize === 0) { data[j - 1] = 14; return true; } return false; } } if (state.firstStackClearing &amp;&amp; validationCommand.stackClearing) { state.firstStackClearing = false; stackSize -= validationCommand.min; if (stackSize &gt;= 2 &amp;&amp; validationCommand.stem) { stackSize %= 2; } else if (stackSize &gt; 1) { (0, _util.warn)(&quot;Found too many parameters for stack-clearing command&quot;); } if (stackSize &gt; 0) { state.width = stack[stackSize - 1]; } } if (&quot;stackDelta&quot; in validationCommand) { if (&quot;stackFn&quot; in validationCommand) { validationCommand.stackFn(stack, stackSize); } stackSize += validationCommand.stackDelta; } else if (validationCommand.stackClearing) { stackSize = 0; } else if (validationCommand.resetStack) { stackSize = 0; state.undefStack = false; } else if (validationCommand.undefStack) { stackSize = 0; state.undefStack = true; state.firstStackClearing = false; } } } state.stackSize = stackSize; return true; } parseCharStrings({ charStrings, localSubrIndex, globalSubrIndex, fdSelect, fdArray, privateDict }) { const seacs = []; const widths = []; const count = charStrings.count; for (let i = 0; i &lt; count; i++) { const charstring = charStrings.get(i); const state = { callDepth: 0, stackSize: 0, stack: [], undefStack: true, hints: 0, firstStackClearing: true, seac: null, width: null, hasVStems: false }; let valid = true; let localSubrToUse = null; let privateDictToUse = privateDict; if (fdSelect &amp;&amp; fdArray.length) { const fdIndex = fdSelect.getFDIndex(i); if (fdIndex === -1) { (0, _util.warn)(&quot;Glyph index is not in fd select.&quot;); valid = false; } if (fdIndex &gt;= fdArray.length) { (0, _util.warn)(&quot;Invalid fd index for glyph index.&quot;); valid = false; } if (valid) { privateDictToUse = fdArray[fdIndex].privateDict; localSubrToUse = privateDictToUse.subrsIndex; } } else if (localSubrIndex) { localSubrToUse = localSubrIndex; } if (valid) { valid = this.parseCharString(state, charstring, localSubrToUse, globalSubrIndex); } if (state.width !== null) { const nominalWidth = privateDictToUse.getByName(&quot;nominalWidthX&quot;); widths[i] = nominalWidth + state.width; } else { const defaultWidth = privateDictToUse.getByName(&quot;defaultWidthX&quot;); widths[i] = defaultWidth; } if (state.seac !== null) { seacs[i] = state.seac; } if (!valid) { charStrings.set(i, new Uint8Array([14])); } } return { charStrings, seacs, widths }; } emptyPrivateDictionary(parentDict) { const privateDict = this.createDict(CFFPrivateDict, [], parentDict.strings); parentDict.setByKey(18, [0, 0]); parentDict.privateDict = privateDict; } parsePrivateDict(parentDict) { if (!parentDict.hasName(&quot;Private&quot;)) { this.emptyPrivateDictionary(parentDict); return; } const privateOffset = parentDict.getByName(&quot;Private&quot;); if (!Array.isArray(privateOffset) || privateOffset.length !== 2) { parentDict.removeByName(&quot;Private&quot;); return; } const size = privateOffset[0]; const offset = privateOffset[1]; if (size === 0 || offset &gt;= this.bytes.length) { this.emptyPrivateDictionary(parentDict); return; } const privateDictEnd = offset + size; const dictData = this.bytes.subarray(offset, privateDictEnd); const dict = this.parseDict(dictData); const privateDict = this.createDict(CFFPrivateDict, dict, parentDict.strings); parentDict.privateDict = privateDict; if (!privateDict.getByName(&quot;Subrs&quot;)) { return; } const subrsOffset = privateDict.getByName(&quot;Subrs&quot;); const relativeOffset = offset + subrsOffset; if (subrsOffset === 0 || relativeOffset &gt;= this.bytes.length) { this.emptyPrivateDictionary(parentDict); return; } const subrsIndex = this.parseIndex(relativeOffset); privateDict.subrsIndex = subrsIndex.obj; } parseCharsets(pos, length, strings, cid) { if (pos === 0) { return new CFFCharset(true, CFFCharsetPredefinedTypes.ISO_ADOBE, _charsets.ISOAdobeCharset); } else if (pos === 1) { return new CFFCharset(true, CFFCharsetPredefinedTypes.EXPERT, _charsets.ExpertCharset); } else if (pos === 2) { return new CFFCharset(true, CFFCharsetPredefinedTypes.EXPERT_SUBSET, _charsets.ExpertSubsetCharset); } const bytes = this.bytes; const start = pos; const format = bytes[pos++]; const charset = [cid ? 0 : &quot;.notdef&quot;]; let id, count, i; length -= 1; switch (format) { case 0: for (i = 0; i &lt; length; i++) { id = bytes[pos++] &lt;&lt; 8 | bytes[pos++]; charset.push(cid ? id : strings.get(id)); } break; case 1: while (charset.length &lt;= length) { id = bytes[pos++] &lt;&lt; 8 | bytes[pos++]; count = bytes[pos++]; for (i = 0; i &lt;= count; i++) { charset.push(cid ? id++ : strings.get(id++)); } } break; case 2: while (charset.length &lt;= length) { id = bytes[pos++] &lt;&lt; 8 | bytes[pos++]; count = bytes[pos++] &lt;&lt; 8 | bytes[pos++]; for (i = 0; i &lt;= count; i++) { charset.push(cid ? id++ : strings.get(id++)); } } break; default: throw new _util.FormatError(&quot;Unknown charset format&quot;); } const end = pos; const raw = bytes.subarray(start, end); return new CFFCharset(false, format, charset, raw); } parseEncoding(pos, properties, strings, charset) { const encoding = Object.create(null); const bytes = this.bytes; let predefined = false; let format, i, ii; let raw = null; function readSupplement() { const supplementsCount = bytes[pos++]; for (i = 0; i &lt; supplementsCount; i++) { const code = bytes[pos++]; const sid = (bytes[pos++] &lt;&lt; 8) + (bytes[pos++] &amp; 0xff); encoding[code] = charset.indexOf(strings.get(sid)); } } if (pos === 0 || pos === 1) { predefined = true; format = pos; const baseEncoding = pos ? _encodings.ExpertEncoding : _encodings.StandardEncoding; for (i = 0, ii = charset.length; i &lt; ii; i++) { const index = baseEncoding.indexOf(charset[i]); if (index !== -1) { encoding[index] = i; } } } else { const dataStart = pos; format = bytes[pos++]; switch (format &amp; 0x7f) { case 0: const glyphsCount = bytes[pos++]; for (i = 1; i &lt;= glyphsCount; i++) { encoding[bytes[pos++]] = i; } break; case 1: const rangesCount = bytes[pos++]; let gid = 1; for (i = 0; i &lt; rangesCount; i++) { const start = bytes[pos++]; const left = bytes[pos++]; for (let j = start; j &lt;= start + left; j++) { encoding[j] = gid++; } } break; default: throw new _util.FormatError(`Unknown encoding format: ${format} in CFF`); } const dataEnd = pos; if (format &amp; 0x80) { bytes[dataStart] &amp;= 0x7f; readSupplement(); } raw = bytes.subarray(dataStart, dataEnd); } format &amp;= 0x7f; return new CFFEncoding(predefined, format, encoding, raw); } parseFDSelect(pos, length) { const bytes = this.bytes; const format = bytes[pos++]; const fdSelect = []; let i; switch (format) { case 0: for (i = 0; i &lt; length; ++i) { const id = bytes[pos++]; fdSelect.push(id); } break; case 3: const rangesCount = bytes[pos++] &lt;&lt; 8 | bytes[pos++]; for (i = 0; i &lt; rangesCount; ++i) { let first = bytes[pos++] &lt;&lt; 8 | bytes[pos++]; if (i === 0 &amp;&amp; first !== 0) { (0, _util.warn)(&quot;parseFDSelect: The first range must have a first GID of 0&quot; + &quot; -- trying to recover.&quot;); first = 0; } const fdIndex = bytes[pos++]; const next = bytes[pos] &lt;&lt; 8 | bytes[pos + 1]; for (let j = first; j &lt; next; ++j) { fdSelect.push(fdIndex); } } pos += 2; break; default: throw new _util.FormatError(`parseFDSelect: Unknown format &quot;${format}&quot;.`); } if (fdSelect.length !== length) { throw new _util.FormatError(&quot;parseFDSelect: Invalid font data.&quot;); } return new CFFFDSelect(format, fdSelect); } } exports.CFFParser = CFFParser; class CFF { constructor() { this.header = null; this.names = []; this.topDict = null; this.strings = new CFFStrings(); this.globalSubrIndex = null; this.encoding = null; this.charset = null; this.charStrings = null; this.fdArray = []; this.fdSelect = null; this.isCIDFont = false; } duplicateFirstGlyph() { if (this.charStrings.count &gt;= 65535) { (0, _util.warn)(&quot;Not enough space in charstrings to duplicate first glyph.&quot;); return; } const glyphZero = this.charStrings.get(0); this.charStrings.add(glyphZero); if (this.isCIDFont) { this.fdSelect.fdSelect.push(this.fdSelect.fdSelect[0]); } } hasGlyphId(id) { if (id &lt; 0 || id &gt;= this.charStrings.count) { return false; } const glyph = this.charStrings.get(id); return glyph.length &gt; 0; } } exports.CFF = CFF; class CFFHeader { constructor(major, minor, hdrSize, offSize) { this.major = major; this.minor = minor; this.hdrSize = hdrSize; this.offSize = offSize; } } exports.CFFHeader = CFFHeader; class CFFStrings { constructor() { this.strings = []; } get(index) { if (index &gt;= 0 &amp;&amp; index &lt;= NUM_STANDARD_CFF_STRINGS - 1) { return CFFStandardStrings[index]; } if (index - NUM_STANDARD_CFF_STRINGS &lt;= this.strings.length) { return this.strings[index - NUM_STANDARD_CFF_STRINGS]; } return CFFStandardStrings[0]; } getSID(str) { let index = CFFStandardStrings.indexOf(str); if (index !== -1) { return index; } index = this.strings.indexOf(str); if (index !== -1) { return index + NUM_STANDARD_CFF_STRINGS; } return -1; } add(value) { this.strings.push(value); } get count() { return this.strings.length; } } exports.CFFStrings = CFFStrings; class CFFIndex { constructor() { this.objects = []; this.length = 0; } add(data) { this.length += data.length; this.objects.push(data); } set(index, data) { this.length += data.length - this.objects[index].length; this.objects[index] = data; } get(index) { return this.objects[index]; } get count() { return this.objects.length; } } exports.CFFIndex = CFFIndex; class CFFDict { constructor(tables, strings) { this.keyToNameMap = tables.keyToNameMap; this.nameToKeyMap = tables.nameToKeyMap; this.defaults = tables.defaults; this.types = tables.types; this.opcodes = tables.opcodes; this.order = tables.order; this.strings = strings; this.values = Object.create(null); } setByKey(key, value) { if (!(key in this.keyToNameMap)) { return false; } if (value.length === 0) { return true; } for (const val of value) { if (isNaN(val)) { (0, _util.warn)(`Invalid CFFDict value: &quot;${value}&quot; for key &quot;${key}&quot;.`); return true; } } const type = this.types[key]; if (type === &quot;num&quot; || type === &quot;sid&quot; || type === &quot;offset&quot;) { value = value[0]; } this.values[key] = value; return true; } setByName(name, value) { if (!(name in this.nameToKeyMap)) { throw new _util.FormatError(`Invalid dictionary name &quot;${name}&quot;`); } this.values[this.nameToKeyMap[name]] = value; } hasName(name) { return this.nameToKeyMap[name] in this.values; } getByName(name) { if (!(name in this.nameToKeyMap)) { throw new _util.FormatError(`Invalid dictionary name ${name}&quot;`); } const key = this.nameToKeyMap[name]; if (!(key in this.values)) { return this.defaults[key]; } return this.values[key]; } removeByName(name) { delete this.values[this.nameToKeyMap[name]]; } static createTables(layout) { const tables = { keyToNameMap: {}, nameToKeyMap: {}, defaults: {}, types: {}, opcodes: {}, order: [] }; for (const entry of layout) { const key = Array.isArray(entry[0]) ? (entry[0][0] &lt;&lt; 8) + entry[0][1] : entry[0]; tables.keyToNameMap[key] = entry[1]; tables.nameToKeyMap[entry[1]] = key; tables.types[key] = entry[2]; tables.defaults[key] = entry[3]; tables.opcodes[key] = Array.isArray(entry[0]) ? entry[0] : [entry[0]]; tables.order.push(key); } return tables; } } const CFFTopDictLayout = [[[12, 30], &quot;ROS&quot;, [&quot;sid&quot;, &quot;sid&quot;, &quot;num&quot;], null], [[12, 20], &quot;SyntheticBase&quot;, &quot;num&quot;, null], [0, &quot;version&quot;, &quot;sid&quot;, null], [1, &quot;Notice&quot;, &quot;sid&quot;, null], [[12, 0], &quot;Copyright&quot;, &quot;sid&quot;, null], [2, &quot;FullName&quot;, &quot;sid&quot;, null], [3, &quot;FamilyName&quot;, &quot;sid&quot;, null], [4, &quot;Weight&quot;, &quot;sid&quot;, null], [[12, 1], &quot;isFixedPitch&quot;, &quot;num&quot;, 0], [[12, 2], &quot;ItalicAngle&quot;, &quot;num&quot;, 0], [[12, 3], &quot;UnderlinePosition&quot;, &quot;num&quot;, -100], [[12, 4], &quot;UnderlineThickness&quot;, &quot;num&quot;, 50], [[12, 5], &quot;PaintType&quot;, &quot;num&quot;, 0], [[12, 6], &quot;CharstringType&quot;, &quot;num&quot;, 2], [[12, 7], &quot;FontMatrix&quot;, [&quot;num&quot;, &quot;num&quot;, &quot;num&quot;, &quot;num&quot;, &quot;num&quot;, &quot;num&quot;], [0.001, 0, 0, 0.001, 0, 0]], [13, &quot;UniqueID&quot;, &quot;num&quot;, null], [5, &quot;FontBBox&quot;, [&quot;num&quot;, &quot;num&quot;, &quot;num&quot;, &quot;num&quot;], [0, 0, 0, 0]], [[12, 8], &quot;StrokeWidth&quot;, &quot;num&quot;, 0], [14, &quot;XUID&quot;, &quot;array&quot;, null], [15, &quot;charset&quot;, &quot;offset&quot;, 0], [16, &quot;Encoding&quot;, &quot;offset&quot;, 0], [17, &quot;CharStrings&quot;, &quot;offset&quot;, 0], [18, &quot;Private&quot;, [&quot;offset&quot;, &quot;offset&quot;], null], [[12, 21], &quot;PostScript&quot;, &quot;sid&quot;, null], [[12, 22], &quot;BaseFontName&quot;, &quot;sid&quot;, null], [[12, 23], &quot;BaseFontBlend&quot;, &quot;delta&quot;, null], [[12, 31], &quot;CIDFontVersion&quot;, &quot;num&quot;, 0], [[12, 32], &quot;CIDFontRevision&quot;, &quot;num&quot;, 0], [[12, 33], &quot;CIDFontType&quot;, &quot;num&quot;, 0], [[12, 34], &quot;CIDCount&quot;, &quot;num&quot;, 8720], [[12, 35], &quot;UIDBase&quot;, &quot;num&quot;, null], [[12, 37], &quot;FDSelect&quot;, &quot;offset&quot;, null], [[12, 36], &quot;FDArray&quot;, &quot;offset&quot;, null], [[12, 38], &quot;FontName&quot;, &quot;sid&quot;, null]]; class CFFTopDict extends CFFDict { static get tables() { return (0, _util.shadow)(this, &quot;tables&quot;, this.createTables(CFFTopDictLayout)); } constructor(strings) { super(CFFTopDict.tables, strings); this.privateDict = null; } } exports.CFFTopDict = CFFTopDict; const CFFPrivateDictLayout = [[6, &quot;BlueValues&quot;, &quot;delta&quot;, null], [7, &quot;OtherBlues&quot;, &quot;delta&quot;, null], [8, &quot;FamilyBlues&quot;, &quot;delta&quot;, null], [9, &quot;FamilyOtherBlues&quot;, &quot;delta&quot;, null], [[12, 9], &quot;BlueScale&quot;, &quot;num&quot;, 0.039625], [[12, 10], &quot;BlueShift&quot;, &quot;num&quot;, 7], [[12, 11], &quot;BlueFuzz&quot;, &quot;num&quot;, 1], [10, &quot;StdHW&quot;, &quot;num&quot;, null], [11, &quot;StdVW&quot;, &quot;num&quot;, null], [[12, 12], &quot;StemSnapH&quot;, &quot;delta&quot;, null], [[12, 13], &quot;StemSnapV&quot;, &quot;delta&quot;, null], [[12, 14], &quot;ForceBold&quot;, &quot;num&quot;, 0], [[12, 17], &quot;LanguageGroup&quot;, &quot;num&quot;, 0], [[12, 18], &quot;ExpansionFactor&quot;, &quot;num&quot;, 0.06], [[12, 19], &quot;initialRandomSeed&quot;, &quot;num&quot;, 0], [20, &quot;defaultWidthX&quot;, &quot;num&quot;, 0], [21, &quot;nominalWidthX&quot;, &quot;num&quot;, 0], [19, &quot;Subrs&quot;, &quot;offset&quot;, null]]; class CFFPrivateDict extends CFFDict { static get tables() { return (0, _util.shadow)(this, &quot;tables&quot;, this.createTables(CFFPrivateDictLayout)); } constructor(strings) { super(CFFPrivateDict.tables, strings); this.subrsIndex = null; } } exports.CFFPrivateDict = CFFPrivateDict; const CFFCharsetPredefinedTypes = { ISO_ADOBE: 0, EXPERT: 1, EXPERT_SUBSET: 2 }; class CFFCharset { constructor(predefined, format, charset, raw) { this.predefined = predefined; this.format = format; this.charset = charset; this.raw = raw; } } exports.CFFCharset = CFFCharset; class CFFEncoding { constructor(predefined, format, encoding, raw) { this.predefined = predefined; this.format = format; this.encoding = encoding; this.raw = raw; } } class CFFFDSelect { constructor(format, fdSelect) { this.format = format; this.fdSelect = fdSelect; } getFDIndex(glyphIndex) { if (glyphIndex &lt; 0 || glyphIndex &gt;= this.fdSelect.length) { return -1; } return this.fdSelect[glyphIndex]; } } exports.CFFFDSelect = CFFFDSelect; class CFFOffsetTracker { constructor() { this.offsets = Object.create(null); } isTracking(key) { return key in this.offsets; } track(key, location) { if (key in this.offsets) { throw new _util.FormatError(`Already tracking location of ${key}`); } this.offsets[key] = location; } offset(value) { for (const key in this.offsets) { this.offsets[key] += value; } } setEntryLocation(key, values, output) { if (!(key in this.offsets)) { throw new _util.FormatError(`Not tracking location of ${key}`); } const data = output.data; const dataOffset = this.offsets[key]; const size = 5; for (let i = 0, ii = values.length; i &lt; ii; ++i) { const offset0 = i * size + dataOffset; const offset1 = offset0 + 1; const offset2 = offset0 + 2; const offset3 = offset0 + 3; const offset4 = offset0 + 4; if (data[offset0] !== 0x1d || data[offset1] !== 0 || data[offset2] !== 0 || data[offset3] !== 0 || data[offset4] !== 0) { throw new _util.FormatError(&quot;writing to an offset that is not empty&quot;); } const value = values[i]; data[offset0] = 0x1d; data[offset1] = value &gt;&gt; 24 &amp; 0xff; data[offset2] = value &gt;&gt; 16 &amp; 0xff; data[offset3] = value &gt;&gt; 8 &amp; 0xff; data[offset4] = value &amp; 0xff; } } } class CFFCompiler { constructor(cff) { this.cff = cff; } compile() { const cff = this.cff; const output = { data: [], length: 0, add(data) { this.data = this.data.concat(data); this.length = this.data.length; } }; const header = this.compileHeader(cff.header); output.add(header); const nameIndex = this.compileNameIndex(cff.names); output.add(nameIndex); if (cff.isCIDFont) { if (cff.topDict.hasName(&quot;FontMatrix&quot;)) { const base = cff.topDict.getByName(&quot;FontMatrix&quot;); cff.topDict.removeByName(&quot;FontMatrix&quot;); for (const subDict of cff.fdArray) { let matrix = base.slice(0); if (subDict.hasName(&quot;FontMatrix&quot;)) { matrix = _util.Util.transform(matrix, subDict.getByName(&quot;FontMatrix&quot;)); } subDict.setByName(&quot;FontMatrix&quot;, matrix); } } } const xuid = cff.topDict.getByName(&quot;XUID&quot;); if (xuid &amp;&amp; xuid.length &gt; 16) { cff.topDict.removeByName(&quot;XUID&quot;); } cff.topDict.setByName(&quot;charset&quot;, 0); let compiled = this.compileTopDicts([cff.topDict], output.length, cff.isCIDFont); output.add(compiled.output); const topDictTracker = compiled.trackers[0]; const stringIndex = this.compileStringIndex(cff.strings.strings); output.add(stringIndex); const globalSubrIndex = this.compileIndex(cff.globalSubrIndex); output.add(globalSubrIndex); if (cff.encoding &amp;&amp; cff.topDict.hasName(&quot;Encoding&quot;)) { if (cff.encoding.predefined) { topDictTracker.setEntryLocation(&quot;Encoding&quot;, [cff.encoding.format], output); } else { const encoding = this.compileEncoding(cff.encoding); topDictTracker.setEntryLocation(&quot;Encoding&quot;, [output.length], output); output.add(encoding); } } const charset = this.compileCharset(cff.charset, cff.charStrings.count, cff.strings, cff.isCIDFont); topDictTracker.setEntryLocation(&quot;charset&quot;, [output.length], output); output.add(charset); const charStrings = this.compileCharStrings(cff.charStrings); topDictTracker.setEntryLocation(&quot;CharStrings&quot;, [output.length], output); output.add(charStrings); if (cff.isCIDFont) { topDictTracker.setEntryLocation(&quot;FDSelect&quot;, [output.length], output); const fdSelect = this.compileFDSelect(cff.fdSelect); output.add(fdSelect); compiled = this.compileTopDicts(cff.fdArray, output.length, true); topDictTracker.setEntryLocation(&quot;FDArray&quot;, [output.length], output); output.add(compiled.output); const fontDictTrackers = compiled.trackers; this.compilePrivateDicts(cff.fdArray, fontDictTrackers, output); } this.compilePrivateDicts([cff.topDict], [topDictTracker], output); output.add([0]); return output.data; } encodeNumber(value) { if (Number.isInteger(value)) { return this.encodeInteger(value); } return this.encodeFloat(value); } static get EncodeFloatRegExp() { return (0, _util.shadow)(this, &quot;EncodeFloatRegExp&quot;, /\\.(\\d*?)(?:9{5,20}|0{5,20})\\d{0,2}(?:e(.+)|$)/); } encodeFloat(num) { let value = num.toString(); const m = CFFCompiler.EncodeFloatRegExp.exec(value); if (m) { const epsilon = parseFloat(&quot;1e&quot; + ((m[2] ? +m[2] : 0) + m[1].length)); value = (Math.round(num * epsilon) / epsilon).toString(); } let nibbles = &quot;&quot;; let i, ii; for (i = 0, ii = value.length; i &lt; ii; ++i) { const a = value[i]; if (a === &quot;e&quot;) { nibbles += value[++i] === &quot;-&quot; ? &quot;c&quot; : &quot;b&quot;; } else if (a === &quot;.&quot;) { nibbles += &quot;a&quot;; } else if (a === &quot;-&quot;) { nibbles += &quot;e&quot;; } else { nibbles += a; } } nibbles += nibbles.length &amp; 1 ? &quot;f&quot; : &quot;ff&quot;; const out = [30]; for (i = 0, ii = nibbles.length; i &lt; ii; i += 2) { out.push(parseInt(nibbles.substring(i, i + 2), 16)); } return out; } encodeInteger(value) { let code; if (value &gt;= -107 &amp;&amp; value &lt;= 107) { code = [value + 139]; } else if (value &gt;= 108 &amp;&amp; value &lt;= 1131) { value -= 108; code = [(value &gt;&gt; 8) + 247, value &amp; 0xff]; } else if (value &gt;= -1131 &amp;&amp; value &lt;= -108) { value = -value - 108; code = [(value &gt;&gt; 8) + 251, value &amp; 0xff]; } else if (value &gt;= -32768 &amp;&amp; value &lt;= 32767) { code = [0x1c, value &gt;&gt; 8 &amp; 0xff, value &amp; 0xff]; } else { code = [0x1d, value &gt;&gt; 24 &amp; 0xff, value &gt;&gt; 16 &amp; 0xff, value &gt;&gt; 8 &amp; 0xff, value &amp; 0xff]; } return code; } compileHeader(header) { return [header.major, header.minor, 4, header.offSize]; } compileNameIndex(names) { const nameIndex = new CFFIndex(); for (const name of names) { const length = Math.min(name.length, 127); let sanitizedName = new Array(length); for (let j = 0; j &lt; length; j++) { let char = name[j]; if (char &lt; &quot;!&quot; || char &gt; &quot;~&quot; || char === &quot;[&quot; || char === &quot;]&quot; || char === &quot;(&quot; || char === &quot;)&quot; || char === &quot;{&quot; || char === &quot;}&quot; || char === &quot;&lt;&quot; || char === &quot;&gt;&quot; || char === &quot;/&quot; || char === &quot;%&quot;) { char = &quot;_&quot;; } sanitizedName[j] = char; } sanitizedName = sanitizedName.join(&quot;&quot;); if (sanitizedName === &quot;&quot;) { sanitizedName = &quot;Bad_Font_Name&quot;; } nameIndex.add((0, _util.stringToBytes)(sanitizedName)); } return this.compileIndex(nameIndex); } compileTopDicts(dicts, length, removeCidKeys) { const fontDictTrackers = []; let fdArrayIndex = new CFFIndex(); for (const fontDict of dicts) { if (removeCidKeys) { fontDict.removeByName(&quot;CIDFontVersion&quot;); fontDict.removeByName(&quot;CIDFontRevision&quot;); fontDict.removeByName(&quot;CIDFontType&quot;); fontDict.removeByName(&quot;CIDCount&quot;); fontDict.removeByName(&quot;UIDBase&quot;); } const fontDictTracker = new CFFOffsetTracker(); const fontDictData = this.compileDict(fontDict, fontDictTracker); fontDictTrackers.push(fontDictTracker); fdArrayIndex.add(fontDictData); fontDictTracker.offset(length); } fdArrayIndex = this.compileIndex(fdArrayIndex, fontDictTrackers); return { trackers: fontDictTrackers, output: fdArrayIndex }; } compilePrivateDicts(dicts, trackers, output) { for (let i = 0, ii = dicts.length; i &lt; ii; ++i) { const fontDict = dicts[i]; const privateDict = fontDict.privateDict; if (!privateDict || !fontDict.hasName(&quot;Private&quot;)) { throw new _util.FormatError(&quot;There must be a private dictionary.&quot;); } const privateDictTracker = new CFFOffsetTracker(); const privateDictData = this.compileDict(privateDict, privateDictTracker); let outputLength = output.length; privateDictTracker.offset(outputLength); if (!privateDictData.length) { outputLength = 0; } trackers[i].setEntryLocation(&quot;Private&quot;, [privateDictData.length, outputLength], output); output.add(privateDictData); if (privateDict.subrsIndex &amp;&amp; privateDict.hasName(&quot;Subrs&quot;)) { const subrs = this.compileIndex(privateDict.subrsIndex); privateDictTracker.setEntryLocation(&quot;Subrs&quot;, [privateDictData.length], output); output.add(subrs); } } } compileDict(dict, offsetTracker) { const out = []; for (const key of dict.order) { if (!(key in dict.values)) { continue; } let values = dict.values[key]; let types = dict.types[key]; if (!Array.isArray(types)) { types = [types]; } if (!Array.isArray(values)) { values = [values]; } if (values.length === 0) { continue; } for (let j = 0, jj = types.length; j &lt; jj; ++j) { const type = types[j]; const value = values[j]; switch (type) { case &quot;num&quot;: case &quot;sid&quot;: out.push(...this.encodeNumber(value)); break; case &quot;offset&quot;: const name = dict.keyToNameMap[key]; if (!offsetTracker.isTracking(name)) { offsetTracker.track(name, out.length); } out.push(0x1d, 0, 0, 0, 0); break; case &quot;array&quot;: case &quot;delta&quot;: out.push(...this.encodeNumber(value)); for (let k = 1, kk = values.length; k &lt; kk; ++k) { out.push(...this.encodeNumber(values[k])); } break; default: throw new _util.FormatError(`Unknown data type of ${type}`); } } out.push(...dict.opcodes[key]); } return out; } compileStringIndex(strings) { const stringIndex = new CFFIndex(); for (const string of strings) { stringIndex.add((0, _util.stringToBytes)(string)); } return this.compileIndex(stringIndex); } compileGlobalSubrIndex() { const globalSubrIndex = this.cff.globalSubrIndex; this.out.writeByteArray(this.compileIndex(globalSubrIndex)); } compileCharStrings(charStrings) { const charStringsIndex = new CFFIndex(); for (let i = 0; i &lt; charStrings.count; i++) { const glyph = charStrings.get(i); if (glyph.length === 0) { charStringsIndex.add(new Uint8Array([0x8b, 0x0e])); continue; } charStringsIndex.add(glyph); } return this.compileIndex(charStringsIndex); } compileCharset(charset, numGlyphs, strings, isCIDFont) { let out; const numGlyphsLessNotDef = numGlyphs - 1; if (isCIDFont) { out = new Uint8Array([2, 0, 0, numGlyphsLessNotDef &gt;&gt; 8 &amp; 0xff, numGlyphsLessNotDef &amp; 0xff]); } else { const length = 1 + numGlyphsLessNotDef * 2; out = new Uint8Array(length); out[0] = 0; let charsetIndex = 0; const numCharsets = charset.charset.length; let warned = false; for (let i = 1; i &lt; out.length; i += 2) { let sid = 0; if (charsetIndex &lt; numCharsets) { const name = charset.charset[charsetIndex++]; sid = strings.getSID(name); if (sid === -1) { sid = 0; if (!warned) { warned = true; (0, _util.warn)(`Couldn&apos;t find ${name} in CFF strings`); } } } out[i] = sid &gt;&gt; 8 &amp; 0xff; out[i + 1] = sid &amp; 0xff; } } return this.compileTypedArray(out); } compileEncoding(encoding) { return this.compileTypedArray(encoding.raw); } compileFDSelect(fdSelect) { const format = fdSelect.format; let out, i; switch (format) { case 0: out = new Uint8Array(1 + fdSelect.fdSelect.length); out[0] = format; for (i = 0; i &lt; fdSelect.fdSelect.length; i++) { out[i + 1] = fdSelect.fdSelect[i]; } break; case 3: const start = 0; let lastFD = fdSelect.fdSelect[0]; const ranges = [format, 0, 0, start &gt;&gt; 8 &amp; 0xff, start &amp; 0xff, lastFD]; for (i = 1; i &lt; fdSelect.fdSelect.length; i++) { const currentFD = fdSelect.fdSelect[i]; if (currentFD !== lastFD) { ranges.push(i &gt;&gt; 8 &amp; 0xff, i &amp; 0xff, currentFD); lastFD = currentFD; } } const numRanges = (ranges.length - 3) / 3; ranges[1] = numRanges &gt;&gt; 8 &amp; 0xff; ranges[2] = numRanges &amp; 0xff; ranges.push(i &gt;&gt; 8 &amp; 0xff, i &amp; 0xff); out = new Uint8Array(ranges); break; } return this.compileTypedArray(out); } compileTypedArray(data) { const out = []; for (let i = 0, ii = data.length; i &lt; ii; ++i) { out[i] = data[i]; } return out; } compileIndex(index, trackers = []) { const objects = index.objects; const count = objects.length; if (count === 0) { return [0, 0]; } const data = [count &gt;&gt; 8 &amp; 0xff, count &amp; 0xff]; let lastOffset = 1, i; for (i = 0; i &lt; count; ++i) { lastOffset += objects[i].length; } let offsetSize; if (lastOffset &lt; 0x100) { offsetSize = 1; } else if (lastOffset &lt; 0x10000) { offsetSize = 2; } else if (lastOffset &lt; 0x1000000) { offsetSize = 3; } else { offsetSize = 4; } data.push(offsetSize); let relativeOffset = 1; for (i = 0; i &lt; count + 1; i++) { if (offsetSize === 1) { data.push(relativeOffset &amp; 0xff); } else if (offsetSize === 2) { data.push(relativeOffset &gt;&gt; 8 &amp; 0xff, relativeOffset &amp; 0xff); } else if (offsetSize === 3) { data.push(relativeOffset &gt;&gt; 16 &amp; 0xff, relativeOffset &gt;&gt; 8 &amp; 0xff, relativeOffset &amp; 0xff); } else { data.push(relativeOffset &gt;&gt;&gt; 24 &amp; 0xff, relativeOffset &gt;&gt; 16 &amp; 0xff, relativeOffset &gt;&gt; 8 &amp; 0xff, relativeOffset &amp; 0xff); } if (objects[i]) { relativeOffset += objects[i].length; } } for (i = 0; i &lt; count; i++) { if (trackers[i]) { trackers[i].offset(data.length); } data.push(...objects[i]); } return data; } } exports.CFFCompiler = CFFCompiler; /***/ }), /* 34 */ /***/ ((__unused_webpack_module, exports) =&gt; { Object.defineProperty(exports, &quot;__esModule&quot;, ({ value: true })); exports.ISOAdobeCharset = exports.ExpertSubsetCharset = exports.ExpertCharset = void 0; const ISOAdobeCharset = [&quot;.notdef&quot;, &quot;space&quot;, &quot;exclam&quot;, &quot;quotedbl&quot;, &quot;numbersign&quot;, &quot;dollar&quot;, &quot;percent&quot;, &quot;ampersand&quot;, &quot;quoteright&quot;, &quot;parenleft&quot;, &quot;parenright&quot;, &quot;asterisk&quot;, &quot;plus&quot;, &quot;comma&quot;, &quot;hyphen&quot;, &quot;period&quot;, &quot;slash&quot;, &quot;zero&quot;, &quot;one&quot;, &quot;two&quot;, &quot;three&quot;, &quot;four&quot;, &quot;five&quot;, &quot;six&quot;, &quot;seven&quot;, &quot;eight&quot;, &quot;nine&quot;, &quot;colon&quot;, &quot;semicolon&quot;, &quot;less&quot;, &quot;equal&quot;, &quot;greater&quot;, &quot;question&quot;, &quot;at&quot;, &quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;, &quot;E&quot;, &quot;F&quot;, &quot;G&quot;, &quot;H&quot;, &quot;I&quot;, &quot;J&quot;, &quot;K&quot;, &quot;L&quot;, &quot;M&quot;, &quot;N&quot;, &quot;O&quot;, &quot;P&quot;, &quot;Q&quot;, &quot;R&quot;, &quot;S&quot;, &quot;T&quot;, &quot;U&quot;, &quot;V&quot;, &quot;W&quot;, &quot;X&quot;, &quot;Y&quot;, &quot;Z&quot;, &quot;bracketleft&quot;, &quot;backslash&quot;, &quot;bracketright&quot;, &quot;asciicircum&quot;, &quot;underscore&quot;, &quot;quoteleft&quot;, &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;, &quot;f&quot;, &quot;g&quot;, &quot;h&quot;, &quot;i&quot;, &quot;j&quot;, &quot;k&quot;, &quot;l&quot;, &quot;m&quot;, &quot;n&quot;, &quot;o&quot;, &quot;p&quot;, &quot;q&quot;, &quot;r&quot;, &quot;s&quot;, &quot;t&quot;, &quot;u&quot;, &quot;v&quot;, &quot;w&quot;, &quot;x&quot;, &quot;y&quot;, &quot;z&quot;, &quot;braceleft&quot;, &quot;bar&quot;, &quot;braceright&quot;, &quot;asciitilde&quot;, &quot;exclamdown&quot;, &quot;cent&quot;, &quot;sterling&quot;, &quot;fraction&quot;, &quot;yen&quot;, &quot;florin&quot;, &quot;section&quot;, &quot;currency&quot;, &quot;quotesingle&quot;, &quot;quotedblleft&quot;, &quot;guillemotleft&quot;, &quot;guilsinglleft&quot;, &quot;guilsinglright&quot;, &quot;fi&quot;, &quot;fl&quot;, &quot;endash&quot;, &quot;dagger&quot;, &quot;daggerdbl&quot;, &quot;periodcentered&quot;, &quot;paragraph&quot;, &quot;bullet&quot;, &quot;quotesinglbase&quot;, &quot;quotedblbase&quot;, &quot;quotedblright&quot;, &quot;guillemotright&quot;, &quot;ellipsis&quot;, &quot;perthousand&quot;, &quot;questiondown&quot;, &quot;grave&quot;, &quot;acute&quot;, &quot;circumflex&quot;, &quot;tilde&quot;, &quot;macron&quot;, &quot;breve&quot;, &quot;dotaccent&quot;, &quot;dieresis&quot;, &quot;ring&quot;, &quot;cedilla&quot;, &quot;hungarumlaut&quot;, &quot;ogonek&quot;, &quot;caron&quot;, &quot;emdash&quot;, &quot;AE&quot;, &quot;ordfeminine&quot;, &quot;Lslash&quot;, &quot;Oslash&quot;, &quot;OE&quot;, &quot;ordmasculine&quot;, &quot;ae&quot;, &quot;dotlessi&quot;, &quot;lslash&quot;, &quot;oslash&quot;, &quot;oe&quot;, &quot;germandbls&quot;, &quot;onesuperior&quot;, &quot;logicalnot&quot;, &quot;mu&quot;, &quot;trademark&quot;, &quot;Eth&quot;, &quot;onehalf&quot;, &quot;plusminus&quot;, &quot;Thorn&quot;, &quot;onequarter&quot;, &quot;divide&quot;, &quot;brokenbar&quot;, &quot;degree&quot;, &quot;thorn&quot;, &quot;threequarters&quot;, &quot;twosuperior&quot;, &quot;registered&quot;, &quot;minus&quot;, &quot;eth&quot;, &quot;multiply&quot;, &quot;threesuperior&quot;, &quot;copyright&quot;, &quot;Aacute&quot;, &quot;Acircumflex&quot;, &quot;Adieresis&quot;, &quot;Agrave&quot;, &quot;Aring&quot;, &quot;Atilde&quot;, &quot;Ccedilla&quot;, &quot;Eacute&quot;, &quot;Ecircumflex&quot;, &quot;Edieresis&quot;, &quot;Egrave&quot;, &quot;Iacute&quot;, &quot;Icircumflex&quot;, &quot;Idieresis&quot;, &quot;Igrave&quot;, &quot;Ntilde&quot;, &quot;Oacute&quot;, &quot;Ocircumflex&quot;, &quot;Odieresis&quot;, &quot;Ograve&quot;, &quot;Otilde&quot;, &quot;Scaron&quot;, &quot;Uacute&quot;, &quot;Ucircumflex&quot;, &quot;Udieresis&quot;, &quot;Ugrave&quot;, &quot;Yacute&quot;, &quot;Ydieresis&quot;, &quot;Zcaron&quot;, &quot;aacute&quot;, &quot;acircumflex&quot;, &quot;adieresis&quot;, &quot;agrave&quot;, &quot;aring&quot;, &quot;atilde&quot;, &quot;ccedilla&quot;, &quot;eacute&quot;, &quot;ecircumflex&quot;, &quot;edieresis&quot;, &quot;egrave&quot;, &quot;iacute&quot;, &quot;icircumflex&quot;, &quot;idieresis&quot;, &quot;igrave&quot;, &quot;ntilde&quot;, &quot;oacute&quot;, &quot;ocircumflex&quot;, &quot;odieresis&quot;, &quot;ograve&quot;, &quot;otilde&quot;, &quot;scaron&quot;, &quot;uacute&quot;, &quot;ucircumflex&quot;, &quot;udieresis&quot;, &quot;ugrave&quot;, &quot;yacute&quot;, &quot;ydieresis&quot;, &quot;zcaron&quot;]; exports.ISOAdobeCharset = ISOAdobeCharset; const ExpertCharset = [&quot;.notdef&quot;, &quot;space&quot;, &quot;exclamsmall&quot;, &quot;Hungarumlautsmall&quot;, &quot;dollaroldstyle&quot;, &quot;dollarsuperior&quot;, &quot;ampersandsmall&quot;, &quot;Acutesmall&quot;, &quot;parenleftsuperior&quot;, &quot;parenrightsuperior&quot;, &quot;twodotenleader&quot;, &quot;onedotenleader&quot;, &quot;comma&quot;, &quot;hyphen&quot;, &quot;period&quot;, &quot;fraction&quot;, &quot;zerooldstyle&quot;, &quot;oneoldstyle&quot;, &quot;twooldstyle&quot;, &quot;threeoldstyle&quot;, &quot;fouroldstyle&quot;, &quot;fiveoldstyle&quot;, &quot;sixoldstyle&quot;, &quot;sevenoldstyle&quot;, &quot;eightoldstyle&quot;, &quot;nineoldstyle&quot;, &quot;colon&quot;, &quot;semicolon&quot;, &quot;commasuperior&quot;, &quot;threequartersemdash&quot;, &quot;periodsuperior&quot;, &quot;questionsmall&quot;, &quot;asuperior&quot;, &quot;bsuperior&quot;, &quot;centsuperior&quot;, &quot;dsuperior&quot;, &quot;esuperior&quot;, &quot;isuperior&quot;, &quot;lsuperior&quot;, &quot;msuperior&quot;, &quot;nsuperior&quot;, &quot;osuperior&quot;, &quot;rsuperior&quot;, &quot;ssuperior&quot;, &quot;tsuperior&quot;, &quot;ff&quot;, &quot;fi&quot;, &quot;fl&quot;, &quot;ffi&quot;, &quot;ffl&quot;, &quot;parenleftinferior&quot;, &quot;parenrightinferior&quot;, &quot;Circumflexsmall&quot;, &quot;hyphensuperior&quot;, &quot;Gravesmall&quot;, &quot;Asmall&quot;, &quot;Bsmall&quot;, &quot;Csmall&quot;, &quot;Dsmall&quot;, &quot;Esmall&quot;, &quot;Fsmall&quot;, &quot;Gsmall&quot;, &quot;Hsmall&quot;, &quot;Ismall&quot;, &quot;Jsmall&quot;, &quot;Ksmall&quot;, &quot;Lsmall&quot;, &quot;Msmall&quot;, &quot;Nsmall&quot;, &quot;Osmall&quot;, &quot;Psmall&quot;, &quot;Qsmall&quot;, &quot;Rsmall&quot;, &quot;Ssmall&quot;, &quot;Tsmall&quot;, &quot;Usmall&quot;, &quot;Vsmall&quot;, &quot;Wsmall&quot;, &quot;Xsmall&quot;, &quot;Ysmall&quot;, &quot;Zsmall&quot;, &quot;colonmonetary&quot;, &quot;onefitted&quot;, &quot;rupiah&quot;, &quot;Tildesmall&quot;, &quot;exclamdownsmall&quot;, &quot;centoldstyle&quot;, &quot;Lslashsmall&quot;, &quot;Scaronsmall&quot;, &quot;Zcaronsmall&quot;, &quot;Dieresissmall&quot;, &quot;Brevesmall&quot;, &quot;Caronsmall&quot;, &quot;Dotaccentsmall&quot;, &quot;Macronsmall&quot;, &quot;figuredash&quot;, &quot;hypheninferior&quot;, &quot;Ogoneksmall&quot;, &quot;Ringsmall&quot;, &quot;Cedillasmall&quot;, &quot;onequarter&quot;, &quot;onehalf&quot;, &quot;threequarters&quot;, &quot;questiondownsmall&quot;, &quot;oneeighth&quot;, &quot;threeeighths&quot;, &quot;fiveeighths&quot;, &quot;seveneighths&quot;, &quot;onethird&quot;, &quot;twothirds&quot;, &quot;zerosuperior&quot;, &quot;onesuperior&quot;, &quot;twosuperior&quot;, &quot;threesuperior&quot;, &quot;foursuperior&quot;, &quot;fivesuperior&quot;, &quot;sixsuperior&quot;, &quot;sevensuperior&quot;, &quot;eightsuperior&quot;, &quot;ninesuperior&quot;, &quot;zeroinferior&quot;, &quot;oneinferior&quot;, &quot;twoinferior&quot;, &quot;threeinferior&quot;, &quot;fourinferior&quot;, &quot;fiveinferior&quot;, &quot;sixinferior&quot;, &quot;seveninferior&quot;, &quot;eightinferior&quot;, &quot;nineinferior&quot;, &quot;centinferior&quot;, &quot;dollarinferior&quot;, &quot;periodinferior&quot;, &quot;commainferior&quot;, &quot;Agravesmall&quot;, &quot;Aacutesmall&quot;, &quot;Acircumflexsmall&quot;, &quot;Atildesmall&quot;, &quot;Adieresissmall&quot;, &quot;Aringsmall&quot;, &quot;AEsmall&quot;, &quot;Ccedillasmall&quot;, &quot;Egravesmall&quot;, &quot;Eacutesmall&quot;, &quot;Ecircumflexsmall&quot;, &quot;Edieresissmall&quot;, &quot;Igravesmall&quot;, &quot;Iacutesmall&quot;, &quot;Icircumflexsmall&quot;, &quot;Idieresissmall&quot;, &quot;Ethsmall&quot;, &quot;Ntildesmall&quot;, &quot;Ogravesmall&quot;, &quot;Oacutesmall&quot;, &quot;Ocircumflexsmall&quot;, &quot;Otildesmall&quot;, &quot;Odieresissmall&quot;, &quot;OEsmall&quot;, &quot;Oslashsmall&quot;, &quot;Ugravesmall&quot;, &quot;Uacutesmall&quot;, &quot;Ucircumflexsmall&quot;, &quot;Udieresissmall&quot;, &quot;Yacutesmall&quot;, &quot;Thornsmall&quot;, &quot;Ydieresissmall&quot;]; exports.ExpertCharset = ExpertCharset; const ExpertSubsetCharset = [&quot;.notdef&quot;, &quot;space&quot;, &quot;dollaroldstyle&quot;, &quot;dollarsuperior&quot;, &quot;parenleftsuperior&quot;, &quot;parenrightsuperior&quot;, &quot;twodotenleader&quot;, &quot;onedotenleader&quot;, &quot;comma&quot;, &quot;hyphen&quot;, &quot;period&quot;, &quot;fraction&quot;, &quot;zerooldstyle&quot;, &quot;oneoldstyle&quot;, &quot;twooldstyle&quot;, &quot;threeoldstyle&quot;, &quot;fouroldstyle&quot;, &quot;fiveoldstyle&quot;, &quot;sixoldstyle&quot;, &quot;sevenoldstyle&quot;, &quot;eightoldstyle&quot;, &quot;nineoldstyle&quot;, &quot;colon&quot;, &quot;semicolon&quot;, &quot;commasuperior&quot;, &quot;threequartersemdash&quot;, &quot;periodsuperior&quot;, &quot;asuperior&quot;, &quot;bsuperior&quot;, &quot;centsuperior&quot;, &quot;dsuperior&quot;, &quot;esuperior&quot;, &quot;isuperior&quot;, &quot;lsuperior&quot;, &quot;msuperior&quot;, &quot;nsuperior&quot;, &quot;osuperior&quot;, &quot;rsuperior&quot;, &quot;ssuperior&quot;, &quot;tsuperior&quot;, &quot;ff&quot;, &quot;fi&quot;, &quot;fl&quot;, &quot;ffi&quot;, &quot;ffl&quot;, &quot;parenleftinferior&quot;, &quot;parenrightinferior&quot;, &quot;hyphensuperior&quot;, &quot;colonmonetary&quot;, &quot;onefitted&quot;, &quot;rupiah&quot;, &quot;centoldstyle&quot;, &quot;figuredash&quot;, &quot;hypheninferior&quot;, &quot;onequarter&quot;, &quot;onehalf&quot;, &quot;threequarters&quot;, &quot;oneeighth&quot;, &quot;threeeighths&quot;, &quot;fiveeighths&quot;, &quot;seveneighths&quot;, &quot;onethird&quot;, &quot;twothirds&quot;, &quot;zerosuperior&quot;, &quot;onesuperior&quot;, &quot;twosuperior&quot;, &quot;threesuperior&quot;, &quot;foursuperior&quot;, &quot;fivesuperior&quot;, &quot;sixsuperior&quot;, &quot;sevensuperior&quot;, &quot;eightsuperior&quot;, &quot;ninesuperior&quot;, &quot;zeroinferior&quot;, &quot;oneinferior&quot;, &quot;twoinferior&quot;, &quot;threeinferior&quot;, &quot;fourinferior&quot;, &quot;fiveinferior&quot;, &quot;sixinferior&quot;, &quot;seveninferior&quot;, &quot;eightinferior&quot;, &quot;nineinferior&quot;, &quot;centinferior&quot;, &quot;dollarinferior&quot;, &quot;periodinferior&quot;, &quot;commainferior&quot;]; exports.ExpertSubsetCharset = ExpertSubsetCharset; /***/ }), /* 35 */ /***/ ((__unused_webpack_module, exports) =&gt; { Object.defineProperty(exports, &quot;__esModule&quot;, ({ value: true })); exports.ZapfDingbatsEncoding = exports.WinAnsiEncoding = exports.SymbolSetEncoding = exports.StandardEncoding = exports.MacRomanEncoding = exports.ExpertEncoding = void 0; exports.getEncoding = getEncoding; const ExpertEncoding = [&quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;space&quot;, &quot;exclamsmall&quot;, &quot;Hungarumlautsmall&quot;, &quot;&quot;, &quot;dollaroldstyle&quot;, &quot;dollarsuperior&quot;, &quot;ampersandsmall&quot;, &quot;Acutesmall&quot;, &quot;parenleftsuperior&quot;, &quot;parenrightsuperior&quot;, &quot;twodotenleader&quot;, &quot;onedotenleader&quot;, &quot;comma&quot;, &quot;hyphen&quot;, &quot;period&quot;, &quot;fraction&quot;, &quot;zerooldstyle&quot;, &quot;oneoldstyle&quot;, &quot;twooldstyle&quot;, &quot;threeoldstyle&quot;, &quot;fouroldstyle&quot;, &quot;fiveoldstyle&quot;, &quot;sixoldstyle&quot;, &quot;sevenoldstyle&quot;, &quot;eightoldstyle&quot;, &quot;nineoldstyle&quot;, &quot;colon&quot;, &quot;semicolon&quot;, &quot;commasuperior&quot;, &quot;threequartersemdash&quot;, &quot;periodsuperior&quot;, &quot;questionsmall&quot;, &quot;&quot;, &quot;asuperior&quot;, &quot;bsuperior&quot;, &quot;centsuperior&quot;, &quot;dsuperior&quot;, &quot;esuperior&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;isuperior&quot;, &quot;&quot;, &quot;&quot;, &quot;lsuperior&quot;, &quot;msuperior&quot;, &quot;nsuperior&quot;, &quot;osuperior&quot;, &quot;&quot;, &quot;&quot;, &quot;rsuperior&quot;, &quot;ssuperior&quot;, &quot;tsuperior&quot;, &quot;&quot;, &quot;ff&quot;, &quot;fi&quot;, &quot;fl&quot;, &quot;ffi&quot;, &quot;ffl&quot;, &quot;parenleftinferior&quot;, &quot;&quot;, &quot;parenrightinferior&quot;, &quot;Circumflexsmall&quot;, &quot;hyphensuperior&quot;, &quot;Gravesmall&quot;, &quot;Asmall&quot;, &quot;Bsmall&quot;, &quot;Csmall&quot;, &quot;Dsmall&quot;, &quot;Esmall&quot;, &quot;Fsmall&quot;, &quot;Gsmall&quot;, &quot;Hsmall&quot;, &quot;Ismall&quot;, &quot;Jsmall&quot;, &quot;Ksmall&quot;, &quot;Lsmall&quot;, &quot;Msmall&quot;, &quot;Nsmall&quot;, &quot;Osmall&quot;, &quot;Psmall&quot;, &quot;Qsmall&quot;, &quot;Rsmall&quot;, &quot;Ssmall&quot;, &quot;Tsmall&quot;, &quot;Usmall&quot;, &quot;Vsmall&quot;, &quot;Wsmall&quot;, &quot;Xsmall&quot;, &quot;Ysmall&quot;, &quot;Zsmall&quot;, &quot;colonmonetary&quot;, &quot;onefitted&quot;, &quot;rupiah&quot;, &quot;Tildesmall&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;exclamdownsmall&quot;, &quot;centoldstyle&quot;, &quot;Lslashsmall&quot;, &quot;&quot;, &quot;&quot;, &quot;Scaronsmall&quot;, &quot;Zcaronsmall&quot;, &quot;Dieresissmall&quot;, &quot;Brevesmall&quot;, &quot;Caronsmall&quot;, &quot;&quot;, &quot;Dotaccentsmall&quot;, &quot;&quot;, &quot;&quot;, &quot;Macronsmall&quot;, &quot;&quot;, &quot;&quot;, &quot;figuredash&quot;, &quot;hypheninferior&quot;, &quot;&quot;, &quot;&quot;, &quot;Ogoneksmall&quot;, &quot;Ringsmall&quot;, &quot;Cedillasmall&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;onequarter&quot;, &quot;onehalf&quot;, &quot;threequarters&quot;, &quot;questiondownsmall&quot;, &quot;oneeighth&quot;, &quot;threeeighths&quot;, &quot;fiveeighths&quot;, &quot;seveneighths&quot;, &quot;onethird&quot;, &quot;twothirds&quot;, &quot;&quot;, &quot;&quot;, &quot;zerosuperior&quot;, &quot;onesuperior&quot;, &quot;twosuperior&quot;, &quot;threesuperior&quot;, &quot;foursuperior&quot;, &quot;fivesuperior&quot;, &quot;sixsuperior&quot;, &quot;sevensuperior&quot;, &quot;eightsuperior&quot;, &quot;ninesuperior&quot;, &quot;zeroinferior&quot;, &quot;oneinferior&quot;, &quot;twoinferior&quot;, &quot;threeinferior&quot;, &quot;fourinferior&quot;, &quot;fiveinferior&quot;, &quot;sixinferior&quot;, &quot;seveninferior&quot;, &quot;eightinferior&quot;, &quot;nineinferior&quot;, &quot;centinferior&quot;, &quot;dollarinferior&quot;, &quot;periodinferior&quot;, &quot;commainferior&quot;, &quot;Agravesmall&quot;, &quot;Aacutesmall&quot;, &quot;Acircumflexsmall&quot;, &quot;Atildesmall&quot;, &quot;Adieresissmall&quot;, &quot;Aringsmall&quot;, &quot;AEsmall&quot;, &quot;Ccedillasmall&quot;, &quot;Egravesmall&quot;, &quot;Eacutesmall&quot;, &quot;Ecircumflexsmall&quot;, &quot;Edieresissmall&quot;, &quot;Igravesmall&quot;, &quot;Iacutesmall&quot;, &quot;Icircumflexsmall&quot;, &quot;Idieresissmall&quot;, &quot;Ethsmall&quot;, &quot;Ntildesmall&quot;, &quot;Ogravesmall&quot;, &quot;Oacutesmall&quot;, &quot;Ocircumflexsmall&quot;, &quot;Otildesmall&quot;, &quot;Odieresissmall&quot;, &quot;OEsmall&quot;, &quot;Oslashsmall&quot;, &quot;Ugravesmall&quot;, &quot;Uacutesmall&quot;, &quot;Ucircumflexsmall&quot;, &quot;Udieresissmall&quot;, &quot;Yacutesmall&quot;, &quot;Thornsmall&quot;, &quot;Ydieresissmall&quot;]; exports.ExpertEncoding = ExpertEncoding; const MacExpertEncoding = [&quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;space&quot;, &quot;exclamsmall&quot;, &quot;Hungarumlautsmall&quot;, &quot;centoldstyle&quot;, &quot;dollaroldstyle&quot;, &quot;dollarsuperior&quot;, &quot;ampersandsmall&quot;, &quot;Acutesmall&quot;, &quot;parenleftsuperior&quot;, &quot;parenrightsuperior&quot;, &quot;twodotenleader&quot;, &quot;onedotenleader&quot;, &quot;comma&quot;, &quot;hyphen&quot;, &quot;period&quot;, &quot;fraction&quot;, &quot;zerooldstyle&quot;, &quot;oneoldstyle&quot;, &quot;twooldstyle&quot;, &quot;threeoldstyle&quot;, &quot;fouroldstyle&quot;, &quot;fiveoldstyle&quot;, &quot;sixoldstyle&quot;, &quot;sevenoldstyle&quot;, &quot;eightoldstyle&quot;, &quot;nineoldstyle&quot;, &quot;colon&quot;, &quot;semicolon&quot;, &quot;&quot;, &quot;threequartersemdash&quot;, &quot;&quot;, &quot;questionsmall&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;Ethsmall&quot;, &quot;&quot;, &quot;&quot;, &quot;onequarter&quot;, &quot;onehalf&quot;, &quot;threequarters&quot;, &quot;oneeighth&quot;, &quot;threeeighths&quot;, &quot;fiveeighths&quot;, &quot;seveneighths&quot;, &quot;onethird&quot;, &quot;twothirds&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;ff&quot;, &quot;fi&quot;, &quot;fl&quot;, &quot;ffi&quot;, &quot;ffl&quot;, &quot;parenleftinferior&quot;, &quot;&quot;, &quot;parenrightinferior&quot;, &quot;Circumflexsmall&quot;, &quot;hypheninferior&quot;, &quot;Gravesmall&quot;, &quot;Asmall&quot;, &quot;Bsmall&quot;, &quot;Csmall&quot;, &quot;Dsmall&quot;, &quot;Esmall&quot;, &quot;Fsmall&quot;, &quot;Gsmall&quot;, &quot;Hsmall&quot;, &quot;Ismall&quot;, &quot;Jsmall&quot;, &quot;Ksmall&quot;, &quot;Lsmall&quot;, &quot;Msmall&quot;, &quot;Nsmall&quot;, &quot;Osmall&quot;, &quot;Psmall&quot;, &quot;Qsmall&quot;, &quot;Rsmall&quot;, &quot;Ssmall&quot;, &quot;Tsmall&quot;, &quot;Usmall&quot;, &quot;Vsmall&quot;, &quot;Wsmall&quot;, &quot;Xsmall&quot;, &quot;Ysmall&quot;, &quot;Zsmall&quot;, &quot;colonmonetary&quot;, &quot;onefitted&quot;, &quot;rupiah&quot;, &quot;Tildesmall&quot;, &quot;&quot;, &quot;&quot;, &quot;asuperior&quot;, &quot;centsuperior&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;Aacutesmall&quot;, &quot;Agravesmall&quot;, &quot;Acircumflexsmall&quot;, &quot;Adieresissmall&quot;, &quot;Atildesmall&quot;, &quot;Aringsmall&quot;, &quot;Ccedillasmall&quot;, &quot;Eacutesmall&quot;, &quot;Egravesmall&quot;, &quot;Ecircumflexsmall&quot;, &quot;Edieresissmall&quot;, &quot;Iacutesmall&quot;, &quot;Igravesmall&quot;, &quot;Icircumflexsmall&quot;, &quot;Idieresissmall&quot;, &quot;Ntildesmall&quot;, &quot;Oacutesmall&quot;, &quot;Ogravesmall&quot;, &quot;Ocircumflexsmall&quot;, &quot;Odieresissmall&quot;, &quot;Otildesmall&quot;, &quot;Uacutesmall&quot;, &quot;Ugravesmall&quot;, &quot;Ucircumflexsmall&quot;, &quot;Udieresissmall&quot;, &quot;&quot;, &quot;eightsuperior&quot;, &quot;fourinferior&quot;, &quot;threeinferior&quot;, &quot;sixinferior&quot;, &quot;eightinferior&quot;, &quot;seveninferior&quot;, &quot;Scaronsmall&quot;, &quot;&quot;, &quot;centinferior&quot;, &quot;twoinferior&quot;, &quot;&quot;, &quot;Dieresissmall&quot;, &quot;&quot;, &quot;Caronsmall&quot;, &quot;osuperior&quot;, &quot;fiveinferior&quot;, &quot;&quot;, &quot;commainferior&quot;, &quot;periodinferior&quot;, &quot;Yacutesmall&quot;, &quot;&quot;, &quot;dollarinferior&quot;, &quot;&quot;, &quot;&quot;, &quot;Thornsmall&quot;, &quot;&quot;, &quot;nineinferior&quot;, &quot;zeroinferior&quot;, &quot;Zcaronsmall&quot;, &quot;AEsmall&quot;, &quot;Oslashsmall&quot;, &quot;questiondownsmall&quot;, &quot;oneinferior&quot;, &quot;Lslashsmall&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;Cedillasmall&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;OEsmall&quot;, &quot;figuredash&quot;, &quot;hyphensuperior&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;exclamdownsmall&quot;, &quot;&quot;, &quot;Ydieresissmall&quot;, &quot;&quot;, &quot;onesuperior&quot;, &quot;twosuperior&quot;, &quot;threesuperior&quot;, &quot;foursuperior&quot;, &quot;fivesuperior&quot;, &quot;sixsuperior&quot;, &quot;sevensuperior&quot;, &quot;ninesuperior&quot;, &quot;zerosuperior&quot;, &quot;&quot;, &quot;esuperior&quot;, &quot;rsuperior&quot;, &quot;tsuperior&quot;, &quot;&quot;, &quot;&quot;, &quot;isuperior&quot;, &quot;ssuperior&quot;, &quot;dsuperior&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;lsuperior&quot;, &quot;Ogoneksmall&quot;, &quot;Brevesmall&quot;, &quot;Macronsmall&quot;, &quot;bsuperior&quot;, &quot;nsuperior&quot;, &quot;msuperior&quot;, &quot;commasuperior&quot;, &quot;periodsuperior&quot;, &quot;Dotaccentsmall&quot;, &quot;Ringsmall&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;]; const MacRomanEncoding = [&quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;space&quot;, &quot;exclam&quot;, &quot;quotedbl&quot;, &quot;numbersign&quot;, &quot;dollar&quot;, &quot;percent&quot;, &quot;ampersand&quot;, &quot;quotesingle&quot;, &quot;parenleft&quot;, &quot;parenright&quot;, &quot;asterisk&quot;, &quot;plus&quot;, &quot;comma&quot;, &quot;hyphen&quot;, &quot;period&quot;, &quot;slash&quot;, &quot;zero&quot;, &quot;one&quot;, &quot;two&quot;, &quot;three&quot;, &quot;four&quot;, &quot;five&quot;, &quot;six&quot;, &quot;seven&quot;, &quot;eight&quot;, &quot;nine&quot;, &quot;colon&quot;, &quot;semicolon&quot;, &quot;less&quot;, &quot;equal&quot;, &quot;greater&quot;, &quot;question&quot;, &quot;at&quot;, &quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;, &quot;E&quot;, &quot;F&quot;, &quot;G&quot;, &quot;H&quot;, &quot;I&quot;, &quot;J&quot;, &quot;K&quot;, &quot;L&quot;, &quot;M&quot;, &quot;N&quot;, &quot;O&quot;, &quot;P&quot;, &quot;Q&quot;, &quot;R&quot;, &quot;S&quot;, &quot;T&quot;, &quot;U&quot;, &quot;V&quot;, &quot;W&quot;, &quot;X&quot;, &quot;Y&quot;, &quot;Z&quot;, &quot;bracketleft&quot;, &quot;backslash&quot;, &quot;bracketright&quot;, &quot;asciicircum&quot;, &quot;underscore&quot;, &quot;grave&quot;, &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;, &quot;f&quot;, &quot;g&quot;, &quot;h&quot;, &quot;i&quot;, &quot;j&quot;, &quot;k&quot;, &quot;l&quot;, &quot;m&quot;, &quot;n&quot;, &quot;o&quot;, &quot;p&quot;, &quot;q&quot;, &quot;r&quot;, &quot;s&quot;, &quot;t&quot;, &quot;u&quot;, &quot;v&quot;, &quot;w&quot;, &quot;x&quot;, &quot;y&quot;, &quot;z&quot;, &quot;braceleft&quot;, &quot;bar&quot;, &quot;braceright&quot;, &quot;asciitilde&quot;, &quot;&quot;, &quot;Adieresis&quot;, &quot;Aring&quot;, &quot;Ccedilla&quot;, &quot;Eacute&quot;, &quot;Ntilde&quot;, &quot;Odieresis&quot;, &quot;Udieresis&quot;, &quot;aacute&quot;, &quot;agrave&quot;, &quot;acircumflex&quot;, &quot;adieresis&quot;, &quot;atilde&quot;, &quot;aring&quot;, &quot;ccedilla&quot;, &quot;eacute&quot;, &quot;egrave&quot;, &quot;ecircumflex&quot;, &quot;edieresis&quot;, &quot;iacute&quot;, &quot;igrave&quot;, &quot;icircumflex&quot;, &quot;idieresis&quot;, &quot;ntilde&quot;, &quot;oacute&quot;, &quot;ograve&quot;, &quot;ocircumflex&quot;, &quot;odieresis&quot;, &quot;otilde&quot;, &quot;uacute&quot;, &quot;ugrave&quot;, &quot;ucircumflex&quot;, &quot;udieresis&quot;, &quot;dagger&quot;, &quot;degree&quot;, &quot;cent&quot;, &quot;sterling&quot;, &quot;section&quot;, &quot;bullet&quot;, &quot;paragraph&quot;, &quot;germandbls&quot;, &quot;registered&quot;, &quot;copyright&quot;, &quot;trademark&quot;, &quot;acute&quot;, &quot;dieresis&quot;, &quot;notequal&quot;, &quot;AE&quot;, &quot;Oslash&quot;, &quot;infinity&quot;, &quot;plusminus&quot;, &quot;lessequal&quot;, &quot;greaterequal&quot;, &quot;yen&quot;, &quot;mu&quot;, &quot;partialdiff&quot;, &quot;summation&quot;, &quot;product&quot;, &quot;pi&quot;, &quot;integral&quot;, &quot;ordfeminine&quot;, &quot;ordmasculine&quot;, &quot;Omega&quot;, &quot;ae&quot;, &quot;oslash&quot;, &quot;questiondown&quot;, &quot;exclamdown&quot;, &quot;logicalnot&quot;, &quot;radical&quot;, &quot;florin&quot;, &quot;approxequal&quot;, &quot;Delta&quot;, &quot;guillemotleft&quot;, &quot;guillemotright&quot;, &quot;ellipsis&quot;, &quot;space&quot;, &quot;Agrave&quot;, &quot;Atilde&quot;, &quot;Otilde&quot;, &quot;OE&quot;, &quot;oe&quot;, &quot;endash&quot;, &quot;emdash&quot;, &quot;quotedblleft&quot;, &quot;quotedblright&quot;, &quot;quoteleft&quot;, &quot;quoteright&quot;, &quot;divide&quot;, &quot;lozenge&quot;, &quot;ydieresis&quot;, &quot;Ydieresis&quot;, &quot;fraction&quot;, &quot;currency&quot;, &quot;guilsinglleft&quot;, &quot;guilsinglright&quot;, &quot;fi&quot;, &quot;fl&quot;, &quot;daggerdbl&quot;, &quot;periodcentered&quot;, &quot;quotesinglbase&quot;, &quot;quotedblbase&quot;, &quot;perthousand&quot;, &quot;Acircumflex&quot;, &quot;Ecircumflex&quot;, &quot;Aacute&quot;, &quot;Edieresis&quot;, &quot;Egrave&quot;, &quot;Iacute&quot;, &quot;Icircumflex&quot;, &quot;Idieresis&quot;, &quot;Igrave&quot;, &quot;Oacute&quot;, &quot;Ocircumflex&quot;, &quot;apple&quot;, &quot;Ograve&quot;, &quot;Uacute&quot;, &quot;Ucircumflex&quot;, &quot;Ugrave&quot;, &quot;dotlessi&quot;, &quot;circumflex&quot;, &quot;tilde&quot;, &quot;macron&quot;, &quot;breve&quot;, &quot;dotaccent&quot;, &quot;ring&quot;, &quot;cedilla&quot;, &quot;hungarumlaut&quot;, &quot;ogonek&quot;, &quot;caron&quot;]; exports.MacRomanEncoding = MacRomanEncoding; const StandardEncoding = [&quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;space&quot;, &quot;exclam&quot;, &quot;quotedbl&quot;, &quot;numbersign&quot;, &quot;dollar&quot;, &quot;percent&quot;, &quot;ampersand&quot;, &quot;quoteright&quot;, &quot;parenleft&quot;, &quot;parenright&quot;, &quot;asterisk&quot;, &quot;plus&quot;, &quot;comma&quot;, &quot;hyphen&quot;, &quot;period&quot;, &quot;slash&quot;, &quot;zero&quot;, &quot;one&quot;, &quot;two&quot;, &quot;three&quot;, &quot;four&quot;, &quot;five&quot;, &quot;six&quot;, &quot;seven&quot;, &quot;eight&quot;, &quot;nine&quot;, &quot;colon&quot;, &quot;semicolon&quot;, &quot;less&quot;, &quot;equal&quot;, &quot;greater&quot;, &quot;question&quot;, &quot;at&quot;, &quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;, &quot;E&quot;, &quot;F&quot;, &quot;G&quot;, &quot;H&quot;, &quot;I&quot;, &quot;J&quot;, &quot;K&quot;, &quot;L&quot;, &quot;M&quot;, &quot;N&quot;, &quot;O&quot;, &quot;P&quot;, &quot;Q&quot;, &quot;R&quot;, &quot;S&quot;, &quot;T&quot;, &quot;U&quot;, &quot;V&quot;, &quot;W&quot;, &quot;X&quot;, &quot;Y&quot;, &quot;Z&quot;, &quot;bracketleft&quot;, &quot;backslash&quot;, &quot;bracketright&quot;, &quot;asciicircum&quot;, &quot;underscore&quot;, &quot;quoteleft&quot;, &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;, &quot;f&quot;, &quot;g&quot;, &quot;h&quot;, &quot;i&quot;, &quot;j&quot;, &quot;k&quot;, &quot;l&quot;, &quot;m&quot;, &quot;n&quot;, &quot;o&quot;, &quot;p&quot;, &quot;q&quot;, &quot;r&quot;, &quot;s&quot;, &quot;t&quot;, &quot;u&quot;, &quot;v&quot;, &quot;w&quot;, &quot;x&quot;, &quot;y&quot;, &quot;z&quot;, &quot;braceleft&quot;, &quot;bar&quot;, &quot;braceright&quot;, &quot;asciitilde&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;exclamdown&quot;, &quot;cent&quot;, &quot;sterling&quot;, &quot;fraction&quot;, &quot;yen&quot;, &quot;florin&quot;, &quot;section&quot;, &quot;currency&quot;, &quot;quotesingle&quot;, &quot;quotedblleft&quot;, &quot;guillemotleft&quot;, &quot;guilsinglleft&quot;, &quot;guilsinglright&quot;, &quot;fi&quot;, &quot;fl&quot;, &quot;&quot;, &quot;endash&quot;, &quot;dagger&quot;, &quot;daggerdbl&quot;, &quot;periodcentered&quot;, &quot;&quot;, &quot;paragraph&quot;, &quot;bullet&quot;, &quot;quotesinglbase&quot;, &quot;quotedblbase&quot;, &quot;quotedblright&quot;, &quot;guillemotright&quot;, &quot;ellipsis&quot;, &quot;perthousand&quot;, &quot;&quot;, &quot;questiondown&quot;, &quot;&quot;, &quot;grave&quot;, &quot;acute&quot;, &quot;circumflex&quot;, &quot;tilde&quot;, &quot;macron&quot;, &quot;breve&quot;, &quot;dotaccent&quot;, &quot;dieresis&quot;, &quot;&quot;, &quot;ring&quot;, &quot;cedilla&quot;, &quot;&quot;, &quot;hungarumlaut&quot;, &quot;ogonek&quot;, &quot;caron&quot;, &quot;emdash&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;AE&quot;, &quot;&quot;, &quot;ordfeminine&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;Lslash&quot;, &quot;Oslash&quot;, &quot;OE&quot;, &quot;ordmasculine&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;ae&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;dotlessi&quot;, &quot;&quot;, &quot;&quot;, &quot;lslash&quot;, &quot;oslash&quot;, &quot;oe&quot;, &quot;germandbls&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;]; exports.StandardEncoding = StandardEncoding; const WinAnsiEncoding = [&quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;space&quot;, &quot;exclam&quot;, &quot;quotedbl&quot;, &quot;numbersign&quot;, &quot;dollar&quot;, &quot;percent&quot;, &quot;ampersand&quot;, &quot;quotesingle&quot;, &quot;parenleft&quot;, &quot;parenright&quot;, &quot;asterisk&quot;, &quot;plus&quot;, &quot;comma&quot;, &quot;hyphen&quot;, &quot;period&quot;, &quot;slash&quot;, &quot;zero&quot;, &quot;one&quot;, &quot;two&quot;, &quot;three&quot;, &quot;four&quot;, &quot;five&quot;, &quot;six&quot;, &quot;seven&quot;, &quot;eight&quot;, &quot;nine&quot;, &quot;colon&quot;, &quot;semicolon&quot;, &quot;less&quot;, &quot;equal&quot;, &quot;greater&quot;, &quot;question&quot;, &quot;at&quot;, &quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;, &quot;E&quot;, &quot;F&quot;, &quot;G&quot;, &quot;H&quot;, &quot;I&quot;, &quot;J&quot;, &quot;K&quot;, &quot;L&quot;, &quot;M&quot;, &quot;N&quot;, &quot;O&quot;, &quot;P&quot;, &quot;Q&quot;, &quot;R&quot;, &quot;S&quot;, &quot;T&quot;, &quot;U&quot;, &quot;V&quot;, &quot;W&quot;, &quot;X&quot;, &quot;Y&quot;, &quot;Z&quot;, &quot;bracketleft&quot;, &quot;backslash&quot;, &quot;bracketright&quot;, &quot;asciicircum&quot;, &quot;underscore&quot;, &quot;grave&quot;, &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;, &quot;f&quot;, &quot;g&quot;, &quot;h&quot;, &quot;i&quot;, &quot;j&quot;, &quot;k&quot;, &quot;l&quot;, &quot;m&quot;, &quot;n&quot;, &quot;o&quot;, &quot;p&quot;, &quot;q&quot;, &quot;r&quot;, &quot;s&quot;, &quot;t&quot;, &quot;u&quot;, &quot;v&quot;, &quot;w&quot;, &quot;x&quot;, &quot;y&quot;, &quot;z&quot;, &quot;braceleft&quot;, &quot;bar&quot;, &quot;braceright&quot;, &quot;asciitilde&quot;, &quot;bullet&quot;, &quot;Euro&quot;, &quot;bullet&quot;, &quot;quotesinglbase&quot;, &quot;florin&quot;, &quot;quotedblbase&quot;, &quot;ellipsis&quot;, &quot;dagger&quot;, &quot;daggerdbl&quot;, &quot;circumflex&quot;, &quot;perthousand&quot;, &quot;Scaron&quot;, &quot;guilsinglleft&quot;, &quot;OE&quot;, &quot;bullet&quot;, &quot;Zcaron&quot;, &quot;bullet&quot;, &quot;bullet&quot;, &quot;quoteleft&quot;, &quot;quoteright&quot;, &quot;quotedblleft&quot;, &quot;quotedblright&quot;, &quot;bullet&quot;, &quot;endash&quot;, &quot;emdash&quot;, &quot;tilde&quot;, &quot;trademark&quot;, &quot;scaron&quot;, &quot;guilsinglright&quot;, &quot;oe&quot;, &quot;bullet&quot;, &quot;zcaron&quot;, &quot;Ydieresis&quot;, &quot;space&quot;, &quot;exclamdown&quot;, &quot;cent&quot;, &quot;sterling&quot;, &quot;currency&quot;, &quot;yen&quot;, &quot;brokenbar&quot;, &quot;section&quot;, &quot;dieresis&quot;, &quot;copyright&quot;, &quot;ordfeminine&quot;, &quot;guillemotleft&quot;, &quot;logicalnot&quot;, &quot;hyphen&quot;, &quot;registered&quot;, &quot;macron&quot;, &quot;degree&quot;, &quot;plusminus&quot;, &quot;twosuperior&quot;, &quot;threesuperior&quot;, &quot;acute&quot;, &quot;mu&quot;, &quot;paragraph&quot;, &quot;periodcentered&quot;, &quot;cedilla&quot;, &quot;onesuperior&quot;, &quot;ordmasculine&quot;, &quot;guillemotright&quot;, &quot;onequarter&quot;, &quot;onehalf&quot;, &quot;threequarters&quot;, &quot;questiondown&quot;, &quot;Agrave&quot;, &quot;Aacute&quot;, &quot;Acircumflex&quot;, &quot;Atilde&quot;, &quot;Adieresis&quot;, &quot;Aring&quot;, &quot;AE&quot;, &quot;Ccedilla&quot;, &quot;Egrave&quot;, &quot;Eacute&quot;, &quot;Ecircumflex&quot;, &quot;Edieresis&quot;, &quot;Igrave&quot;, &quot;Iacute&quot;, &quot;Icircumflex&quot;, &quot;Idieresis&quot;, &quot;Eth&quot;, &quot;Ntilde&quot;, &quot;Ograve&quot;, &quot;Oacute&quot;, &quot;Ocircumflex&quot;, &quot;Otilde&quot;, &quot;Odieresis&quot;, &quot;multiply&quot;, &quot;Oslash&quot;, &quot;Ugrave&quot;, &quot;Uacute&quot;, &quot;Ucircumflex&quot;, &quot;Udieresis&quot;, &quot;Yacute&quot;, &quot;Thorn&quot;, &quot;germandbls&quot;, &quot;agrave&quot;, &quot;aacute&quot;, &quot;acircumflex&quot;, &quot;atilde&quot;, &quot;adieresis&quot;, &quot;aring&quot;, &quot;ae&quot;, &quot;ccedilla&quot;, &quot;egrave&quot;, &quot;eacute&quot;, &quot;ecircumflex&quot;, &quot;edieresis&quot;, &quot;igrave&quot;, &quot;iacute&quot;, &quot;icircumflex&quot;, &quot;idieresis&quot;, &quot;eth&quot;, &quot;ntilde&quot;, &quot;ograve&quot;, &quot;oacute&quot;, &quot;ocircumflex&quot;, &quot;otilde&quot;, &quot;odieresis&quot;, &quot;divide&quot;, &quot;oslash&quot;, &quot;ugrave&quot;, &quot;uacute&quot;, &quot;ucircumflex&quot;, &quot;udieresis&quot;, &quot;yacute&quot;, &quot;thorn&quot;, &quot;ydieresis&quot;]; exports.WinAnsiEncoding = WinAnsiEncoding; const SymbolSetEncoding = [&quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;space&quot;, &quot;exclam&quot;, &quot;universal&quot;, &quot;numbersign&quot;, &quot;existential&quot;, &quot;percent&quot;, &quot;ampersand&quot;, &quot;suchthat&quot;, &quot;parenleft&quot;, &quot;parenright&quot;, &quot;asteriskmath&quot;, &quot;plus&quot;, &quot;comma&quot;, &quot;minus&quot;, &quot;period&quot;, &quot;slash&quot;, &quot;zero&quot;, &quot;one&quot;, &quot;two&quot;, &quot;three&quot;, &quot;four&quot;, &quot;five&quot;, &quot;six&quot;, &quot;seven&quot;, &quot;eight&quot;, &quot;nine&quot;, &quot;colon&quot;, &quot;semicolon&quot;, &quot;less&quot;, &quot;equal&quot;, &quot;greater&quot;, &quot;question&quot;, &quot;congruent&quot;, &quot;Alpha&quot;, &quot;Beta&quot;, &quot;Chi&quot;, &quot;Delta&quot;, &quot;Epsilon&quot;, &quot;Phi&quot;, &quot;Gamma&quot;, &quot;Eta&quot;, &quot;Iota&quot;, &quot;theta1&quot;, &quot;Kappa&quot;, &quot;Lambda&quot;, &quot;Mu&quot;, &quot;Nu&quot;, &quot;Omicron&quot;, &quot;Pi&quot;, &quot;Theta&quot;, &quot;Rho&quot;, &quot;Sigma&quot;, &quot;Tau&quot;, &quot;Upsilon&quot;, &quot;sigma1&quot;, &quot;Omega&quot;, &quot;Xi&quot;, &quot;Psi&quot;, &quot;Zeta&quot;, &quot;bracketleft&quot;, &quot;therefore&quot;, &quot;bracketright&quot;, &quot;perpendicular&quot;, &quot;underscore&quot;, &quot;radicalex&quot;, &quot;alpha&quot;, &quot;beta&quot;, &quot;chi&quot;, &quot;delta&quot;, &quot;epsilon&quot;, &quot;phi&quot;, &quot;gamma&quot;, &quot;eta&quot;, &quot;iota&quot;, &quot;phi1&quot;, &quot;kappa&quot;, &quot;lambda&quot;, &quot;mu&quot;, &quot;nu&quot;, &quot;omicron&quot;, &quot;pi&quot;, &quot;theta&quot;, &quot;rho&quot;, &quot;sigma&quot;, &quot;tau&quot;, &quot;upsilon&quot;, &quot;omega1&quot;, &quot;omega&quot;, &quot;xi&quot;, &quot;psi&quot;, &quot;zeta&quot;, &quot;braceleft&quot;, &quot;bar&quot;, &quot;braceright&quot;, &quot;similar&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;Euro&quot;, &quot;Upsilon1&quot;, &quot;minute&quot;, &quot;lessequal&quot;, &quot;fraction&quot;, &quot;infinity&quot;, &quot;florin&quot;, &quot;club&quot;, &quot;diamond&quot;, &quot;heart&quot;, &quot;spade&quot;, &quot;arrowboth&quot;, &quot;arrowleft&quot;, &quot;arrowup&quot;, &quot;arrowright&quot;, &quot;arrowdown&quot;, &quot;degree&quot;, &quot;plusminus&quot;, &quot;second&quot;, &quot;greaterequal&quot;, &quot;multiply&quot;, &quot;proportional&quot;, &quot;partialdiff&quot;, &quot;bullet&quot;, &quot;divide&quot;, &quot;notequal&quot;, &quot;equivalence&quot;, &quot;approxequal&quot;, &quot;ellipsis&quot;, &quot;arrowvertex&quot;, &quot;arrowhorizex&quot;, &quot;carriagereturn&quot;, &quot;aleph&quot;, &quot;Ifraktur&quot;, &quot;Rfraktur&quot;, &quot;weierstrass&quot;, &quot;circlemultiply&quot;, &quot;circleplus&quot;, &quot;emptyset&quot;, &quot;intersection&quot;, &quot;union&quot;, &quot;propersuperset&quot;, &quot;reflexsuperset&quot;, &quot;notsubset&quot;, &quot;propersubset&quot;, &quot;reflexsubset&quot;, &quot;element&quot;, &quot;notelement&quot;, &quot;angle&quot;, &quot;gradient&quot;, &quot;registerserif&quot;, &quot;copyrightserif&quot;, &quot;trademarkserif&quot;, &quot;product&quot;, &quot;radical&quot;, &quot;dotmath&quot;, &quot;logicalnot&quot;, &quot;logicaland&quot;, &quot;logicalor&quot;, &quot;arrowdblboth&quot;, &quot;arrowdblleft&quot;, &quot;arrowdblup&quot;, &quot;arrowdblright&quot;, &quot;arrowdbldown&quot;, &quot;lozenge&quot;, &quot;angleleft&quot;, &quot;registersans&quot;, &quot;copyrightsans&quot;, &quot;trademarksans&quot;, &quot;summation&quot;, &quot;parenlefttp&quot;, &quot;parenleftex&quot;, &quot;parenleftbt&quot;, &quot;bracketlefttp&quot;, &quot;bracketleftex&quot;, &quot;bracketleftbt&quot;, &quot;bracelefttp&quot;, &quot;braceleftmid&quot;, &quot;braceleftbt&quot;, &quot;braceex&quot;, &quot;&quot;, &quot;angleright&quot;, &quot;integral&quot;, &quot;integraltp&quot;, &quot;integralex&quot;, &quot;integralbt&quot;, &quot;parenrighttp&quot;, &quot;parenrightex&quot;, &quot;parenrightbt&quot;, &quot;bracketrighttp&quot;, &quot;bracketrightex&quot;, &quot;bracketrightbt&quot;, &quot;bracerighttp&quot;, &quot;bracerightmid&quot;, &quot;bracerightbt&quot;, &quot;&quot;]; exports.SymbolSetEncoding = SymbolSetEncoding; const ZapfDingbatsEncoding = [&quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;space&quot;, &quot;a1&quot;, &quot;a2&quot;, &quot;a202&quot;, &quot;a3&quot;, &quot;a4&quot;, &quot;a5&quot;, &quot;a119&quot;, &quot;a118&quot;, &quot;a117&quot;, &quot;a11&quot;, &quot;a12&quot;, &quot;a13&quot;, &quot;a14&quot;, &quot;a15&quot;, &quot;a16&quot;, &quot;a105&quot;, &quot;a17&quot;, &quot;a18&quot;, &quot;a19&quot;, &quot;a20&quot;, &quot;a21&quot;, &quot;a22&quot;, &quot;a23&quot;, &quot;a24&quot;, &quot;a25&quot;, &quot;a26&quot;, &quot;a27&quot;, &quot;a28&quot;, &quot;a6&quot;, &quot;a7&quot;, &quot;a8&quot;, &quot;a9&quot;, &quot;a10&quot;, &quot;a29&quot;, &quot;a30&quot;, &quot;a31&quot;, &quot;a32&quot;, &quot;a33&quot;, &quot;a34&quot;, &quot;a35&quot;, &quot;a36&quot;, &quot;a37&quot;, &quot;a38&quot;, &quot;a39&quot;, &quot;a40&quot;, &quot;a41&quot;, &quot;a42&quot;, &quot;a43&quot;, &quot;a44&quot;, &quot;a45&quot;, &quot;a46&quot;, &quot;a47&quot;, &quot;a48&quot;, &quot;a49&quot;, &quot;a50&quot;, &quot;a51&quot;, &quot;a52&quot;, &quot;a53&quot;, &quot;a54&quot;, &quot;a55&quot;, &quot;a56&quot;, &quot;a57&quot;, &quot;a58&quot;, &quot;a59&quot;, &quot;a60&quot;, &quot;a61&quot;, &quot;a62&quot;, &quot;a63&quot;, &quot;a64&quot;, &quot;a65&quot;, &quot;a66&quot;, &quot;a67&quot;, &quot;a68&quot;, &quot;a69&quot;, &quot;a70&quot;, &quot;a71&quot;, &quot;a72&quot;, &quot;a73&quot;, &quot;a74&quot;, &quot;a203&quot;, &quot;a75&quot;, &quot;a204&quot;, &quot;a76&quot;, &quot;a77&quot;, &quot;a78&quot;, &quot;a79&quot;, &quot;a81&quot;, &quot;a82&quot;, &quot;a83&quot;, &quot;a84&quot;, &quot;a97&quot;, &quot;a98&quot;, &quot;a99&quot;, &quot;a100&quot;, &quot;&quot;, &quot;a89&quot;, &quot;a90&quot;, &quot;a93&quot;, &quot;a94&quot;, &quot;a91&quot;, &quot;a92&quot;, &quot;a205&quot;, &quot;a85&quot;, &quot;a206&quot;, &quot;a86&quot;, &quot;a87&quot;, &quot;a88&quot;, &quot;a95&quot;, &quot;a96&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;a101&quot;, &quot;a102&quot;, &quot;a103&quot;, &quot;a104&quot;, &quot;a106&quot;, &quot;a107&quot;, &quot;a108&quot;, &quot;a112&quot;, &quot;a111&quot;, &quot;a110&quot;, &quot;a109&quot;, &quot;a120&quot;, &quot;a121&quot;, &quot;a122&quot;, &quot;a123&quot;, &quot;a124&quot;, &quot;a125&quot;, &quot;a126&quot;, &quot;a127&quot;, &quot;a128&quot;, &quot;a129&quot;, &quot;a130&quot;, &quot;a131&quot;, &quot;a132&quot;, &quot;a133&quot;, &quot;a134&quot;, &quot;a135&quot;, &quot;a136&quot;, &quot;a137&quot;, &quot;a138&quot;, &quot;a139&quot;, &quot;a140&quot;, &quot;a141&quot;, &quot;a142&quot;, &quot;a143&quot;, &quot;a144&quot;, &quot;a145&quot;, &quot;a146&quot;, &quot;a147&quot;, &quot;a148&quot;, &quot;a149&quot;, &quot;a150&quot;, &quot;a151&quot;, &quot;a152&quot;, &quot;a153&quot;, &quot;a154&quot;, &quot;a155&quot;, &quot;a156&quot;, &quot;a157&quot;, &quot;a158&quot;, &quot;a159&quot;, &quot;a160&quot;, &quot;a161&quot;, &quot;a163&quot;, &quot;a164&quot;, &quot;a196&quot;, &quot;a165&quot;, &quot;a192&quot;, &quot;a166&quot;, &quot;a167&quot;, &quot;a168&quot;, &quot;a169&quot;, &quot;a170&quot;, &quot;a171&quot;, &quot;a172&quot;, &quot;a173&quot;, &quot;a162&quot;, &quot;a174&quot;, &quot;a175&quot;, &quot;a176&quot;, &quot;a177&quot;, &quot;a178&quot;, &quot;a179&quot;, &quot;a193&quot;, &quot;a180&quot;, &quot;a199&quot;, &quot;a181&quot;, &quot;a200&quot;, &quot;a182&quot;, &quot;&quot;, &quot;a201&quot;, &quot;a183&quot;, &quot;a184&quot;, &quot;a197&quot;, &quot;a185&quot;, &quot;a194&quot;, &quot;a198&quot;, &quot;a186&quot;, &quot;a195&quot;, &quot;a187&quot;, &quot;a188&quot;, &quot;a189&quot;, &quot;a190&quot;, &quot;a191&quot;, &quot;&quot;]; exports.ZapfDingbatsEncoding = ZapfDingbatsEncoding; function getEncoding(encodingName) { switch (encodingName) { case &quot;WinAnsiEncoding&quot;: return WinAnsiEncoding; case &quot;StandardEncoding&quot;: return StandardEncoding; case &quot;MacRomanEncoding&quot;: return MacRomanEncoding; case &quot;SymbolSetEncoding&quot;: return SymbolSetEncoding; case &quot;ZapfDingbatsEncoding&quot;: return ZapfDingbatsEncoding; case &quot;ExpertEncoding&quot;: return ExpertEncoding; case &quot;MacExpertEncoding&quot;: return MacExpertEncoding; default: return null; } } /***/ }), /* 36 */ /***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) =&gt; { Object.defineProperty(exports, &quot;__esModule&quot;, ({ value: true })); exports.SEAC_ANALYSIS_ENABLED = exports.MacStandardGlyphOrdering = exports.FontFlags = void 0; exports.getFontType = getFontType; exports.normalizeFontName = normalizeFontName; exports.recoverGlyphName = recoverGlyphName; exports.type1FontGlyphMapping = type1FontGlyphMapping; var _util = __w_pdfjs_require__(2); var _encodings = __w_pdfjs_require__(35); var _glyphlist = __w_pdfjs_require__(37); var _unicode = __w_pdfjs_require__(38); const SEAC_ANALYSIS_ENABLED = true; exports.SEAC_ANALYSIS_ENABLED = SEAC_ANALYSIS_ENABLED; const FontFlags = { FixedPitch: 1, Serif: 2, Symbolic: 4, Script: 8, Nonsymbolic: 32, Italic: 64, AllCap: 65536, SmallCap: 131072, ForceBold: 262144 }; exports.FontFlags = FontFlags; const MacStandardGlyphOrdering = [&quot;.notdef&quot;, &quot;.null&quot;, &quot;nonmarkingreturn&quot;, &quot;space&quot;, &quot;exclam&quot;, &quot;quotedbl&quot;, &quot;numbersign&quot;, &quot;dollar&quot;, &quot;percent&quot;, &quot;ampersand&quot;, &quot;quotesingle&quot;, &quot;parenleft&quot;, &quot;parenright&quot;, &quot;asterisk&quot;, &quot;plus&quot;, &quot;comma&quot;, &quot;hyphen&quot;, &quot;period&quot;, &quot;slash&quot;, &quot;zero&quot;, &quot;one&quot;, &quot;two&quot;, &quot;three&quot;, &quot;four&quot;, &quot;five&quot;, &quot;six&quot;, &quot;seven&quot;, &quot;eight&quot;, &quot;nine&quot;, &quot;colon&quot;, &quot;semicolon&quot;, &quot;less&quot;, &quot;equal&quot;, &quot;greater&quot;, &quot;question&quot;, &quot;at&quot;, &quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;, &quot;E&quot;, &quot;F&quot;, &quot;G&quot;, &quot;H&quot;, &quot;I&quot;, &quot;J&quot;, &quot;K&quot;, &quot;L&quot;, &quot;M&quot;, &quot;N&quot;, &quot;O&quot;, &quot;P&quot;, &quot;Q&quot;, &quot;R&quot;, &quot;S&quot;, &quot;T&quot;, &quot;U&quot;, &quot;V&quot;, &quot;W&quot;, &quot;X&quot;, &quot;Y&quot;, &quot;Z&quot;, &quot;bracketleft&quot;, &quot;backslash&quot;, &quot;bracketright&quot;, &quot;asciicircum&quot;, &quot;underscore&quot;, &quot;grave&quot;, &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;, &quot;f&quot;, &quot;g&quot;, &quot;h&quot;, &quot;i&quot;, &quot;j&quot;, &quot;k&quot;, &quot;l&quot;, &quot;m&quot;, &quot;n&quot;, &quot;o&quot;, &quot;p&quot;, &quot;q&quot;, &quot;r&quot;, &quot;s&quot;, &quot;t&quot;, &quot;u&quot;, &quot;v&quot;, &quot;w&quot;, &quot;x&quot;, &quot;y&quot;, &quot;z&quot;, &quot;braceleft&quot;, &quot;bar&quot;, &quot;braceright&quot;, &quot;asciitilde&quot;, &quot;Adieresis&quot;, &quot;Aring&quot;, &quot;Ccedilla&quot;, &quot;Eacute&quot;, &quot;Ntilde&quot;, &quot;Odieresis&quot;, &quot;Udieresis&quot;, &quot;aacute&quot;, &quot;agrave&quot;, &quot;acircumflex&quot;, &quot;adieresis&quot;, &quot;atilde&quot;, &quot;aring&quot;, &quot;ccedilla&quot;, &quot;eacute&quot;, &quot;egrave&quot;, &quot;ecircumflex&quot;, &quot;edieresis&quot;, &quot;iacute&quot;, &quot;igrave&quot;, &quot;icircumflex&quot;, &quot;idieresis&quot;, &quot;ntilde&quot;, &quot;oacute&quot;, &quot;ograve&quot;, &quot;ocircumflex&quot;, &quot;odieresis&quot;, &quot;otilde&quot;, &quot;uacute&quot;, &quot;ugrave&quot;, &quot;ucircumflex&quot;, &quot;udieresis&quot;, &quot;dagger&quot;, &quot;degree&quot;, &quot;cent&quot;, &quot;sterling&quot;, &quot;section&quot;, &quot;bullet&quot;, &quot;paragraph&quot;, &quot;germandbls&quot;, &quot;registered&quot;, &quot;copyright&quot;, &quot;trademark&quot;, &quot;acute&quot;, &quot;dieresis&quot;, &quot;notequal&quot;, &quot;AE&quot;, &quot;Oslash&quot;, &quot;infinity&quot;, &quot;plusminus&quot;, &quot;lessequal&quot;, &quot;greaterequal&quot;, &quot;yen&quot;, &quot;mu&quot;, &quot;partialdiff&quot;, &quot;summation&quot;, &quot;product&quot;, &quot;pi&quot;, &quot;integral&quot;, &quot;ordfeminine&quot;, &quot;ordmasculine&quot;, &quot;Omega&quot;, &quot;ae&quot;, &quot;oslash&quot;, &quot;questiondown&quot;, &quot;exclamdown&quot;, &quot;logicalnot&quot;, &quot;radical&quot;, &quot;florin&quot;, &quot;approxequal&quot;, &quot;Delta&quot;, &quot;guillemotleft&quot;, &quot;guillemotright&quot;, &quot;ellipsis&quot;, &quot;nonbreakingspace&quot;, &quot;Agrave&quot;, &quot;Atilde&quot;, &quot;Otilde&quot;, &quot;OE&quot;, &quot;oe&quot;, &quot;endash&quot;, &quot;emdash&quot;, &quot;quotedblleft&quot;, &quot;quotedblright&quot;, &quot;quoteleft&quot;, &quot;quoteright&quot;, &quot;divide&quot;, &quot;lozenge&quot;, &quot;ydieresis&quot;, &quot;Ydieresis&quot;, &quot;fraction&quot;, &quot;currency&quot;, &quot;guilsinglleft&quot;, &quot;guilsinglright&quot;, &quot;fi&quot;, &quot;fl&quot;, &quot;daggerdbl&quot;, &quot;periodcentered&quot;, &quot;quotesinglbase&quot;, &quot;quotedblbase&quot;, &quot;perthousand&quot;, &quot;Acircumflex&quot;, &quot;Ecircumflex&quot;, &quot;Aacute&quot;, &quot;Edieresis&quot;, &quot;Egrave&quot;, &quot;Iacute&quot;, &quot;Icircumflex&quot;, &quot;Idieresis&quot;, &quot;Igrave&quot;, &quot;Oacute&quot;, &quot;Ocircumflex&quot;, &quot;apple&quot;, &quot;Ograve&quot;, &quot;Uacute&quot;, &quot;Ucircumflex&quot;, &quot;Ugrave&quot;, &quot;dotlessi&quot;, &quot;circumflex&quot;, &quot;tilde&quot;, &quot;macron&quot;, &quot;breve&quot;, &quot;dotaccent&quot;, &quot;ring&quot;, &quot;cedilla&quot;, &quot;hungarumlaut&quot;, &quot;ogonek&quot;, &quot;caron&quot;, &quot;Lslash&quot;, &quot;lslash&quot;, &quot;Scaron&quot;, &quot;scaron&quot;, &quot;Zcaron&quot;, &quot;zcaron&quot;, &quot;brokenbar&quot;, &quot;Eth&quot;, &quot;eth&quot;, &quot;Yacute&quot;, &quot;yacute&quot;, &quot;Thorn&quot;, &quot;thorn&quot;, &quot;minus&quot;, &quot;multiply&quot;, &quot;onesuperior&quot;, &quot;twosuperior&quot;, &quot;threesuperior&quot;, &quot;onehalf&quot;, &quot;onequarter&quot;, &quot;threequarters&quot;, &quot;franc&quot;, &quot;Gbreve&quot;, &quot;gbreve&quot;, &quot;Idotaccent&quot;, &quot;Scedilla&quot;, &quot;scedilla&quot;, &quot;Cacute&quot;, &quot;cacute&quot;, &quot;Ccaron&quot;, &quot;ccaron&quot;, &quot;dcroat&quot;]; exports.MacStandardGlyphOrdering = MacStandardGlyphOrdering; function getFontType(type, subtype, isStandardFont = false) { switch (type) { case &quot;Type1&quot;: if (isStandardFont) { return _util.FontType.TYPE1STANDARD; } return subtype === &quot;Type1C&quot; ? _util.FontType.TYPE1C : _util.FontType.TYPE1; case &quot;CIDFontType0&quot;: return subtype === &quot;CIDFontType0C&quot; ? _util.FontType.CIDFONTTYPE0C : _util.FontType.CIDFONTTYPE0; case &quot;OpenType&quot;: return _util.FontType.OPENTYPE; case &quot;TrueType&quot;: return _util.FontType.TRUETYPE; case &quot;CIDFontType2&quot;: return _util.FontType.CIDFONTTYPE2; case &quot;MMType1&quot;: return _util.FontType.MMTYPE1; case &quot;Type0&quot;: return _util.FontType.TYPE0; default: return _util.FontType.UNKNOWN; } } function recoverGlyphName(name, glyphsUnicodeMap) { if (glyphsUnicodeMap[name] !== undefined) { return name; } const unicode = (0, _unicode.getUnicodeForGlyph)(name, glyphsUnicodeMap); if (unicode !== -1) { for (const key in glyphsUnicodeMap) { if (glyphsUnicodeMap[key] === unicode) { return key; } } } (0, _util.info)(&quot;Unable to recover a standard glyph name for: &quot; + name); return name; } function type1FontGlyphMapping(properties, builtInEncoding, glyphNames) { const charCodeToGlyphId = Object.create(null); let glyphId, charCode, baseEncoding; const isSymbolicFont = !!(properties.flags &amp; FontFlags.Symbolic); if (properties.isInternalFont) { baseEncoding = builtInEncoding; for (charCode = 0; charCode &lt; baseEncoding.length; charCode++) { glyphId = glyphNames.indexOf(baseEncoding[charCode]); if (glyphId &gt;= 0) { charCodeToGlyphId[charCode] = glyphId; } else { charCodeToGlyphId[charCode] = 0; } } } else if (properties.baseEncodingName) { baseEncoding = (0, _encodings.getEncoding)(properties.baseEncodingName); for (charCode = 0; charCode &lt; baseEncoding.length; charCode++) { glyphId = glyphNames.indexOf(baseEncoding[charCode]); if (glyphId &gt;= 0) { charCodeToGlyphId[charCode] = glyphId; } else { charCodeToGlyphId[charCode] = 0; } } } else if (isSymbolicFont) { for (charCode in builtInEncoding) { charCodeToGlyphId[charCode] = builtInEncoding[charCode]; } } else { baseEncoding = _encodings.StandardEncoding; for (charCode = 0; charCode &lt; baseEncoding.length; charCode++) { glyphId = glyphNames.indexOf(baseEncoding[charCode]); if (glyphId &gt;= 0) { charCodeToGlyphId[charCode] = glyphId; } else { charCodeToGlyphId[charCode] = 0; } } } const differences = properties.differences; let glyphsUnicodeMap; if (differences) { for (charCode in differences) { const glyphName = differences[charCode]; glyphId = glyphNames.indexOf(glyphName); if (glyphId === -1) { if (!glyphsUnicodeMap) { glyphsUnicodeMap = (0, _glyphlist.getGlyphsUnicode)(); } const standardGlyphName = recoverGlyphName(glyphName, glyphsUnicodeMap); if (standardGlyphName !== glyphName) { glyphId = glyphNames.indexOf(standardGlyphName); } } if (glyphId &gt;= 0) { charCodeToGlyphId[charCode] = glyphId; } else { charCodeToGlyphId[charCode] = 0; } } } return charCodeToGlyphId; } function normalizeFontName(name) { return name.replace(/[,_]/g, &quot;-&quot;).replace(/\\s/g, &quot;&quot;); } /***/ }), /* 37 */ /***/ ((__unused_webpack_module, __webpack_exports__, __w_pdfjs_require__) =&gt; { __w_pdfjs_require__.r(__webpack_exports__); /* harmony export */ __w_pdfjs_require__.d(__webpack_exports__, { /* harmony export */ &quot;getDingbatsGlyphsUnicode&quot;: () =&gt; (/* binding */ getDingbatsGlyphsUnicode), /* harmony export */ &quot;getGlyphsUnicode&quot;: () =&gt; (/* binding */ getGlyphsUnicode) /* harmony export */ }); /* harmony import */ var _core_utils_js__WEBPACK_IMPORTED_MODULE_0__ = __w_pdfjs_require__(4); const getGlyphsUnicode = (0,_core_utils_js__WEBPACK_IMPORTED_MODULE_0__.getArrayLookupTableFactory)(function () { return [ &quot;A&quot;, 0x0041, &quot;AE&quot;, 0x00c6, &quot;AEacute&quot;, 0x01fc, &quot;AEmacron&quot;, 0x01e2, &quot;AEsmall&quot;, 0xf7e6, &quot;Aacute&quot;, 0x00c1, &quot;Aacutesmall&quot;, 0xf7e1, &quot;Abreve&quot;, 0x0102, &quot;Abreveacute&quot;, 0x1eae, &quot;Abrevecyrillic&quot;, 0x04d0, &quot;Abrevedotbelow&quot;, 0x1eb6, &quot;Abrevegrave&quot;, 0x1eb0, &quot;Abrevehookabove&quot;, 0x1eb2, &quot;Abrevetilde&quot;, 0x1eb4, &quot;Acaron&quot;, 0x01cd, &quot;Acircle&quot;, 0x24b6, &quot;Acircumflex&quot;, 0x00c2, &quot;Acircumflexacute&quot;, 0x1ea4, &quot;Acircumflexdotbelow&quot;, 0x1eac, &quot;Acircumflexgrave&quot;, 0x1ea6, &quot;Acircumflexhookabove&quot;, 0x1ea8, &quot;Acircumflexsmall&quot;, 0xf7e2, &quot;Acircumflextilde&quot;, 0x1eaa, &quot;Acute&quot;, 0xf6c9, &quot;Acutesmall&quot;, 0xf7b4, &quot;Acyrillic&quot;, 0x0410, &quot;Adblgrave&quot;, 0x0200, &quot;Adieresis&quot;, 0x00c4, &quot;Adieresiscyrillic&quot;, 0x04d2, &quot;Adieresismacron&quot;, 0x01de, &quot;Adieresissmall&quot;, 0xf7e4, &quot;Adotbelow&quot;, 0x1ea0, &quot;Adotmacron&quot;, 0x01e0, &quot;Agrave&quot;, 0x00c0, &quot;Agravesmall&quot;, 0xf7e0, &quot;Ahookabove&quot;, 0x1ea2, &quot;Aiecyrillic&quot;, 0x04d4, &quot;Ainvertedbreve&quot;, 0x0202, &quot;Alpha&quot;, 0x0391, &quot;Alphatonos&quot;, 0x0386, &quot;Amacron&quot;, 0x0100, &quot;Amonospace&quot;, 0xff21, &quot;Aogonek&quot;, 0x0104, &quot;Aring&quot;, 0x00c5, &quot;Aringacute&quot;, 0x01fa, &quot;Aringbelow&quot;, 0x1e00, &quot;Aringsmall&quot;, 0xf7e5, &quot;Asmall&quot;, 0xf761, &quot;Atilde&quot;, 0x00c3, &quot;Atildesmall&quot;, 0xf7e3, &quot;Aybarmenian&quot;, 0x0531, &quot;B&quot;, 0x0042, &quot;Bcircle&quot;, 0x24b7, &quot;Bdotaccent&quot;, 0x1e02, &quot;Bdotbelow&quot;, 0x1e04, &quot;Becyrillic&quot;, 0x0411, &quot;Benarmenian&quot;, 0x0532, &quot;Beta&quot;, 0x0392, &quot;Bhook&quot;, 0x0181, &quot;Blinebelow&quot;, 0x1e06, &quot;Bmonospace&quot;, 0xff22, &quot;Brevesmall&quot;, 0xf6f4, &quot;Bsmall&quot;, 0xf762, &quot;Btopbar&quot;, 0x0182, &quot;C&quot;, 0x0043, &quot;Caarmenian&quot;, 0x053e, &quot;Cacute&quot;, 0x0106, &quot;Caron&quot;, 0xf6ca, &quot;Caronsmall&quot;, 0xf6f5, &quot;Ccaron&quot;, 0x010c, &quot;Ccedilla&quot;, 0x00c7, &quot;Ccedillaacute&quot;, 0x1e08, &quot;Ccedillasmall&quot;, 0xf7e7, &quot;Ccircle&quot;, 0x24b8, &quot;Ccircumflex&quot;, 0x0108, &quot;Cdot&quot;, 0x010a, &quot;Cdotaccent&quot;, 0x010a, &quot;Cedillasmall&quot;, 0xf7b8, &quot;Chaarmenian&quot;, 0x0549, &quot;Cheabkhasiancyrillic&quot;, 0x04bc, &quot;Checyrillic&quot;, 0x0427, &quot;Chedescenderabkhasiancyrillic&quot;, 0x04be, &quot;Chedescendercyrillic&quot;, 0x04b6, &quot;Chedieresiscyrillic&quot;, 0x04f4, &quot;Cheharmenian&quot;, 0x0543, &quot;Chekhakassiancyrillic&quot;, 0x04cb, &quot;Cheverticalstrokecyrillic&quot;, 0x04b8, &quot;Chi&quot;, 0x03a7, &quot;Chook&quot;, 0x0187, &quot;Circumflexsmall&quot;, 0xf6f6, &quot;Cmonospace&quot;, 0xff23, &quot;Coarmenian&quot;, 0x0551, &quot;Csmall&quot;, 0xf763, &quot;D&quot;, 0x0044, &quot;DZ&quot;, 0x01f1, &quot;DZcaron&quot;, 0x01c4, &quot;Daarmenian&quot;, 0x0534, &quot;Dafrican&quot;, 0x0189, &quot;Dcaron&quot;, 0x010e, &quot;Dcedilla&quot;, 0x1e10, &quot;Dcircle&quot;, 0x24b9, &quot;Dcircumflexbelow&quot;, 0x1e12, &quot;Dcroat&quot;, 0x0110, &quot;Ddotaccent&quot;, 0x1e0a, &quot;Ddotbelow&quot;, 0x1e0c, &quot;Decyrillic&quot;, 0x0414, &quot;Deicoptic&quot;, 0x03ee, &quot;Delta&quot;, 0x2206, &quot;Deltagreek&quot;, 0x0394, &quot;Dhook&quot;, 0x018a, &quot;Dieresis&quot;, 0xf6cb, &quot;DieresisAcute&quot;, 0xf6cc, &quot;DieresisGrave&quot;, 0xf6cd, &quot;Dieresissmall&quot;, 0xf7a8, &quot;Digammagreek&quot;, 0x03dc, &quot;Djecyrillic&quot;, 0x0402, &quot;Dlinebelow&quot;, 0x1e0e, &quot;Dmonospace&quot;, 0xff24, &quot;Dotaccentsmall&quot;, 0xf6f7, &quot;Dslash&quot;, 0x0110, &quot;Dsmall&quot;, 0xf764, &quot;Dtopbar&quot;, 0x018b, &quot;Dz&quot;, 0x01f2, &quot;Dzcaron&quot;, 0x01c5, &quot;Dzeabkhasiancyrillic&quot;, 0x04e0, &quot;Dzecyrillic&quot;, 0x0405, &quot;Dzhecyrillic&quot;, 0x040f, &quot;E&quot;, 0x0045, &quot;Eacute&quot;, 0x00c9, &quot;Eacutesmall&quot;, 0xf7e9, &quot;Ebreve&quot;, 0x0114, &quot;Ecaron&quot;, 0x011a, &quot;Ecedillabreve&quot;, 0x1e1c, &quot;Echarmenian&quot;, 0x0535, &quot;Ecircle&quot;, 0x24ba, &quot;Ecircumflex&quot;, 0x00ca, &quot;Ecircumflexacute&quot;, 0x1ebe, &quot;Ecircumflexbelow&quot;, 0x1e18, &quot;Ecircumflexdotbelow&quot;, 0x1ec6, &quot;Ecircumflexgrave&quot;, 0x1ec0, &quot;Ecircumflexhookabove&quot;, 0x1ec2, &quot;Ecircumflexsmall&quot;, 0xf7ea, &quot;Ecircumflextilde&quot;, 0x1ec4, &quot;Ecyrillic&quot;, 0x0404, &quot;Edblgrave&quot;, 0x0204, &quot;Edieresis&quot;, 0x00cb, &quot;Edieresissmall&quot;, 0xf7eb, &quot;Edot&quot;, 0x0116, &quot;Edotaccent&quot;, 0x0116, &quot;Edotbelow&quot;, 0x1eb8, &quot;Efcyrillic&quot;, 0x0424, &quot;Egrave&quot;, 0x00c8, &quot;Egravesmall&quot;, 0xf7e8, &quot;Eharmenian&quot;, 0x0537, &quot;Ehookabove&quot;, 0x1eba, &quot;Eightroman&quot;, 0x2167, &quot;Einvertedbreve&quot;, 0x0206, &quot;Eiotifiedcyrillic&quot;, 0x0464, &quot;Elcyrillic&quot;, 0x041b, &quot;Elevenroman&quot;, 0x216a, &quot;Emacron&quot;, 0x0112, &quot;Emacronacute&quot;, 0x1e16, &quot;Emacrongrave&quot;, 0x1e14, &quot;Emcyrillic&quot;, 0x041c, &quot;Emonospace&quot;, 0xff25, &quot;Encyrillic&quot;, 0x041d, &quot;Endescendercyrillic&quot;, 0x04a2, &quot;Eng&quot;, 0x014a, &quot;Enghecyrillic&quot;, 0x04a4, &quot;Enhookcyrillic&quot;, 0x04c7, &quot;Eogonek&quot;, 0x0118, &quot;Eopen&quot;, 0x0190, &quot;Epsilon&quot;, 0x0395, &quot;Epsilontonos&quot;, 0x0388, &quot;Ercyrillic&quot;, 0x0420, &quot;Ereversed&quot;, 0x018e, &quot;Ereversedcyrillic&quot;, 0x042d, &quot;Escyrillic&quot;, 0x0421, &quot;Esdescendercyrillic&quot;, 0x04aa, &quot;Esh&quot;, 0x01a9, &quot;Esmall&quot;, 0xf765, &quot;Eta&quot;, 0x0397, &quot;Etarmenian&quot;, 0x0538, &quot;Etatonos&quot;, 0x0389, &quot;Eth&quot;, 0x00d0, &quot;Ethsmall&quot;, 0xf7f0, &quot;Etilde&quot;, 0x1ebc, &quot;Etildebelow&quot;, 0x1e1a, &quot;Euro&quot;, 0x20ac, &quot;Ezh&quot;, 0x01b7, &quot;Ezhcaron&quot;, 0x01ee, &quot;Ezhreversed&quot;, 0x01b8, &quot;F&quot;, 0x0046, &quot;Fcircle&quot;, 0x24bb, &quot;Fdotaccent&quot;, 0x1e1e, &quot;Feharmenian&quot;, 0x0556, &quot;Feicoptic&quot;, 0x03e4, &quot;Fhook&quot;, 0x0191, &quot;Fitacyrillic&quot;, 0x0472, &quot;Fiveroman&quot;, 0x2164, &quot;Fmonospace&quot;, 0xff26, &quot;Fourroman&quot;, 0x2163, &quot;Fsmall&quot;, 0xf766, &quot;G&quot;, 0x0047, &quot;GBsquare&quot;, 0x3387, &quot;Gacute&quot;, 0x01f4, &quot;Gamma&quot;, 0x0393, &quot;Gammaafrican&quot;, 0x0194, &quot;Gangiacoptic&quot;, 0x03ea, &quot;Gbreve&quot;, 0x011e, &quot;Gcaron&quot;, 0x01e6, &quot;Gcedilla&quot;, 0x0122, &quot;Gcircle&quot;, 0x24bc, &quot;Gcircumflex&quot;, 0x011c, &quot;Gcommaaccent&quot;, 0x0122, &quot;Gdot&quot;, 0x0120, &quot;Gdotaccent&quot;, 0x0120, &quot;Gecyrillic&quot;, 0x0413, &quot;Ghadarmenian&quot;, 0x0542, &quot;Ghemiddlehookcyrillic&quot;, 0x0494, &quot;Ghestrokecyrillic&quot;, 0x0492, &quot;Gheupturncyrillic&quot;, 0x0490, &quot;Ghook&quot;, 0x0193, &quot;Gimarmenian&quot;, 0x0533, &quot;Gjecyrillic&quot;, 0x0403, &quot;Gmacron&quot;, 0x1e20, &quot;Gmonospace&quot;, 0xff27, &quot;Grave&quot;, 0xf6ce, &quot;Gravesmall&quot;, 0xf760, &quot;Gsmall&quot;, 0xf767, &quot;Gsmallhook&quot;, 0x029b, &quot;Gstroke&quot;, 0x01e4, &quot;H&quot;, 0x0048, &quot;H18533&quot;, 0x25cf, &quot;H18543&quot;, 0x25aa, &quot;H18551&quot;, 0x25ab, &quot;H22073&quot;, 0x25a1, &quot;HPsquare&quot;, 0x33cb, &quot;Haabkhasiancyrillic&quot;, 0x04a8, &quot;Hadescendercyrillic&quot;, 0x04b2, &quot;Hardsigncyrillic&quot;, 0x042a, &quot;Hbar&quot;, 0x0126, &quot;Hbrevebelow&quot;, 0x1e2a, &quot;Hcedilla&quot;, 0x1e28, &quot;Hcircle&quot;, 0x24bd, &quot;Hcircumflex&quot;, 0x0124, &quot;Hdieresis&quot;, 0x1e26, &quot;Hdotaccent&quot;, 0x1e22, &quot;Hdotbelow&quot;, 0x1e24, &quot;Hmonospace&quot;, 0xff28, &quot;Hoarmenian&quot;, 0x0540, &quot;Horicoptic&quot;, 0x03e8, &quot;Hsmall&quot;, 0xf768, &quot;Hungarumlaut&quot;, 0xf6cf, &quot;Hungarumlautsmall&quot;, 0xf6f8, &quot;Hzsquare&quot;, 0x3390, &quot;I&quot;, 0x0049, &quot;IAcyrillic&quot;, 0x042f, &quot;IJ&quot;, 0x0132, &quot;IUcyrillic&quot;, 0x042e, &quot;Iacute&quot;, 0x00cd, &quot;Iacutesmall&quot;, 0xf7ed, &quot;Ibreve&quot;, 0x012c, &quot;Icaron&quot;, 0x01cf, &quot;Icircle&quot;, 0x24be, &quot;Icircumflex&quot;, 0x00ce, &quot;Icircumflexsmall&quot;, 0xf7ee, &quot;Icyrillic&quot;, 0x0406, &quot;Idblgrave&quot;, 0x0208, &quot;Idieresis&quot;, 0x00cf, &quot;Idieresisacute&quot;, 0x1e2e, &quot;Idieresiscyrillic&quot;, 0x04e4, &quot;Idieresissmall&quot;, 0xf7ef, &quot;Idot&quot;, 0x0130, &quot;Idotaccent&quot;, 0x0130, &quot;Idotbelow&quot;, 0x1eca, &quot;Iebrevecyrillic&quot;, 0x04d6, &quot;Iecyrillic&quot;, 0x0415, &quot;Ifraktur&quot;, 0x2111, &quot;Igrave&quot;, 0x00cc, &quot;Igravesmall&quot;, 0xf7ec, &quot;Ihookabove&quot;, 0x1ec8, &quot;Iicyrillic&quot;, 0x0418, &quot;Iinvertedbreve&quot;, 0x020a, &quot;Iishortcyrillic&quot;, 0x0419, &quot;Imacron&quot;, 0x012a, &quot;Imacroncyrillic&quot;, 0x04e2, &quot;Imonospace&quot;, 0xff29, &quot;Iniarmenian&quot;, 0x053b, &quot;Iocyrillic&quot;, 0x0401, &quot;Iogonek&quot;, 0x012e, &quot;Iota&quot;, 0x0399, &quot;Iotaafrican&quot;, 0x0196, &quot;Iotadieresis&quot;, 0x03aa, &quot;Iotatonos&quot;, 0x038a, &quot;Ismall&quot;, 0xf769, &quot;Istroke&quot;, 0x0197, &quot;Itilde&quot;, 0x0128, &quot;Itildebelow&quot;, 0x1e2c, &quot;Izhitsacyrillic&quot;, 0x0474, &quot;Izhitsadblgravecyrillic&quot;, 0x0476, &quot;J&quot;, 0x004a, &quot;Jaarmenian&quot;, 0x0541, &quot;Jcircle&quot;, 0x24bf, &quot;Jcircumflex&quot;, 0x0134, &quot;Jecyrillic&quot;, 0x0408, &quot;Jheharmenian&quot;, 0x054b, &quot;Jmonospace&quot;, 0xff2a, &quot;Jsmall&quot;, 0xf76a, &quot;K&quot;, 0x004b, &quot;KBsquare&quot;, 0x3385, &quot;KKsquare&quot;, 0x33cd, &quot;Kabashkircyrillic&quot;, 0x04a0, &quot;Kacute&quot;, 0x1e30, &quot;Kacyrillic&quot;, 0x041a, &quot;Kadescendercyrillic&quot;, 0x049a, &quot;Kahookcyrillic&quot;, 0x04c3, &quot;Kappa&quot;, 0x039a, &quot;Kastrokecyrillic&quot;, 0x049e, &quot;Kaverticalstrokecyrillic&quot;, 0x049c, &quot;Kcaron&quot;, 0x01e8, &quot;Kcedilla&quot;, 0x0136, &quot;Kcircle&quot;, 0x24c0, &quot;Kcommaaccent&quot;, 0x0136, &quot;Kdotbelow&quot;, 0x1e32, &quot;Keharmenian&quot;, 0x0554, &quot;Kenarmenian&quot;, 0x053f, &quot;Khacyrillic&quot;, 0x0425, &quot;Kheicoptic&quot;, 0x03e6, &quot;Khook&quot;, 0x0198, &quot;Kjecyrillic&quot;, 0x040c, &quot;Klinebelow&quot;, 0x1e34, &quot;Kmonospace&quot;, 0xff2b, &quot;Koppacyrillic&quot;, 0x0480, &quot;Koppagreek&quot;, 0x03de, &quot;Ksicyrillic&quot;, 0x046e, &quot;Ksmall&quot;, 0xf76b, &quot;L&quot;, 0x004c, &quot;LJ&quot;, 0x01c7, &quot;LL&quot;, 0xf6bf, &quot;Lacute&quot;, 0x0139, &quot;Lambda&quot;, 0x039b, &quot;Lcaron&quot;, 0x013d, &quot;Lcedilla&quot;, 0x013b, &quot;Lcircle&quot;, 0x24c1, &quot;Lcircumflexbelow&quot;, 0x1e3c, &quot;Lcommaaccent&quot;, 0x013b, &quot;Ldot&quot;, 0x013f, &quot;Ldotaccent&quot;, 0x013f, &quot;Ldotbelow&quot;, 0x1e36, &quot;Ldotbelowmacron&quot;, 0x1e38, &quot;Liwnarmenian&quot;, 0x053c, &quot;Lj&quot;, 0x01c8, &quot;Ljecyrillic&quot;, 0x0409, &quot;Llinebelow&quot;, 0x1e3a, &quot;Lmonospace&quot;, 0xff2c, &quot;Lslash&quot;, 0x0141, &quot;Lslashsmall&quot;, 0xf6f9, &quot;Lsmall&quot;, 0xf76c, &quot;M&quot;, 0x004d, &quot;MBsquare&quot;, 0x3386, &quot;Macron&quot;, 0xf6d0, &quot;Macronsmall&quot;, 0xf7af, &quot;Macute&quot;, 0x1e3e, &quot;Mcircle&quot;, 0x24c2, &quot;Mdotaccent&quot;, 0x1e40, &quot;Mdotbelow&quot;, 0x1e42, &quot;Menarmenian&quot;, 0x0544, &quot;Mmonospace&quot;, 0xff2d, &quot;Msmall&quot;, 0xf76d, &quot;Mturned&quot;, 0x019c, &quot;Mu&quot;, 0x039c, &quot;N&quot;, 0x004e, &quot;NJ&quot;, 0x01ca, &quot;Nacute&quot;, 0x0143, &quot;Ncaron&quot;, 0x0147, &quot;Ncedilla&quot;, 0x0145, &quot;Ncircle&quot;, 0x24c3, &quot;Ncircumflexbelow&quot;, 0x1e4a, &quot;Ncommaaccent&quot;, 0x0145, &quot;Ndotaccent&quot;, 0x1e44, &quot;Ndotbelow&quot;, 0x1e46, &quot;Nhookleft&quot;, 0x019d, &quot;Nineroman&quot;, 0x2168, &quot;Nj&quot;, 0x01cb, &quot;Njecyrillic&quot;, 0x040a, &quot;Nlinebelow&quot;, 0x1e48, &quot;Nmonospace&quot;, 0xff2e, &quot;Nowarmenian&quot;, 0x0546, &quot;Nsmall&quot;, 0xf76e, &quot;Ntilde&quot;, 0x00d1, &quot;Ntildesmall&quot;, 0xf7f1, &quot;Nu&quot;, 0x039d, &quot;O&quot;, 0x004f, &quot;OE&quot;, 0x0152, &quot;OEsmall&quot;, 0xf6fa, &quot;Oacute&quot;, 0x00d3, &quot;Oacutesmall&quot;, 0xf7f3, &quot;Obarredcyrillic&quot;, 0x04e8, &quot;Obarreddieresiscyrillic&quot;, 0x04ea, &quot;Obreve&quot;, 0x014e, &quot;Ocaron&quot;, 0x01d1, &quot;Ocenteredtilde&quot;, 0x019f, &quot;Ocircle&quot;, 0x24c4, &quot;Ocircumflex&quot;, 0x00d4, &quot;Ocircumflexacute&quot;, 0x1ed0, &quot;Ocircumflexdotbelow&quot;, 0x1ed8, &quot;Ocircumflexgrave&quot;, 0x1ed2, &quot;Ocircumflexhookabove&quot;, 0x1ed4, &quot;Ocircumflexsmall&quot;, 0xf7f4, &quot;Ocircumflextilde&quot;, 0x1ed6, &quot;Ocyrillic&quot;, 0x041e, &quot;Odblacute&quot;, 0x0150, &quot;Odblgrave&quot;, 0x020c, &quot;Odieresis&quot;, 0x00d6, &quot;Odieresiscyrillic&quot;, 0x04e6, &quot;Odieresissmall&quot;, 0xf7f6, &quot;Odotbelow&quot;, 0x1ecc, &quot;Ogoneksmall&quot;, 0xf6fb, &quot;Ograve&quot;, 0x00d2, &quot;Ogravesmall&quot;, 0xf7f2, &quot;Oharmenian&quot;, 0x0555, &quot;Ohm&quot;, 0x2126, &quot;Ohookabove&quot;, 0x1ece, &quot;Ohorn&quot;, 0x01a0, &quot;Ohornacute&quot;, 0x1eda, &quot;Ohorndotbelow&quot;, 0x1ee2, &quot;Ohorngrave&quot;, 0x1edc, &quot;Ohornhookabove&quot;, 0x1ede, &quot;Ohorntilde&quot;, 0x1ee0, &quot;Ohungarumlaut&quot;, 0x0150, &quot;Oi&quot;, 0x01a2, &quot;Oinvertedbreve&quot;, 0x020e, &quot;Omacron&quot;, 0x014c, &quot;Omacronacute&quot;, 0x1e52, &quot;Omacrongrave&quot;, 0x1e50, &quot;Omega&quot;, 0x2126, &quot;Omegacyrillic&quot;, 0x0460, &quot;Omegagreek&quot;, 0x03a9, &quot;Omegaroundcyrillic&quot;, 0x047a, &quot;Omegatitlocyrillic&quot;, 0x047c, &quot;Omegatonos&quot;, 0x038f, &quot;Omicron&quot;, 0x039f, &quot;Omicrontonos&quot;, 0x038c, &quot;Omonospace&quot;, 0xff2f, &quot;Oneroman&quot;, 0x2160, &quot;Oogonek&quot;, 0x01ea, &quot;Oogonekmacron&quot;, 0x01ec, &quot;Oopen&quot;, 0x0186, &quot;Oslash&quot;, 0x00d8, &quot;Oslashacute&quot;, 0x01fe, &quot;Oslashsmall&quot;, 0xf7f8, &quot;Osmall&quot;, 0xf76f, &quot;Ostrokeacute&quot;, 0x01fe, &quot;Otcyrillic&quot;, 0x047e, &quot;Otilde&quot;, 0x00d5, &quot;Otildeacute&quot;, 0x1e4c, &quot;Otildedieresis&quot;, 0x1e4e, &quot;Otildesmall&quot;, 0xf7f5, &quot;P&quot;, 0x0050, &quot;Pacute&quot;, 0x1e54, &quot;Pcircle&quot;, 0x24c5, &quot;Pdotaccent&quot;, 0x1e56, &quot;Pecyrillic&quot;, 0x041f, &quot;Peharmenian&quot;, 0x054a, &quot;Pemiddlehookcyrillic&quot;, 0x04a6, &quot;Phi&quot;, 0x03a6, &quot;Phook&quot;, 0x01a4, &quot;Pi&quot;, 0x03a0, &quot;Piwrarmenian&quot;, 0x0553, &quot;Pmonospace&quot;, 0xff30, &quot;Psi&quot;, 0x03a8, &quot;Psicyrillic&quot;, 0x0470, &quot;Psmall&quot;, 0xf770, &quot;Q&quot;, 0x0051, &quot;Qcircle&quot;, 0x24c6, &quot;Qmonospace&quot;, 0xff31, &quot;Qsmall&quot;, 0xf771, &quot;R&quot;, 0x0052, &quot;Raarmenian&quot;, 0x054c, &quot;Racute&quot;, 0x0154, &quot;Rcaron&quot;, 0x0158, &quot;Rcedilla&quot;, 0x0156, &quot;Rcircle&quot;, 0x24c7, &quot;Rcommaaccent&quot;, 0x0156, &quot;Rdblgrave&quot;, 0x0210, &quot;Rdotaccent&quot;, 0x1e58, &quot;Rdotbelow&quot;, 0x1e5a, &quot;Rdotbelowmacron&quot;, 0x1e5c, &quot;Reharmenian&quot;, 0x0550, &quot;Rfraktur&quot;, 0x211c, &quot;Rho&quot;, 0x03a1, &quot;Ringsmall&quot;, 0xf6fc, &quot;Rinvertedbreve&quot;, 0x0212, &quot;Rlinebelow&quot;, 0x1e5e, &quot;Rmonospace&quot;, 0xff32, &quot;Rsmall&quot;, 0xf772, &quot;Rsmallinverted&quot;, 0x0281, &quot;Rsmallinvertedsuperior&quot;, 0x02b6, &quot;S&quot;, 0x0053, &quot;SF010000&quot;, 0x250c, &quot;SF020000&quot;, 0x2514, &quot;SF030000&quot;, 0x2510, &quot;SF040000&quot;, 0x2518, &quot;SF050000&quot;, 0x253c, &quot;SF060000&quot;, 0x252c, &quot;SF070000&quot;, 0x2534, &quot;SF080000&quot;, 0x251c, &quot;SF090000&quot;, 0x2524, &quot;SF100000&quot;, 0x2500, &quot;SF110000&quot;, 0x2502, &quot;SF190000&quot;, 0x2561, &quot;SF200000&quot;, 0x2562, &quot;SF210000&quot;, 0x2556, &quot;SF220000&quot;, 0x2555, &quot;SF230000&quot;, 0x2563, &quot;SF240000&quot;, 0x2551, &quot;SF250000&quot;, 0x2557, &quot;SF260000&quot;, 0x255d, &quot;SF270000&quot;, 0x255c, &quot;SF280000&quot;, 0x255b, &quot;SF360000&quot;, 0x255e, &quot;SF370000&quot;, 0x255f, &quot;SF380000&quot;, 0x255a, &quot;SF390000&quot;, 0x2554, &quot;SF400000&quot;, 0x2569, &quot;SF410000&quot;, 0x2566, &quot;SF420000&quot;, 0x2560, &quot;SF430000&quot;, 0x2550, &quot;SF440000&quot;, 0x256c, &quot;SF450000&quot;, 0x2567, &quot;SF460000&quot;, 0x2568, &quot;SF470000&quot;, 0x2564, &quot;SF480000&quot;, 0x2565, &quot;SF490000&quot;, 0x2559, &quot;SF500000&quot;, 0x2558, &quot;SF510000&quot;, 0x2552, &quot;SF520000&quot;, 0x2553, &quot;SF530000&quot;, 0x256b, &quot;SF540000&quot;, 0x256a, &quot;Sacute&quot;, 0x015a, &quot;Sacutedotaccent&quot;, 0x1e64, &quot;Sampigreek&quot;, 0x03e0, &quot;Scaron&quot;, 0x0160, &quot;Scarondotaccent&quot;, 0x1e66, &quot;Scaronsmall&quot;, 0xf6fd, &quot;Scedilla&quot;, 0x015e, &quot;Schwa&quot;, 0x018f, &quot;Schwacyrillic&quot;, 0x04d8, &quot;Schwadieresiscyrillic&quot;, 0x04da, &quot;Scircle&quot;, 0x24c8, &quot;Scircumflex&quot;, 0x015c, &quot;Scommaaccent&quot;, 0x0218, &quot;Sdotaccent&quot;, 0x1e60, &quot;Sdotbelow&quot;, 0x1e62, &quot;Sdotbelowdotaccent&quot;, 0x1e68, &quot;Seharmenian&quot;, 0x054d, &quot;Sevenroman&quot;, 0x2166, &quot;Shaarmenian&quot;, 0x0547, &quot;Shacyrillic&quot;, 0x0428, &quot;Shchacyrillic&quot;, 0x0429, &quot;Sheicoptic&quot;, 0x03e2, &quot;Shhacyrillic&quot;, 0x04ba, &quot;Shimacoptic&quot;, 0x03ec, &quot;Sigma&quot;, 0x03a3, &quot;Sixroman&quot;, 0x2165, &quot;Smonospace&quot;, 0xff33, &quot;Softsigncyrillic&quot;, 0x042c, &quot;Ssmall&quot;, 0xf773, &quot;Stigmagreek&quot;, 0x03da, &quot;T&quot;, 0x0054, &quot;Tau&quot;, 0x03a4, &quot;Tbar&quot;, 0x0166, &quot;Tcaron&quot;, 0x0164, &quot;Tcedilla&quot;, 0x0162, &quot;Tcircle&quot;, 0x24c9, &quot;Tcircumflexbelow&quot;, 0x1e70, &quot;Tcommaaccent&quot;, 0x0162, &quot;Tdotaccent&quot;, 0x1e6a, &quot;Tdotbelow&quot;, 0x1e6c, &quot;Tecyrillic&quot;, 0x0422, &quot;Tedescendercyrillic&quot;, 0x04ac, &quot;Tenroman&quot;, 0x2169, &quot;Tetsecyrillic&quot;, 0x04b4, &quot;Theta&quot;, 0x0398, &quot;Thook&quot;, 0x01ac, &quot;Thorn&quot;, 0x00de, &quot;Thornsmall&quot;, 0xf7fe, &quot;Threeroman&quot;, 0x2162, &quot;Tildesmall&quot;, 0xf6fe, &quot;Tiwnarmenian&quot;, 0x054f, &quot;Tlinebelow&quot;, 0x1e6e, &quot;Tmonospace&quot;, 0xff34, &quot;Toarmenian&quot;, 0x0539, &quot;Tonefive&quot;, 0x01bc, &quot;Tonesix&quot;, 0x0184, &quot;Tonetwo&quot;, 0x01a7, &quot;Tretroflexhook&quot;, 0x01ae, &quot;Tsecyrillic&quot;, 0x0426, &quot;Tshecyrillic&quot;, 0x040b, &quot;Tsmall&quot;, 0xf774, &quot;Twelveroman&quot;, 0x216b, &quot;Tworoman&quot;, 0x2161, &quot;U&quot;, 0x0055, &quot;Uacute&quot;, 0x00da, &quot;Uacutesmall&quot;, 0xf7fa, &quot;Ubreve&quot;, 0x016c, &quot;Ucaron&quot;, 0x01d3, &quot;Ucircle&quot;, 0x24ca, &quot;Ucircumflex&quot;, 0x00db, &quot;Ucircumflexbelow&quot;, 0x1e76, &quot;Ucircumflexsmall&quot;, 0xf7fb, &quot;Ucyrillic&quot;, 0x0423, &quot;Udblacute&quot;, 0x0170, &quot;Udblgrave&quot;, 0x0214, &quot;Udieresis&quot;, 0x00dc, &quot;Udieresisacute&quot;, 0x01d7, &quot;Udieresisbelow&quot;, 0x1e72, &quot;Udieresiscaron&quot;, 0x01d9, &quot;Udieresiscyrillic&quot;, 0x04f0, &quot;Udieresisgrave&quot;, 0x01db, &quot;Udieresismacron&quot;, 0x01d5, &quot;Udieresissmall&quot;, 0xf7fc, &quot;Udotbelow&quot;, 0x1ee4, &quot;Ugrave&quot;, 0x00d9, &quot;Ugravesmall&quot;, 0xf7f9, &quot;Uhookabove&quot;, 0x1ee6, &quot;Uhorn&quot;, 0x01af, &quot;Uhornacute&quot;, 0x1ee8, &quot;Uhorndotbelow&quot;, 0x1ef0, &quot;Uhorngrave&quot;, 0x1eea, &quot;Uhornhookabove&quot;, 0x1eec, &quot;Uhorntilde&quot;, 0x1eee, &quot;Uhungarumlaut&quot;, 0x0170, &quot;Uhungarumlautcyrillic&quot;, 0x04f2, &quot;Uinvertedbreve&quot;, 0x0216, &quot;Ukcyrillic&quot;, 0x0478, &quot;Umacron&quot;, 0x016a, &quot;Umacroncyrillic&quot;, 0x04ee, &quot;Umacrondieresis&quot;, 0x1e7a, &quot;Umonospace&quot;, 0xff35, &quot;Uogonek&quot;, 0x0172, &quot;Upsilon&quot;, 0x03a5, &quot;Upsilon1&quot;, 0x03d2, &quot;Upsilonacutehooksymbolgreek&quot;, 0x03d3, &quot;Upsilonafrican&quot;, 0x01b1, &quot;Upsilondieresis&quot;, 0x03ab, &quot;Upsilondieresishooksymbolgreek&quot;, 0x03d4, &quot;Upsilonhooksymbol&quot;, 0x03d2, &quot;Upsilontonos&quot;, 0x038e, &quot;Uring&quot;, 0x016e, &quot;Ushortcyrillic&quot;, 0x040e, &quot;Usmall&quot;, 0xf775, &quot;Ustraightcyrillic&quot;, 0x04ae, &quot;Ustraightstrokecyrillic&quot;, 0x04b0, &quot;Utilde&quot;, 0x0168, &quot;Utildeacute&quot;, 0x1e78, &quot;Utildebelow&quot;, 0x1e74, &quot;V&quot;, 0x0056, &quot;Vcircle&quot;, 0x24cb, &quot;Vdotbelow&quot;, 0x1e7e, &quot;Vecyrillic&quot;, 0x0412, &quot;Vewarmenian&quot;, 0x054e, &quot;Vhook&quot;, 0x01b2, &quot;Vmonospace&quot;, 0xff36, &quot;Voarmenian&quot;, 0x0548, &quot;Vsmall&quot;, 0xf776, &quot;Vtilde&quot;, 0x1e7c, &quot;W&quot;, 0x0057, &quot;Wacute&quot;, 0x1e82, &quot;Wcircle&quot;, 0x24cc, &quot;Wcircumflex&quot;, 0x0174, &quot;Wdieresis&quot;, 0x1e84, &quot;Wdotaccent&quot;, 0x1e86, &quot;Wdotbelow&quot;, 0x1e88, &quot;Wgrave&quot;, 0x1e80, &quot;Wmonospace&quot;, 0xff37, &quot;Wsmall&quot;, 0xf777, &quot;X&quot;, 0x0058, &quot;Xcircle&quot;, 0x24cd, &quot;Xdieresis&quot;, 0x1e8c, &quot;Xdotaccent&quot;, 0x1e8a, &quot;Xeharmenian&quot;, 0x053d, &quot;Xi&quot;, 0x039e, &quot;Xmonospace&quot;, 0xff38, &quot;Xsmall&quot;, 0xf778, &quot;Y&quot;, 0x0059, &quot;Yacute&quot;, 0x00dd, &quot;Yacutesmall&quot;, 0xf7fd, &quot;Yatcyrillic&quot;, 0x0462, &quot;Ycircle&quot;, 0x24ce, &quot;Ycircumflex&quot;, 0x0176, &quot;Ydieresis&quot;, 0x0178, &quot;Ydieresissmall&quot;, 0xf7ff, &quot;Ydotaccent&quot;, 0x1e8e, &quot;Ydotbelow&quot;, 0x1ef4, &quot;Yericyrillic&quot;, 0x042b, &quot;Yerudieresiscyrillic&quot;, 0x04f8, &quot;Ygrave&quot;, 0x1ef2, &quot;Yhook&quot;, 0x01b3, &quot;Yhookabove&quot;, 0x1ef6, &quot;Yiarmenian&quot;, 0x0545, &quot;Yicyrillic&quot;, 0x0407, &quot;Yiwnarmenian&quot;, 0x0552, &quot;Ymonospace&quot;, 0xff39, &quot;Ysmall&quot;, 0xf779, &quot;Ytilde&quot;, 0x1ef8, &quot;Yusbigcyrillic&quot;, 0x046a, &quot;Yusbigiotifiedcyrillic&quot;, 0x046c, &quot;Yuslittlecyrillic&quot;, 0x0466, &quot;Yuslittleiotifiedcyrillic&quot;, 0x0468, &quot;Z&quot;, 0x005a, &quot;Zaarmenian&quot;, 0x0536, &quot;Zacute&quot;, 0x0179, &quot;Zcaron&quot;, 0x017d, &quot;Zcaronsmall&quot;, 0xf6ff, &quot;Zcircle&quot;, 0x24cf, &quot;Zcircumflex&quot;, 0x1e90, &quot;Zdot&quot;, 0x017b, &quot;Zdotaccent&quot;, 0x017b, &quot;Zdotbelow&quot;, 0x1e92, &quot;Zecyrillic&quot;, 0x0417, &quot;Zedescendercyrillic&quot;, 0x0498, &quot;Zedieresiscyrillic&quot;, 0x04de, &quot;Zeta&quot;, 0x0396, &quot;Zhearmenian&quot;, 0x053a, &quot;Zhebrevecyrillic&quot;, 0x04c1, &quot;Zhecyrillic&quot;, 0x0416, &quot;Zhedescendercyrillic&quot;, 0x0496, &quot;Zhedieresiscyrillic&quot;, 0x04dc, &quot;Zlinebelow&quot;, 0x1e94, &quot;Zmonospace&quot;, 0xff3a, &quot;Zsmall&quot;, 0xf77a, &quot;Zstroke&quot;, 0x01b5, &quot;a&quot;, 0x0061, &quot;aabengali&quot;, 0x0986, &quot;aacute&quot;, 0x00e1, &quot;aadeva&quot;, 0x0906, &quot;aagujarati&quot;, 0x0a86, &quot;aagurmukhi&quot;, 0x0a06, &quot;aamatragurmukhi&quot;, 0x0a3e, &quot;aarusquare&quot;, 0x3303, &quot;aavowelsignbengali&quot;, 0x09be, &quot;aavowelsigndeva&quot;, 0x093e, &quot;aavowelsigngujarati&quot;, 0x0abe, &quot;abbreviationmarkarmenian&quot;, 0x055f, &quot;abbreviationsigndeva&quot;, 0x0970, &quot;abengali&quot;, 0x0985, &quot;abopomofo&quot;, 0x311a, &quot;abreve&quot;, 0x0103, &quot;abreveacute&quot;, 0x1eaf, &quot;abrevecyrillic&quot;, 0x04d1, &quot;abrevedotbelow&quot;, 0x1eb7, &quot;abrevegrave&quot;, 0x1eb1, &quot;abrevehookabove&quot;, 0x1eb3, &quot;abrevetilde&quot;, 0x1eb5, &quot;acaron&quot;, 0x01ce, &quot;acircle&quot;, 0x24d0, &quot;acircumflex&quot;, 0x00e2, &quot;acircumflexacute&quot;, 0x1ea5, &quot;acircumflexdotbelow&quot;, 0x1ead, &quot;acircumflexgrave&quot;, 0x1ea7, &quot;acircumflexhookabove&quot;, 0x1ea9, &quot;acircumflextilde&quot;, 0x1eab, &quot;acute&quot;, 0x00b4, &quot;acutebelowcmb&quot;, 0x0317, &quot;acutecmb&quot;, 0x0301, &quot;acutecomb&quot;, 0x0301, &quot;acutedeva&quot;, 0x0954, &quot;acutelowmod&quot;, 0x02cf, &quot;acutetonecmb&quot;, 0x0341, &quot;acyrillic&quot;, 0x0430, &quot;adblgrave&quot;, 0x0201, &quot;addakgurmukhi&quot;, 0x0a71, &quot;adeva&quot;, 0x0905, &quot;adieresis&quot;, 0x00e4, &quot;adieresiscyrillic&quot;, 0x04d3, &quot;adieresismacron&quot;, 0x01df, &quot;adotbelow&quot;, 0x1ea1, &quot;adotmacron&quot;, 0x01e1, &quot;ae&quot;, 0x00e6, &quot;aeacute&quot;, 0x01fd, &quot;aekorean&quot;, 0x3150, &quot;aemacron&quot;, 0x01e3, &quot;afii00208&quot;, 0x2015, &quot;afii08941&quot;, 0x20a4, &quot;afii10017&quot;, 0x0410, &quot;afii10018&quot;, 0x0411, &quot;afii10019&quot;, 0x0412, &quot;afii10020&quot;, 0x0413, &quot;afii10021&quot;, 0x0414, &quot;afii10022&quot;, 0x0415, &quot;afii10023&quot;, 0x0401, &quot;afii10024&quot;, 0x0416, &quot;afii10025&quot;, 0x0417, &quot;afii10026&quot;, 0x0418, &quot;afii10027&quot;, 0x0419, &quot;afii10028&quot;, 0x041a, &quot;afii10029&quot;, 0x041b, &quot;afii10030&quot;, 0x041c, &quot;afii10031&quot;, 0x041d, &quot;afii10032&quot;, 0x041e, &quot;afii10033&quot;, 0x041f, &quot;afii10034&quot;, 0x0420, &quot;afii10035&quot;, 0x0421, &quot;afii10036&quot;, 0x0422, &quot;afii10037&quot;, 0x0423, &quot;afii10038&quot;, 0x0424, &quot;afii10039&quot;, 0x0425, &quot;afii10040&quot;, 0x0426, &quot;afii10041&quot;, 0x0427, &quot;afii10042&quot;, 0x0428, &quot;afii10043&quot;, 0x0429, &quot;afii10044&quot;, 0x042a, &quot;afii10045&quot;, 0x042b, &quot;afii10046&quot;, 0x042c, &quot;afii10047&quot;, 0x042d, &quot;afii10048&quot;, 0x042e, &quot;afii10049&quot;, 0x042f, &quot;afii10050&quot;, 0x0490, &quot;afii10051&quot;, 0x0402, &quot;afii10052&quot;, 0x0403, &quot;afii10053&quot;, 0x0404, &quot;afii10054&quot;, 0x0405, &quot;afii10055&quot;, 0x0406, &quot;afii10056&quot;, 0x0407, &quot;afii10057&quot;, 0x0408, &quot;afii10058&quot;, 0x0409, &quot;afii10059&quot;, 0x040a, &quot;afii10060&quot;, 0x040b, &quot;afii10061&quot;, 0x040c, &quot;afii10062&quot;, 0x040e, &quot;afii10063&quot;, 0xf6c4, &quot;afii10064&quot;, 0xf6c5, &quot;afii10065&quot;, 0x0430, &quot;afii10066&quot;, 0x0431, &quot;afii10067&quot;, 0x0432, &quot;afii10068&quot;, 0x0433, &quot;afii10069&quot;, 0x0434, &quot;afii10070&quot;, 0x0435, &quot;afii10071&quot;, 0x0451, &quot;afii10072&quot;, 0x0436, &quot;afii10073&quot;, 0x0437, &quot;afii10074&quot;, 0x0438, &quot;afii10075&quot;, 0x0439, &quot;afii10076&quot;, 0x043a, &quot;afii10077&quot;, 0x043b, &quot;afii10078&quot;, 0x043c, &quot;afii10079&quot;, 0x043d, &quot;afii10080&quot;, 0x043e, &quot;afii10081&quot;, 0x043f, &quot;afii10082&quot;, 0x0440, &quot;afii10083&quot;, 0x0441, &quot;afii10084&quot;, 0x0442, &quot;afii10085&quot;, 0x0443, &quot;afii10086&quot;, 0x0444, &quot;afii10087&quot;, 0x0445, &quot;afii10088&quot;, 0x0446, &quot;afii10089&quot;, 0x0447, &quot;afii10090&quot;, 0x0448, &quot;afii10091&quot;, 0x0449, &quot;afii10092&quot;, 0x044a, &quot;afii10093&quot;, 0x044b, &quot;afii10094&quot;, 0x044c, &quot;afii10095&quot;, 0x044d, &quot;afii10096&quot;, 0x044e, &quot;afii10097&quot;, 0x044f, &quot;afii10098&quot;, 0x0491, &quot;afii10099&quot;, 0x0452, &quot;afii10100&quot;, 0x0453, &quot;afii10101&quot;, 0x0454, &quot;afii10102&quot;, 0x0455, &quot;afii10103&quot;, 0x0456, &quot;afii10104&quot;, 0x0457, &quot;afii10105&quot;, 0x0458, &quot;afii10106&quot;, 0x0459, &quot;afii10107&quot;, 0x045a, &quot;afii10108&quot;, 0x045b, &quot;afii10109&quot;, 0x045c, &quot;afii10110&quot;, 0x045e, &quot;afii10145&quot;, 0x040f, &quot;afii10146&quot;, 0x0462, &quot;afii10147&quot;, 0x0472, &quot;afii10148&quot;, 0x0474, &quot;afii10192&quot;, 0xf6c6, &quot;afii10193&quot;, 0x045f, &quot;afii10194&quot;, 0x0463, &quot;afii10195&quot;, 0x0473, &quot;afii10196&quot;, 0x0475, &quot;afii10831&quot;, 0xf6c7, &quot;afii10832&quot;, 0xf6c8, &quot;afii10846&quot;, 0x04d9, &quot;afii299&quot;, 0x200e, &quot;afii300&quot;, 0x200f, &quot;afii301&quot;, 0x200d, &quot;afii57381&quot;, 0x066a, &quot;afii57388&quot;, 0x060c, &quot;afii57392&quot;, 0x0660, &quot;afii57393&quot;, 0x0661, &quot;afii57394&quot;, 0x0662, &quot;afii57395&quot;, 0x0663, &quot;afii57396&quot;, 0x0664, &quot;afii57397&quot;, 0x0665, &quot;afii57398&quot;, 0x0666, &quot;afii57399&quot;, 0x0667, &quot;afii57400&quot;, 0x0668, &quot;afii57401&quot;, 0x0669, &quot;afii57403&quot;, 0x061b, &quot;afii57407&quot;, 0x061f, &quot;afii57409&quot;, 0x0621, &quot;afii57410&quot;, 0x0622, &quot;afii57411&quot;, 0x0623, &quot;afii57412&quot;, 0x0624, &quot;afii57413&quot;, 0x0625, &quot;afii57414&quot;, 0x0626, &quot;afii57415&quot;, 0x0627, &quot;afii57416&quot;, 0x0628, &quot;afii57417&quot;, 0x0629, &quot;afii57418&quot;, 0x062a, &quot;afii57419&quot;, 0x062b, &quot;afii57420&quot;, 0x062c, &quot;afii57421&quot;, 0x062d, &quot;afii57422&quot;, 0x062e, &quot;afii57423&quot;, 0x062f, &quot;afii57424&quot;, 0x0630, &quot;afii57425&quot;, 0x0631, &quot;afii57426&quot;, 0x0632, &quot;afii57427&quot;, 0x0633, &quot;afii57428&quot;, 0x0634, &quot;afii57429&quot;, 0x0635, &quot;afii57430&quot;, 0x0636, &quot;afii57431&quot;, 0x0637, &quot;afii57432&quot;, 0x0638, &quot;afii57433&quot;, 0x0639, &quot;afii57434&quot;, 0x063a, &quot;afii57440&quot;, 0x0640, &quot;afii57441&quot;, 0x0641, &quot;afii57442&quot;, 0x0642, &quot;afii57443&quot;, 0x0643, &quot;afii57444&quot;, 0x0644, &quot;afii57445&quot;, 0x0645, &quot;afii57446&quot;, 0x0646, &quot;afii57448&quot;, 0x0648, &quot;afii57449&quot;, 0x0649, &quot;afii57450&quot;, 0x064a, &quot;afii57451&quot;, 0x064b, &quot;afii57452&quot;, 0x064c, &quot;afii57453&quot;, 0x064d, &quot;afii57454&quot;, 0x064e, &quot;afii57455&quot;, 0x064f, &quot;afii57456&quot;, 0x0650, &quot;afii57457&quot;, 0x0651, &quot;afii57458&quot;, 0x0652, &quot;afii57470&quot;, 0x0647, &quot;afii57505&quot;, 0x06a4, &quot;afii57506&quot;, 0x067e, &quot;afii57507&quot;, 0x0686, &quot;afii57508&quot;, 0x0698, &quot;afii57509&quot;, 0x06af, &quot;afii57511&quot;, 0x0679, &quot;afii57512&quot;, 0x0688, &quot;afii57513&quot;, 0x0691, &quot;afii57514&quot;, 0x06ba, &quot;afii57519&quot;, 0x06d2, &quot;afii57534&quot;, 0x06d5, &quot;afii57636&quot;, 0x20aa, &quot;afii57645&quot;, 0x05be, &quot;afii57658&quot;, 0x05c3, &quot;afii57664&quot;, 0x05d0, &quot;afii57665&quot;, 0x05d1, &quot;afii57666&quot;, 0x05d2, &quot;afii57667&quot;, 0x05d3, &quot;afii57668&quot;, 0x05d4, &quot;afii57669&quot;, 0x05d5, &quot;afii57670&quot;, 0x05d6, &quot;afii57671&quot;, 0x05d7, &quot;afii57672&quot;, 0x05d8, &quot;afii57673&quot;, 0x05d9, &quot;afii57674&quot;, 0x05da, &quot;afii57675&quot;, 0x05db, &quot;afii57676&quot;, 0x05dc, &quot;afii57677&quot;, 0x05dd, &quot;afii57678&quot;, 0x05de, &quot;afii57679&quot;, 0x05df, &quot;afii57680&quot;, 0x05e0, &quot;afii57681&quot;, 0x05e1, &quot;afii57682&quot;, 0x05e2, &quot;afii57683&quot;, 0x05e3, &quot;afii57684&quot;, 0x05e4, &quot;afii57685&quot;, 0x05e5, &quot;afii57686&quot;, 0x05e6, &quot;afii57687&quot;, 0x05e7, &quot;afii57688&quot;, 0x05e8, &quot;afii57689&quot;, 0x05e9, &quot;afii57690&quot;, 0x05ea, &quot;afii57694&quot;, 0xfb2a, &quot;afii57695&quot;, 0xfb2b, &quot;afii57700&quot;, 0xfb4b, &quot;afii57705&quot;, 0xfb1f, &quot;afii57716&quot;, 0x05f0, &quot;afii57717&quot;, 0x05f1, &quot;afii57718&quot;, 0x05f2, &quot;afii57723&quot;, 0xfb35, &quot;afii57793&quot;, 0x05b4, &quot;afii57794&quot;, 0x05b5, &quot;afii57795&quot;, 0x05b6, &quot;afii57796&quot;, 0x05bb, &quot;afii57797&quot;, 0x05b8, &quot;afii57798&quot;, 0x05b7, &quot;afii57799&quot;, 0x05b0, &quot;afii57800&quot;, 0x05b2, &quot;afii57801&quot;, 0x05b1, &quot;afii57802&quot;, 0x05b3, &quot;afii57803&quot;, 0x05c2, &quot;afii57804&quot;, 0x05c1, &quot;afii57806&quot;, 0x05b9, &quot;afii57807&quot;, 0x05bc, &quot;afii57839&quot;, 0x05bd, &quot;afii57841&quot;, 0x05bf, &quot;afii57842&quot;, 0x05c0, &quot;afii57929&quot;, 0x02bc, &quot;afii61248&quot;, 0x2105, &quot;afii61289&quot;, 0x2113, &quot;afii61352&quot;, 0x2116, &quot;afii61573&quot;, 0x202c, &quot;afii61574&quot;, 0x202d, &quot;afii61575&quot;, 0x202e, &quot;afii61664&quot;, 0x200c, &quot;afii63167&quot;, 0x066d, &quot;afii64937&quot;, 0x02bd, &quot;agrave&quot;, 0x00e0, &quot;agujarati&quot;, 0x0a85, &quot;agurmukhi&quot;, 0x0a05, &quot;ahiragana&quot;, 0x3042, &quot;ahookabove&quot;, 0x1ea3, &quot;aibengali&quot;, 0x0990, &quot;aibopomofo&quot;, 0x311e, &quot;aideva&quot;, 0x0910, &quot;aiecyrillic&quot;, 0x04d5, &quot;aigujarati&quot;, 0x0a90, &quot;aigurmukhi&quot;, 0x0a10, &quot;aimatragurmukhi&quot;, 0x0a48, &quot;ainarabic&quot;, 0x0639, &quot;ainfinalarabic&quot;, 0xfeca, &quot;aininitialarabic&quot;, 0xfecb, &quot;ainmedialarabic&quot;, 0xfecc, &quot;ainvertedbreve&quot;, 0x0203, &quot;aivowelsignbengali&quot;, 0x09c8, &quot;aivowelsigndeva&quot;, 0x0948, &quot;aivowelsigngujarati&quot;, 0x0ac8, &quot;akatakana&quot;, 0x30a2, &quot;akatakanahalfwidth&quot;, 0xff71, &quot;akorean&quot;, 0x314f, &quot;alef&quot;, 0x05d0, &quot;alefarabic&quot;, 0x0627, &quot;alefdageshhebrew&quot;, 0xfb30, &quot;aleffinalarabic&quot;, 0xfe8e, &quot;alefhamzaabovearabic&quot;, 0x0623, &quot;alefhamzaabovefinalarabic&quot;, 0xfe84, &quot;alefhamzabelowarabic&quot;, 0x0625, &quot;alefhamzabelowfinalarabic&quot;, 0xfe88, &quot;alefhebrew&quot;, 0x05d0, &quot;aleflamedhebrew&quot;, 0xfb4f, &quot;alefmaddaabovearabic&quot;, 0x0622, &quot;alefmaddaabovefinalarabic&quot;, 0xfe82, &quot;alefmaksuraarabic&quot;, 0x0649, &quot;alefmaksurafinalarabic&quot;, 0xfef0, &quot;alefmaksurainitialarabic&quot;, 0xfef3, &quot;alefmaksuramedialarabic&quot;, 0xfef4, &quot;alefpatahhebrew&quot;, 0xfb2e, &quot;alefqamatshebrew&quot;, 0xfb2f, &quot;aleph&quot;, 0x2135, &quot;allequal&quot;, 0x224c, &quot;alpha&quot;, 0x03b1, &quot;alphatonos&quot;, 0x03ac, &quot;amacron&quot;, 0x0101, &quot;amonospace&quot;, 0xff41, &quot;ampersand&quot;, 0x0026, &quot;ampersandmonospace&quot;, 0xff06, &quot;ampersandsmall&quot;, 0xf726, &quot;amsquare&quot;, 0x33c2, &quot;anbopomofo&quot;, 0x3122, &quot;angbopomofo&quot;, 0x3124, &quot;angbracketleft&quot;, 0x3008, &quot;angbracketright&quot;, 0x3009, &quot;angkhankhuthai&quot;, 0x0e5a, &quot;angle&quot;, 0x2220, &quot;anglebracketleft&quot;, 0x3008, &quot;anglebracketleftvertical&quot;, 0xfe3f, &quot;anglebracketright&quot;, 0x3009, &quot;anglebracketrightvertical&quot;, 0xfe40, &quot;angleleft&quot;, 0x2329, &quot;angleright&quot;, 0x232a, &quot;angstrom&quot;, 0x212b, &quot;anoteleia&quot;, 0x0387, &quot;anudattadeva&quot;, 0x0952, &quot;anusvarabengali&quot;, 0x0982, &quot;anusvaradeva&quot;, 0x0902, &quot;anusvaragujarati&quot;, 0x0a82, &quot;aogonek&quot;, 0x0105, &quot;apaatosquare&quot;, 0x3300, &quot;aparen&quot;, 0x249c, &quot;apostrophearmenian&quot;, 0x055a, &quot;apostrophemod&quot;, 0x02bc, &quot;apple&quot;, 0xf8ff, &quot;approaches&quot;, 0x2250, &quot;approxequal&quot;, 0x2248, &quot;approxequalorimage&quot;, 0x2252, &quot;approximatelyequal&quot;, 0x2245, &quot;araeaekorean&quot;, 0x318e, &quot;araeakorean&quot;, 0x318d, &quot;arc&quot;, 0x2312, &quot;arighthalfring&quot;, 0x1e9a, &quot;aring&quot;, 0x00e5, &quot;aringacute&quot;, 0x01fb, &quot;aringbelow&quot;, 0x1e01, &quot;arrowboth&quot;, 0x2194, &quot;arrowdashdown&quot;, 0x21e3, &quot;arrowdashleft&quot;, 0x21e0, &quot;arrowdashright&quot;, 0x21e2, &quot;arrowdashup&quot;, 0x21e1, &quot;arrowdblboth&quot;, 0x21d4, &quot;arrowdbldown&quot;, 0x21d3, &quot;arrowdblleft&quot;, 0x21d0, &quot;arrowdblright&quot;, 0x21d2, &quot;arrowdblup&quot;, 0x21d1, &quot;arrowdown&quot;, 0x2193, &quot;arrowdownleft&quot;, 0x2199, &quot;arrowdownright&quot;, 0x2198, &quot;arrowdownwhite&quot;, 0x21e9, &quot;arrowheaddownmod&quot;, 0x02c5, &quot;arrowheadleftmod&quot;, 0x02c2, &quot;arrowheadrightmod&quot;, 0x02c3, &quot;arrowheadupmod&quot;, 0x02c4, &quot;arrowhorizex&quot;, 0xf8e7, &quot;arrowleft&quot;, 0x2190, &quot;arrowleftdbl&quot;, 0x21d0, &quot;arrowleftdblstroke&quot;, 0x21cd, &quot;arrowleftoverright&quot;, 0x21c6, &quot;arrowleftwhite&quot;, 0x21e6, &quot;arrowright&quot;, 0x2192, &quot;arrowrightdblstroke&quot;, 0x21cf, &quot;arrowrightheavy&quot;, 0x279e, &quot;arrowrightoverleft&quot;, 0x21c4, &quot;arrowrightwhite&quot;, 0x21e8, &quot;arrowtableft&quot;, 0x21e4, &quot;arrowtabright&quot;, 0x21e5, &quot;arrowup&quot;, 0x2191, &quot;arrowupdn&quot;, 0x2195, &quot;arrowupdnbse&quot;, 0x21a8, &quot;arrowupdownbase&quot;, 0x21a8, &quot;arrowupleft&quot;, 0x2196, &quot;arrowupleftofdown&quot;, 0x21c5, &quot;arrowupright&quot;, 0x2197, &quot;arrowupwhite&quot;, 0x21e7, &quot;arrowvertex&quot;, 0xf8e6, &quot;asciicircum&quot;, 0x005e, &quot;asciicircummonospace&quot;, 0xff3e, &quot;asciitilde&quot;, 0x007e, &quot;asciitildemonospace&quot;, 0xff5e, &quot;ascript&quot;, 0x0251, &quot;ascriptturned&quot;, 0x0252, &quot;asmallhiragana&quot;, 0x3041, &quot;asmallkatakana&quot;, 0x30a1, &quot;asmallkatakanahalfwidth&quot;, 0xff67, &quot;asterisk&quot;, 0x002a, &quot;asteriskaltonearabic&quot;, 0x066d, &quot;asteriskarabic&quot;, 0x066d, &quot;asteriskmath&quot;, 0x2217, &quot;asteriskmonospace&quot;, 0xff0a, &quot;asterisksmall&quot;, 0xfe61, &quot;asterism&quot;, 0x2042, &quot;asuperior&quot;, 0xf6e9, &quot;asymptoticallyequal&quot;, 0x2243, &quot;at&quot;, 0x0040, &quot;atilde&quot;, 0x00e3, &quot;atmonospace&quot;, 0xff20, &quot;atsmall&quot;, 0xfe6b, &quot;aturned&quot;, 0x0250, &quot;aubengali&quot;, 0x0994, &quot;aubopomofo&quot;, 0x3120, &quot;audeva&quot;, 0x0914, &quot;augujarati&quot;, 0x0a94, &quot;augurmukhi&quot;, 0x0a14, &quot;aulengthmarkbengali&quot;, 0x09d7, &quot;aumatragurmukhi&quot;, 0x0a4c, &quot;auvowelsignbengali&quot;, 0x09cc, &quot;auvowelsigndeva&quot;, 0x094c, &quot;auvowelsigngujarati&quot;, 0x0acc, &quot;avagrahadeva&quot;, 0x093d, &quot;aybarmenian&quot;, 0x0561, &quot;ayin&quot;, 0x05e2, &quot;ayinaltonehebrew&quot;, 0xfb20, &quot;ayinhebrew&quot;, 0x05e2, &quot;b&quot;, 0x0062, &quot;babengali&quot;, 0x09ac, &quot;backslash&quot;, 0x005c, &quot;backslashmonospace&quot;, 0xff3c, &quot;badeva&quot;, 0x092c, &quot;bagujarati&quot;, 0x0aac, &quot;bagurmukhi&quot;, 0x0a2c, &quot;bahiragana&quot;, 0x3070, &quot;bahtthai&quot;, 0x0e3f, &quot;bakatakana&quot;, 0x30d0, &quot;bar&quot;, 0x007c, &quot;barmonospace&quot;, 0xff5c, &quot;bbopomofo&quot;, 0x3105, &quot;bcircle&quot;, 0x24d1, &quot;bdotaccent&quot;, 0x1e03, &quot;bdotbelow&quot;, 0x1e05, &quot;beamedsixteenthnotes&quot;, 0x266c, &quot;because&quot;, 0x2235, &quot;becyrillic&quot;, 0x0431, &quot;beharabic&quot;, 0x0628, &quot;behfinalarabic&quot;, 0xfe90, &quot;behinitialarabic&quot;, 0xfe91, &quot;behiragana&quot;, 0x3079, &quot;behmedialarabic&quot;, 0xfe92, &quot;behmeeminitialarabic&quot;, 0xfc9f, &quot;behmeemisolatedarabic&quot;, 0xfc08, &quot;behnoonfinalarabic&quot;, 0xfc6d, &quot;bekatakana&quot;, 0x30d9, &quot;benarmenian&quot;, 0x0562, &quot;bet&quot;, 0x05d1, &quot;beta&quot;, 0x03b2, &quot;betasymbolgreek&quot;, 0x03d0, &quot;betdagesh&quot;, 0xfb31, &quot;betdageshhebrew&quot;, 0xfb31, &quot;bethebrew&quot;, 0x05d1, &quot;betrafehebrew&quot;, 0xfb4c, &quot;bhabengali&quot;, 0x09ad, &quot;bhadeva&quot;, 0x092d, &quot;bhagujarati&quot;, 0x0aad, &quot;bhagurmukhi&quot;, 0x0a2d, &quot;bhook&quot;, 0x0253, &quot;bihiragana&quot;, 0x3073, &quot;bikatakana&quot;, 0x30d3, &quot;bilabialclick&quot;, 0x0298, &quot;bindigurmukhi&quot;, 0x0a02, &quot;birusquare&quot;, 0x3331, &quot;blackcircle&quot;, 0x25cf, &quot;blackdiamond&quot;, 0x25c6, &quot;blackdownpointingtriangle&quot;, 0x25bc, &quot;blackleftpointingpointer&quot;, 0x25c4, &quot;blackleftpointingtriangle&quot;, 0x25c0, &quot;blacklenticularbracketleft&quot;, 0x3010, &quot;blacklenticularbracketleftvertical&quot;, 0xfe3b, &quot;blacklenticularbracketright&quot;, 0x3011, &quot;blacklenticularbracketrightvertical&quot;, 0xfe3c, &quot;blacklowerlefttriangle&quot;, 0x25e3, &quot;blacklowerrighttriangle&quot;, 0x25e2, &quot;blackrectangle&quot;, 0x25ac, &quot;blackrightpointingpointer&quot;, 0x25ba, &quot;blackrightpointingtriangle&quot;, 0x25b6, &quot;blacksmallsquare&quot;, 0x25aa, &quot;blacksmilingface&quot;, 0x263b, &quot;blacksquare&quot;, 0x25a0, &quot;blackstar&quot;, 0x2605, &quot;blackupperlefttriangle&quot;, 0x25e4, &quot;blackupperrighttriangle&quot;, 0x25e5, &quot;blackuppointingsmalltriangle&quot;, 0x25b4, &quot;blackuppointingtriangle&quot;, 0x25b2, &quot;blank&quot;, 0x2423, &quot;blinebelow&quot;, 0x1e07, &quot;block&quot;, 0x2588, &quot;bmonospace&quot;, 0xff42, &quot;bobaimaithai&quot;, 0x0e1a, &quot;bohiragana&quot;, 0x307c, &quot;bokatakana&quot;, 0x30dc, &quot;bparen&quot;, 0x249d, &quot;bqsquare&quot;, 0x33c3, &quot;braceex&quot;, 0xf8f4, &quot;braceleft&quot;, 0x007b, &quot;braceleftbt&quot;, 0xf8f3, &quot;braceleftmid&quot;, 0xf8f2, &quot;braceleftmonospace&quot;, 0xff5b, &quot;braceleftsmall&quot;, 0xfe5b, &quot;bracelefttp&quot;, 0xf8f1, &quot;braceleftvertical&quot;, 0xfe37, &quot;braceright&quot;, 0x007d, &quot;bracerightbt&quot;, 0xf8fe, &quot;bracerightmid&quot;, 0xf8fd, &quot;bracerightmonospace&quot;, 0xff5d, &quot;bracerightsmall&quot;, 0xfe5c, &quot;bracerighttp&quot;, 0xf8fc, &quot;bracerightvertical&quot;, 0xfe38, &quot;bracketleft&quot;, 0x005b, &quot;bracketleftbt&quot;, 0xf8f0, &quot;bracketleftex&quot;, 0xf8ef, &quot;bracketleftmonospace&quot;, 0xff3b, &quot;bracketlefttp&quot;, 0xf8ee, &quot;bracketright&quot;, 0x005d, &quot;bracketrightbt&quot;, 0xf8fb, &quot;bracketrightex&quot;, 0xf8fa, &quot;bracketrightmonospace&quot;, 0xff3d, &quot;bracketrighttp&quot;, 0xf8f9, &quot;breve&quot;, 0x02d8, &quot;brevebelowcmb&quot;, 0x032e, &quot;brevecmb&quot;, 0x0306, &quot;breveinvertedbelowcmb&quot;, 0x032f, &quot;breveinvertedcmb&quot;, 0x0311, &quot;breveinverteddoublecmb&quot;, 0x0361, &quot;bridgebelowcmb&quot;, 0x032a, &quot;bridgeinvertedbelowcmb&quot;, 0x033a, &quot;brokenbar&quot;, 0x00a6, &quot;bstroke&quot;, 0x0180, &quot;bsuperior&quot;, 0xf6ea, &quot;btopbar&quot;, 0x0183, &quot;buhiragana&quot;, 0x3076, &quot;bukatakana&quot;, 0x30d6, &quot;bullet&quot;, 0x2022, &quot;bulletinverse&quot;, 0x25d8, &quot;bulletoperator&quot;, 0x2219, &quot;bullseye&quot;, 0x25ce, &quot;c&quot;, 0x0063, &quot;caarmenian&quot;, 0x056e, &quot;cabengali&quot;, 0x099a, &quot;cacute&quot;, 0x0107, &quot;cadeva&quot;, 0x091a, &quot;cagujarati&quot;, 0x0a9a, &quot;cagurmukhi&quot;, 0x0a1a, &quot;calsquare&quot;, 0x3388, &quot;candrabindubengali&quot;, 0x0981, &quot;candrabinducmb&quot;, 0x0310, &quot;candrabindudeva&quot;, 0x0901, &quot;candrabindugujarati&quot;, 0x0a81, &quot;capslock&quot;, 0x21ea, &quot;careof&quot;, 0x2105, &quot;caron&quot;, 0x02c7, &quot;caronbelowcmb&quot;, 0x032c, &quot;caroncmb&quot;, 0x030c, &quot;carriagereturn&quot;, 0x21b5, &quot;cbopomofo&quot;, 0x3118, &quot;ccaron&quot;, 0x010d, &quot;ccedilla&quot;, 0x00e7, &quot;ccedillaacute&quot;, 0x1e09, &quot;ccircle&quot;, 0x24d2, &quot;ccircumflex&quot;, 0x0109, &quot;ccurl&quot;, 0x0255, &quot;cdot&quot;, 0x010b, &quot;cdotaccent&quot;, 0x010b, &quot;cdsquare&quot;, 0x33c5, &quot;cedilla&quot;, 0x00b8, &quot;cedillacmb&quot;, 0x0327, &quot;cent&quot;, 0x00a2, &quot;centigrade&quot;, 0x2103, &quot;centinferior&quot;, 0xf6df, &quot;centmonospace&quot;, 0xffe0, &quot;centoldstyle&quot;, 0xf7a2, &quot;centsuperior&quot;, 0xf6e0, &quot;chaarmenian&quot;, 0x0579, &quot;chabengali&quot;, 0x099b, &quot;chadeva&quot;, 0x091b, &quot;chagujarati&quot;, 0x0a9b, &quot;chagurmukhi&quot;, 0x0a1b, &quot;chbopomofo&quot;, 0x3114, &quot;cheabkhasiancyrillic&quot;, 0x04bd, &quot;checkmark&quot;, 0x2713, &quot;checyrillic&quot;, 0x0447, &quot;chedescenderabkhasiancyrillic&quot;, 0x04bf, &quot;chedescendercyrillic&quot;, 0x04b7, &quot;chedieresiscyrillic&quot;, 0x04f5, &quot;cheharmenian&quot;, 0x0573, &quot;chekhakassiancyrillic&quot;, 0x04cc, &quot;cheverticalstrokecyrillic&quot;, 0x04b9, &quot;chi&quot;, 0x03c7, &quot;chieuchacirclekorean&quot;, 0x3277, &quot;chieuchaparenkorean&quot;, 0x3217, &quot;chieuchcirclekorean&quot;, 0x3269, &quot;chieuchkorean&quot;, 0x314a, &quot;chieuchparenkorean&quot;, 0x3209, &quot;chochangthai&quot;, 0x0e0a, &quot;chochanthai&quot;, 0x0e08, &quot;chochingthai&quot;, 0x0e09, &quot;chochoethai&quot;, 0x0e0c, &quot;chook&quot;, 0x0188, &quot;cieucacirclekorean&quot;, 0x3276, &quot;cieucaparenkorean&quot;, 0x3216, &quot;cieuccirclekorean&quot;, 0x3268, &quot;cieuckorean&quot;, 0x3148, &quot;cieucparenkorean&quot;, 0x3208, &quot;cieucuparenkorean&quot;, 0x321c, &quot;circle&quot;, 0x25cb, &quot;circlecopyrt&quot;, 0x00a9, &quot;circlemultiply&quot;, 0x2297, &quot;circleot&quot;, 0x2299, &quot;circleplus&quot;, 0x2295, &quot;circlepostalmark&quot;, 0x3036, &quot;circlewithlefthalfblack&quot;, 0x25d0, &quot;circlewithrighthalfblack&quot;, 0x25d1, &quot;circumflex&quot;, 0x02c6, &quot;circumflexbelowcmb&quot;, 0x032d, &quot;circumflexcmb&quot;, 0x0302, &quot;clear&quot;, 0x2327, &quot;clickalveolar&quot;, 0x01c2, &quot;clickdental&quot;, 0x01c0, &quot;clicklateral&quot;, 0x01c1, &quot;clickretroflex&quot;, 0x01c3, &quot;club&quot;, 0x2663, &quot;clubsuitblack&quot;, 0x2663, &quot;clubsuitwhite&quot;, 0x2667, &quot;cmcubedsquare&quot;, 0x33a4, &quot;cmonospace&quot;, 0xff43, &quot;cmsquaredsquare&quot;, 0x33a0, &quot;coarmenian&quot;, 0x0581, &quot;colon&quot;, 0x003a, &quot;colonmonetary&quot;, 0x20a1, &quot;colonmonospace&quot;, 0xff1a, &quot;colonsign&quot;, 0x20a1, &quot;colonsmall&quot;, 0xfe55, &quot;colontriangularhalfmod&quot;, 0x02d1, &quot;colontriangularmod&quot;, 0x02d0, &quot;comma&quot;, 0x002c, &quot;commaabovecmb&quot;, 0x0313, &quot;commaaboverightcmb&quot;, 0x0315, &quot;commaaccent&quot;, 0xf6c3, &quot;commaarabic&quot;, 0x060c, &quot;commaarmenian&quot;, 0x055d, &quot;commainferior&quot;, 0xf6e1, &quot;commamonospace&quot;, 0xff0c, &quot;commareversedabovecmb&quot;, 0x0314, &quot;commareversedmod&quot;, 0x02bd, &quot;commasmall&quot;, 0xfe50, &quot;commasuperior&quot;, 0xf6e2, &quot;commaturnedabovecmb&quot;, 0x0312, &quot;commaturnedmod&quot;, 0x02bb, &quot;compass&quot;, 0x263c, &quot;congruent&quot;, 0x2245, &quot;contourintegral&quot;, 0x222e, &quot;control&quot;, 0x2303, &quot;controlACK&quot;, 0x0006, &quot;controlBEL&quot;, 0x0007, &quot;controlBS&quot;, 0x0008, &quot;controlCAN&quot;, 0x0018, &quot;controlCR&quot;, 0x000d, &quot;controlDC1&quot;, 0x0011, &quot;controlDC2&quot;, 0x0012, &quot;controlDC3&quot;, 0x0013, &quot;controlDC4&quot;, 0x0014, &quot;controlDEL&quot;, 0x007f, &quot;controlDLE&quot;, 0x0010, &quot;controlEM&quot;, 0x0019, &quot;controlENQ&quot;, 0x0005, &quot;controlEOT&quot;, 0x0004, &quot;controlESC&quot;, 0x001b, &quot;controlETB&quot;, 0x0017, &quot;controlETX&quot;, 0x0003, &quot;controlFF&quot;, 0x000c, &quot;controlFS&quot;, 0x001c, &quot;controlGS&quot;, 0x001d, &quot;controlHT&quot;, 0x0009, &quot;controlLF&quot;, 0x000a, &quot;controlNAK&quot;, 0x0015, &quot;controlNULL&quot;, 0x0000, &quot;controlRS&quot;, 0x001e, &quot;controlSI&quot;, 0x000f, &quot;controlSO&quot;, 0x000e, &quot;controlSOT&quot;, 0x0002, &quot;controlSTX&quot;, 0x0001, &quot;controlSUB&quot;, 0x001a, &quot;controlSYN&quot;, 0x0016, &quot;controlUS&quot;, 0x001f, &quot;controlVT&quot;, 0x000b, &quot;copyright&quot;, 0x00a9, &quot;copyrightsans&quot;, 0xf8e9, &quot;copyrightserif&quot;, 0xf6d9, &quot;cornerbracketleft&quot;, 0x300c, &quot;cornerbracketlefthalfwidth&quot;, 0xff62, &quot;cornerbracketleftvertical&quot;, 0xfe41, &quot;cornerbracketright&quot;, 0x300d, &quot;cornerbracketrighthalfwidth&quot;, 0xff63, &quot;cornerbracketrightvertical&quot;, 0xfe42, &quot;corporationsquare&quot;, 0x337f, &quot;cosquare&quot;, 0x33c7, &quot;coverkgsquare&quot;, 0x33c6, &quot;cparen&quot;, 0x249e, &quot;cruzeiro&quot;, 0x20a2, &quot;cstretched&quot;, 0x0297, &quot;curlyand&quot;, 0x22cf, &quot;curlyor&quot;, 0x22ce, &quot;currency&quot;, 0x00a4, &quot;cyrBreve&quot;, 0xf6d1, &quot;cyrFlex&quot;, 0xf6d2, &quot;cyrbreve&quot;, 0xf6d4, &quot;cyrflex&quot;, 0xf6d5, &quot;d&quot;, 0x0064, &quot;daarmenian&quot;, 0x0564, &quot;dabengali&quot;, 0x09a6, &quot;dadarabic&quot;, 0x0636, &quot;dadeva&quot;, 0x0926, &quot;dadfinalarabic&quot;, 0xfebe, &quot;dadinitialarabic&quot;, 0xfebf, &quot;dadmedialarabic&quot;, 0xfec0, &quot;dagesh&quot;, 0x05bc, &quot;dageshhebrew&quot;, 0x05bc, &quot;dagger&quot;, 0x2020, &quot;daggerdbl&quot;, 0x2021, &quot;dagujarati&quot;, 0x0aa6, &quot;dagurmukhi&quot;, 0x0a26, &quot;dahiragana&quot;, 0x3060, &quot;dakatakana&quot;, 0x30c0, &quot;dalarabic&quot;, 0x062f, &quot;dalet&quot;, 0x05d3, &quot;daletdagesh&quot;, 0xfb33, &quot;daletdageshhebrew&quot;, 0xfb33, &quot;dalethebrew&quot;, 0x05d3, &quot;dalfinalarabic&quot;, 0xfeaa, &quot;dammaarabic&quot;, 0x064f, &quot;dammalowarabic&quot;, 0x064f, &quot;dammatanaltonearabic&quot;, 0x064c, &quot;dammatanarabic&quot;, 0x064c, &quot;danda&quot;, 0x0964, &quot;dargahebrew&quot;, 0x05a7, &quot;dargalefthebrew&quot;, 0x05a7, &quot;dasiapneumatacyrilliccmb&quot;, 0x0485, &quot;dblGrave&quot;, 0xf6d3, &quot;dblanglebracketleft&quot;, 0x300a, &quot;dblanglebracketleftvertical&quot;, 0xfe3d, &quot;dblanglebracketright&quot;, 0x300b, &quot;dblanglebracketrightvertical&quot;, 0xfe3e, &quot;dblarchinvertedbelowcmb&quot;, 0x032b, &quot;dblarrowleft&quot;, 0x21d4, &quot;dblarrowright&quot;, 0x21d2, &quot;dbldanda&quot;, 0x0965, &quot;dblgrave&quot;, 0xf6d6, &quot;dblgravecmb&quot;, 0x030f, &quot;dblintegral&quot;, 0x222c, &quot;dbllowline&quot;, 0x2017, &quot;dbllowlinecmb&quot;, 0x0333, &quot;dbloverlinecmb&quot;, 0x033f, &quot;dblprimemod&quot;, 0x02ba, &quot;dblverticalbar&quot;, 0x2016, &quot;dblverticallineabovecmb&quot;, 0x030e, &quot;dbopomofo&quot;, 0x3109, &quot;dbsquare&quot;, 0x33c8, &quot;dcaron&quot;, 0x010f, &quot;dcedilla&quot;, 0x1e11, &quot;dcircle&quot;, 0x24d3, &quot;dcircumflexbelow&quot;, 0x1e13, &quot;dcroat&quot;, 0x0111, &quot;ddabengali&quot;, 0x09a1, &quot;ddadeva&quot;, 0x0921, &quot;ddagujarati&quot;, 0x0aa1, &quot;ddagurmukhi&quot;, 0x0a21, &quot;ddalarabic&quot;, 0x0688, &quot;ddalfinalarabic&quot;, 0xfb89, &quot;dddhadeva&quot;, 0x095c, &quot;ddhabengali&quot;, 0x09a2, &quot;ddhadeva&quot;, 0x0922, &quot;ddhagujarati&quot;, 0x0aa2, &quot;ddhagurmukhi&quot;, 0x0a22, &quot;ddotaccent&quot;, 0x1e0b, &quot;ddotbelow&quot;, 0x1e0d, &quot;decimalseparatorarabic&quot;, 0x066b, &quot;decimalseparatorpersian&quot;, 0x066b, &quot;decyrillic&quot;, 0x0434, &quot;degree&quot;, 0x00b0, &quot;dehihebrew&quot;, 0x05ad, &quot;dehiragana&quot;, 0x3067, &quot;deicoptic&quot;, 0x03ef, &quot;dekatakana&quot;, 0x30c7, &quot;deleteleft&quot;, 0x232b, &quot;deleteright&quot;, 0x2326, &quot;delta&quot;, 0x03b4, &quot;deltaturned&quot;, 0x018d, &quot;denominatorminusonenumeratorbengali&quot;, 0x09f8, &quot;dezh&quot;, 0x02a4, &quot;dhabengali&quot;, 0x09a7, &quot;dhadeva&quot;, 0x0927, &quot;dhagujarati&quot;, 0x0aa7, &quot;dhagurmukhi&quot;, 0x0a27, &quot;dhook&quot;, 0x0257, &quot;dialytikatonos&quot;, 0x0385, &quot;dialytikatonoscmb&quot;, 0x0344, &quot;diamond&quot;, 0x2666, &quot;diamondsuitwhite&quot;, 0x2662, &quot;dieresis&quot;, 0x00a8, &quot;dieresisacute&quot;, 0xf6d7, &quot;dieresisbelowcmb&quot;, 0x0324, &quot;dieresiscmb&quot;, 0x0308, &quot;dieresisgrave&quot;, 0xf6d8, &quot;dieresistonos&quot;, 0x0385, &quot;dihiragana&quot;, 0x3062, &quot;dikatakana&quot;, 0x30c2, &quot;dittomark&quot;, 0x3003, &quot;divide&quot;, 0x00f7, &quot;divides&quot;, 0x2223, &quot;divisionslash&quot;, 0x2215, &quot;djecyrillic&quot;, 0x0452, &quot;dkshade&quot;, 0x2593, &quot;dlinebelow&quot;, 0x1e0f, &quot;dlsquare&quot;, 0x3397, &quot;dmacron&quot;, 0x0111, &quot;dmonospace&quot;, 0xff44, &quot;dnblock&quot;, 0x2584, &quot;dochadathai&quot;, 0x0e0e, &quot;dodekthai&quot;, 0x0e14, &quot;dohiragana&quot;, 0x3069, &quot;dokatakana&quot;, 0x30c9, &quot;dollar&quot;, 0x0024, &quot;dollarinferior&quot;, 0xf6e3, &quot;dollarmonospace&quot;, 0xff04, &quot;dollaroldstyle&quot;, 0xf724, &quot;dollarsmall&quot;, 0xfe69, &quot;dollarsuperior&quot;, 0xf6e4, &quot;dong&quot;, 0x20ab, &quot;dorusquare&quot;, 0x3326, &quot;dotaccent&quot;, 0x02d9, &quot;dotaccentcmb&quot;, 0x0307, &quot;dotbelowcmb&quot;, 0x0323, &quot;dotbelowcomb&quot;, 0x0323, &quot;dotkatakana&quot;, 0x30fb, &quot;dotlessi&quot;, 0x0131, &quot;dotlessj&quot;, 0xf6be, &quot;dotlessjstrokehook&quot;, 0x0284, &quot;dotmath&quot;, 0x22c5, &quot;dottedcircle&quot;, 0x25cc, &quot;doubleyodpatah&quot;, 0xfb1f, &quot;doubleyodpatahhebrew&quot;, 0xfb1f, &quot;downtackbelowcmb&quot;, 0x031e, &quot;downtackmod&quot;, 0x02d5, &quot;dparen&quot;, 0x249f, &quot;dsuperior&quot;, 0xf6eb, &quot;dtail&quot;, 0x0256, &quot;dtopbar&quot;, 0x018c, &quot;duhiragana&quot;, 0x3065, &quot;dukatakana&quot;, 0x30c5, &quot;dz&quot;, 0x01f3, &quot;dzaltone&quot;, 0x02a3, &quot;dzcaron&quot;, 0x01c6, &quot;dzcurl&quot;, 0x02a5, &quot;dzeabkhasiancyrillic&quot;, 0x04e1, &quot;dzecyrillic&quot;, 0x0455, &quot;dzhecyrillic&quot;, 0x045f, &quot;e&quot;, 0x0065, &quot;eacute&quot;, 0x00e9, &quot;earth&quot;, 0x2641, &quot;ebengali&quot;, 0x098f, &quot;ebopomofo&quot;, 0x311c, &quot;ebreve&quot;, 0x0115, &quot;ecandradeva&quot;, 0x090d, &quot;ecandragujarati&quot;, 0x0a8d, &quot;ecandravowelsigndeva&quot;, 0x0945, &quot;ecandravowelsigngujarati&quot;, 0x0ac5, &quot;ecaron&quot;, 0x011b, &quot;ecedillabreve&quot;, 0x1e1d, &quot;echarmenian&quot;, 0x0565, &quot;echyiwnarmenian&quot;, 0x0587, &quot;ecircle&quot;, 0x24d4, &quot;ecircumflex&quot;, 0x00ea, &quot;ecircumflexacute&quot;, 0x1ebf, &quot;ecircumflexbelow&quot;, 0x1e19, &quot;ecircumflexdotbelow&quot;, 0x1ec7, &quot;ecircumflexgrave&quot;, 0x1ec1, &quot;ecircumflexhookabove&quot;, 0x1ec3, &quot;ecircumflextilde&quot;, 0x1ec5, &quot;ecyrillic&quot;, 0x0454, &quot;edblgrave&quot;, 0x0205, &quot;edeva&quot;, 0x090f, &quot;edieresis&quot;, 0x00eb, &quot;edot&quot;, 0x0117, &quot;edotaccent&quot;, 0x0117, &quot;edotbelow&quot;, 0x1eb9, &quot;eegurmukhi&quot;, 0x0a0f, &quot;eematragurmukhi&quot;, 0x0a47, &quot;efcyrillic&quot;, 0x0444, &quot;egrave&quot;, 0x00e8, &quot;egujarati&quot;, 0x0a8f, &quot;eharmenian&quot;, 0x0567, &quot;ehbopomofo&quot;, 0x311d, &quot;ehiragana&quot;, 0x3048, &quot;ehookabove&quot;, 0x1ebb, &quot;eibopomofo&quot;, 0x311f, &quot;eight&quot;, 0x0038, &quot;eightarabic&quot;, 0x0668, &quot;eightbengali&quot;, 0x09ee, &quot;eightcircle&quot;, 0x2467, &quot;eightcircleinversesansserif&quot;, 0x2791, &quot;eightdeva&quot;, 0x096e, &quot;eighteencircle&quot;, 0x2471, &quot;eighteenparen&quot;, 0x2485, &quot;eighteenperiod&quot;, 0x2499, &quot;eightgujarati&quot;, 0x0aee, &quot;eightgurmukhi&quot;, 0x0a6e, &quot;eighthackarabic&quot;, 0x0668, &quot;eighthangzhou&quot;, 0x3028, &quot;eighthnotebeamed&quot;, 0x266b, &quot;eightideographicparen&quot;, 0x3227, &quot;eightinferior&quot;, 0x2088, &quot;eightmonospace&quot;, 0xff18, &quot;eightoldstyle&quot;, 0xf738, &quot;eightparen&quot;, 0x247b, &quot;eightperiod&quot;, 0x248f, &quot;eightpersian&quot;, 0x06f8, &quot;eightroman&quot;, 0x2177, &quot;eightsuperior&quot;, 0x2078, &quot;eightthai&quot;, 0x0e58, &quot;einvertedbreve&quot;, 0x0207, &quot;eiotifiedcyrillic&quot;, 0x0465, &quot;ekatakana&quot;, 0x30a8, &quot;ekatakanahalfwidth&quot;, 0xff74, &quot;ekonkargurmukhi&quot;, 0x0a74, &quot;ekorean&quot;, 0x3154, &quot;elcyrillic&quot;, 0x043b, &quot;element&quot;, 0x2208, &quot;elevencircle&quot;, 0x246a, &quot;elevenparen&quot;, 0x247e, &quot;elevenperiod&quot;, 0x2492, &quot;elevenroman&quot;, 0x217a, &quot;ellipsis&quot;, 0x2026, &quot;ellipsisvertical&quot;, 0x22ee, &quot;emacron&quot;, 0x0113, &quot;emacronacute&quot;, 0x1e17, &quot;emacrongrave&quot;, 0x1e15, &quot;emcyrillic&quot;, 0x043c, &quot;emdash&quot;, 0x2014, &quot;emdashvertical&quot;, 0xfe31, &quot;emonospace&quot;, 0xff45, &quot;emphasismarkarmenian&quot;, 0x055b, &quot;emptyset&quot;, 0x2205, &quot;enbopomofo&quot;, 0x3123, &quot;encyrillic&quot;, 0x043d, &quot;endash&quot;, 0x2013, &quot;endashvertical&quot;, 0xfe32, &quot;endescendercyrillic&quot;, 0x04a3, &quot;eng&quot;, 0x014b, &quot;engbopomofo&quot;, 0x3125, &quot;enghecyrillic&quot;, 0x04a5, &quot;enhookcyrillic&quot;, 0x04c8, &quot;enspace&quot;, 0x2002, &quot;eogonek&quot;, 0x0119, &quot;eokorean&quot;, 0x3153, &quot;eopen&quot;, 0x025b, &quot;eopenclosed&quot;, 0x029a, &quot;eopenreversed&quot;, 0x025c, &quot;eopenreversedclosed&quot;, 0x025e, &quot;eopenreversedhook&quot;, 0x025d, &quot;eparen&quot;, 0x24a0, &quot;epsilon&quot;, 0x03b5, &quot;epsilontonos&quot;, 0x03ad, &quot;equal&quot;, 0x003d, &quot;equalmonospace&quot;, 0xff1d, &quot;equalsmall&quot;, 0xfe66, &quot;equalsuperior&quot;, 0x207c, &quot;equivalence&quot;, 0x2261, &quot;erbopomofo&quot;, 0x3126, &quot;ercyrillic&quot;, 0x0440, &quot;ereversed&quot;, 0x0258, &quot;ereversedcyrillic&quot;, 0x044d, &quot;escyrillic&quot;, 0x0441, &quot;esdescendercyrillic&quot;, 0x04ab, &quot;esh&quot;, 0x0283, &quot;eshcurl&quot;, 0x0286, &quot;eshortdeva&quot;, 0x090e, &quot;eshortvowelsigndeva&quot;, 0x0946, &quot;eshreversedloop&quot;, 0x01aa, &quot;eshsquatreversed&quot;, 0x0285, &quot;esmallhiragana&quot;, 0x3047, &quot;esmallkatakana&quot;, 0x30a7, &quot;esmallkatakanahalfwidth&quot;, 0xff6a, &quot;estimated&quot;, 0x212e, &quot;esuperior&quot;, 0xf6ec, &quot;eta&quot;, 0x03b7, &quot;etarmenian&quot;, 0x0568, &quot;etatonos&quot;, 0x03ae, &quot;eth&quot;, 0x00f0, &quot;etilde&quot;, 0x1ebd, &quot;etildebelow&quot;, 0x1e1b, &quot;etnahtafoukhhebrew&quot;, 0x0591, &quot;etnahtafoukhlefthebrew&quot;, 0x0591, &quot;etnahtahebrew&quot;, 0x0591, &quot;etnahtalefthebrew&quot;, 0x0591, &quot;eturned&quot;, 0x01dd, &quot;eukorean&quot;, 0x3161, &quot;euro&quot;, 0x20ac, &quot;evowelsignbengali&quot;, 0x09c7, &quot;evowelsigndeva&quot;, 0x0947, &quot;evowelsigngujarati&quot;, 0x0ac7, &quot;exclam&quot;, 0x0021, &quot;exclamarmenian&quot;, 0x055c, &quot;exclamdbl&quot;, 0x203c, &quot;exclamdown&quot;, 0x00a1, &quot;exclamdownsmall&quot;, 0xf7a1, &quot;exclammonospace&quot;, 0xff01, &quot;exclamsmall&quot;, 0xf721, &quot;existential&quot;, 0x2203, &quot;ezh&quot;, 0x0292, &quot;ezhcaron&quot;, 0x01ef, &quot;ezhcurl&quot;, 0x0293, &quot;ezhreversed&quot;, 0x01b9, &quot;ezhtail&quot;, 0x01ba, &quot;f&quot;, 0x0066, &quot;fadeva&quot;, 0x095e, &quot;fagurmukhi&quot;, 0x0a5e, &quot;fahrenheit&quot;, 0x2109, &quot;fathaarabic&quot;, 0x064e, &quot;fathalowarabic&quot;, 0x064e, &quot;fathatanarabic&quot;, 0x064b, &quot;fbopomofo&quot;, 0x3108, &quot;fcircle&quot;, 0x24d5, &quot;fdotaccent&quot;, 0x1e1f, &quot;feharabic&quot;, 0x0641, &quot;feharmenian&quot;, 0x0586, &quot;fehfinalarabic&quot;, 0xfed2, &quot;fehinitialarabic&quot;, 0xfed3, &quot;fehmedialarabic&quot;, 0xfed4, &quot;feicoptic&quot;, 0x03e5, &quot;female&quot;, 0x2640, &quot;ff&quot;, 0xfb00, &quot;f_f&quot;, 0xfb00, &quot;ffi&quot;, 0xfb03, &quot;f_f_i&quot;, 0xfb03, &quot;ffl&quot;, 0xfb04, &quot;f_f_l&quot;, 0xfb04, &quot;fi&quot;, 0xfb01, &quot;f_i&quot;, 0xfb01, &quot;fifteencircle&quot;, 0x246e, &quot;fifteenparen&quot;, 0x2482, &quot;fifteenperiod&quot;, 0x2496, &quot;figuredash&quot;, 0x2012, &quot;filledbox&quot;, 0x25a0, &quot;filledrect&quot;, 0x25ac, &quot;finalkaf&quot;, 0x05da, &quot;finalkafdagesh&quot;, 0xfb3a, &quot;finalkafdageshhebrew&quot;, 0xfb3a, &quot;finalkafhebrew&quot;, 0x05da, &quot;finalmem&quot;, 0x05dd, &quot;finalmemhebrew&quot;, 0x05dd, &quot;finalnun&quot;, 0x05df, &quot;finalnunhebrew&quot;, 0x05df, &quot;finalpe&quot;, 0x05e3, &quot;finalpehebrew&quot;, 0x05e3, &quot;finaltsadi&quot;, 0x05e5, &quot;finaltsadihebrew&quot;, 0x05e5, &quot;firsttonechinese&quot;, 0x02c9, &quot;fisheye&quot;, 0x25c9, &quot;fitacyrillic&quot;, 0x0473, &quot;five&quot;, 0x0035, &quot;fivearabic&quot;, 0x0665, &quot;fivebengali&quot;, 0x09eb, &quot;fivecircle&quot;, 0x2464, &quot;fivecircleinversesansserif&quot;, 0x278e, &quot;fivedeva&quot;, 0x096b, &quot;fiveeighths&quot;, 0x215d, &quot;fivegujarati&quot;, 0x0aeb, &quot;fivegurmukhi&quot;, 0x0a6b, &quot;fivehackarabic&quot;, 0x0665, &quot;fivehangzhou&quot;, 0x3025, &quot;fiveideographicparen&quot;, 0x3224, &quot;fiveinferior&quot;, 0x2085, &quot;fivemonospace&quot;, 0xff15, &quot;fiveoldstyle&quot;, 0xf735, &quot;fiveparen&quot;, 0x2478, &quot;fiveperiod&quot;, 0x248c, &quot;fivepersian&quot;, 0x06f5, &quot;fiveroman&quot;, 0x2174, &quot;fivesuperior&quot;, 0x2075, &quot;fivethai&quot;, 0x0e55, &quot;fl&quot;, 0xfb02, &quot;f_l&quot;, 0xfb02, &quot;florin&quot;, 0x0192, &quot;fmonospace&quot;, 0xff46, &quot;fmsquare&quot;, 0x3399, &quot;fofanthai&quot;, 0x0e1f, &quot;fofathai&quot;, 0x0e1d, &quot;fongmanthai&quot;, 0x0e4f, &quot;forall&quot;, 0x2200, &quot;four&quot;, 0x0034, &quot;fourarabic&quot;, 0x0664, &quot;fourbengali&quot;, 0x09ea, &quot;fourcircle&quot;, 0x2463, &quot;fourcircleinversesansserif&quot;, 0x278d, &quot;fourdeva&quot;, 0x096a, &quot;fourgujarati&quot;, 0x0aea, &quot;fourgurmukhi&quot;, 0x0a6a, &quot;fourhackarabic&quot;, 0x0664, &quot;fourhangzhou&quot;, 0x3024, &quot;fourideographicparen&quot;, 0x3223, &quot;fourinferior&quot;, 0x2084, &quot;fourmonospace&quot;, 0xff14, &quot;fournumeratorbengali&quot;, 0x09f7, &quot;fouroldstyle&quot;, 0xf734, &quot;fourparen&quot;, 0x2477, &quot;fourperiod&quot;, 0x248b, &quot;fourpersian&quot;, 0x06f4, &quot;fourroman&quot;, 0x2173, &quot;foursuperior&quot;, 0x2074, &quot;fourteencircle&quot;, 0x246d, &quot;fourteenparen&quot;, 0x2481, &quot;fourteenperiod&quot;, 0x2495, &quot;fourthai&quot;, 0x0e54, &quot;fourthtonechinese&quot;, 0x02cb, &quot;fparen&quot;, 0x24a1, &quot;fraction&quot;, 0x2044, &quot;franc&quot;, 0x20a3, &quot;g&quot;, 0x0067, &quot;gabengali&quot;, 0x0997, &quot;gacute&quot;, 0x01f5, &quot;gadeva&quot;, 0x0917, &quot;gafarabic&quot;, 0x06af, &quot;gaffinalarabic&quot;, 0xfb93, &quot;gafinitialarabic&quot;, 0xfb94, &quot;gafmedialarabic&quot;, 0xfb95, &quot;gagujarati&quot;, 0x0a97, &quot;gagurmukhi&quot;, 0x0a17, &quot;gahiragana&quot;, 0x304c, &quot;gakatakana&quot;, 0x30ac, &quot;gamma&quot;, 0x03b3, &quot;gammalatinsmall&quot;, 0x0263, &quot;gammasuperior&quot;, 0x02e0, &quot;gangiacoptic&quot;, 0x03eb, &quot;gbopomofo&quot;, 0x310d, &quot;gbreve&quot;, 0x011f, &quot;gcaron&quot;, 0x01e7, &quot;gcedilla&quot;, 0x0123, &quot;gcircle&quot;, 0x24d6, &quot;gcircumflex&quot;, 0x011d, &quot;gcommaaccent&quot;, 0x0123, &quot;gdot&quot;, 0x0121, &quot;gdotaccent&quot;, 0x0121, &quot;gecyrillic&quot;, 0x0433, &quot;gehiragana&quot;, 0x3052, &quot;gekatakana&quot;, 0x30b2, &quot;geometricallyequal&quot;, 0x2251, &quot;gereshaccenthebrew&quot;, 0x059c, &quot;gereshhebrew&quot;, 0x05f3, &quot;gereshmuqdamhebrew&quot;, 0x059d, &quot;germandbls&quot;, 0x00df, &quot;gershayimaccenthebrew&quot;, 0x059e, &quot;gershayimhebrew&quot;, 0x05f4, &quot;getamark&quot;, 0x3013, &quot;ghabengali&quot;, 0x0998, &quot;ghadarmenian&quot;, 0x0572, &quot;ghadeva&quot;, 0x0918, &quot;ghagujarati&quot;, 0x0a98, &quot;ghagurmukhi&quot;, 0x0a18, &quot;ghainarabic&quot;, 0x063a, &quot;ghainfinalarabic&quot;, 0xfece, &quot;ghaininitialarabic&quot;, 0xfecf, &quot;ghainmedialarabic&quot;, 0xfed0, &quot;ghemiddlehookcyrillic&quot;, 0x0495, &quot;ghestrokecyrillic&quot;, 0x0493, &quot;gheupturncyrillic&quot;, 0x0491, &quot;ghhadeva&quot;, 0x095a, &quot;ghhagurmukhi&quot;, 0x0a5a, &quot;ghook&quot;, 0x0260, &quot;ghzsquare&quot;, 0x3393, &quot;gihiragana&quot;, 0x304e, &quot;gikatakana&quot;, 0x30ae, &quot;gimarmenian&quot;, 0x0563, &quot;gimel&quot;, 0x05d2, &quot;gimeldagesh&quot;, 0xfb32, &quot;gimeldageshhebrew&quot;, 0xfb32, &quot;gimelhebrew&quot;, 0x05d2, &quot;gjecyrillic&quot;, 0x0453, &quot;glottalinvertedstroke&quot;, 0x01be, &quot;glottalstop&quot;, 0x0294, &quot;glottalstopinverted&quot;, 0x0296, &quot;glottalstopmod&quot;, 0x02c0, &quot;glottalstopreversed&quot;, 0x0295, &quot;glottalstopreversedmod&quot;, 0x02c1, &quot;glottalstopreversedsuperior&quot;, 0x02e4, &quot;glottalstopstroke&quot;, 0x02a1, &quot;glottalstopstrokereversed&quot;, 0x02a2, &quot;gmacron&quot;, 0x1e21, &quot;gmonospace&quot;, 0xff47, &quot;gohiragana&quot;, 0x3054, &quot;gokatakana&quot;, 0x30b4, &quot;gparen&quot;, 0x24a2, &quot;gpasquare&quot;, 0x33ac, &quot;gradient&quot;, 0x2207, &quot;grave&quot;, 0x0060, &quot;gravebelowcmb&quot;, 0x0316, &quot;gravecmb&quot;, 0x0300, &quot;gravecomb&quot;, 0x0300, &quot;gravedeva&quot;, 0x0953, &quot;gravelowmod&quot;, 0x02ce, &quot;gravemonospace&quot;, 0xff40, &quot;gravetonecmb&quot;, 0x0340, &quot;greater&quot;, 0x003e, &quot;greaterequal&quot;, 0x2265, &quot;greaterequalorless&quot;, 0x22db, &quot;greatermonospace&quot;, 0xff1e, &quot;greaterorequivalent&quot;, 0x2273, &quot;greaterorless&quot;, 0x2277, &quot;greateroverequal&quot;, 0x2267, &quot;greatersmall&quot;, 0xfe65, &quot;gscript&quot;, 0x0261, &quot;gstroke&quot;, 0x01e5, &quot;guhiragana&quot;, 0x3050, &quot;guillemotleft&quot;, 0x00ab, &quot;guillemotright&quot;, 0x00bb, &quot;guilsinglleft&quot;, 0x2039, &quot;guilsinglright&quot;, 0x203a, &quot;gukatakana&quot;, 0x30b0, &quot;guramusquare&quot;, 0x3318, &quot;gysquare&quot;, 0x33c9, &quot;h&quot;, 0x0068, &quot;haabkhasiancyrillic&quot;, 0x04a9, &quot;haaltonearabic&quot;, 0x06c1, &quot;habengali&quot;, 0x09b9, &quot;hadescendercyrillic&quot;, 0x04b3, &quot;hadeva&quot;, 0x0939, &quot;hagujarati&quot;, 0x0ab9, &quot;hagurmukhi&quot;, 0x0a39, &quot;haharabic&quot;, 0x062d, &quot;hahfinalarabic&quot;, 0xfea2, &quot;hahinitialarabic&quot;, 0xfea3, &quot;hahiragana&quot;, 0x306f, &quot;hahmedialarabic&quot;, 0xfea4, &quot;haitusquare&quot;, 0x332a, &quot;hakatakana&quot;, 0x30cf, &quot;hakatakanahalfwidth&quot;, 0xff8a, &quot;halantgurmukhi&quot;, 0x0a4d, &quot;hamzaarabic&quot;, 0x0621, &quot;hamzalowarabic&quot;, 0x0621, &quot;hangulfiller&quot;, 0x3164, &quot;hardsigncyrillic&quot;, 0x044a, &quot;harpoonleftbarbup&quot;, 0x21bc, &quot;harpoonrightbarbup&quot;, 0x21c0, &quot;hasquare&quot;, 0x33ca, &quot;hatafpatah&quot;, 0x05b2, &quot;hatafpatah16&quot;, 0x05b2, &quot;hatafpatah23&quot;, 0x05b2, &quot;hatafpatah2f&quot;, 0x05b2, &quot;hatafpatahhebrew&quot;, 0x05b2, &quot;hatafpatahnarrowhebrew&quot;, 0x05b2, &quot;hatafpatahquarterhebrew&quot;, 0x05b2, &quot;hatafpatahwidehebrew&quot;, 0x05b2, &quot;hatafqamats&quot;, 0x05b3, &quot;hatafqamats1b&quot;, 0x05b3, &quot;hatafqamats28&quot;, 0x05b3, &quot;hatafqamats34&quot;, 0x05b3, &quot;hatafqamatshebrew&quot;, 0x05b3, &quot;hatafqamatsnarrowhebrew&quot;, 0x05b3, &quot;hatafqamatsquarterhebrew&quot;, 0x05b3, &quot;hatafqamatswidehebrew&quot;, 0x05b3, &quot;hatafsegol&quot;, 0x05b1, &quot;hatafsegol17&quot;, 0x05b1, &quot;hatafsegol24&quot;, 0x05b1, &quot;hatafsegol30&quot;, 0x05b1, &quot;hatafsegolhebrew&quot;, 0x05b1, &quot;hatafsegolnarrowhebrew&quot;, 0x05b1, &quot;hatafsegolquarterhebrew&quot;, 0x05b1, &quot;hatafsegolwidehebrew&quot;, 0x05b1, &quot;hbar&quot;, 0x0127, &quot;hbopomofo&quot;, 0x310f, &quot;hbrevebelow&quot;, 0x1e2b, &quot;hcedilla&quot;, 0x1e29, &quot;hcircle&quot;, 0x24d7, &quot;hcircumflex&quot;, 0x0125, &quot;hdieresis&quot;, 0x1e27, &quot;hdotaccent&quot;, 0x1e23, &quot;hdotbelow&quot;, 0x1e25, &quot;he&quot;, 0x05d4, &quot;heart&quot;, 0x2665, &quot;heartsuitblack&quot;, 0x2665, &quot;heartsuitwhite&quot;, 0x2661, &quot;hedagesh&quot;, 0xfb34, &quot;hedageshhebrew&quot;, 0xfb34, &quot;hehaltonearabic&quot;, 0x06c1, &quot;heharabic&quot;, 0x0647, &quot;hehebrew&quot;, 0x05d4, &quot;hehfinalaltonearabic&quot;, 0xfba7, &quot;hehfinalalttwoarabic&quot;, 0xfeea, &quot;hehfinalarabic&quot;, 0xfeea, &quot;hehhamzaabovefinalarabic&quot;, 0xfba5, &quot;hehhamzaaboveisolatedarabic&quot;, 0xfba4, &quot;hehinitialaltonearabic&quot;, 0xfba8, &quot;hehinitialarabic&quot;, 0xfeeb, &quot;hehiragana&quot;, 0x3078, &quot;hehmedialaltonearabic&quot;, 0xfba9, &quot;hehmedialarabic&quot;, 0xfeec, &quot;heiseierasquare&quot;, 0x337b, &quot;hekatakana&quot;, 0x30d8, &quot;hekatakanahalfwidth&quot;, 0xff8d, &quot;hekutaarusquare&quot;, 0x3336, &quot;henghook&quot;, 0x0267, &quot;herutusquare&quot;, 0x3339, &quot;het&quot;, 0x05d7, &quot;hethebrew&quot;, 0x05d7, &quot;hhook&quot;, 0x0266, &quot;hhooksuperior&quot;, 0x02b1, &quot;hieuhacirclekorean&quot;, 0x327b, &quot;hieuhaparenkorean&quot;, 0x321b, &quot;hieuhcirclekorean&quot;, 0x326d, &quot;hieuhkorean&quot;, 0x314e, &quot;hieuhparenkorean&quot;, 0x320d, &quot;hihiragana&quot;, 0x3072, &quot;hikatakana&quot;, 0x30d2, &quot;hikatakanahalfwidth&quot;, 0xff8b, &quot;hiriq&quot;, 0x05b4, &quot;hiriq14&quot;, 0x05b4, &quot;hiriq21&quot;, 0x05b4, &quot;hiriq2d&quot;, 0x05b4, &quot;hiriqhebrew&quot;, 0x05b4, &quot;hiriqnarrowhebrew&quot;, 0x05b4, &quot;hiriqquarterhebrew&quot;, 0x05b4, &quot;hiriqwidehebrew&quot;, 0x05b4, &quot;hlinebelow&quot;, 0x1e96, &quot;hmonospace&quot;, 0xff48, &quot;hoarmenian&quot;, 0x0570, &quot;hohipthai&quot;, 0x0e2b, &quot;hohiragana&quot;, 0x307b, &quot;hokatakana&quot;, 0x30db, &quot;hokatakanahalfwidth&quot;, 0xff8e, &quot;holam&quot;, 0x05b9, &quot;holam19&quot;, 0x05b9, &quot;holam26&quot;, 0x05b9, &quot;holam32&quot;, 0x05b9, &quot;holamhebrew&quot;, 0x05b9, &quot;holamnarrowhebrew&quot;, 0x05b9, &quot;holamquarterhebrew&quot;, 0x05b9, &quot;holamwidehebrew&quot;, 0x05b9, &quot;honokhukthai&quot;, 0x0e2e, &quot;hookabovecomb&quot;, 0x0309, &quot;hookcmb&quot;, 0x0309, &quot;hookpalatalizedbelowcmb&quot;, 0x0321, &quot;hookretroflexbelowcmb&quot;, 0x0322, &quot;hoonsquare&quot;, 0x3342, &quot;horicoptic&quot;, 0x03e9, &quot;horizontalbar&quot;, 0x2015, &quot;horncmb&quot;, 0x031b, &quot;hotsprings&quot;, 0x2668, &quot;house&quot;, 0x2302, &quot;hparen&quot;, 0x24a3, &quot;hsuperior&quot;, 0x02b0, &quot;hturned&quot;, 0x0265, &quot;huhiragana&quot;, 0x3075, &quot;huiitosquare&quot;, 0x3333, &quot;hukatakana&quot;, 0x30d5, &quot;hukatakanahalfwidth&quot;, 0xff8c, &quot;hungarumlaut&quot;, 0x02dd, &quot;hungarumlautcmb&quot;, 0x030b, &quot;hv&quot;, 0x0195, &quot;hyphen&quot;, 0x002d, &quot;hypheninferior&quot;, 0xf6e5, &quot;hyphenmonospace&quot;, 0xff0d, &quot;hyphensmall&quot;, 0xfe63, &quot;hyphensuperior&quot;, 0xf6e6, &quot;hyphentwo&quot;, 0x2010, &quot;i&quot;, 0x0069, &quot;iacute&quot;, 0x00ed, &quot;iacyrillic&quot;, 0x044f, &quot;ibengali&quot;, 0x0987, &quot;ibopomofo&quot;, 0x3127, &quot;ibreve&quot;, 0x012d, &quot;icaron&quot;, 0x01d0, &quot;icircle&quot;, 0x24d8, &quot;icircumflex&quot;, 0x00ee, &quot;icyrillic&quot;, 0x0456, &quot;idblgrave&quot;, 0x0209, &quot;ideographearthcircle&quot;, 0x328f, &quot;ideographfirecircle&quot;, 0x328b, &quot;ideographicallianceparen&quot;, 0x323f, &quot;ideographiccallparen&quot;, 0x323a, &quot;ideographiccentrecircle&quot;, 0x32a5, &quot;ideographicclose&quot;, 0x3006, &quot;ideographiccomma&quot;, 0x3001, &quot;ideographiccommaleft&quot;, 0xff64, &quot;ideographiccongratulationparen&quot;, 0x3237, &quot;ideographiccorrectcircle&quot;, 0x32a3, &quot;ideographicearthparen&quot;, 0x322f, &quot;ideographicenterpriseparen&quot;, 0x323d, &quot;ideographicexcellentcircle&quot;, 0x329d, &quot;ideographicfestivalparen&quot;, 0x3240, &quot;ideographicfinancialcircle&quot;, 0x3296, &quot;ideographicfinancialparen&quot;, 0x3236, &quot;ideographicfireparen&quot;, 0x322b, &quot;ideographichaveparen&quot;, 0x3232, &quot;ideographichighcircle&quot;, 0x32a4, &quot;ideographiciterationmark&quot;, 0x3005, &quot;ideographiclaborcircle&quot;, 0x3298, &quot;ideographiclaborparen&quot;, 0x3238, &quot;ideographicleftcircle&quot;, 0x32a7, &quot;ideographiclowcircle&quot;, 0x32a6, &quot;ideographicmedicinecircle&quot;, 0x32a9, &quot;ideographicmetalparen&quot;, 0x322e, &quot;ideographicmoonparen&quot;, 0x322a, &quot;ideographicnameparen&quot;, 0x3234, &quot;ideographicperiod&quot;, 0x3002, &quot;ideographicprintcircle&quot;, 0x329e, &quot;ideographicreachparen&quot;, 0x3243, &quot;ideographicrepresentparen&quot;, 0x3239, &quot;ideographicresourceparen&quot;, 0x323e, &quot;ideographicrightcircle&quot;, 0x32a8, &quot;ideographicsecretcircle&quot;, 0x3299, &quot;ideographicselfparen&quot;, 0x3242, &quot;ideographicsocietyparen&quot;, 0x3233, &quot;ideographicspace&quot;, 0x3000, &quot;ideographicspecialparen&quot;, 0x3235, &quot;ideographicstockparen&quot;, 0x3231, &quot;ideographicstudyparen&quot;, 0x323b, &quot;ideographicsunparen&quot;, 0x3230, &quot;ideographicsuperviseparen&quot;, 0x323c, &quot;ideographicwaterparen&quot;, 0x322c, &quot;ideographicwoodparen&quot;, 0x322d, &quot;ideographiczero&quot;, 0x3007, &quot;ideographmetalcircle&quot;, 0x328e, &quot;ideographmooncircle&quot;, 0x328a, &quot;ideographnamecircle&quot;, 0x3294, &quot;ideographsuncircle&quot;, 0x3290, &quot;ideographwatercircle&quot;, 0x328c, &quot;ideographwoodcircle&quot;, 0x328d, &quot;ideva&quot;, 0x0907, &quot;idieresis&quot;, 0x00ef, &quot;idieresisacute&quot;, 0x1e2f, &quot;idieresiscyrillic&quot;, 0x04e5, &quot;idotbelow&quot;, 0x1ecb, &quot;iebrevecyrillic&quot;, 0x04d7, &quot;iecyrillic&quot;, 0x0435, &quot;ieungacirclekorean&quot;, 0x3275, &quot;ieungaparenkorean&quot;, 0x3215, &quot;ieungcirclekorean&quot;, 0x3267, &quot;ieungkorean&quot;, 0x3147, &quot;ieungparenkorean&quot;, 0x3207, &quot;igrave&quot;, 0x00ec, &quot;igujarati&quot;, 0x0a87, &quot;igurmukhi&quot;, 0x0a07, &quot;ihiragana&quot;, 0x3044, &quot;ihookabove&quot;, 0x1ec9, &quot;iibengali&quot;, 0x0988, &quot;iicyrillic&quot;, 0x0438, &quot;iideva&quot;, 0x0908, &quot;iigujarati&quot;, 0x0a88, &quot;iigurmukhi&quot;, 0x0a08, &quot;iimatragurmukhi&quot;, 0x0a40, &quot;iinvertedbreve&quot;, 0x020b, &quot;iishortcyrillic&quot;, 0x0439, &quot;iivowelsignbengali&quot;, 0x09c0, &quot;iivowelsigndeva&quot;, 0x0940, &quot;iivowelsigngujarati&quot;, 0x0ac0, &quot;ij&quot;, 0x0133, &quot;ikatakana&quot;, 0x30a4, &quot;ikatakanahalfwidth&quot;, 0xff72, &quot;ikorean&quot;, 0x3163, &quot;ilde&quot;, 0x02dc, &quot;iluyhebrew&quot;, 0x05ac, &quot;imacron&quot;, 0x012b, &quot;imacroncyrillic&quot;, 0x04e3, &quot;imageorapproximatelyequal&quot;, 0x2253, &quot;imatragurmukhi&quot;, 0x0a3f, &quot;imonospace&quot;, 0xff49, &quot;increment&quot;, 0x2206, &quot;infinity&quot;, 0x221e, &quot;iniarmenian&quot;, 0x056b, &quot;integral&quot;, 0x222b, &quot;integralbottom&quot;, 0x2321, &quot;integralbt&quot;, 0x2321, &quot;integralex&quot;, 0xf8f5, &quot;integraltop&quot;, 0x2320, &quot;integraltp&quot;, 0x2320, &quot;intersection&quot;, 0x2229, &quot;intisquare&quot;, 0x3305, &quot;invbullet&quot;, 0x25d8, &quot;invcircle&quot;, 0x25d9, &quot;invsmileface&quot;, 0x263b, &quot;iocyrillic&quot;, 0x0451, &quot;iogonek&quot;, 0x012f, &quot;iota&quot;, 0x03b9, &quot;iotadieresis&quot;, 0x03ca, &quot;iotadieresistonos&quot;, 0x0390, &quot;iotalatin&quot;, 0x0269, &quot;iotatonos&quot;, 0x03af, &quot;iparen&quot;, 0x24a4, &quot;irigurmukhi&quot;, 0x0a72, &quot;ismallhiragana&quot;, 0x3043, &quot;ismallkatakana&quot;, 0x30a3, &quot;ismallkatakanahalfwidth&quot;, 0xff68, &quot;issharbengali&quot;, 0x09fa, &quot;istroke&quot;, 0x0268, &quot;isuperior&quot;, 0xf6ed, &quot;iterationhiragana&quot;, 0x309d, &quot;iterationkatakana&quot;, 0x30fd, &quot;itilde&quot;, 0x0129, &quot;itildebelow&quot;, 0x1e2d, &quot;iubopomofo&quot;, 0x3129, &quot;iucyrillic&quot;, 0x044e, &quot;ivowelsignbengali&quot;, 0x09bf, &quot;ivowelsigndeva&quot;, 0x093f, &quot;ivowelsigngujarati&quot;, 0x0abf, &quot;izhitsacyrillic&quot;, 0x0475, &quot;izhitsadblgravecyrillic&quot;, 0x0477, &quot;j&quot;, 0x006a, &quot;jaarmenian&quot;, 0x0571, &quot;jabengali&quot;, 0x099c, &quot;jadeva&quot;, 0x091c, &quot;jagujarati&quot;, 0x0a9c, &quot;jagurmukhi&quot;, 0x0a1c, &quot;jbopomofo&quot;, 0x3110, &quot;jcaron&quot;, 0x01f0, &quot;jcircle&quot;, 0x24d9, &quot;jcircumflex&quot;, 0x0135, &quot;jcrossedtail&quot;, 0x029d, &quot;jdotlessstroke&quot;, 0x025f, &quot;jecyrillic&quot;, 0x0458, &quot;jeemarabic&quot;, 0x062c, &quot;jeemfinalarabic&quot;, 0xfe9e, &quot;jeeminitialarabic&quot;, 0xfe9f, &quot;jeemmedialarabic&quot;, 0xfea0, &quot;jeharabic&quot;, 0x0698, &quot;jehfinalarabic&quot;, 0xfb8b, &quot;jhabengali&quot;, 0x099d, &quot;jhadeva&quot;, 0x091d, &quot;jhagujarati&quot;, 0x0a9d, &quot;jhagurmukhi&quot;, 0x0a1d, &quot;jheharmenian&quot;, 0x057b, &quot;jis&quot;, 0x3004, &quot;jmonospace&quot;, 0xff4a, &quot;jparen&quot;, 0x24a5, &quot;jsuperior&quot;, 0x02b2, &quot;k&quot;, 0x006b, &quot;kabashkircyrillic&quot;, 0x04a1, &quot;kabengali&quot;, 0x0995, &quot;kacute&quot;, 0x1e31, &quot;kacyrillic&quot;, 0x043a, &quot;kadescendercyrillic&quot;, 0x049b, &quot;kadeva&quot;, 0x0915, &quot;kaf&quot;, 0x05db, &quot;kafarabic&quot;, 0x0643, &quot;kafdagesh&quot;, 0xfb3b, &quot;kafdageshhebrew&quot;, 0xfb3b, &quot;kaffinalarabic&quot;, 0xfeda, &quot;kafhebrew&quot;, 0x05db, &quot;kafinitialarabic&quot;, 0xfedb, &quot;kafmedialarabic&quot;, 0xfedc, &quot;kafrafehebrew&quot;, 0xfb4d, &quot;kagujarati&quot;, 0x0a95, &quot;kagurmukhi&quot;, 0x0a15, &quot;kahiragana&quot;, 0x304b, &quot;kahookcyrillic&quot;, 0x04c4, &quot;kakatakana&quot;, 0x30ab, &quot;kakatakanahalfwidth&quot;, 0xff76, &quot;kappa&quot;, 0x03ba, &quot;kappasymbolgreek&quot;, 0x03f0, &quot;kapyeounmieumkorean&quot;, 0x3171, &quot;kapyeounphieuphkorean&quot;, 0x3184, &quot;kapyeounpieupkorean&quot;, 0x3178, &quot;kapyeounssangpieupkorean&quot;, 0x3179, &quot;karoriisquare&quot;, 0x330d, &quot;kashidaautoarabic&quot;, 0x0640, &quot;kashidaautonosidebearingarabic&quot;, 0x0640, &quot;kasmallkatakana&quot;, 0x30f5, &quot;kasquare&quot;, 0x3384, &quot;kasraarabic&quot;, 0x0650, &quot;kasratanarabic&quot;, 0x064d, &quot;kastrokecyrillic&quot;, 0x049f, &quot;katahiraprolongmarkhalfwidth&quot;, 0xff70, &quot;kaverticalstrokecyrillic&quot;, 0x049d, &quot;kbopomofo&quot;, 0x310e, &quot;kcalsquare&quot;, 0x3389, &quot;kcaron&quot;, 0x01e9, &quot;kcedilla&quot;, 0x0137, &quot;kcircle&quot;, 0x24da, &quot;kcommaaccent&quot;, 0x0137, &quot;kdotbelow&quot;, 0x1e33, &quot;keharmenian&quot;, 0x0584, &quot;kehiragana&quot;, 0x3051, &quot;kekatakana&quot;, 0x30b1, &quot;kekatakanahalfwidth&quot;, 0xff79, &quot;kenarmenian&quot;, 0x056f, &quot;kesmallkatakana&quot;, 0x30f6, &quot;kgreenlandic&quot;, 0x0138, &quot;khabengali&quot;, 0x0996, &quot;khacyrillic&quot;, 0x0445, &quot;khadeva&quot;, 0x0916, &quot;khagujarati&quot;, 0x0a96, &quot;khagurmukhi&quot;, 0x0a16, &quot;khaharabic&quot;, 0x062e, &quot;khahfinalarabic&quot;, 0xfea6, &quot;khahinitialarabic&quot;, 0xfea7, &quot;khahmedialarabic&quot;, 0xfea8, &quot;kheicoptic&quot;, 0x03e7, &quot;khhadeva&quot;, 0x0959, &quot;khhagurmukhi&quot;, 0x0a59, &quot;khieukhacirclekorean&quot;, 0x3278, &quot;khieukhaparenkorean&quot;, 0x3218, &quot;khieukhcirclekorean&quot;, 0x326a, &quot;khieukhkorean&quot;, 0x314b, &quot;khieukhparenkorean&quot;, 0x320a, &quot;khokhaithai&quot;, 0x0e02, &quot;khokhonthai&quot;, 0x0e05, &quot;khokhuatthai&quot;, 0x0e03, &quot;khokhwaithai&quot;, 0x0e04, &quot;khomutthai&quot;, 0x0e5b, &quot;khook&quot;, 0x0199, &quot;khorakhangthai&quot;, 0x0e06, &quot;khzsquare&quot;, 0x3391, &quot;kihiragana&quot;, 0x304d, &quot;kikatakana&quot;, 0x30ad, &quot;kikatakanahalfwidth&quot;, 0xff77, &quot;kiroguramusquare&quot;, 0x3315, &quot;kiromeetorusquare&quot;, 0x3316, &quot;kirosquare&quot;, 0x3314, &quot;kiyeokacirclekorean&quot;, 0x326e, &quot;kiyeokaparenkorean&quot;, 0x320e, &quot;kiyeokcirclekorean&quot;, 0x3260, &quot;kiyeokkorean&quot;, 0x3131, &quot;kiyeokparenkorean&quot;, 0x3200, &quot;kiyeoksioskorean&quot;, 0x3133, &quot;kjecyrillic&quot;, 0x045c, &quot;klinebelow&quot;, 0x1e35, &quot;klsquare&quot;, 0x3398, &quot;kmcubedsquare&quot;, 0x33a6, &quot;kmonospace&quot;, 0xff4b, &quot;kmsquaredsquare&quot;, 0x33a2, &quot;kohiragana&quot;, 0x3053, &quot;kohmsquare&quot;, 0x33c0, &quot;kokaithai&quot;, 0x0e01, &quot;kokatakana&quot;, 0x30b3, &quot;kokatakanahalfwidth&quot;, 0xff7a, &quot;kooposquare&quot;, 0x331e, &quot;koppacyrillic&quot;, 0x0481, &quot;koreanstandardsymbol&quot;, 0x327f, &quot;koroniscmb&quot;, 0x0343, &quot;kparen&quot;, 0x24a6, &quot;kpasquare&quot;, 0x33aa, &quot;ksicyrillic&quot;, 0x046f, &quot;ktsquare&quot;, 0x33cf, &quot;kturned&quot;, 0x029e, &quot;kuhiragana&quot;, 0x304f, &quot;kukatakana&quot;, 0x30af, &quot;kukatakanahalfwidth&quot;, 0xff78, &quot;kvsquare&quot;, 0x33b8, &quot;kwsquare&quot;, 0x33be, &quot;l&quot;, 0x006c, &quot;labengali&quot;, 0x09b2, &quot;lacute&quot;, 0x013a, &quot;ladeva&quot;, 0x0932, &quot;lagujarati&quot;, 0x0ab2, &quot;lagurmukhi&quot;, 0x0a32, &quot;lakkhangyaothai&quot;, 0x0e45, &quot;lamaleffinalarabic&quot;, 0xfefc, &quot;lamalefhamzaabovefinalarabic&quot;, 0xfef8, &quot;lamalefhamzaaboveisolatedarabic&quot;, 0xfef7, &quot;lamalefhamzabelowfinalarabic&quot;, 0xfefa, &quot;lamalefhamzabelowisolatedarabic&quot;, 0xfef9, &quot;lamalefisolatedarabic&quot;, 0xfefb, &quot;lamalefmaddaabovefinalarabic&quot;, 0xfef6, &quot;lamalefmaddaaboveisolatedarabic&quot;, 0xfef5, &quot;lamarabic&quot;, 0x0644, &quot;lambda&quot;, 0x03bb, &quot;lambdastroke&quot;, 0x019b, &quot;lamed&quot;, 0x05dc, &quot;lameddagesh&quot;, 0xfb3c, &quot;lameddageshhebrew&quot;, 0xfb3c, &quot;lamedhebrew&quot;, 0x05dc, &quot;lamfinalarabic&quot;, 0xfede, &quot;lamhahinitialarabic&quot;, 0xfcca, &quot;laminitialarabic&quot;, 0xfedf, &quot;lamjeeminitialarabic&quot;, 0xfcc9, &quot;lamkhahinitialarabic&quot;, 0xfccb, &quot;lamlamhehisolatedarabic&quot;, 0xfdf2, &quot;lammedialarabic&quot;, 0xfee0, &quot;lammeemhahinitialarabic&quot;, 0xfd88, &quot;lammeeminitialarabic&quot;, 0xfccc, &quot;largecircle&quot;, 0x25ef, &quot;lbar&quot;, 0x019a, &quot;lbelt&quot;, 0x026c, &quot;lbopomofo&quot;, 0x310c, &quot;lcaron&quot;, 0x013e, &quot;lcedilla&quot;, 0x013c, &quot;lcircle&quot;, 0x24db, &quot;lcircumflexbelow&quot;, 0x1e3d, &quot;lcommaaccent&quot;, 0x013c, &quot;ldot&quot;, 0x0140, &quot;ldotaccent&quot;, 0x0140, &quot;ldotbelow&quot;, 0x1e37, &quot;ldotbelowmacron&quot;, 0x1e39, &quot;leftangleabovecmb&quot;, 0x031a, &quot;lefttackbelowcmb&quot;, 0x0318, &quot;less&quot;, 0x003c, &quot;lessequal&quot;, 0x2264, &quot;lessequalorgreater&quot;, 0x22da, &quot;lessmonospace&quot;, 0xff1c, &quot;lessorequivalent&quot;, 0x2272, &quot;lessorgreater&quot;, 0x2276, &quot;lessoverequal&quot;, 0x2266, &quot;lesssmall&quot;, 0xfe64, &quot;lezh&quot;, 0x026e, &quot;lfblock&quot;, 0x258c, &quot;lhookretroflex&quot;, 0x026d, &quot;lira&quot;, 0x20a4, &quot;liwnarmenian&quot;, 0x056c, &quot;lj&quot;, 0x01c9, &quot;ljecyrillic&quot;, 0x0459, &quot;ll&quot;, 0xf6c0, &quot;lladeva&quot;, 0x0933, &quot;llagujarati&quot;, 0x0ab3, &quot;llinebelow&quot;, 0x1e3b, &quot;llladeva&quot;, 0x0934, &quot;llvocalicbengali&quot;, 0x09e1, &quot;llvocalicdeva&quot;, 0x0961, &quot;llvocalicvowelsignbengali&quot;, 0x09e3, &quot;llvocalicvowelsigndeva&quot;, 0x0963, &quot;lmiddletilde&quot;, 0x026b, &quot;lmonospace&quot;, 0xff4c, &quot;lmsquare&quot;, 0x33d0, &quot;lochulathai&quot;, 0x0e2c, &quot;logicaland&quot;, 0x2227, &quot;logicalnot&quot;, 0x00ac, &quot;logicalnotreversed&quot;, 0x2310, &quot;logicalor&quot;, 0x2228, &quot;lolingthai&quot;, 0x0e25, &quot;longs&quot;, 0x017f, &quot;lowlinecenterline&quot;, 0xfe4e, &quot;lowlinecmb&quot;, 0x0332, &quot;lowlinedashed&quot;, 0xfe4d, &quot;lozenge&quot;, 0x25ca, &quot;lparen&quot;, 0x24a7, &quot;lslash&quot;, 0x0142, &quot;lsquare&quot;, 0x2113, &quot;lsuperior&quot;, 0xf6ee, &quot;ltshade&quot;, 0x2591, &quot;luthai&quot;, 0x0e26, &quot;lvocalicbengali&quot;, 0x098c, &quot;lvocalicdeva&quot;, 0x090c, &quot;lvocalicvowelsignbengali&quot;, 0x09e2, &quot;lvocalicvowelsigndeva&quot;, 0x0962, &quot;lxsquare&quot;, 0x33d3, &quot;m&quot;, 0x006d, &quot;mabengali&quot;, 0x09ae, &quot;macron&quot;, 0x00af, &quot;macronbelowcmb&quot;, 0x0331, &quot;macroncmb&quot;, 0x0304, &quot;macronlowmod&quot;, 0x02cd, &quot;macronmonospace&quot;, 0xffe3, &quot;macute&quot;, 0x1e3f, &quot;madeva&quot;, 0x092e, &quot;magujarati&quot;, 0x0aae, &quot;magurmukhi&quot;, 0x0a2e, &quot;mahapakhhebrew&quot;, 0x05a4, &quot;mahapakhlefthebrew&quot;, 0x05a4, &quot;mahiragana&quot;, 0x307e, &quot;maichattawalowleftthai&quot;, 0xf895, &quot;maichattawalowrightthai&quot;, 0xf894, &quot;maichattawathai&quot;, 0x0e4b, &quot;maichattawaupperleftthai&quot;, 0xf893, &quot;maieklowleftthai&quot;, 0xf88c, &quot;maieklowrightthai&quot;, 0xf88b, &quot;maiekthai&quot;, 0x0e48, &quot;maiekupperleftthai&quot;, 0xf88a, &quot;maihanakatleftthai&quot;, 0xf884, &quot;maihanakatthai&quot;, 0x0e31, &quot;maitaikhuleftthai&quot;, 0xf889, &quot;maitaikhuthai&quot;, 0x0e47, &quot;maitholowleftthai&quot;, 0xf88f, &quot;maitholowrightthai&quot;, 0xf88e, &quot;maithothai&quot;, 0x0e49, &quot;maithoupperleftthai&quot;, 0xf88d, &quot;maitrilowleftthai&quot;, 0xf892, &quot;maitrilowrightthai&quot;, 0xf891, &quot;maitrithai&quot;, 0x0e4a, &quot;maitriupperleftthai&quot;, 0xf890, &quot;maiyamokthai&quot;, 0x0e46, &quot;makatakana&quot;, 0x30de, &quot;makatakanahalfwidth&quot;, 0xff8f, &quot;male&quot;, 0x2642, &quot;mansyonsquare&quot;, 0x3347, &quot;maqafhebrew&quot;, 0x05be, &quot;mars&quot;, 0x2642, &quot;masoracirclehebrew&quot;, 0x05af, &quot;masquare&quot;, 0x3383, &quot;mbopomofo&quot;, 0x3107, &quot;mbsquare&quot;, 0x33d4, &quot;mcircle&quot;, 0x24dc, &quot;mcubedsquare&quot;, 0x33a5, &quot;mdotaccent&quot;, 0x1e41, &quot;mdotbelow&quot;, 0x1e43, &quot;meemarabic&quot;, 0x0645, &quot;meemfinalarabic&quot;, 0xfee2, &quot;meeminitialarabic&quot;, 0xfee3, &quot;meemmedialarabic&quot;, 0xfee4, &quot;meemmeeminitialarabic&quot;, 0xfcd1, &quot;meemmeemisolatedarabic&quot;, 0xfc48, &quot;meetorusquare&quot;, 0x334d, &quot;mehiragana&quot;, 0x3081, &quot;meizierasquare&quot;, 0x337e, &quot;mekatakana&quot;, 0x30e1, &quot;mekatakanahalfwidth&quot;, 0xff92, &quot;mem&quot;, 0x05de, &quot;memdagesh&quot;, 0xfb3e, &quot;memdageshhebrew&quot;, 0xfb3e, &quot;memhebrew&quot;, 0x05de, &quot;menarmenian&quot;, 0x0574, &quot;merkhahebrew&quot;, 0x05a5, &quot;merkhakefulahebrew&quot;, 0x05a6, &quot;merkhakefulalefthebrew&quot;, 0x05a6, &quot;merkhalefthebrew&quot;, 0x05a5, &quot;mhook&quot;, 0x0271, &quot;mhzsquare&quot;, 0x3392, &quot;middledotkatakanahalfwidth&quot;, 0xff65, &quot;middot&quot;, 0x00b7, &quot;mieumacirclekorean&quot;, 0x3272, &quot;mieumaparenkorean&quot;, 0x3212, &quot;mieumcirclekorean&quot;, 0x3264, &quot;mieumkorean&quot;, 0x3141, &quot;mieumpansioskorean&quot;, 0x3170, &quot;mieumparenkorean&quot;, 0x3204, &quot;mieumpieupkorean&quot;, 0x316e, &quot;mieumsioskorean&quot;, 0x316f, &quot;mihiragana&quot;, 0x307f, &quot;mikatakana&quot;, 0x30df, &quot;mikatakanahalfwidth&quot;, 0xff90, &quot;minus&quot;, 0x2212, &quot;minusbelowcmb&quot;, 0x0320, &quot;minuscircle&quot;, 0x2296, &quot;minusmod&quot;, 0x02d7, &quot;minusplus&quot;, 0x2213, &quot;minute&quot;, 0x2032, &quot;miribaarusquare&quot;, 0x334a, &quot;mirisquare&quot;, 0x3349, &quot;mlonglegturned&quot;, 0x0270, &quot;mlsquare&quot;, 0x3396, &quot;mmcubedsquare&quot;, 0x33a3, &quot;mmonospace&quot;, 0xff4d, &quot;mmsquaredsquare&quot;, 0x339f, &quot;mohiragana&quot;, 0x3082, &quot;mohmsquare&quot;, 0x33c1, &quot;mokatakana&quot;, 0x30e2, &quot;mokatakanahalfwidth&quot;, 0xff93, &quot;molsquare&quot;, 0x33d6, &quot;momathai&quot;, 0x0e21, &quot;moverssquare&quot;, 0x33a7, &quot;moverssquaredsquare&quot;, 0x33a8, &quot;mparen&quot;, 0x24a8, &quot;mpasquare&quot;, 0x33ab, &quot;mssquare&quot;, 0x33b3, &quot;msuperior&quot;, 0xf6ef, &quot;mturned&quot;, 0x026f, &quot;mu&quot;, 0x00b5, &quot;mu1&quot;, 0x00b5, &quot;muasquare&quot;, 0x3382, &quot;muchgreater&quot;, 0x226b, &quot;muchless&quot;, 0x226a, &quot;mufsquare&quot;, 0x338c, &quot;mugreek&quot;, 0x03bc, &quot;mugsquare&quot;, 0x338d, &quot;muhiragana&quot;, 0x3080, &quot;mukatakana&quot;, 0x30e0, &quot;mukatakanahalfwidth&quot;, 0xff91, &quot;mulsquare&quot;, 0x3395, &quot;multiply&quot;, 0x00d7, &quot;mumsquare&quot;, 0x339b, &quot;munahhebrew&quot;, 0x05a3, &quot;munahlefthebrew&quot;, 0x05a3, &quot;musicalnote&quot;, 0x266a, &quot;musicalnotedbl&quot;, 0x266b, &quot;musicflatsign&quot;, 0x266d, &quot;musicsharpsign&quot;, 0x266f, &quot;mussquare&quot;, 0x33b2, &quot;muvsquare&quot;, 0x33b6, &quot;muwsquare&quot;, 0x33bc, &quot;mvmegasquare&quot;, 0x33b9, &quot;mvsquare&quot;, 0x33b7, &quot;mwmegasquare&quot;, 0x33bf, &quot;mwsquare&quot;, 0x33bd, &quot;n&quot;, 0x006e, &quot;nabengali&quot;, 0x09a8, &quot;nabla&quot;, 0x2207, &quot;nacute&quot;, 0x0144, &quot;nadeva&quot;, 0x0928, &quot;nagujarati&quot;, 0x0aa8, &quot;nagurmukhi&quot;, 0x0a28, &quot;nahiragana&quot;, 0x306a, &quot;nakatakana&quot;, 0x30ca, &quot;nakatakanahalfwidth&quot;, 0xff85, &quot;napostrophe&quot;, 0x0149, &quot;nasquare&quot;, 0x3381, &quot;nbopomofo&quot;, 0x310b, &quot;nbspace&quot;, 0x00a0, &quot;ncaron&quot;, 0x0148, &quot;ncedilla&quot;, 0x0146, &quot;ncircle&quot;, 0x24dd, &quot;ncircumflexbelow&quot;, 0x1e4b, &quot;ncommaaccent&quot;, 0x0146, &quot;ndotaccent&quot;, 0x1e45, &quot;ndotbelow&quot;, 0x1e47, &quot;nehiragana&quot;, 0x306d, &quot;nekatakana&quot;, 0x30cd, &quot;nekatakanahalfwidth&quot;, 0xff88, &quot;newsheqelsign&quot;, 0x20aa, &quot;nfsquare&quot;, 0x338b, &quot;ngabengali&quot;, 0x0999, &quot;ngadeva&quot;, 0x0919, &quot;ngagujarati&quot;, 0x0a99, &quot;ngagurmukhi&quot;, 0x0a19, &quot;ngonguthai&quot;, 0x0e07, &quot;nhiragana&quot;, 0x3093, &quot;nhookleft&quot;, 0x0272, &quot;nhookretroflex&quot;, 0x0273, &quot;nieunacirclekorean&quot;, 0x326f, &quot;nieunaparenkorean&quot;, 0x320f, &quot;nieuncieuckorean&quot;, 0x3135, &quot;nieuncirclekorean&quot;, 0x3261, &quot;nieunhieuhkorean&quot;, 0x3136, &quot;nieunkorean&quot;, 0x3134, &quot;nieunpansioskorean&quot;, 0x3168, &quot;nieunparenkorean&quot;, 0x3201, &quot;nieunsioskorean&quot;, 0x3167, &quot;nieuntikeutkorean&quot;, 0x3166, &quot;nihiragana&quot;, 0x306b, &quot;nikatakana&quot;, 0x30cb, &quot;nikatakanahalfwidth&quot;, 0xff86, &quot;nikhahitleftthai&quot;, 0xf899, &quot;nikhahitthai&quot;, 0x0e4d, &quot;nine&quot;, 0x0039, &quot;ninearabic&quot;, 0x0669, &quot;ninebengali&quot;, 0x09ef, &quot;ninecircle&quot;, 0x2468, &quot;ninecircleinversesansserif&quot;, 0x2792, &quot;ninedeva&quot;, 0x096f, &quot;ninegujarati&quot;, 0x0aef, &quot;ninegurmukhi&quot;, 0x0a6f, &quot;ninehackarabic&quot;, 0x0669, &quot;ninehangzhou&quot;, 0x3029, &quot;nineideographicparen&quot;, 0x3228, &quot;nineinferior&quot;, 0x2089, &quot;ninemonospace&quot;, 0xff19, &quot;nineoldstyle&quot;, 0xf739, &quot;nineparen&quot;, 0x247c, &quot;nineperiod&quot;, 0x2490, &quot;ninepersian&quot;, 0x06f9, &quot;nineroman&quot;, 0x2178, &quot;ninesuperior&quot;, 0x2079, &quot;nineteencircle&quot;, 0x2472, &quot;nineteenparen&quot;, 0x2486, &quot;nineteenperiod&quot;, 0x249a, &quot;ninethai&quot;, 0x0e59, &quot;nj&quot;, 0x01cc, &quot;njecyrillic&quot;, 0x045a, &quot;nkatakana&quot;, 0x30f3, &quot;nkatakanahalfwidth&quot;, 0xff9d, &quot;nlegrightlong&quot;, 0x019e, &quot;nlinebelow&quot;, 0x1e49, &quot;nmonospace&quot;, 0xff4e, &quot;nmsquare&quot;, 0x339a, &quot;nnabengali&quot;, 0x09a3, &quot;nnadeva&quot;, 0x0923, &quot;nnagujarati&quot;, 0x0aa3, &quot;nnagurmukhi&quot;, 0x0a23, &quot;nnnadeva&quot;, 0x0929, &quot;nohiragana&quot;, 0x306e, &quot;nokatakana&quot;, 0x30ce, &quot;nokatakanahalfwidth&quot;, 0xff89, &quot;nonbreakingspace&quot;, 0x00a0, &quot;nonenthai&quot;, 0x0e13, &quot;nonuthai&quot;, 0x0e19, &quot;noonarabic&quot;, 0x0646, &quot;noonfinalarabic&quot;, 0xfee6, &quot;noonghunnaarabic&quot;, 0x06ba, &quot;noonghunnafinalarabic&quot;, 0xfb9f, &quot;nooninitialarabic&quot;, 0xfee7, &quot;noonjeeminitialarabic&quot;, 0xfcd2, &quot;noonjeemisolatedarabic&quot;, 0xfc4b, &quot;noonmedialarabic&quot;, 0xfee8, &quot;noonmeeminitialarabic&quot;, 0xfcd5, &quot;noonmeemisolatedarabic&quot;, 0xfc4e, &quot;noonnoonfinalarabic&quot;, 0xfc8d, &quot;notcontains&quot;, 0x220c, &quot;notelement&quot;, 0x2209, &quot;notelementof&quot;, 0x2209, &quot;notequal&quot;, 0x2260, &quot;notgreater&quot;, 0x226f, &quot;notgreaternorequal&quot;, 0x2271, &quot;notgreaternorless&quot;, 0x2279, &quot;notidentical&quot;, 0x2262, &quot;notless&quot;, 0x226e, &quot;notlessnorequal&quot;, 0x2270, &quot;notparallel&quot;, 0x2226, &quot;notprecedes&quot;, 0x2280, &quot;notsubset&quot;, 0x2284, &quot;notsucceeds&quot;, 0x2281, &quot;notsuperset&quot;, 0x2285, &quot;nowarmenian&quot;, 0x0576, &quot;nparen&quot;, 0x24a9, &quot;nssquare&quot;, 0x33b1, &quot;nsuperior&quot;, 0x207f, &quot;ntilde&quot;, 0x00f1, &quot;nu&quot;, 0x03bd, &quot;nuhiragana&quot;, 0x306c, &quot;nukatakana&quot;, 0x30cc, &quot;nukatakanahalfwidth&quot;, 0xff87, &quot;nuktabengali&quot;, 0x09bc, &quot;nuktadeva&quot;, 0x093c, &quot;nuktagujarati&quot;, 0x0abc, &quot;nuktagurmukhi&quot;, 0x0a3c, &quot;numbersign&quot;, 0x0023, &quot;numbersignmonospace&quot;, 0xff03, &quot;numbersignsmall&quot;, 0xfe5f, &quot;numeralsigngreek&quot;, 0x0374, &quot;numeralsignlowergreek&quot;, 0x0375, &quot;numero&quot;, 0x2116, &quot;nun&quot;, 0x05e0, &quot;nundagesh&quot;, 0xfb40, &quot;nundageshhebrew&quot;, 0xfb40, &quot;nunhebrew&quot;, 0x05e0, &quot;nvsquare&quot;, 0x33b5, &quot;nwsquare&quot;, 0x33bb, &quot;nyabengali&quot;, 0x099e, &quot;nyadeva&quot;, 0x091e, &quot;nyagujarati&quot;, 0x0a9e, &quot;nyagurmukhi&quot;, 0x0a1e, &quot;o&quot;, 0x006f, &quot;oacute&quot;, 0x00f3, &quot;oangthai&quot;, 0x0e2d, &quot;obarred&quot;, 0x0275, &quot;obarredcyrillic&quot;, 0x04e9, &quot;obarreddieresiscyrillic&quot;, 0x04eb, &quot;obengali&quot;, 0x0993, &quot;obopomofo&quot;, 0x311b, &quot;obreve&quot;, 0x014f, &quot;ocandradeva&quot;, 0x0911, &quot;ocandragujarati&quot;, 0x0a91, &quot;ocandravowelsigndeva&quot;, 0x0949, &quot;ocandravowelsigngujarati&quot;, 0x0ac9, &quot;ocaron&quot;, 0x01d2, &quot;ocircle&quot;, 0x24de, &quot;ocircumflex&quot;, 0x00f4, &quot;ocircumflexacute&quot;, 0x1ed1, &quot;ocircumflexdotbelow&quot;, 0x1ed9, &quot;ocircumflexgrave&quot;, 0x1ed3, &quot;ocircumflexhookabove&quot;, 0x1ed5, &quot;ocircumflextilde&quot;, 0x1ed7, &quot;ocyrillic&quot;, 0x043e, &quot;odblacute&quot;, 0x0151, &quot;odblgrave&quot;, 0x020d, &quot;odeva&quot;, 0x0913, &quot;odieresis&quot;, 0x00f6, &quot;odieresiscyrillic&quot;, 0x04e7, &quot;odotbelow&quot;, 0x1ecd, &quot;oe&quot;, 0x0153, &quot;oekorean&quot;, 0x315a, &quot;ogonek&quot;, 0x02db, &quot;ogonekcmb&quot;, 0x0328, &quot;ograve&quot;, 0x00f2, &quot;ogujarati&quot;, 0x0a93, &quot;oharmenian&quot;, 0x0585, &quot;ohiragana&quot;, 0x304a, &quot;ohookabove&quot;, 0x1ecf, &quot;ohorn&quot;, 0x01a1, &quot;ohornacute&quot;, 0x1edb, &quot;ohorndotbelow&quot;, 0x1ee3, &quot;ohorngrave&quot;, 0x1edd, &quot;ohornhookabove&quot;, 0x1edf, &quot;ohorntilde&quot;, 0x1ee1, &quot;ohungarumlaut&quot;, 0x0151, &quot;oi&quot;, 0x01a3, &quot;oinvertedbreve&quot;, 0x020f, &quot;okatakana&quot;, 0x30aa, &quot;okatakanahalfwidth&quot;, 0xff75, &quot;okorean&quot;, 0x3157, &quot;olehebrew&quot;, 0x05ab, &quot;omacron&quot;, 0x014d, &quot;omacronacute&quot;, 0x1e53, &quot;omacrongrave&quot;, 0x1e51, &quot;omdeva&quot;, 0x0950, &quot;omega&quot;, 0x03c9, &quot;omega1&quot;, 0x03d6, &quot;omegacyrillic&quot;, 0x0461, &quot;omegalatinclosed&quot;, 0x0277, &quot;omegaroundcyrillic&quot;, 0x047b, &quot;omegatitlocyrillic&quot;, 0x047d, &quot;omegatonos&quot;, 0x03ce, &quot;omgujarati&quot;, 0x0ad0, &quot;omicron&quot;, 0x03bf, &quot;omicrontonos&quot;, 0x03cc, &quot;omonospace&quot;, 0xff4f, &quot;one&quot;, 0x0031, &quot;onearabic&quot;, 0x0661, &quot;onebengali&quot;, 0x09e7, &quot;onecircle&quot;, 0x2460, &quot;onecircleinversesansserif&quot;, 0x278a, &quot;onedeva&quot;, 0x0967, &quot;onedotenleader&quot;, 0x2024, &quot;oneeighth&quot;, 0x215b, &quot;onefitted&quot;, 0xf6dc, &quot;onegujarati&quot;, 0x0ae7, &quot;onegurmukhi&quot;, 0x0a67, &quot;onehackarabic&quot;, 0x0661, &quot;onehalf&quot;, 0x00bd, &quot;onehangzhou&quot;, 0x3021, &quot;oneideographicparen&quot;, 0x3220, &quot;oneinferior&quot;, 0x2081, &quot;onemonospace&quot;, 0xff11, &quot;onenumeratorbengali&quot;, 0x09f4, &quot;oneoldstyle&quot;, 0xf731, &quot;oneparen&quot;, 0x2474, &quot;oneperiod&quot;, 0x2488, &quot;onepersian&quot;, 0x06f1, &quot;onequarter&quot;, 0x00bc, &quot;oneroman&quot;, 0x2170, &quot;onesuperior&quot;, 0x00b9, &quot;onethai&quot;, 0x0e51, &quot;onethird&quot;, 0x2153, &quot;oogonek&quot;, 0x01eb, &quot;oogonekmacron&quot;, 0x01ed, &quot;oogurmukhi&quot;, 0x0a13, &quot;oomatragurmukhi&quot;, 0x0a4b, &quot;oopen&quot;, 0x0254, &quot;oparen&quot;, 0x24aa, &quot;openbullet&quot;, 0x25e6, &quot;option&quot;, 0x2325, &quot;ordfeminine&quot;, 0x00aa, &quot;ordmasculine&quot;, 0x00ba, &quot;orthogonal&quot;, 0x221f, &quot;oshortdeva&quot;, 0x0912, &quot;oshortvowelsigndeva&quot;, 0x094a, &quot;oslash&quot;, 0x00f8, &quot;oslashacute&quot;, 0x01ff, &quot;osmallhiragana&quot;, 0x3049, &quot;osmallkatakana&quot;, 0x30a9, &quot;osmallkatakanahalfwidth&quot;, 0xff6b, &quot;ostrokeacute&quot;, 0x01ff, &quot;osuperior&quot;, 0xf6f0, &quot;otcyrillic&quot;, 0x047f, &quot;otilde&quot;, 0x00f5, &quot;otildeacute&quot;, 0x1e4d, &quot;otildedieresis&quot;, 0x1e4f, &quot;oubopomofo&quot;, 0x3121, &quot;overline&quot;, 0x203e, &quot;overlinecenterline&quot;, 0xfe4a, &quot;overlinecmb&quot;, 0x0305, &quot;overlinedashed&quot;, 0xfe49, &quot;overlinedblwavy&quot;, 0xfe4c, &quot;overlinewavy&quot;, 0xfe4b, &quot;overscore&quot;, 0x00af, &quot;ovowelsignbengali&quot;, 0x09cb, &quot;ovowelsigndeva&quot;, 0x094b, &quot;ovowelsigngujarati&quot;, 0x0acb, &quot;p&quot;, 0x0070, &quot;paampssquare&quot;, 0x3380, &quot;paasentosquare&quot;, 0x332b, &quot;pabengali&quot;, 0x09aa, &quot;pacute&quot;, 0x1e55, &quot;padeva&quot;, 0x092a, &quot;pagedown&quot;, 0x21df, &quot;pageup&quot;, 0x21de, &quot;pagujarati&quot;, 0x0aaa, &quot;pagurmukhi&quot;, 0x0a2a, &quot;pahiragana&quot;, 0x3071, &quot;paiyannoithai&quot;, 0x0e2f, &quot;pakatakana&quot;, 0x30d1, &quot;palatalizationcyrilliccmb&quot;, 0x0484, &quot;palochkacyrillic&quot;, 0x04c0, &quot;pansioskorean&quot;, 0x317f, &quot;paragraph&quot;, 0x00b6, &quot;parallel&quot;, 0x2225, &quot;parenleft&quot;, 0x0028, &quot;parenleftaltonearabic&quot;, 0xfd3e, &quot;parenleftbt&quot;, 0xf8ed, &quot;parenleftex&quot;, 0xf8ec, &quot;parenleftinferior&quot;, 0x208d, &quot;parenleftmonospace&quot;, 0xff08, &quot;parenleftsmall&quot;, 0xfe59, &quot;parenleftsuperior&quot;, 0x207d, &quot;parenlefttp&quot;, 0xf8eb, &quot;parenleftvertical&quot;, 0xfe35, &quot;parenright&quot;, 0x0029, &quot;parenrightaltonearabic&quot;, 0xfd3f, &quot;parenrightbt&quot;, 0xf8f8, &quot;parenrightex&quot;, 0xf8f7, &quot;parenrightinferior&quot;, 0x208e, &quot;parenrightmonospace&quot;, 0xff09, &quot;parenrightsmall&quot;, 0xfe5a, &quot;parenrightsuperior&quot;, 0x207e, &quot;parenrighttp&quot;, 0xf8f6, &quot;parenrightvertical&quot;, 0xfe36, &quot;partialdiff&quot;, 0x2202, &quot;paseqhebrew&quot;, 0x05c0, &quot;pashtahebrew&quot;, 0x0599, &quot;pasquare&quot;, 0x33a9, &quot;patah&quot;, 0x05b7, &quot;patah11&quot;, 0x05b7, &quot;patah1d&quot;, 0x05b7, &quot;patah2a&quot;, 0x05b7, &quot;patahhebrew&quot;, 0x05b7, &quot;patahnarrowhebrew&quot;, 0x05b7, &quot;patahquarterhebrew&quot;, 0x05b7, &quot;patahwidehebrew&quot;, 0x05b7, &quot;pazerhebrew&quot;, 0x05a1, &quot;pbopomofo&quot;, 0x3106, &quot;pcircle&quot;, 0x24df, &quot;pdotaccent&quot;, 0x1e57, &quot;pe&quot;, 0x05e4, &quot;pecyrillic&quot;, 0x043f, &quot;pedagesh&quot;, 0xfb44, &quot;pedageshhebrew&quot;, 0xfb44, &quot;peezisquare&quot;, 0x333b, &quot;pefinaldageshhebrew&quot;, 0xfb43, &quot;peharabic&quot;, 0x067e, &quot;peharmenian&quot;, 0x057a, &quot;pehebrew&quot;, 0x05e4, &quot;pehfinalarabic&quot;, 0xfb57, &quot;pehinitialarabic&quot;, 0xfb58, &quot;pehiragana&quot;, 0x307a, &quot;pehmedialarabic&quot;, 0xfb59, &quot;pekatakana&quot;, 0x30da, &quot;pemiddlehookcyrillic&quot;, 0x04a7, &quot;perafehebrew&quot;, 0xfb4e, &quot;percent&quot;, 0x0025, &quot;percentarabic&quot;, 0x066a, &quot;percentmonospace&quot;, 0xff05, &quot;percentsmall&quot;, 0xfe6a, &quot;period&quot;, 0x002e, &quot;periodarmenian&quot;, 0x0589, &quot;periodcentered&quot;, 0x00b7, &quot;periodhalfwidth&quot;, 0xff61, &quot;periodinferior&quot;, 0xf6e7, &quot;periodmonospace&quot;, 0xff0e, &quot;periodsmall&quot;, 0xfe52, &quot;periodsuperior&quot;, 0xf6e8, &quot;perispomenigreekcmb&quot;, 0x0342, &quot;perpendicular&quot;, 0x22a5, &quot;perthousand&quot;, 0x2030, &quot;peseta&quot;, 0x20a7, &quot;pfsquare&quot;, 0x338a, &quot;phabengali&quot;, 0x09ab, &quot;phadeva&quot;, 0x092b, &quot;phagujarati&quot;, 0x0aab, &quot;phagurmukhi&quot;, 0x0a2b, &quot;phi&quot;, 0x03c6, &quot;phi1&quot;, 0x03d5, &quot;phieuphacirclekorean&quot;, 0x327a, &quot;phieuphaparenkorean&quot;, 0x321a, &quot;phieuphcirclekorean&quot;, 0x326c, &quot;phieuphkorean&quot;, 0x314d, &quot;phieuphparenkorean&quot;, 0x320c, &quot;philatin&quot;, 0x0278, &quot;phinthuthai&quot;, 0x0e3a, &quot;phisymbolgreek&quot;, 0x03d5, &quot;phook&quot;, 0x01a5, &quot;phophanthai&quot;, 0x0e1e, &quot;phophungthai&quot;, 0x0e1c, &quot;phosamphaothai&quot;, 0x0e20, &quot;pi&quot;, 0x03c0, &quot;pieupacirclekorean&quot;, 0x3273, &quot;pieupaparenkorean&quot;, 0x3213, &quot;pieupcieuckorean&quot;, 0x3176, &quot;pieupcirclekorean&quot;, 0x3265, &quot;pieupkiyeokkorean&quot;, 0x3172, &quot;pieupkorean&quot;, 0x3142, &quot;pieupparenkorean&quot;, 0x3205, &quot;pieupsioskiyeokkorean&quot;, 0x3174, &quot;pieupsioskorean&quot;, 0x3144, &quot;pieupsiostikeutkorean&quot;, 0x3175, &quot;pieupthieuthkorean&quot;, 0x3177, &quot;pieuptikeutkorean&quot;, 0x3173, &quot;pihiragana&quot;, 0x3074, &quot;pikatakana&quot;, 0x30d4, &quot;pisymbolgreek&quot;, 0x03d6, &quot;piwrarmenian&quot;, 0x0583, &quot;plus&quot;, 0x002b, &quot;plusbelowcmb&quot;, 0x031f, &quot;pluscircle&quot;, 0x2295, &quot;plusminus&quot;, 0x00b1, &quot;plusmod&quot;, 0x02d6, &quot;plusmonospace&quot;, 0xff0b, &quot;plussmall&quot;, 0xfe62, &quot;plussuperior&quot;, 0x207a, &quot;pmonospace&quot;, 0xff50, &quot;pmsquare&quot;, 0x33d8, &quot;pohiragana&quot;, 0x307d, &quot;pointingindexdownwhite&quot;, 0x261f, &quot;pointingindexleftwhite&quot;, 0x261c, &quot;pointingindexrightwhite&quot;, 0x261e, &quot;pointingindexupwhite&quot;, 0x261d, &quot;pokatakana&quot;, 0x30dd, &quot;poplathai&quot;, 0x0e1b, &quot;postalmark&quot;, 0x3012, &quot;postalmarkface&quot;, 0x3020, &quot;pparen&quot;, 0x24ab, &quot;precedes&quot;, 0x227a, &quot;prescription&quot;, 0x211e, &quot;primemod&quot;, 0x02b9, &quot;primereversed&quot;, 0x2035, &quot;product&quot;, 0x220f, &quot;projective&quot;, 0x2305, &quot;prolongedkana&quot;, 0x30fc, &quot;propellor&quot;, 0x2318, &quot;propersubset&quot;, 0x2282, &quot;propersuperset&quot;, 0x2283, &quot;proportion&quot;, 0x2237, &quot;proportional&quot;, 0x221d, &quot;psi&quot;, 0x03c8, &quot;psicyrillic&quot;, 0x0471, &quot;psilipneumatacyrilliccmb&quot;, 0x0486, &quot;pssquare&quot;, 0x33b0, &quot;puhiragana&quot;, 0x3077, &quot;pukatakana&quot;, 0x30d7, &quot;pvsquare&quot;, 0x33b4, &quot;pwsquare&quot;, 0x33ba, &quot;q&quot;, 0x0071, &quot;qadeva&quot;, 0x0958, &quot;qadmahebrew&quot;, 0x05a8, &quot;qafarabic&quot;, 0x0642, &quot;qaffinalarabic&quot;, 0xfed6, &quot;qafinitialarabic&quot;, 0xfed7, &quot;qafmedialarabic&quot;, 0xfed8, &quot;qamats&quot;, 0x05b8, &quot;qamats10&quot;, 0x05b8, &quot;qamats1a&quot;, 0x05b8, &quot;qamats1c&quot;, 0x05b8, &quot;qamats27&quot;, 0x05b8, &quot;qamats29&quot;, 0x05b8, &quot;qamats33&quot;, 0x05b8, &quot;qamatsde&quot;, 0x05b8, &quot;qamatshebrew&quot;, 0x05b8, &quot;qamatsnarrowhebrew&quot;, 0x05b8, &quot;qamatsqatanhebrew&quot;, 0x05b8, &quot;qamatsqatannarrowhebrew&quot;, 0x05b8, &quot;qamatsqatanquarterhebrew&quot;, 0x05b8, &quot;qamatsqatanwidehebrew&quot;, 0x05b8, &quot;qamatsquarterhebrew&quot;, 0x05b8, &quot;qamatswidehebrew&quot;, 0x05b8, &quot;qarneyparahebrew&quot;, 0x059f, &quot;qbopomofo&quot;, 0x3111, &quot;qcircle&quot;, 0x24e0, &quot;qhook&quot;, 0x02a0, &quot;qmonospace&quot;, 0xff51, &quot;qof&quot;, 0x05e7, &quot;qofdagesh&quot;, 0xfb47, &quot;qofdageshhebrew&quot;, 0xfb47, &quot;qofhebrew&quot;, 0x05e7, &quot;qparen&quot;, 0x24ac, &quot;quarternote&quot;, 0x2669, &quot;qubuts&quot;, 0x05bb, &quot;qubuts18&quot;, 0x05bb, &quot;qubuts25&quot;, 0x05bb, &quot;qubuts31&quot;, 0x05bb, &quot;qubutshebrew&quot;, 0x05bb, &quot;qubutsnarrowhebrew&quot;, 0x05bb, &quot;qubutsquarterhebrew&quot;, 0x05bb, &quot;qubutswidehebrew&quot;, 0x05bb, &quot;question&quot;, 0x003f, &quot;questionarabic&quot;, 0x061f, &quot;questionarmenian&quot;, 0x055e, &quot;questiondown&quot;, 0x00bf, &quot;questiondownsmall&quot;, 0xf7bf, &quot;questiongreek&quot;, 0x037e, &quot;questionmonospace&quot;, 0xff1f, &quot;questionsmall&quot;, 0xf73f, &quot;quotedbl&quot;, 0x0022, &quot;quotedblbase&quot;, 0x201e, &quot;quotedblleft&quot;, 0x201c, &quot;quotedblmonospace&quot;, 0xff02, &quot;quotedblprime&quot;, 0x301e, &quot;quotedblprimereversed&quot;, 0x301d, &quot;quotedblright&quot;, 0x201d, &quot;quoteleft&quot;, 0x2018, &quot;quoteleftreversed&quot;, 0x201b, &quot;quotereversed&quot;, 0x201b, &quot;quoteright&quot;, 0x2019, &quot;quoterightn&quot;, 0x0149, &quot;quotesinglbase&quot;, 0x201a, &quot;quotesingle&quot;, 0x0027, &quot;quotesinglemonospace&quot;, 0xff07, &quot;r&quot;, 0x0072, &quot;raarmenian&quot;, 0x057c, &quot;rabengali&quot;, 0x09b0, &quot;racute&quot;, 0x0155, &quot;radeva&quot;, 0x0930, &quot;radical&quot;, 0x221a, &quot;radicalex&quot;, 0xf8e5, &quot;radoverssquare&quot;, 0x33ae, &quot;radoverssquaredsquare&quot;, 0x33af, &quot;radsquare&quot;, 0x33ad, &quot;rafe&quot;, 0x05bf, &quot;rafehebrew&quot;, 0x05bf, &quot;ragujarati&quot;, 0x0ab0, &quot;ragurmukhi&quot;, 0x0a30, &quot;rahiragana&quot;, 0x3089, &quot;rakatakana&quot;, 0x30e9, &quot;rakatakanahalfwidth&quot;, 0xff97, &quot;ralowerdiagonalbengali&quot;, 0x09f1, &quot;ramiddlediagonalbengali&quot;, 0x09f0, &quot;ramshorn&quot;, 0x0264, &quot;ratio&quot;, 0x2236, &quot;rbopomofo&quot;, 0x3116, &quot;rcaron&quot;, 0x0159, &quot;rcedilla&quot;, 0x0157, &quot;rcircle&quot;, 0x24e1, &quot;rcommaaccent&quot;, 0x0157, &quot;rdblgrave&quot;, 0x0211, &quot;rdotaccent&quot;, 0x1e59, &quot;rdotbelow&quot;, 0x1e5b, &quot;rdotbelowmacron&quot;, 0x1e5d, &quot;referencemark&quot;, 0x203b, &quot;reflexsubset&quot;, 0x2286, &quot;reflexsuperset&quot;, 0x2287, &quot;registered&quot;, 0x00ae, &quot;registersans&quot;, 0xf8e8, &quot;registerserif&quot;, 0xf6da, &quot;reharabic&quot;, 0x0631, &quot;reharmenian&quot;, 0x0580, &quot;rehfinalarabic&quot;, 0xfeae, &quot;rehiragana&quot;, 0x308c, &quot;rekatakana&quot;, 0x30ec, &quot;rekatakanahalfwidth&quot;, 0xff9a, &quot;resh&quot;, 0x05e8, &quot;reshdageshhebrew&quot;, 0xfb48, &quot;reshhebrew&quot;, 0x05e8, &quot;reversedtilde&quot;, 0x223d, &quot;reviahebrew&quot;, 0x0597, &quot;reviamugrashhebrew&quot;, 0x0597, &quot;revlogicalnot&quot;, 0x2310, &quot;rfishhook&quot;, 0x027e, &quot;rfishhookreversed&quot;, 0x027f, &quot;rhabengali&quot;, 0x09dd, &quot;rhadeva&quot;, 0x095d, &quot;rho&quot;, 0x03c1, &quot;rhook&quot;, 0x027d, &quot;rhookturned&quot;, 0x027b, &quot;rhookturnedsuperior&quot;, 0x02b5, &quot;rhosymbolgreek&quot;, 0x03f1, &quot;rhotichookmod&quot;, 0x02de, &quot;rieulacirclekorean&quot;, 0x3271, &quot;rieulaparenkorean&quot;, 0x3211, &quot;rieulcirclekorean&quot;, 0x3263, &quot;rieulhieuhkorean&quot;, 0x3140, &quot;rieulkiyeokkorean&quot;, 0x313a, &quot;rieulkiyeoksioskorean&quot;, 0x3169, &quot;rieulkorean&quot;, 0x3139, &quot;rieulmieumkorean&quot;, 0x313b, &quot;rieulpansioskorean&quot;, 0x316c, &quot;rieulparenkorean&quot;, 0x3203, &quot;rieulphieuphkorean&quot;, 0x313f, &quot;rieulpieupkorean&quot;, 0x313c, &quot;rieulpieupsioskorean&quot;, 0x316b, &quot;rieulsioskorean&quot;, 0x313d, &quot;rieulthieuthkorean&quot;, 0x313e, &quot;rieultikeutkorean&quot;, 0x316a, &quot;rieulyeorinhieuhkorean&quot;, 0x316d, &quot;rightangle&quot;, 0x221f, &quot;righttackbelowcmb&quot;, 0x0319, &quot;righttriangle&quot;, 0x22bf, &quot;rihiragana&quot;, 0x308a, &quot;rikatakana&quot;, 0x30ea, &quot;rikatakanahalfwidth&quot;, 0xff98, &quot;ring&quot;, 0x02da, &quot;ringbelowcmb&quot;, 0x0325, &quot;ringcmb&quot;, 0x030a, &quot;ringhalfleft&quot;, 0x02bf, &quot;ringhalfleftarmenian&quot;, 0x0559, &quot;ringhalfleftbelowcmb&quot;, 0x031c, &quot;ringhalfleftcentered&quot;, 0x02d3, &quot;ringhalfright&quot;, 0x02be, &quot;ringhalfrightbelowcmb&quot;, 0x0339, &quot;ringhalfrightcentered&quot;, 0x02d2, &quot;rinvertedbreve&quot;, 0x0213, &quot;rittorusquare&quot;, 0x3351, &quot;rlinebelow&quot;, 0x1e5f, &quot;rlongleg&quot;, 0x027c, &quot;rlonglegturned&quot;, 0x027a, &quot;rmonospace&quot;, 0xff52, &quot;rohiragana&quot;, 0x308d, &quot;rokatakana&quot;, 0x30ed, &quot;rokatakanahalfwidth&quot;, 0xff9b, &quot;roruathai&quot;, 0x0e23, &quot;rparen&quot;, 0x24ad, &quot;rrabengali&quot;, 0x09dc, &quot;rradeva&quot;, 0x0931, &quot;rragurmukhi&quot;, 0x0a5c, &quot;rreharabic&quot;, 0x0691, &quot;rrehfinalarabic&quot;, 0xfb8d, &quot;rrvocalicbengali&quot;, 0x09e0, &quot;rrvocalicdeva&quot;, 0x0960, &quot;rrvocalicgujarati&quot;, 0x0ae0, &quot;rrvocalicvowelsignbengali&quot;, 0x09c4, &quot;rrvocalicvowelsigndeva&quot;, 0x0944, &quot;rrvocalicvowelsigngujarati&quot;, 0x0ac4, &quot;rsuperior&quot;, 0xf6f1, &quot;rtblock&quot;, 0x2590, &quot;rturned&quot;, 0x0279, &quot;rturnedsuperior&quot;, 0x02b4, &quot;ruhiragana&quot;, 0x308b, &quot;rukatakana&quot;, 0x30eb, &quot;rukatakanahalfwidth&quot;, 0xff99, &quot;rupeemarkbengali&quot;, 0x09f2, &quot;rupeesignbengali&quot;, 0x09f3, &quot;rupiah&quot;, 0xf6dd, &quot;ruthai&quot;, 0x0e24, &quot;rvocalicbengali&quot;, 0x098b, &quot;rvocalicdeva&quot;, 0x090b, &quot;rvocalicgujarati&quot;, 0x0a8b, &quot;rvocalicvowelsignbengali&quot;, 0x09c3, &quot;rvocalicvowelsigndeva&quot;, 0x0943, &quot;rvocalicvowelsigngujarati&quot;, 0x0ac3, &quot;s&quot;, 0x0073, &quot;sabengali&quot;, 0x09b8, &quot;sacute&quot;, 0x015b, &quot;sacutedotaccent&quot;, 0x1e65, &quot;sadarabic&quot;, 0x0635, &quot;sadeva&quot;, 0x0938, &quot;sadfinalarabic&quot;, 0xfeba, &quot;sadinitialarabic&quot;, 0xfebb, &quot;sadmedialarabic&quot;, 0xfebc, &quot;sagujarati&quot;, 0x0ab8, &quot;sagurmukhi&quot;, 0x0a38, &quot;sahiragana&quot;, 0x3055, &quot;sakatakana&quot;, 0x30b5, &quot;sakatakanahalfwidth&quot;, 0xff7b, &quot;sallallahoualayhewasallamarabic&quot;, 0xfdfa, &quot;samekh&quot;, 0x05e1, &quot;samekhdagesh&quot;, 0xfb41, &quot;samekhdageshhebrew&quot;, 0xfb41, &quot;samekhhebrew&quot;, 0x05e1, &quot;saraaathai&quot;, 0x0e32, &quot;saraaethai&quot;, 0x0e41, &quot;saraaimaimalaithai&quot;, 0x0e44, &quot;saraaimaimuanthai&quot;, 0x0e43, &quot;saraamthai&quot;, 0x0e33, &quot;saraathai&quot;, 0x0e30, &quot;saraethai&quot;, 0x0e40, &quot;saraiileftthai&quot;, 0xf886, &quot;saraiithai&quot;, 0x0e35, &quot;saraileftthai&quot;, 0xf885, &quot;saraithai&quot;, 0x0e34, &quot;saraothai&quot;, 0x0e42, &quot;saraueeleftthai&quot;, 0xf888, &quot;saraueethai&quot;, 0x0e37, &quot;saraueleftthai&quot;, 0xf887, &quot;sarauethai&quot;, 0x0e36, &quot;sarauthai&quot;, 0x0e38, &quot;sarauuthai&quot;, 0x0e39, &quot;sbopomofo&quot;, 0x3119, &quot;scaron&quot;, 0x0161, &quot;scarondotaccent&quot;, 0x1e67, &quot;scedilla&quot;, 0x015f, &quot;schwa&quot;, 0x0259, &quot;schwacyrillic&quot;, 0x04d9, &quot;schwadieresiscyrillic&quot;, 0x04db, &quot;schwahook&quot;, 0x025a, &quot;scircle&quot;, 0x24e2, &quot;scircumflex&quot;, 0x015d, &quot;scommaaccent&quot;, 0x0219, &quot;sdotaccent&quot;, 0x1e61, &quot;sdotbelow&quot;, 0x1e63, &quot;sdotbelowdotaccent&quot;, 0x1e69, &quot;seagullbelowcmb&quot;, 0x033c, &quot;second&quot;, 0x2033, &quot;secondtonechinese&quot;, 0x02ca, &quot;section&quot;, 0x00a7, &quot;seenarabic&quot;, 0x0633, &quot;seenfinalarabic&quot;, 0xfeb2, &quot;seeninitialarabic&quot;, 0xfeb3, &quot;seenmedialarabic&quot;, 0xfeb4, &quot;segol&quot;, 0x05b6, &quot;segol13&quot;, 0x05b6, &quot;segol1f&quot;, 0x05b6, &quot;segol2c&quot;, 0x05b6, &quot;segolhebrew&quot;, 0x05b6, &quot;segolnarrowhebrew&quot;, 0x05b6, &quot;segolquarterhebrew&quot;, 0x05b6, &quot;segoltahebrew&quot;, 0x0592, &quot;segolwidehebrew&quot;, 0x05b6, &quot;seharmenian&quot;, 0x057d, &quot;sehiragana&quot;, 0x305b, &quot;sekatakana&quot;, 0x30bb, &quot;sekatakanahalfwidth&quot;, 0xff7e, &quot;semicolon&quot;, 0x003b, &quot;semicolonarabic&quot;, 0x061b, &quot;semicolonmonospace&quot;, 0xff1b, &quot;semicolonsmall&quot;, 0xfe54, &quot;semivoicedmarkkana&quot;, 0x309c, &quot;semivoicedmarkkanahalfwidth&quot;, 0xff9f, &quot;sentisquare&quot;, 0x3322, &quot;sentosquare&quot;, 0x3323, &quot;seven&quot;, 0x0037, &quot;sevenarabic&quot;, 0x0667, &quot;sevenbengali&quot;, 0x09ed, &quot;sevencircle&quot;, 0x2466, &quot;sevencircleinversesansserif&quot;, 0x2790, &quot;sevendeva&quot;, 0x096d, &quot;seveneighths&quot;, 0x215e, &quot;sevengujarati&quot;, 0x0aed, &quot;sevengurmukhi&quot;, 0x0a6d, &quot;sevenhackarabic&quot;, 0x0667, &quot;sevenhangzhou&quot;, 0x3027, &quot;sevenideographicparen&quot;, 0x3226, &quot;seveninferior&quot;, 0x2087, &quot;sevenmonospace&quot;, 0xff17, &quot;sevenoldstyle&quot;, 0xf737, &quot;sevenparen&quot;, 0x247a, &quot;sevenperiod&quot;, 0x248e, &quot;sevenpersian&quot;, 0x06f7, &quot;sevenroman&quot;, 0x2176, &quot;sevensuperior&quot;, 0x2077, &quot;seventeencircle&quot;, 0x2470, &quot;seventeenparen&quot;, 0x2484, &quot;seventeenperiod&quot;, 0x2498, &quot;seventhai&quot;, 0x0e57, &quot;sfthyphen&quot;, 0x00ad, &quot;shaarmenian&quot;, 0x0577, &quot;shabengali&quot;, 0x09b6, &quot;shacyrillic&quot;, 0x0448, &quot;shaddaarabic&quot;, 0x0651, &quot;shaddadammaarabic&quot;, 0xfc61, &quot;shaddadammatanarabic&quot;, 0xfc5e, &quot;shaddafathaarabic&quot;, 0xfc60, &quot;shaddakasraarabic&quot;, 0xfc62, &quot;shaddakasratanarabic&quot;, 0xfc5f, &quot;shade&quot;, 0x2592, &quot;shadedark&quot;, 0x2593, &quot;shadelight&quot;, 0x2591, &quot;shademedium&quot;, 0x2592, &quot;shadeva&quot;, 0x0936, &quot;shagujarati&quot;, 0x0ab6, &quot;shagurmukhi&quot;, 0x0a36, &quot;shalshelethebrew&quot;, 0x0593, &quot;shbopomofo&quot;, 0x3115, &quot;shchacyrillic&quot;, 0x0449, &quot;sheenarabic&quot;, 0x0634, &quot;sheenfinalarabic&quot;, 0xfeb6, &quot;sheeninitialarabic&quot;, 0xfeb7, &quot;sheenmedialarabic&quot;, 0xfeb8, &quot;sheicoptic&quot;, 0x03e3, &quot;sheqel&quot;, 0x20aa, &quot;sheqelhebrew&quot;, 0x20aa, &quot;sheva&quot;, 0x05b0, &quot;sheva115&quot;, 0x05b0, &quot;sheva15&quot;, 0x05b0, &quot;sheva22&quot;, 0x05b0, &quot;sheva2e&quot;, 0x05b0, &quot;shevahebrew&quot;, 0x05b0, &quot;shevanarrowhebrew&quot;, 0x05b0, &quot;shevaquarterhebrew&quot;, 0x05b0, &quot;shevawidehebrew&quot;, 0x05b0, &quot;shhacyrillic&quot;, 0x04bb, &quot;shimacoptic&quot;, 0x03ed, &quot;shin&quot;, 0x05e9, &quot;shindagesh&quot;, 0xfb49, &quot;shindageshhebrew&quot;, 0xfb49, &quot;shindageshshindot&quot;, 0xfb2c, &quot;shindageshshindothebrew&quot;, 0xfb2c, &quot;shindageshsindot&quot;, 0xfb2d, &quot;shindageshsindothebrew&quot;, 0xfb2d, &quot;shindothebrew&quot;, 0x05c1, &quot;shinhebrew&quot;, 0x05e9, &quot;shinshindot&quot;, 0xfb2a, &quot;shinshindothebrew&quot;, 0xfb2a, &quot;shinsindot&quot;, 0xfb2b, &quot;shinsindothebrew&quot;, 0xfb2b, &quot;shook&quot;, 0x0282, &quot;sigma&quot;, 0x03c3, &quot;sigma1&quot;, 0x03c2, &quot;sigmafinal&quot;, 0x03c2, &quot;sigmalunatesymbolgreek&quot;, 0x03f2, &quot;sihiragana&quot;, 0x3057, &quot;sikatakana&quot;, 0x30b7, &quot;sikatakanahalfwidth&quot;, 0xff7c, &quot;siluqhebrew&quot;, 0x05bd, &quot;siluqlefthebrew&quot;, 0x05bd, &quot;similar&quot;, 0x223c, &quot;sindothebrew&quot;, 0x05c2, &quot;siosacirclekorean&quot;, 0x3274, &quot;siosaparenkorean&quot;, 0x3214, &quot;sioscieuckorean&quot;, 0x317e, &quot;sioscirclekorean&quot;, 0x3266, &quot;sioskiyeokkorean&quot;, 0x317a, &quot;sioskorean&quot;, 0x3145, &quot;siosnieunkorean&quot;, 0x317b, &quot;siosparenkorean&quot;, 0x3206, &quot;siospieupkorean&quot;, 0x317d, &quot;siostikeutkorean&quot;, 0x317c, &quot;six&quot;, 0x0036, &quot;sixarabic&quot;, 0x0666, &quot;sixbengali&quot;, 0x09ec, &quot;sixcircle&quot;, 0x2465, &quot;sixcircleinversesansserif&quot;, 0x278f, &quot;sixdeva&quot;, 0x096c, &quot;sixgujarati&quot;, 0x0aec, &quot;sixgurmukhi&quot;, 0x0a6c, &quot;sixhackarabic&quot;, 0x0666, &quot;sixhangzhou&quot;, 0x3026, &quot;sixideographicparen&quot;, 0x3225, &quot;sixinferior&quot;, 0x2086, &quot;sixmonospace&quot;, 0xff16, &quot;sixoldstyle&quot;, 0xf736, &quot;sixparen&quot;, 0x2479, &quot;sixperiod&quot;, 0x248d, &quot;sixpersian&quot;, 0x06f6, &quot;sixroman&quot;, 0x2175, &quot;sixsuperior&quot;, 0x2076, &quot;sixteencircle&quot;, 0x246f, &quot;sixteencurrencydenominatorbengali&quot;, 0x09f9, &quot;sixteenparen&quot;, 0x2483, &quot;sixteenperiod&quot;, 0x2497, &quot;sixthai&quot;, 0x0e56, &quot;slash&quot;, 0x002f, &quot;slashmonospace&quot;, 0xff0f, &quot;slong&quot;, 0x017f, &quot;slongdotaccent&quot;, 0x1e9b, &quot;smileface&quot;, 0x263a, &quot;smonospace&quot;, 0xff53, &quot;sofpasuqhebrew&quot;, 0x05c3, &quot;softhyphen&quot;, 0x00ad, &quot;softsigncyrillic&quot;, 0x044c, &quot;sohiragana&quot;, 0x305d, &quot;sokatakana&quot;, 0x30bd, &quot;sokatakanahalfwidth&quot;, 0xff7f, &quot;soliduslongoverlaycmb&quot;, 0x0338, &quot;solidusshortoverlaycmb&quot;, 0x0337, &quot;sorusithai&quot;, 0x0e29, &quot;sosalathai&quot;, 0x0e28, &quot;sosothai&quot;, 0x0e0b, &quot;sosuathai&quot;, 0x0e2a, &quot;space&quot;, 0x0020, &quot;spacehackarabic&quot;, 0x0020, &quot;spade&quot;, 0x2660, &quot;spadesuitblack&quot;, 0x2660, &quot;spadesuitwhite&quot;, 0x2664, &quot;sparen&quot;, 0x24ae, &quot;squarebelowcmb&quot;, 0x033b, &quot;squarecc&quot;, 0x33c4, &quot;squarecm&quot;, 0x339d, &quot;squarediagonalcrosshatchfill&quot;, 0x25a9, &quot;squarehorizontalfill&quot;, 0x25a4, &quot;squarekg&quot;, 0x338f, &quot;squarekm&quot;, 0x339e, &quot;squarekmcapital&quot;, 0x33ce, &quot;squareln&quot;, 0x33d1, &quot;squarelog&quot;, 0x33d2, &quot;squaremg&quot;, 0x338e, &quot;squaremil&quot;, 0x33d5, &quot;squaremm&quot;, 0x339c, &quot;squaremsquared&quot;, 0x33a1, &quot;squareorthogonalcrosshatchfill&quot;, 0x25a6, &quot;squareupperlefttolowerrightfill&quot;, 0x25a7, &quot;squareupperrighttolowerleftfill&quot;, 0x25a8, &quot;squareverticalfill&quot;, 0x25a5, &quot;squarewhitewithsmallblack&quot;, 0x25a3, &quot;srsquare&quot;, 0x33db, &quot;ssabengali&quot;, 0x09b7, &quot;ssadeva&quot;, 0x0937, &quot;ssagujarati&quot;, 0x0ab7, &quot;ssangcieuckorean&quot;, 0x3149, &quot;ssanghieuhkorean&quot;, 0x3185, &quot;ssangieungkorean&quot;, 0x3180, &quot;ssangkiyeokkorean&quot;, 0x3132, &quot;ssangnieunkorean&quot;, 0x3165, &quot;ssangpieupkorean&quot;, 0x3143, &quot;ssangsioskorean&quot;, 0x3146, &quot;ssangtikeutkorean&quot;, 0x3138, &quot;ssuperior&quot;, 0xf6f2, &quot;sterling&quot;, 0x00a3, &quot;sterlingmonospace&quot;, 0xffe1, &quot;strokelongoverlaycmb&quot;, 0x0336, &quot;strokeshortoverlaycmb&quot;, 0x0335, &quot;subset&quot;, 0x2282, &quot;subsetnotequal&quot;, 0x228a, &quot;subsetorequal&quot;, 0x2286, &quot;succeeds&quot;, 0x227b, &quot;suchthat&quot;, 0x220b, &quot;suhiragana&quot;, 0x3059, &quot;sukatakana&quot;, 0x30b9, &quot;sukatakanahalfwidth&quot;, 0xff7d, &quot;sukunarabic&quot;, 0x0652, &quot;summation&quot;, 0x2211, &quot;sun&quot;, 0x263c, &quot;superset&quot;, 0x2283, &quot;supersetnotequal&quot;, 0x228b, &quot;supersetorequal&quot;, 0x2287, &quot;svsquare&quot;, 0x33dc, &quot;syouwaerasquare&quot;, 0x337c, &quot;t&quot;, 0x0074, &quot;tabengali&quot;, 0x09a4, &quot;tackdown&quot;, 0x22a4, &quot;tackleft&quot;, 0x22a3, &quot;tadeva&quot;, 0x0924, &quot;tagujarati&quot;, 0x0aa4, &quot;tagurmukhi&quot;, 0x0a24, &quot;taharabic&quot;, 0x0637, &quot;tahfinalarabic&quot;, 0xfec2, &quot;tahinitialarabic&quot;, 0xfec3, &quot;tahiragana&quot;, 0x305f, &quot;tahmedialarabic&quot;, 0xfec4, &quot;taisyouerasquare&quot;, 0x337d, &quot;takatakana&quot;, 0x30bf, &quot;takatakanahalfwidth&quot;, 0xff80, &quot;tatweelarabic&quot;, 0x0640, &quot;tau&quot;, 0x03c4, &quot;tav&quot;, 0x05ea, &quot;tavdages&quot;, 0xfb4a, &quot;tavdagesh&quot;, 0xfb4a, &quot;tavdageshhebrew&quot;, 0xfb4a, &quot;tavhebrew&quot;, 0x05ea, &quot;tbar&quot;, 0x0167, &quot;tbopomofo&quot;, 0x310a, &quot;tcaron&quot;, 0x0165, &quot;tccurl&quot;, 0x02a8, &quot;tcedilla&quot;, 0x0163, &quot;tcheharabic&quot;, 0x0686, &quot;tchehfinalarabic&quot;, 0xfb7b, &quot;tchehinitialarabic&quot;, 0xfb7c, &quot;tchehmedialarabic&quot;, 0xfb7d, &quot;tcircle&quot;, 0x24e3, &quot;tcircumflexbelow&quot;, 0x1e71, &quot;tcommaaccent&quot;, 0x0163, &quot;tdieresis&quot;, 0x1e97, &quot;tdotaccent&quot;, 0x1e6b, &quot;tdotbelow&quot;, 0x1e6d, &quot;tecyrillic&quot;, 0x0442, &quot;tedescendercyrillic&quot;, 0x04ad, &quot;teharabic&quot;, 0x062a, &quot;tehfinalarabic&quot;, 0xfe96, &quot;tehhahinitialarabic&quot;, 0xfca2, &quot;tehhahisolatedarabic&quot;, 0xfc0c, &quot;tehinitialarabic&quot;, 0xfe97, &quot;tehiragana&quot;, 0x3066, &quot;tehjeeminitialarabic&quot;, 0xfca1, &quot;tehjeemisolatedarabic&quot;, 0xfc0b, &quot;tehmarbutaarabic&quot;, 0x0629, &quot;tehmarbutafinalarabic&quot;, 0xfe94, &quot;tehmedialarabic&quot;, 0xfe98, &quot;tehmeeminitialarabic&quot;, 0xfca4, &quot;tehmeemisolatedarabic&quot;, 0xfc0e, &quot;tehnoonfinalarabic&quot;, 0xfc73, &quot;tekatakana&quot;, 0x30c6, &quot;tekatakanahalfwidth&quot;, 0xff83, &quot;telephone&quot;, 0x2121, &quot;telephoneblack&quot;, 0x260e, &quot;telishagedolahebrew&quot;, 0x05a0, &quot;telishaqetanahebrew&quot;, 0x05a9, &quot;tencircle&quot;, 0x2469, &quot;tenideographicparen&quot;, 0x3229, &quot;tenparen&quot;, 0x247d, &quot;tenperiod&quot;, 0x2491, &quot;tenroman&quot;, 0x2179, &quot;tesh&quot;, 0x02a7, &quot;tet&quot;, 0x05d8, &quot;tetdagesh&quot;, 0xfb38, &quot;tetdageshhebrew&quot;, 0xfb38, &quot;tethebrew&quot;, 0x05d8, &quot;tetsecyrillic&quot;, 0x04b5, &quot;tevirhebrew&quot;, 0x059b, &quot;tevirlefthebrew&quot;, 0x059b, &quot;thabengali&quot;, 0x09a5, &quot;thadeva&quot;, 0x0925, &quot;thagujarati&quot;, 0x0aa5, &quot;thagurmukhi&quot;, 0x0a25, &quot;thalarabic&quot;, 0x0630, &quot;thalfinalarabic&quot;, 0xfeac, &quot;thanthakhatlowleftthai&quot;, 0xf898, &quot;thanthakhatlowrightthai&quot;, 0xf897, &quot;thanthakhatthai&quot;, 0x0e4c, &quot;thanthakhatupperleftthai&quot;, 0xf896, &quot;theharabic&quot;, 0x062b, &quot;thehfinalarabic&quot;, 0xfe9a, &quot;thehinitialarabic&quot;, 0xfe9b, &quot;thehmedialarabic&quot;, 0xfe9c, &quot;thereexists&quot;, 0x2203, &quot;therefore&quot;, 0x2234, &quot;theta&quot;, 0x03b8, &quot;theta1&quot;, 0x03d1, &quot;thetasymbolgreek&quot;, 0x03d1, &quot;thieuthacirclekorean&quot;, 0x3279, &quot;thieuthaparenkorean&quot;, 0x3219, &quot;thieuthcirclekorean&quot;, 0x326b, &quot;thieuthkorean&quot;, 0x314c, &quot;thieuthparenkorean&quot;, 0x320b, &quot;thirteencircle&quot;, 0x246c, &quot;thirteenparen&quot;, 0x2480, &quot;thirteenperiod&quot;, 0x2494, &quot;thonangmonthothai&quot;, 0x0e11, &quot;thook&quot;, 0x01ad, &quot;thophuthaothai&quot;, 0x0e12, &quot;thorn&quot;, 0x00fe, &quot;thothahanthai&quot;, 0x0e17, &quot;thothanthai&quot;, 0x0e10, &quot;thothongthai&quot;, 0x0e18, &quot;thothungthai&quot;, 0x0e16, &quot;thousandcyrillic&quot;, 0x0482, &quot;thousandsseparatorarabic&quot;, 0x066c, &quot;thousandsseparatorpersian&quot;, 0x066c, &quot;three&quot;, 0x0033, &quot;threearabic&quot;, 0x0663, &quot;threebengali&quot;, 0x09e9, &quot;threecircle&quot;, 0x2462, &quot;threecircleinversesansserif&quot;, 0x278c, &quot;threedeva&quot;, 0x0969, &quot;threeeighths&quot;, 0x215c, &quot;threegujarati&quot;, 0x0ae9, &quot;threegurmukhi&quot;, 0x0a69, &quot;threehackarabic&quot;, 0x0663, &quot;threehangzhou&quot;, 0x3023, &quot;threeideographicparen&quot;, 0x3222, &quot;threeinferior&quot;, 0x2083, &quot;threemonospace&quot;, 0xff13, &quot;threenumeratorbengali&quot;, 0x09f6, &quot;threeoldstyle&quot;, 0xf733, &quot;threeparen&quot;, 0x2476, &quot;threeperiod&quot;, 0x248a, &quot;threepersian&quot;, 0x06f3, &quot;threequarters&quot;, 0x00be, &quot;threequartersemdash&quot;, 0xf6de, &quot;threeroman&quot;, 0x2172, &quot;threesuperior&quot;, 0x00b3, &quot;threethai&quot;, 0x0e53, &quot;thzsquare&quot;, 0x3394, &quot;tihiragana&quot;, 0x3061, &quot;tikatakana&quot;, 0x30c1, &quot;tikatakanahalfwidth&quot;, 0xff81, &quot;tikeutacirclekorean&quot;, 0x3270, &quot;tikeutaparenkorean&quot;, 0x3210, &quot;tikeutcirclekorean&quot;, 0x3262, &quot;tikeutkorean&quot;, 0x3137, &quot;tikeutparenkorean&quot;, 0x3202, &quot;tilde&quot;, 0x02dc, &quot;tildebelowcmb&quot;, 0x0330, &quot;tildecmb&quot;, 0x0303, &quot;tildecomb&quot;, 0x0303, &quot;tildedoublecmb&quot;, 0x0360, &quot;tildeoperator&quot;, 0x223c, &quot;tildeoverlaycmb&quot;, 0x0334, &quot;tildeverticalcmb&quot;, 0x033e, &quot;timescircle&quot;, 0x2297, &quot;tipehahebrew&quot;, 0x0596, &quot;tipehalefthebrew&quot;, 0x0596, &quot;tippigurmukhi&quot;, 0x0a70, &quot;titlocyrilliccmb&quot;, 0x0483, &quot;tiwnarmenian&quot;, 0x057f, &quot;tlinebelow&quot;, 0x1e6f, &quot;tmonospace&quot;, 0xff54, &quot;toarmenian&quot;, 0x0569, &quot;tohiragana&quot;, 0x3068, &quot;tokatakana&quot;, 0x30c8, &quot;tokatakanahalfwidth&quot;, 0xff84, &quot;tonebarextrahighmod&quot;, 0x02e5, &quot;tonebarextralowmod&quot;, 0x02e9, &quot;tonebarhighmod&quot;, 0x02e6, &quot;tonebarlowmod&quot;, 0x02e8, &quot;tonebarmidmod&quot;, 0x02e7, &quot;tonefive&quot;, 0x01bd, &quot;tonesix&quot;, 0x0185, &quot;tonetwo&quot;, 0x01a8, &quot;tonos&quot;, 0x0384, &quot;tonsquare&quot;, 0x3327, &quot;topatakthai&quot;, 0x0e0f, &quot;tortoiseshellbracketleft&quot;, 0x3014, &quot;tortoiseshellbracketleftsmall&quot;, 0xfe5d, &quot;tortoiseshellbracketleftvertical&quot;, 0xfe39, &quot;tortoiseshellbracketright&quot;, 0x3015, &quot;tortoiseshellbracketrightsmall&quot;, 0xfe5e, &quot;tortoiseshellbracketrightvertical&quot;, 0xfe3a, &quot;totaothai&quot;, 0x0e15, &quot;tpalatalhook&quot;, 0x01ab, &quot;tparen&quot;, 0x24af, &quot;trademark&quot;, 0x2122, &quot;trademarksans&quot;, 0xf8ea, &quot;trademarkserif&quot;, 0xf6db, &quot;tretroflexhook&quot;, 0x0288, &quot;triagdn&quot;, 0x25bc, &quot;triaglf&quot;, 0x25c4, &quot;triagrt&quot;, 0x25ba, &quot;triagup&quot;, 0x25b2, &quot;ts&quot;, 0x02a6, &quot;tsadi&quot;, 0x05e6, &quot;tsadidagesh&quot;, 0xfb46, &quot;tsadidageshhebrew&quot;, 0xfb46, &quot;tsadihebrew&quot;, 0x05e6, &quot;tsecyrillic&quot;, 0x0446, &quot;tsere&quot;, 0x05b5, &quot;tsere12&quot;, 0x05b5, &quot;tsere1e&quot;, 0x05b5, &quot;tsere2b&quot;, 0x05b5, &quot;tserehebrew&quot;, 0x05b5, &quot;tserenarrowhebrew&quot;, 0x05b5, &quot;tserequarterhebrew&quot;, 0x05b5, &quot;tserewidehebrew&quot;, 0x05b5, &quot;tshecyrillic&quot;, 0x045b, &quot;tsuperior&quot;, 0xf6f3, &quot;ttabengali&quot;, 0x099f, &quot;ttadeva&quot;, 0x091f, &quot;ttagujarati&quot;, 0x0a9f, &quot;ttagurmukhi&quot;, 0x0a1f, &quot;tteharabic&quot;, 0x0679, &quot;ttehfinalarabic&quot;, 0xfb67, &quot;ttehinitialarabic&quot;, 0xfb68, &quot;ttehmedialarabic&quot;, 0xfb69, &quot;tthabengali&quot;, 0x09a0, &quot;tthadeva&quot;, 0x0920, &quot;tthagujarati&quot;, 0x0aa0, &quot;tthagurmukhi&quot;, 0x0a20, &quot;tturned&quot;, 0x0287, &quot;tuhiragana&quot;, 0x3064, &quot;tukatakana&quot;, 0x30c4, &quot;tukatakanahalfwidth&quot;, 0xff82, &quot;tusmallhiragana&quot;, 0x3063, &quot;tusmallkatakana&quot;, 0x30c3, &quot;tusmallkatakanahalfwidth&quot;, 0xff6f, &quot;twelvecircle&quot;, 0x246b, &quot;twelveparen&quot;, 0x247f, &quot;twelveperiod&quot;, 0x2493, &quot;twelveroman&quot;, 0x217b, &quot;twentycircle&quot;, 0x2473, &quot;twentyhangzhou&quot;, 0x5344, &quot;twentyparen&quot;, 0x2487, &quot;twentyperiod&quot;, 0x249b, &quot;two&quot;, 0x0032, &quot;twoarabic&quot;, 0x0662, &quot;twobengali&quot;, 0x09e8, &quot;twocircle&quot;, 0x2461, &quot;twocircleinversesansserif&quot;, 0x278b, &quot;twodeva&quot;, 0x0968, &quot;twodotenleader&quot;, 0x2025, &quot;twodotleader&quot;, 0x2025, &quot;twodotleadervertical&quot;, 0xfe30, &quot;twogujarati&quot;, 0x0ae8, &quot;twogurmukhi&quot;, 0x0a68, &quot;twohackarabic&quot;, 0x0662, &quot;twohangzhou&quot;, 0x3022, &quot;twoideographicparen&quot;, 0x3221, &quot;twoinferior&quot;, 0x2082, &quot;twomonospace&quot;, 0xff12, &quot;twonumeratorbengali&quot;, 0x09f5, &quot;twooldstyle&quot;, 0xf732, &quot;twoparen&quot;, 0x2475, &quot;twoperiod&quot;, 0x2489, &quot;twopersian&quot;, 0x06f2, &quot;tworoman&quot;, 0x2171, &quot;twostroke&quot;, 0x01bb, &quot;twosuperior&quot;, 0x00b2, &quot;twothai&quot;, 0x0e52, &quot;twothirds&quot;, 0x2154, &quot;u&quot;, 0x0075, &quot;uacute&quot;, 0x00fa, &quot;ubar&quot;, 0x0289, &quot;ubengali&quot;, 0x0989, &quot;ubopomofo&quot;, 0x3128, &quot;ubreve&quot;, 0x016d, &quot;ucaron&quot;, 0x01d4, &quot;ucircle&quot;, 0x24e4, &quot;ucircumflex&quot;, 0x00fb, &quot;ucircumflexbelow&quot;, 0x1e77, &quot;ucyrillic&quot;, 0x0443, &quot;udattadeva&quot;, 0x0951, &quot;udblacute&quot;, 0x0171, &quot;udblgrave&quot;, 0x0215, &quot;udeva&quot;, 0x0909, &quot;udieresis&quot;, 0x00fc, &quot;udieresisacute&quot;, 0x01d8, &quot;udieresisbelow&quot;, 0x1e73, &quot;udieresiscaron&quot;, 0x01da, &quot;udieresiscyrillic&quot;, 0x04f1, &quot;udieresisgrave&quot;, 0x01dc, &quot;udieresismacron&quot;, 0x01d6, &quot;udotbelow&quot;, 0x1ee5, &quot;ugrave&quot;, 0x00f9, &quot;ugujarati&quot;, 0x0a89, &quot;ugurmukhi&quot;, 0x0a09, &quot;uhiragana&quot;, 0x3046, &quot;uhookabove&quot;, 0x1ee7, &quot;uhorn&quot;, 0x01b0, &quot;uhornacute&quot;, 0x1ee9, &quot;uhorndotbelow&quot;, 0x1ef1, &quot;uhorngrave&quot;, 0x1eeb, &quot;uhornhookabove&quot;, 0x1eed, &quot;uhorntilde&quot;, 0x1eef, &quot;uhungarumlaut&quot;, 0x0171, &quot;uhungarumlautcyrillic&quot;, 0x04f3, &quot;uinvertedbreve&quot;, 0x0217, &quot;ukatakana&quot;, 0x30a6, &quot;ukatakanahalfwidth&quot;, 0xff73, &quot;ukcyrillic&quot;, 0x0479, &quot;ukorean&quot;, 0x315c, &quot;umacron&quot;, 0x016b, &quot;umacroncyrillic&quot;, 0x04ef, &quot;umacrondieresis&quot;, 0x1e7b, &quot;umatragurmukhi&quot;, 0x0a41, &quot;umonospace&quot;, 0xff55, &quot;underscore&quot;, 0x005f, &quot;underscoredbl&quot;, 0x2017, &quot;underscoremonospace&quot;, 0xff3f, &quot;underscorevertical&quot;, 0xfe33, &quot;underscorewavy&quot;, 0xfe4f, &quot;union&quot;, 0x222a, &quot;universal&quot;, 0x2200, &quot;uogonek&quot;, 0x0173, &quot;uparen&quot;, 0x24b0, &quot;upblock&quot;, 0x2580, &quot;upperdothebrew&quot;, 0x05c4, &quot;upsilon&quot;, 0x03c5, &quot;upsilondieresis&quot;, 0x03cb, &quot;upsilondieresistonos&quot;, 0x03b0, &quot;upsilonlatin&quot;, 0x028a, &quot;upsilontonos&quot;, 0x03cd, &quot;uptackbelowcmb&quot;, 0x031d, &quot;uptackmod&quot;, 0x02d4, &quot;uragurmukhi&quot;, 0x0a73, &quot;uring&quot;, 0x016f, &quot;ushortcyrillic&quot;, 0x045e, &quot;usmallhiragana&quot;, 0x3045, &quot;usmallkatakana&quot;, 0x30a5, &quot;usmallkatakanahalfwidth&quot;, 0xff69, &quot;ustraightcyrillic&quot;, 0x04af, &quot;ustraightstrokecyrillic&quot;, 0x04b1, &quot;utilde&quot;, 0x0169, &quot;utildeacute&quot;, 0x1e79, &quot;utildebelow&quot;, 0x1e75, &quot;uubengali&quot;, 0x098a, &quot;uudeva&quot;, 0x090a, &quot;uugujarati&quot;, 0x0a8a, &quot;uugurmukhi&quot;, 0x0a0a, &quot;uumatragurmukhi&quot;, 0x0a42, &quot;uuvowelsignbengali&quot;, 0x09c2, &quot;uuvowelsigndeva&quot;, 0x0942, &quot;uuvowelsigngujarati&quot;, 0x0ac2, &quot;uvowelsignbengali&quot;, 0x09c1, &quot;uvowelsigndeva&quot;, 0x0941, &quot;uvowelsigngujarati&quot;, 0x0ac1, &quot;v&quot;, 0x0076, &quot;vadeva&quot;, 0x0935, &quot;vagujarati&quot;, 0x0ab5, &quot;vagurmukhi&quot;, 0x0a35, &quot;vakatakana&quot;, 0x30f7, &quot;vav&quot;, 0x05d5, &quot;vavdagesh&quot;, 0xfb35, &quot;vavdagesh65&quot;, 0xfb35, &quot;vavdageshhebrew&quot;, 0xfb35, &quot;vavhebrew&quot;, 0x05d5, &quot;vavholam&quot;, 0xfb4b, &quot;vavholamhebrew&quot;, 0xfb4b, &quot;vavvavhebrew&quot;, 0x05f0, &quot;vavyodhebrew&quot;, 0x05f1, &quot;vcircle&quot;, 0x24e5, &quot;vdotbelow&quot;, 0x1e7f, &quot;vecyrillic&quot;, 0x0432, &quot;veharabic&quot;, 0x06a4, &quot;vehfinalarabic&quot;, 0xfb6b, &quot;vehinitialarabic&quot;, 0xfb6c, &quot;vehmedialarabic&quot;, 0xfb6d, &quot;vekatakana&quot;, 0x30f9, &quot;venus&quot;, 0x2640, &quot;verticalbar&quot;, 0x007c, &quot;verticallineabovecmb&quot;, 0x030d, &quot;verticallinebelowcmb&quot;, 0x0329, &quot;verticallinelowmod&quot;, 0x02cc, &quot;verticallinemod&quot;, 0x02c8, &quot;vewarmenian&quot;, 0x057e, &quot;vhook&quot;, 0x028b, &quot;vikatakana&quot;, 0x30f8, &quot;viramabengali&quot;, 0x09cd, &quot;viramadeva&quot;, 0x094d, &quot;viramagujarati&quot;, 0x0acd, &quot;visargabengali&quot;, 0x0983, &quot;visargadeva&quot;, 0x0903, &quot;visargagujarati&quot;, 0x0a83, &quot;vmonospace&quot;, 0xff56, &quot;voarmenian&quot;, 0x0578, &quot;voicediterationhiragana&quot;, 0x309e, &quot;voicediterationkatakana&quot;, 0x30fe, &quot;voicedmarkkana&quot;, 0x309b, &quot;voicedmarkkanahalfwidth&quot;, 0xff9e, &quot;vokatakana&quot;, 0x30fa, &quot;vparen&quot;, 0x24b1, &quot;vtilde&quot;, 0x1e7d, &quot;vturned&quot;, 0x028c, &quot;vuhiragana&quot;, 0x3094, &quot;vukatakana&quot;, 0x30f4, &quot;w&quot;, 0x0077, &quot;wacute&quot;, 0x1e83, &quot;waekorean&quot;, 0x3159, &quot;wahiragana&quot;, 0x308f, &quot;wakatakana&quot;, 0x30ef, &quot;wakatakanahalfwidth&quot;, 0xff9c, &quot;wakorean&quot;, 0x3158, &quot;wasmallhiragana&quot;, 0x308e, &quot;wasmallkatakana&quot;, 0x30ee, &quot;wattosquare&quot;, 0x3357, &quot;wavedash&quot;, 0x301c, &quot;wavyunderscorevertical&quot;, 0xfe34, &quot;wawarabic&quot;, 0x0648, &quot;wawfinalarabic&quot;, 0xfeee, &quot;wawhamzaabovearabic&quot;, 0x0624, &quot;wawhamzaabovefinalarabic&quot;, 0xfe86, &quot;wbsquare&quot;, 0x33dd, &quot;wcircle&quot;, 0x24e6, &quot;wcircumflex&quot;, 0x0175, &quot;wdieresis&quot;, 0x1e85, &quot;wdotaccent&quot;, 0x1e87, &quot;wdotbelow&quot;, 0x1e89, &quot;wehiragana&quot;, 0x3091, &quot;weierstrass&quot;, 0x2118, &quot;wekatakana&quot;, 0x30f1, &quot;wekorean&quot;, 0x315e, &quot;weokorean&quot;, 0x315d, &quot;wgrave&quot;, 0x1e81, &quot;whitebullet&quot;, 0x25e6, &quot;whitecircle&quot;, 0x25cb, &quot;whitecircleinverse&quot;, 0x25d9, &quot;whitecornerbracketleft&quot;, 0x300e, &quot;whitecornerbracketleftvertical&quot;, 0xfe43, &quot;whitecornerbracketright&quot;, 0x300f, &quot;whitecornerbracketrightvertical&quot;, 0xfe44, &quot;whitediamond&quot;, 0x25c7, &quot;whitediamondcontainingblacksmalldiamond&quot;, 0x25c8, &quot;whitedownpointingsmalltriangle&quot;, 0x25bf, &quot;whitedownpointingtriangle&quot;, 0x25bd, &quot;whiteleftpointingsmalltriangle&quot;, 0x25c3, &quot;whiteleftpointingtriangle&quot;, 0x25c1, &quot;whitelenticularbracketleft&quot;, 0x3016, &quot;whitelenticularbracketright&quot;, 0x3017, &quot;whiterightpointingsmalltriangle&quot;, 0x25b9, &quot;whiterightpointingtriangle&quot;, 0x25b7, &quot;whitesmallsquare&quot;, 0x25ab, &quot;whitesmilingface&quot;, 0x263a, &quot;whitesquare&quot;, 0x25a1, &quot;whitestar&quot;, 0x2606, &quot;whitetelephone&quot;, 0x260f, &quot;whitetortoiseshellbracketleft&quot;, 0x3018, &quot;whitetortoiseshellbracketright&quot;, 0x3019, &quot;whiteuppointingsmalltriangle&quot;, 0x25b5, &quot;whiteuppointingtriangle&quot;, 0x25b3, &quot;wihiragana&quot;, 0x3090, &quot;wikatakana&quot;, 0x30f0, &quot;wikorean&quot;, 0x315f, &quot;wmonospace&quot;, 0xff57, &quot;wohiragana&quot;, 0x3092, &quot;wokatakana&quot;, 0x30f2, &quot;wokatakanahalfwidth&quot;, 0xff66, &quot;won&quot;, 0x20a9, &quot;wonmonospace&quot;, 0xffe6, &quot;wowaenthai&quot;, 0x0e27, &quot;wparen&quot;, 0x24b2, &quot;wring&quot;, 0x1e98, &quot;wsuperior&quot;, 0x02b7, &quot;wturned&quot;, 0x028d, &quot;wynn&quot;, 0x01bf, &quot;x&quot;, 0x0078, &quot;xabovecmb&quot;, 0x033d, &quot;xbopomofo&quot;, 0x3112, &quot;xcircle&quot;, 0x24e7, &quot;xdieresis&quot;, 0x1e8d, &quot;xdotaccent&quot;, 0x1e8b, &quot;xeharmenian&quot;, 0x056d, &quot;xi&quot;, 0x03be, &quot;xmonospace&quot;, 0xff58, &quot;xparen&quot;, 0x24b3, &quot;xsuperior&quot;, 0x02e3, &quot;y&quot;, 0x0079, &quot;yaadosquare&quot;, 0x334e, &quot;yabengali&quot;, 0x09af, &quot;yacute&quot;, 0x00fd, &quot;yadeva&quot;, 0x092f, &quot;yaekorean&quot;, 0x3152, &quot;yagujarati&quot;, 0x0aaf, &quot;yagurmukhi&quot;, 0x0a2f, &quot;yahiragana&quot;, 0x3084, &quot;yakatakana&quot;, 0x30e4, &quot;yakatakanahalfwidth&quot;, 0xff94, &quot;yakorean&quot;, 0x3151, &quot;yamakkanthai&quot;, 0x0e4e, &quot;yasmallhiragana&quot;, 0x3083, &quot;yasmallkatakana&quot;, 0x30e3, &quot;yasmallkatakanahalfwidth&quot;, 0xff6c, &quot;yatcyrillic&quot;, 0x0463, &quot;ycircle&quot;, 0x24e8, &quot;ycircumflex&quot;, 0x0177, &quot;ydieresis&quot;, 0x00ff, &quot;ydotaccent&quot;, 0x1e8f, &quot;ydotbelow&quot;, 0x1ef5, &quot;yeharabic&quot;, 0x064a, &quot;yehbarreearabic&quot;, 0x06d2, &quot;yehbarreefinalarabic&quot;, 0xfbaf, &quot;yehfinalarabic&quot;, 0xfef2, &quot;yehhamzaabovearabic&quot;, 0x0626, &quot;yehhamzaabovefinalarabic&quot;, 0xfe8a, &quot;yehhamzaaboveinitialarabic&quot;, 0xfe8b, &quot;yehhamzaabovemedialarabic&quot;, 0xfe8c, &quot;yehinitialarabic&quot;, 0xfef3, &quot;yehmedialarabic&quot;, 0xfef4, &quot;yehmeeminitialarabic&quot;, 0xfcdd, &quot;yehmeemisolatedarabic&quot;, 0xfc58, &quot;yehnoonfinalarabic&quot;, 0xfc94, &quot;yehthreedotsbelowarabic&quot;, 0x06d1, &quot;yekorean&quot;, 0x3156, &quot;yen&quot;, 0x00a5, &quot;yenmonospace&quot;, 0xffe5, &quot;yeokorean&quot;, 0x3155, &quot;yeorinhieuhkorean&quot;, 0x3186, &quot;yerahbenyomohebrew&quot;, 0x05aa, &quot;yerahbenyomolefthebrew&quot;, 0x05aa, &quot;yericyrillic&quot;, 0x044b, &quot;yerudieresiscyrillic&quot;, 0x04f9, &quot;yesieungkorean&quot;, 0x3181, &quot;yesieungpansioskorean&quot;, 0x3183, &quot;yesieungsioskorean&quot;, 0x3182, &quot;yetivhebrew&quot;, 0x059a, &quot;ygrave&quot;, 0x1ef3, &quot;yhook&quot;, 0x01b4, &quot;yhookabove&quot;, 0x1ef7, &quot;yiarmenian&quot;, 0x0575, &quot;yicyrillic&quot;, 0x0457, &quot;yikorean&quot;, 0x3162, &quot;yinyang&quot;, 0x262f, &quot;yiwnarmenian&quot;, 0x0582, &quot;ymonospace&quot;, 0xff59, &quot;yod&quot;, 0x05d9, &quot;yoddagesh&quot;, 0xfb39, &quot;yoddageshhebrew&quot;, 0xfb39, &quot;yodhebrew&quot;, 0x05d9, &quot;yodyodhebrew&quot;, 0x05f2, &quot;yodyodpatahhebrew&quot;, 0xfb1f, &quot;yohiragana&quot;, 0x3088, &quot;yoikorean&quot;, 0x3189, &quot;yokatakana&quot;, 0x30e8, &quot;yokatakanahalfwidth&quot;, 0xff96, &quot;yokorean&quot;, 0x315b, &quot;yosmallhiragana&quot;, 0x3087, &quot;yosmallkatakana&quot;, 0x30e7, &quot;yosmallkatakanahalfwidth&quot;, 0xff6e, &quot;yotgreek&quot;, 0x03f3, &quot;yoyaekorean&quot;, 0x3188, &quot;yoyakorean&quot;, 0x3187, &quot;yoyakthai&quot;, 0x0e22, &quot;yoyingthai&quot;, 0x0e0d, &quot;yparen&quot;, 0x24b4, &quot;ypogegrammeni&quot;, 0x037a, &quot;ypogegrammenigreekcmb&quot;, 0x0345, &quot;yr&quot;, 0x01a6, &quot;yring&quot;, 0x1e99, &quot;ysuperior&quot;, 0x02b8, &quot;ytilde&quot;, 0x1ef9, &quot;yturned&quot;, 0x028e, &quot;yuhiragana&quot;, 0x3086, &quot;yuikorean&quot;, 0x318c, &quot;yukatakana&quot;, 0x30e6, &quot;yukatakanahalfwidth&quot;, 0xff95, &quot;yukorean&quot;, 0x3160, &quot;yusbigcyrillic&quot;, 0x046b, &quot;yusbigiotifiedcyrillic&quot;, 0x046d, &quot;yuslittlecyrillic&quot;, 0x0467, &quot;yuslittleiotifiedcyrillic&quot;, 0x0469, &quot;yusmallhiragana&quot;, 0x3085, &quot;yusmallkatakana&quot;, 0x30e5, &quot;yusmallkatakanahalfwidth&quot;, 0xff6d, &quot;yuyekorean&quot;, 0x318b, &quot;yuyeokorean&quot;, 0x318a, &quot;yyabengali&quot;, 0x09df, &quot;yyadeva&quot;, 0x095f, &quot;z&quot;, 0x007a, &quot;zaarmenian&quot;, 0x0566, &quot;zacute&quot;, 0x017a, &quot;zadeva&quot;, 0x095b, &quot;zagurmukhi&quot;, 0x0a5b, &quot;zaharabic&quot;, 0x0638, &quot;zahfinalarabic&quot;, 0xfec6, &quot;zahinitialarabic&quot;, 0xfec7, &quot;zahiragana&quot;, 0x3056, &quot;zahmedialarabic&quot;, 0xfec8, &quot;zainarabic&quot;, 0x0632, &quot;zainfinalarabic&quot;, 0xfeb0, &quot;zakatakana&quot;, 0x30b6, &quot;zaqefgadolhebrew&quot;, 0x0595, &quot;zaqefqatanhebrew&quot;, 0x0594, &quot;zarqahebrew&quot;, 0x0598, &quot;zayin&quot;, 0x05d6, &quot;zayindagesh&quot;, 0xfb36, &quot;zayindageshhebrew&quot;, 0xfb36, &quot;zayinhebrew&quot;, 0x05d6, &quot;zbopomofo&quot;, 0x3117, &quot;zcaron&quot;, 0x017e, &quot;zcircle&quot;, 0x24e9, &quot;zcircumflex&quot;, 0x1e91, &quot;zcurl&quot;, 0x0291, &quot;zdot&quot;, 0x017c, &quot;zdotaccent&quot;, 0x017c, &quot;zdotbelow&quot;, 0x1e93, &quot;zecyrillic&quot;, 0x0437, &quot;zedescendercyrillic&quot;, 0x0499, &quot;zedieresiscyrillic&quot;, 0x04df, &quot;zehiragana&quot;, 0x305c, &quot;zekatakana&quot;, 0x30bc, &quot;zero&quot;, 0x0030, &quot;zeroarabic&quot;, 0x0660, &quot;zerobengali&quot;, 0x09e6, &quot;zerodeva&quot;, 0x0966, &quot;zerogujarati&quot;, 0x0ae6, &quot;zerogurmukhi&quot;, 0x0a66, &quot;zerohackarabic&quot;, 0x0660, &quot;zeroinferior&quot;, 0x2080, &quot;zeromonospace&quot;, 0xff10, &quot;zerooldstyle&quot;, 0xf730, &quot;zeropersian&quot;, 0x06f0, &quot;zerosuperior&quot;, 0x2070, &quot;zerothai&quot;, 0x0e50, &quot;zerowidthjoiner&quot;, 0xfeff, &quot;zerowidthnonjoiner&quot;, 0x200c, &quot;zerowidthspace&quot;, 0x200b, &quot;zeta&quot;, 0x03b6, &quot;zhbopomofo&quot;, 0x3113, &quot;zhearmenian&quot;, 0x056a, &quot;zhebrevecyrillic&quot;, 0x04c2, &quot;zhecyrillic&quot;, 0x0436, &quot;zhedescendercyrillic&quot;, 0x0497, &quot;zhedieresiscyrillic&quot;, 0x04dd, &quot;zihiragana&quot;, 0x3058, &quot;zikatakana&quot;, 0x30b8, &quot;zinorhebrew&quot;, 0x05ae, &quot;zlinebelow&quot;, 0x1e95, &quot;zmonospace&quot;, 0xff5a, &quot;zohiragana&quot;, 0x305e, &quot;zokatakana&quot;, 0x30be, &quot;zparen&quot;, 0x24b5, &quot;zretroflexhook&quot;, 0x0290, &quot;zstroke&quot;, 0x01b6, &quot;zuhiragana&quot;, 0x305a, &quot;zukatakana&quot;, 0x30ba, &quot;.notdef&quot;, 0x0000, &quot;angbracketleftbig&quot;, 0x2329, &quot;angbracketleftBig&quot;, 0x2329, &quot;angbracketleftbigg&quot;, 0x2329, &quot;angbracketleftBigg&quot;, 0x2329, &quot;angbracketrightBig&quot;, 0x232a, &quot;angbracketrightbig&quot;, 0x232a, &quot;angbracketrightBigg&quot;, 0x232a, &quot;angbracketrightbigg&quot;, 0x232a, &quot;arrowhookleft&quot;, 0x21aa, &quot;arrowhookright&quot;, 0x21a9, &quot;arrowlefttophalf&quot;, 0x21bc, &quot;arrowleftbothalf&quot;, 0x21bd, &quot;arrownortheast&quot;, 0x2197, &quot;arrownorthwest&quot;, 0x2196, &quot;arrowrighttophalf&quot;, 0x21c0, &quot;arrowrightbothalf&quot;, 0x21c1, &quot;arrowsoutheast&quot;, 0x2198, &quot;arrowsouthwest&quot;, 0x2199, &quot;backslashbig&quot;, 0x2216, &quot;backslashBig&quot;, 0x2216, &quot;backslashBigg&quot;, 0x2216, &quot;backslashbigg&quot;, 0x2216, &quot;bardbl&quot;, 0x2016, &quot;bracehtipdownleft&quot;, 0xfe37, &quot;bracehtipdownright&quot;, 0xfe37, &quot;bracehtipupleft&quot;, 0xfe38, &quot;bracehtipupright&quot;, 0xfe38, &quot;braceleftBig&quot;, 0x007b, &quot;braceleftbig&quot;, 0x007b, &quot;braceleftbigg&quot;, 0x007b, &quot;braceleftBigg&quot;, 0x007b, &quot;bracerightBig&quot;, 0x007d, &quot;bracerightbig&quot;, 0x007d, &quot;bracerightbigg&quot;, 0x007d, &quot;bracerightBigg&quot;, 0x007d, &quot;bracketleftbig&quot;, 0x005b, &quot;bracketleftBig&quot;, 0x005b, &quot;bracketleftbigg&quot;, 0x005b, &quot;bracketleftBigg&quot;, 0x005b, &quot;bracketrightBig&quot;, 0x005d, &quot;bracketrightbig&quot;, 0x005d, &quot;bracketrightbigg&quot;, 0x005d, &quot;bracketrightBigg&quot;, 0x005d, &quot;ceilingleftbig&quot;, 0x2308, &quot;ceilingleftBig&quot;, 0x2308, &quot;ceilingleftBigg&quot;, 0x2308, &quot;ceilingleftbigg&quot;, 0x2308, &quot;ceilingrightbig&quot;, 0x2309, &quot;ceilingrightBig&quot;, 0x2309, &quot;ceilingrightbigg&quot;, 0x2309, &quot;ceilingrightBigg&quot;, 0x2309, &quot;circledotdisplay&quot;, 0x2299, &quot;circledottext&quot;, 0x2299, &quot;circlemultiplydisplay&quot;, 0x2297, &quot;circlemultiplytext&quot;, 0x2297, &quot;circleplusdisplay&quot;, 0x2295, &quot;circleplustext&quot;, 0x2295, &quot;contintegraldisplay&quot;, 0x222e, &quot;contintegraltext&quot;, 0x222e, &quot;coproductdisplay&quot;, 0x2210, &quot;coproducttext&quot;, 0x2210, &quot;floorleftBig&quot;, 0x230a, &quot;floorleftbig&quot;, 0x230a, &quot;floorleftbigg&quot;, 0x230a, &quot;floorleftBigg&quot;, 0x230a, &quot;floorrightbig&quot;, 0x230b, &quot;floorrightBig&quot;, 0x230b, &quot;floorrightBigg&quot;, 0x230b, &quot;floorrightbigg&quot;, 0x230b, &quot;hatwide&quot;, 0x0302, &quot;hatwider&quot;, 0x0302, &quot;hatwidest&quot;, 0x0302, &quot;intercal&quot;, 0x1d40, &quot;integraldisplay&quot;, 0x222b, &quot;integraltext&quot;, 0x222b, &quot;intersectiondisplay&quot;, 0x22c2, &quot;intersectiontext&quot;, 0x22c2, &quot;logicalanddisplay&quot;, 0x2227, &quot;logicalandtext&quot;, 0x2227, &quot;logicalordisplay&quot;, 0x2228, &quot;logicalortext&quot;, 0x2228, &quot;parenleftBig&quot;, 0x0028, &quot;parenleftbig&quot;, 0x0028, &quot;parenleftBigg&quot;, 0x0028, &quot;parenleftbigg&quot;, 0x0028, &quot;parenrightBig&quot;, 0x0029, &quot;parenrightbig&quot;, 0x0029, &quot;parenrightBigg&quot;, 0x0029, &quot;parenrightbigg&quot;, 0x0029, &quot;prime&quot;, 0x2032, &quot;productdisplay&quot;, 0x220f, &quot;producttext&quot;, 0x220f, &quot;radicalbig&quot;, 0x221a, &quot;radicalBig&quot;, 0x221a, &quot;radicalBigg&quot;, 0x221a, &quot;radicalbigg&quot;, 0x221a, &quot;radicalbt&quot;, 0x221a, &quot;radicaltp&quot;, 0x221a, &quot;radicalvertex&quot;, 0x221a, &quot;slashbig&quot;, 0x002f, &quot;slashBig&quot;, 0x002f, &quot;slashBigg&quot;, 0x002f, &quot;slashbigg&quot;, 0x002f, &quot;summationdisplay&quot;, 0x2211, &quot;summationtext&quot;, 0x2211, &quot;tildewide&quot;, 0x02dc, &quot;tildewider&quot;, 0x02dc, &quot;tildewidest&quot;, 0x02dc, &quot;uniondisplay&quot;, 0x22c3, &quot;unionmultidisplay&quot;, 0x228e, &quot;unionmultitext&quot;, 0x228e, &quot;unionsqdisplay&quot;, 0x2294, &quot;unionsqtext&quot;, 0x2294, &quot;uniontext&quot;, 0x22c3, &quot;vextenddouble&quot;, 0x2225, &quot;vextendsingle&quot;, 0x2223 ]; }); const getDingbatsGlyphsUnicode = (0,_core_utils_js__WEBPACK_IMPORTED_MODULE_0__.getArrayLookupTableFactory)(function () { return [ &quot;space&quot;, 0x0020, &quot;a1&quot;, 0x2701, &quot;a2&quot;, 0x2702, &quot;a202&quot;, 0x2703, &quot;a3&quot;, 0x2704, &quot;a4&quot;, 0x260e, &quot;a5&quot;, 0x2706, &quot;a119&quot;, 0x2707, &quot;a118&quot;, 0x2708, &quot;a117&quot;, 0x2709, &quot;a11&quot;, 0x261b, &quot;a12&quot;, 0x261e, &quot;a13&quot;, 0x270c, &quot;a14&quot;, 0x270d, &quot;a15&quot;, 0x270e, &quot;a16&quot;, 0x270f, &quot;a105&quot;, 0x2710, &quot;a17&quot;, 0x2711, &quot;a18&quot;, 0x2712, &quot;a19&quot;, 0x2713, &quot;a20&quot;, 0x2714, &quot;a21&quot;, 0x2715, &quot;a22&quot;, 0x2716, &quot;a23&quot;, 0x2717, &quot;a24&quot;, 0x2718, &quot;a25&quot;, 0x2719, &quot;a26&quot;, 0x271a, &quot;a27&quot;, 0x271b, &quot;a28&quot;, 0x271c, &quot;a6&quot;, 0x271d, &quot;a7&quot;, 0x271e, &quot;a8&quot;, 0x271f, &quot;a9&quot;, 0x2720, &quot;a10&quot;, 0x2721, &quot;a29&quot;, 0x2722, &quot;a30&quot;, 0x2723, &quot;a31&quot;, 0x2724, &quot;a32&quot;, 0x2725, &quot;a33&quot;, 0x2726, &quot;a34&quot;, 0x2727, &quot;a35&quot;, 0x2605, &quot;a36&quot;, 0x2729, &quot;a37&quot;, 0x272a, &quot;a38&quot;, 0x272b, &quot;a39&quot;, 0x272c, &quot;a40&quot;, 0x272d, &quot;a41&quot;, 0x272e, &quot;a42&quot;, 0x272f, &quot;a43&quot;, 0x2730, &quot;a44&quot;, 0x2731, &quot;a45&quot;, 0x2732, &quot;a46&quot;, 0x2733, &quot;a47&quot;, 0x2734, &quot;a48&quot;, 0x2735, &quot;a49&quot;, 0x2736, &quot;a50&quot;, 0x2737, &quot;a51&quot;, 0x2738, &quot;a52&quot;, 0x2739, &quot;a53&quot;, 0x273a, &quot;a54&quot;, 0x273b, &quot;a55&quot;, 0x273c, &quot;a56&quot;, 0x273d, &quot;a57&quot;, 0x273e, &quot;a58&quot;, 0x273f, &quot;a59&quot;, 0x2740, &quot;a60&quot;, 0x2741, &quot;a61&quot;, 0x2742, &quot;a62&quot;, 0x2743, &quot;a63&quot;, 0x2744, &quot;a64&quot;, 0x2745, &quot;a65&quot;, 0x2746, &quot;a66&quot;, 0x2747, &quot;a67&quot;, 0x2748, &quot;a68&quot;, 0x2749, &quot;a69&quot;, 0x274a, &quot;a70&quot;, 0x274b, &quot;a71&quot;, 0x25cf, &quot;a72&quot;, 0x274d, &quot;a73&quot;, 0x25a0, &quot;a74&quot;, 0x274f, &quot;a203&quot;, 0x2750, &quot;a75&quot;, 0x2751, &quot;a204&quot;, 0x2752, &quot;a76&quot;, 0x25b2, &quot;a77&quot;, 0x25bc, &quot;a78&quot;, 0x25c6, &quot;a79&quot;, 0x2756, &quot;a81&quot;, 0x25d7, &quot;a82&quot;, 0x2758, &quot;a83&quot;, 0x2759, &quot;a84&quot;, 0x275a, &quot;a97&quot;, 0x275b, &quot;a98&quot;, 0x275c, &quot;a99&quot;, 0x275d, &quot;a100&quot;, 0x275e, &quot;a101&quot;, 0x2761, &quot;a102&quot;, 0x2762, &quot;a103&quot;, 0x2763, &quot;a104&quot;, 0x2764, &quot;a106&quot;, 0x2765, &quot;a107&quot;, 0x2766, &quot;a108&quot;, 0x2767, &quot;a112&quot;, 0x2663, &quot;a111&quot;, 0x2666, &quot;a110&quot;, 0x2665, &quot;a109&quot;, 0x2660, &quot;a120&quot;, 0x2460, &quot;a121&quot;, 0x2461, &quot;a122&quot;, 0x2462, &quot;a123&quot;, 0x2463, &quot;a124&quot;, 0x2464, &quot;a125&quot;, 0x2465, &quot;a126&quot;, 0x2466, &quot;a127&quot;, 0x2467, &quot;a128&quot;, 0x2468, &quot;a129&quot;, 0x2469, &quot;a130&quot;, 0x2776, &quot;a131&quot;, 0x2777, &quot;a132&quot;, 0x2778, &quot;a133&quot;, 0x2779, &quot;a134&quot;, 0x277a, &quot;a135&quot;, 0x277b, &quot;a136&quot;, 0x277c, &quot;a137&quot;, 0x277d, &quot;a138&quot;, 0x277e, &quot;a139&quot;, 0x277f, &quot;a140&quot;, 0x2780, &quot;a141&quot;, 0x2781, &quot;a142&quot;, 0x2782, &quot;a143&quot;, 0x2783, &quot;a144&quot;, 0x2784, &quot;a145&quot;, 0x2785, &quot;a146&quot;, 0x2786, &quot;a147&quot;, 0x2787, &quot;a148&quot;, 0x2788, &quot;a149&quot;, 0x2789, &quot;a150&quot;, 0x278a, &quot;a151&quot;, 0x278b, &quot;a152&quot;, 0x278c, &quot;a153&quot;, 0x278d, &quot;a154&quot;, 0x278e, &quot;a155&quot;, 0x278f, &quot;a156&quot;, 0x2790, &quot;a157&quot;, 0x2791, &quot;a158&quot;, 0x2792, &quot;a159&quot;, 0x2793, &quot;a160&quot;, 0x2794, &quot;a161&quot;, 0x2192, &quot;a163&quot;, 0x2194, &quot;a164&quot;, 0x2195, &quot;a196&quot;, 0x2798, &quot;a165&quot;, 0x2799, &quot;a192&quot;, 0x279a, &quot;a166&quot;, 0x279b, &quot;a167&quot;, 0x279c, &quot;a168&quot;, 0x279d, &quot;a169&quot;, 0x279e, &quot;a170&quot;, 0x279f, &quot;a171&quot;, 0x27a0, &quot;a172&quot;, 0x27a1, &quot;a173&quot;, 0x27a2, &quot;a162&quot;, 0x27a3, &quot;a174&quot;, 0x27a4, &quot;a175&quot;, 0x27a5, &quot;a176&quot;, 0x27a6, &quot;a177&quot;, 0x27a7, &quot;a178&quot;, 0x27a8, &quot;a179&quot;, 0x27a9, &quot;a193&quot;, 0x27aa, &quot;a180&quot;, 0x27ab, &quot;a199&quot;, 0x27ac, &quot;a181&quot;, 0x27ad, &quot;a200&quot;, 0x27ae, &quot;a182&quot;, 0x27af, &quot;a201&quot;, 0x27b1, &quot;a183&quot;, 0x27b2, &quot;a184&quot;, 0x27b3, &quot;a197&quot;, 0x27b4, &quot;a185&quot;, 0x27b5, &quot;a194&quot;, 0x27b6, &quot;a198&quot;, 0x27b7, &quot;a186&quot;, 0x27b8, &quot;a195&quot;, 0x27b9, &quot;a187&quot;, 0x27ba, &quot;a188&quot;, 0x27bb, &quot;a189&quot;, 0x27bc, &quot;a190&quot;, 0x27bd, &quot;a191&quot;, 0x27be, &quot;a89&quot;, 0x2768, &quot;a90&quot;, 0x2769, &quot;a93&quot;, 0x276a, &quot;a94&quot;, 0x276b, &quot;a91&quot;, 0x276c, &quot;a92&quot;, 0x276d, &quot;a205&quot;, 0x276e, &quot;a85&quot;, 0x276f, &quot;a206&quot;, 0x2770, &quot;a86&quot;, 0x2771, &quot;a87&quot;, 0x2772, &quot;a88&quot;, 0x2773, &quot;a95&quot;, 0x2774, &quot;a96&quot;, 0x2775, &quot;.notdef&quot;, 0x0000 ]; }); /***/ }), /* 38 */ /***/ ((__unused_webpack_module, __webpack_exports__, __w_pdfjs_require__) =&gt; { __w_pdfjs_require__.r(__webpack_exports__); /* harmony export */ __w_pdfjs_require__.d(__webpack_exports__, { /* harmony export */ &quot;clearUnicodeCaches&quot;: () =&gt; (/* binding */ clearUnicodeCaches), /* harmony export */ &quot;getCharUnicodeCategory&quot;: () =&gt; (/* binding */ getCharUnicodeCategory), /* harmony export */ &quot;getNormalizedUnicodes&quot;: () =&gt; (/* binding */ getNormalizedUnicodes), /* harmony export */ &quot;getUnicodeForGlyph&quot;: () =&gt; (/* binding */ getUnicodeForGlyph), /* harmony export */ &quot;getUnicodeRangeFor&quot;: () =&gt; (/* binding */ getUnicodeRangeFor), /* harmony export */ &quot;mapSpecialUnicodeValues&quot;: () =&gt; (/* binding */ mapSpecialUnicodeValues), /* harmony export */ &quot;reverseIfRtl&quot;: () =&gt; (/* binding */ reverseIfRtl) /* harmony export */ }); /* harmony import */ var _core_utils_js__WEBPACK_IMPORTED_MODULE_0__ = __w_pdfjs_require__(4); const getSpecialPUASymbols = (0,_core_utils_js__WEBPACK_IMPORTED_MODULE_0__.getLookupTableFactory)(function (t) { t[63721] = 0x00a9; t[63193] = 0x00a9; t[63720] = 0x00ae; t[63194] = 0x00ae; t[63722] = 0x2122; t[63195] = 0x2122; t[63729] = 0x23a7; t[63730] = 0x23a8; t[63731] = 0x23a9; t[63740] = 0x23ab; t[63741] = 0x23ac; t[63742] = 0x23ad; t[63726] = 0x23a1; t[63727] = 0x23a2; t[63728] = 0x23a3; t[63737] = 0x23a4; t[63738] = 0x23a5; t[63739] = 0x23a6; t[63723] = 0x239b; t[63724] = 0x239c; t[63725] = 0x239d; t[63734] = 0x239e; t[63735] = 0x239f; t[63736] = 0x23a0; }); function mapSpecialUnicodeValues(code) { if (code &gt;= 0xfff0 &amp;&amp; code &lt;= 0xffff) { return 0; } else if (code &gt;= 0xf600 &amp;&amp; code &lt;= 0xf8ff) { return getSpecialPUASymbols()[code] || code; } else if (code === 0x00ad) { return 0x002d; } return code; } function getUnicodeForGlyph(name, glyphsUnicodeMap) { let unicode = glyphsUnicodeMap[name]; if (unicode !== undefined) { return unicode; } if (!name) { return -1; } if (name[0] === &quot;u&quot;) { const nameLen = name.length; let hexStr; if (nameLen === 7 &amp;&amp; name[1] === &quot;n&quot; &amp;&amp; name[2] === &quot;i&quot;) { hexStr = name.substring(3); } else if (nameLen &gt;= 5 &amp;&amp; nameLen &lt;= 7) { hexStr = name.substring(1); } else { return -1; } if (hexStr === hexStr.toUpperCase()) { unicode = parseInt(hexStr, 16); if (unicode &gt;= 0) { return unicode; } } } return -1; } const UnicodeRanges = [ { begin: 0x0000, end: 0x007f }, { begin: 0x0080, end: 0x00ff }, { begin: 0x0100, end: 0x017f }, { begin: 0x0180, end: 0x024f }, { begin: 0x0250, end: 0x02af }, { begin: 0x02b0, end: 0x02ff }, { begin: 0x0300, end: 0x036f }, { begin: 0x0370, end: 0x03ff }, { begin: 0x2c80, end: 0x2cff }, { begin: 0x0400, end: 0x04ff }, { begin: 0x0530, end: 0x058f }, { begin: 0x0590, end: 0x05ff }, { begin: 0xa500, end: 0xa63f }, { begin: 0x0600, end: 0x06ff }, { begin: 0x07c0, end: 0x07ff }, { begin: 0x0900, end: 0x097f }, { begin: 0x0980, end: 0x09ff }, { begin: 0x0a00, end: 0x0a7f }, { begin: 0x0a80, end: 0x0aff }, { begin: 0x0b00, end: 0x0b7f }, { begin: 0x0b80, end: 0x0bff }, { begin: 0x0c00, end: 0x0c7f }, { begin: 0x0c80, end: 0x0cff }, { begin: 0x0d00, end: 0x0d7f }, { begin: 0x0e00, end: 0x0e7f }, { begin: 0x0e80, end: 0x0eff }, { begin: 0x10a0, end: 0x10ff }, { begin: 0x1b00, end: 0x1b7f }, { begin: 0x1100, end: 0x11ff }, { begin: 0x1e00, end: 0x1eff }, { begin: 0x1f00, end: 0x1fff }, { begin: 0x2000, end: 0x206f }, { begin: 0x2070, end: 0x209f }, { begin: 0x20a0, end: 0x20cf }, { begin: 0x20d0, end: 0x20ff }, { begin: 0x2100, end: 0x214f }, { begin: 0x2150, end: 0x218f }, { begin: 0x2190, end: 0x21ff }, { begin: 0x2200, end: 0x22ff }, { begin: 0x2300, end: 0x23ff }, { begin: 0x2400, end: 0x243f }, { begin: 0x2440, end: 0x245f }, { begin: 0x2460, end: 0x24ff }, { begin: 0x2500, end: 0x257f }, { begin: 0x2580, end: 0x259f }, { begin: 0x25a0, end: 0x25ff }, { begin: 0x2600, end: 0x26ff }, { begin: 0x2700, end: 0x27bf }, { begin: 0x3000, end: 0x303f }, { begin: 0x3040, end: 0x309f }, { begin: 0x30a0, end: 0x30ff }, { begin: 0x3100, end: 0x312f }, { begin: 0x3130, end: 0x318f }, { begin: 0xa840, end: 0xa87f }, { begin: 0x3200, end: 0x32ff }, { begin: 0x3300, end: 0x33ff }, { begin: 0xac00, end: 0xd7af }, { begin: 0xd800, end: 0xdfff }, { begin: 0x10900, end: 0x1091f }, { begin: 0x4e00, end: 0x9fff }, { begin: 0xe000, end: 0xf8ff }, { begin: 0x31c0, end: 0x31ef }, { begin: 0xfb00, end: 0xfb4f }, { begin: 0xfb50, end: 0xfdff }, { begin: 0xfe20, end: 0xfe2f }, { begin: 0xfe10, end: 0xfe1f }, { begin: 0xfe50, end: 0xfe6f }, { begin: 0xfe70, end: 0xfeff }, { begin: 0xff00, end: 0xffef }, { begin: 0xfff0, end: 0xffff }, { begin: 0x0f00, end: 0x0fff }, { begin: 0x0700, end: 0x074f }, { begin: 0x0780, end: 0x07bf }, { begin: 0x0d80, end: 0x0dff }, { begin: 0x1000, end: 0x109f }, { begin: 0x1200, end: 0x137f }, { begin: 0x13a0, end: 0x13ff }, { begin: 0x1400, end: 0x167f }, { begin: 0x1680, end: 0x169f }, { begin: 0x16a0, end: 0x16ff }, { begin: 0x1780, end: 0x17ff }, { begin: 0x1800, end: 0x18af }, { begin: 0x2800, end: 0x28ff }, { begin: 0xa000, end: 0xa48f }, { begin: 0x1700, end: 0x171f }, { begin: 0x10300, end: 0x1032f }, { begin: 0x10330, end: 0x1034f }, { begin: 0x10400, end: 0x1044f }, { begin: 0x1d000, end: 0x1d0ff }, { begin: 0x1d400, end: 0x1d7ff }, { begin: 0xff000, end: 0xffffd }, { begin: 0xfe00, end: 0xfe0f }, { begin: 0xe0000, end: 0xe007f }, { begin: 0x1900, end: 0x194f }, { begin: 0x1950, end: 0x197f }, { begin: 0x1980, end: 0x19df }, { begin: 0x1a00, end: 0x1a1f }, { begin: 0x2c00, end: 0x2c5f }, { begin: 0x2d30, end: 0x2d7f }, { begin: 0x4dc0, end: 0x4dff }, { begin: 0xa800, end: 0xa82f }, { begin: 0x10000, end: 0x1007f }, { begin: 0x10140, end: 0x1018f }, { begin: 0x10380, end: 0x1039f }, { begin: 0x103a0, end: 0x103df }, { begin: 0x10450, end: 0x1047f }, { begin: 0x10480, end: 0x104af }, { begin: 0x10800, end: 0x1083f }, { begin: 0x10a00, end: 0x10a5f }, { begin: 0x1d300, end: 0x1d35f }, { begin: 0x12000, end: 0x123ff }, { begin: 0x1d360, end: 0x1d37f }, { begin: 0x1b80, end: 0x1bbf }, { begin: 0x1c00, end: 0x1c4f }, { begin: 0x1c50, end: 0x1c7f }, { begin: 0xa880, end: 0xa8df }, { begin: 0xa900, end: 0xa92f }, { begin: 0xa930, end: 0xa95f }, { begin: 0xaa00, end: 0xaa5f }, { begin: 0x10190, end: 0x101cf }, { begin: 0x101d0, end: 0x101ff }, { begin: 0x102a0, end: 0x102df }, { begin: 0x1f030, end: 0x1f09f } ]; function getUnicodeRangeFor(value) { for (let i = 0, ii = UnicodeRanges.length; i &lt; ii; i++) { const range = UnicodeRanges[i]; if (value &gt;= range.begin &amp;&amp; value &lt; range.end) { return i; } } return -1; } function isRTLRangeFor(value) { let range = UnicodeRanges[13]; if (value &gt;= range.begin &amp;&amp; value &lt; range.end) { return true; } range = UnicodeRanges[11]; if (value &gt;= range.begin &amp;&amp; value &lt; range.end) { return true; } return false; } const getNormalizedUnicodes = (0,_core_utils_js__WEBPACK_IMPORTED_MODULE_0__.getArrayLookupTableFactory)(function () { return [ &quot;\\u00A8&quot;, &quot;\\u0020\\u0308&quot;, &quot;\\u00AF&quot;, &quot;\\u0020\\u0304&quot;, &quot;\\u00B4&quot;, &quot;\\u0020\\u0301&quot;, &quot;\\u00B5&quot;, &quot;\\u03BC&quot;, &quot;\\u00B8&quot;, &quot;\\u0020\\u0327&quot;, &quot;\\u0132&quot;, &quot;\\u0049\\u004A&quot;, &quot;\\u0133&quot;, &quot;\\u0069\\u006A&quot;, &quot;\\u013F&quot;, &quot;\\u004C\\u00B7&quot;, &quot;\\u0140&quot;, &quot;\\u006C\\u00B7&quot;, &quot;\\u0149&quot;, &quot;\\u02BC\\u006E&quot;, &quot;\\u017F&quot;, &quot;\\u0073&quot;, &quot;\\u01C4&quot;, &quot;\\u0044\\u017D&quot;, &quot;\\u01C5&quot;, &quot;\\u0044\\u017E&quot;, &quot;\\u01C6&quot;, &quot;\\u0064\\u017E&quot;, &quot;\\u01C7&quot;, &quot;\\u004C\\u004A&quot;, &quot;\\u01C8&quot;, &quot;\\u004C\\u006A&quot;, &quot;\\u01C9&quot;, &quot;\\u006C\\u006A&quot;, &quot;\\u01CA&quot;, &quot;\\u004E\\u004A&quot;, &quot;\\u01CB&quot;, &quot;\\u004E\\u006A&quot;, &quot;\\u01CC&quot;, &quot;\\u006E\\u006A&quot;, &quot;\\u01F1&quot;, &quot;\\u0044\\u005A&quot;, &quot;\\u01F2&quot;, &quot;\\u0044\\u007A&quot;, &quot;\\u01F3&quot;, &quot;\\u0064\\u007A&quot;, &quot;\\u02D8&quot;, &quot;\\u0020\\u0306&quot;, &quot;\\u02D9&quot;, &quot;\\u0020\\u0307&quot;, &quot;\\u02DA&quot;, &quot;\\u0020\\u030A&quot;, &quot;\\u02DB&quot;, &quot;\\u0020\\u0328&quot;, &quot;\\u02DC&quot;, &quot;\\u0020\\u0303&quot;, &quot;\\u02DD&quot;, &quot;\\u0020\\u030B&quot;, &quot;\\u037A&quot;, &quot;\\u0020\\u0345&quot;, &quot;\\u0384&quot;, &quot;\\u0020\\u0301&quot;, &quot;\\u03D0&quot;, &quot;\\u03B2&quot;, &quot;\\u03D1&quot;, &quot;\\u03B8&quot;, &quot;\\u03D2&quot;, &quot;\\u03A5&quot;, &quot;\\u03D5&quot;, &quot;\\u03C6&quot;, &quot;\\u03D6&quot;, &quot;\\u03C0&quot;, &quot;\\u03F0&quot;, &quot;\\u03BA&quot;, &quot;\\u03F1&quot;, &quot;\\u03C1&quot;, &quot;\\u03F2&quot;, &quot;\\u03C2&quot;, &quot;\\u03F4&quot;, &quot;\\u0398&quot;, &quot;\\u03F5&quot;, &quot;\\u03B5&quot;, &quot;\\u03F9&quot;, &quot;\\u03A3&quot;, &quot;\\u0587&quot;, &quot;\\u0565\\u0582&quot;, &quot;\\u0675&quot;, &quot;\\u0627\\u0674&quot;, &quot;\\u0676&quot;, &quot;\\u0648\\u0674&quot;, &quot;\\u0677&quot;, &quot;\\u06C7\\u0674&quot;, &quot;\\u0678&quot;, &quot;\\u064A\\u0674&quot;, &quot;\\u0E33&quot;, &quot;\\u0E4D\\u0E32&quot;, &quot;\\u0EB3&quot;, &quot;\\u0ECD\\u0EB2&quot;, &quot;\\u0EDC&quot;, &quot;\\u0EAB\\u0E99&quot;, &quot;\\u0EDD&quot;, &quot;\\u0EAB\\u0EA1&quot;, &quot;\\u0F77&quot;, &quot;\\u0FB2\\u0F81&quot;, &quot;\\u0F79&quot;, &quot;\\u0FB3\\u0F81&quot;, &quot;\\u1E9A&quot;, &quot;\\u0061\\u02BE&quot;, &quot;\\u1FBD&quot;, &quot;\\u0020\\u0313&quot;, &quot;\\u1FBF&quot;, &quot;\\u0020\\u0313&quot;, &quot;\\u1FC0&quot;, &quot;\\u0020\\u0342&quot;, &quot;\\u1FFE&quot;, &quot;\\u0020\\u0314&quot;, &quot;\\u2002&quot;, &quot;\\u0020&quot;, &quot;\\u2003&quot;, &quot;\\u0020&quot;, &quot;\\u2004&quot;, &quot;\\u0020&quot;, &quot;\\u2005&quot;, &quot;\\u0020&quot;, &quot;\\u2006&quot;, &quot;\\u0020&quot;, &quot;\\u2008&quot;, &quot;\\u0020&quot;, &quot;\\u2009&quot;, &quot;\\u0020&quot;, &quot;\\u200A&quot;, &quot;\\u0020&quot;, &quot;\\u2017&quot;, &quot;\\u0020\\u0333&quot;, &quot;\\u2024&quot;, &quot;\\u002E&quot;, &quot;\\u2025&quot;, &quot;\\u002E\\u002E&quot;, &quot;\\u2026&quot;, &quot;\\u002E\\u002E\\u002E&quot;, &quot;\\u2033&quot;, &quot;\\u2032\\u2032&quot;, &quot;\\u2034&quot;, &quot;\\u2032\\u2032\\u2032&quot;, &quot;\\u2036&quot;, &quot;\\u2035\\u2035&quot;, &quot;\\u2037&quot;, &quot;\\u2035\\u2035\\u2035&quot;, &quot;\\u203C&quot;, &quot;\\u0021\\u0021&quot;, &quot;\\u203E&quot;, &quot;\\u0020\\u0305&quot;, &quot;\\u2047&quot;, &quot;\\u003F\\u003F&quot;, &quot;\\u2048&quot;, &quot;\\u003F\\u0021&quot;, &quot;\\u2049&quot;, &quot;\\u0021\\u003F&quot;, &quot;\\u2057&quot;, &quot;\\u2032\\u2032\\u2032\\u2032&quot;, &quot;\\u205F&quot;, &quot;\\u0020&quot;, &quot;\\u20A8&quot;, &quot;\\u0052\\u0073&quot;, &quot;\\u2100&quot;, &quot;\\u0061\\u002F\\u0063&quot;, &quot;\\u2101&quot;, &quot;\\u0061\\u002F\\u0073&quot;, &quot;\\u2103&quot;, &quot;\\u00B0\\u0043&quot;, &quot;\\u2105&quot;, &quot;\\u0063\\u002F\\u006F&quot;, &quot;\\u2106&quot;, &quot;\\u0063\\u002F\\u0075&quot;, &quot;\\u2107&quot;, &quot;\\u0190&quot;, &quot;\\u2109&quot;, &quot;\\u00B0\\u0046&quot;, &quot;\\u2116&quot;, &quot;\\u004E\\u006F&quot;, &quot;\\u2121&quot;, &quot;\\u0054\\u0045\\u004C&quot;, &quot;\\u2135&quot;, &quot;\\u05D0&quot;, &quot;\\u2136&quot;, &quot;\\u05D1&quot;, &quot;\\u2137&quot;, &quot;\\u05D2&quot;, &quot;\\u2138&quot;, &quot;\\u05D3&quot;, &quot;\\u213B&quot;, &quot;\\u0046\\u0041\\u0058&quot;, &quot;\\u2160&quot;, &quot;\\u0049&quot;, &quot;\\u2161&quot;, &quot;\\u0049\\u0049&quot;, &quot;\\u2162&quot;, &quot;\\u0049\\u0049\\u0049&quot;, &quot;\\u2163&quot;, &quot;\\u0049\\u0056&quot;, &quot;\\u2164&quot;, &quot;\\u0056&quot;, &quot;\\u2165&quot;, &quot;\\u0056\\u0049&quot;, &quot;\\u2166&quot;, &quot;\\u0056\\u0049\\u0049&quot;, &quot;\\u2167&quot;, &quot;\\u0056\\u0049\\u0049\\u0049&quot;, &quot;\\u2168&quot;, &quot;\\u0049\\u0058&quot;, &quot;\\u2169&quot;, &quot;\\u0058&quot;, &quot;\\u216A&quot;, &quot;\\u0058\\u0049&quot;, &quot;\\u216B&quot;, &quot;\\u0058\\u0049\\u0049&quot;, &quot;\\u216C&quot;, &quot;\\u004C&quot;, &quot;\\u216D&quot;, &quot;\\u0043&quot;, &quot;\\u216E&quot;, &quot;\\u0044&quot;, &quot;\\u216F&quot;, &quot;\\u004D&quot;, &quot;\\u2170&quot;, &quot;\\u0069&quot;, &quot;\\u2171&quot;, &quot;\\u0069\\u0069&quot;, &quot;\\u2172&quot;, &quot;\\u0069\\u0069\\u0069&quot;, &quot;\\u2173&quot;, &quot;\\u0069\\u0076&quot;, &quot;\\u2174&quot;, &quot;\\u0076&quot;, &quot;\\u2175&quot;, &quot;\\u0076\\u0069&quot;, &quot;\\u2176&quot;, &quot;\\u0076\\u0069\\u0069&quot;, &quot;\\u2177&quot;, &quot;\\u0076\\u0069\\u0069\\u0069&quot;, &quot;\\u2178&quot;, &quot;\\u0069\\u0078&quot;, &quot;\\u2179&quot;, &quot;\\u0078&quot;, &quot;\\u217A&quot;, &quot;\\u0078\\u0069&quot;, &quot;\\u217B&quot;, &quot;\\u0078\\u0069\\u0069&quot;, &quot;\\u217C&quot;, &quot;\\u006C&quot;, &quot;\\u217D&quot;, &quot;\\u0063&quot;, &quot;\\u217E&quot;, &quot;\\u0064&quot;, &quot;\\u217F&quot;, &quot;\\u006D&quot;, &quot;\\u222C&quot;, &quot;\\u222B\\u222B&quot;, &quot;\\u222D&quot;, &quot;\\u222B\\u222B\\u222B&quot;, &quot;\\u222F&quot;, &quot;\\u222E\\u222E&quot;, &quot;\\u2230&quot;, &quot;\\u222E\\u222E\\u222E&quot;, &quot;\\u2474&quot;, &quot;\\u0028\\u0031\\u0029&quot;, &quot;\\u2475&quot;, &quot;\\u0028\\u0032\\u0029&quot;, &quot;\\u2476&quot;, &quot;\\u0028\\u0033\\u0029&quot;, &quot;\\u2477&quot;, &quot;\\u0028\\u0034\\u0029&quot;, &quot;\\u2478&quot;, &quot;\\u0028\\u0035\\u0029&quot;, &quot;\\u2479&quot;, &quot;\\u0028\\u0036\\u0029&quot;, &quot;\\u247A&quot;, &quot;\\u0028\\u0037\\u0029&quot;, &quot;\\u247B&quot;, &quot;\\u0028\\u0038\\u0029&quot;, &quot;\\u247C&quot;, &quot;\\u0028\\u0039\\u0029&quot;, &quot;\\u247D&quot;, &quot;\\u0028\\u0031\\u0030\\u0029&quot;, &quot;\\u247E&quot;, &quot;\\u0028\\u0031\\u0031\\u0029&quot;, &quot;\\u247F&quot;, &quot;\\u0028\\u0031\\u0032\\u0029&quot;, &quot;\\u2480&quot;, &quot;\\u0028\\u0031\\u0033\\u0029&quot;, &quot;\\u2481&quot;, &quot;\\u0028\\u0031\\u0034\\u0029&quot;, &quot;\\u2482&quot;, &quot;\\u0028\\u0031\\u0035\\u0029&quot;, &quot;\\u2483&quot;, &quot;\\u0028\\u0031\\u0036\\u0029&quot;, &quot;\\u2484&quot;, &quot;\\u0028\\u0031\\u0037\\u0029&quot;, &quot;\\u2485&quot;, &quot;\\u0028\\u0031\\u0038\\u0029&quot;, &quot;\\u2486&quot;, &quot;\\u0028\\u0031\\u0039\\u0029&quot;, &quot;\\u2487&quot;, &quot;\\u0028\\u0032\\u0030\\u0029&quot;, &quot;\\u2488&quot;, &quot;\\u0031\\u002E&quot;, &quot;\\u2489&quot;, &quot;\\u0032\\u002E&quot;, &quot;\\u248A&quot;, &quot;\\u0033\\u002E&quot;, &quot;\\u248B&quot;, &quot;\\u0034\\u002E&quot;, &quot;\\u248C&quot;, &quot;\\u0035\\u002E&quot;, &quot;\\u248D&quot;, &quot;\\u0036\\u002E&quot;, &quot;\\u248E&quot;, &quot;\\u0037\\u002E&quot;, &quot;\\u248F&quot;, &quot;\\u0038\\u002E&quot;, &quot;\\u2490&quot;, &quot;\\u0039\\u002E&quot;, &quot;\\u2491&quot;, &quot;\\u0031\\u0030\\u002E&quot;, &quot;\\u2492&quot;, &quot;\\u0031\\u0031\\u002E&quot;, &quot;\\u2493&quot;, &quot;\\u0031\\u0032\\u002E&quot;, &quot;\\u2494&quot;, &quot;\\u0031\\u0033\\u002E&quot;, &quot;\\u2495&quot;, &quot;\\u0031\\u0034\\u002E&quot;, &quot;\\u2496&quot;, &quot;\\u0031\\u0035\\u002E&quot;, &quot;\\u2497&quot;, &quot;\\u0031\\u0036\\u002E&quot;, &quot;\\u2498&quot;, &quot;\\u0031\\u0037\\u002E&quot;, &quot;\\u2499&quot;, &quot;\\u0031\\u0038\\u002E&quot;, &quot;\\u249A&quot;, &quot;\\u0031\\u0039\\u002E&quot;, &quot;\\u249B&quot;, &quot;\\u0032\\u0030\\u002E&quot;, &quot;\\u249C&quot;, &quot;\\u0028\\u0061\\u0029&quot;, &quot;\\u249D&quot;, &quot;\\u0028\\u0062\\u0029&quot;, &quot;\\u249E&quot;, &quot;\\u0028\\u0063\\u0029&quot;, &quot;\\u249F&quot;, &quot;\\u0028\\u0064\\u0029&quot;, &quot;\\u24A0&quot;, &quot;\\u0028\\u0065\\u0029&quot;, &quot;\\u24A1&quot;, &quot;\\u0028\\u0066\\u0029&quot;, &quot;\\u24A2&quot;, &quot;\\u0028\\u0067\\u0029&quot;, &quot;\\u24A3&quot;, &quot;\\u0028\\u0068\\u0029&quot;, &quot;\\u24A4&quot;, &quot;\\u0028\\u0069\\u0029&quot;, &quot;\\u24A5&quot;, &quot;\\u0028\\u006A\\u0029&quot;, &quot;\\u24A6&quot;, &quot;\\u0028\\u006B\\u0029&quot;, &quot;\\u24A7&quot;, &quot;\\u0028\\u006C\\u0029&quot;, &quot;\\u24A8&quot;, &quot;\\u0028\\u006D\\u0029&quot;, &quot;\\u24A9&quot;, &quot;\\u0028\\u006E\\u0029&quot;, &quot;\\u24AA&quot;, &quot;\\u0028\\u006F\\u0029&quot;, &quot;\\u24AB&quot;, &quot;\\u0028\\u0070\\u0029&quot;, &quot;\\u24AC&quot;, &quot;\\u0028\\u0071\\u0029&quot;, &quot;\\u24AD&quot;, &quot;\\u0028\\u0072\\u0029&quot;, &quot;\\u24AE&quot;, &quot;\\u0028\\u0073\\u0029&quot;, &quot;\\u24AF&quot;, &quot;\\u0028\\u0074\\u0029&quot;, &quot;\\u24B0&quot;, &quot;\\u0028\\u0075\\u0029&quot;, &quot;\\u24B1&quot;, &quot;\\u0028\\u0076\\u0029&quot;, &quot;\\u24B2&quot;, &quot;\\u0028\\u0077\\u0029&quot;, &quot;\\u24B3&quot;, &quot;\\u0028\\u0078\\u0029&quot;, &quot;\\u24B4&quot;, &quot;\\u0028\\u0079\\u0029&quot;, &quot;\\u24B5&quot;, &quot;\\u0028\\u007A\\u0029&quot;, &quot;\\u2A0C&quot;, &quot;\\u222B\\u222B\\u222B\\u222B&quot;, &quot;\\u2A74&quot;, &quot;\\u003A\\u003A\\u003D&quot;, &quot;\\u2A75&quot;, &quot;\\u003D\\u003D&quot;, &quot;\\u2A76&quot;, &quot;\\u003D\\u003D\\u003D&quot;, &quot;\\u2E9F&quot;, &quot;\\u6BCD&quot;, &quot;\\u2EF3&quot;, &quot;\\u9F9F&quot;, &quot;\\u2F00&quot;, &quot;\\u4E00&quot;, &quot;\\u2F01&quot;, &quot;\\u4E28&quot;, &quot;\\u2F02&quot;, &quot;\\u4E36&quot;, &quot;\\u2F03&quot;, &quot;\\u4E3F&quot;, &quot;\\u2F04&quot;, &quot;\\u4E59&quot;, &quot;\\u2F05&quot;, &quot;\\u4E85&quot;, &quot;\\u2F06&quot;, &quot;\\u4E8C&quot;, &quot;\\u2F07&quot;, &quot;\\u4EA0&quot;, &quot;\\u2F08&quot;, &quot;\\u4EBA&quot;, &quot;\\u2F09&quot;, &quot;\\u513F&quot;, &quot;\\u2F0A&quot;, &quot;\\u5165&quot;, &quot;\\u2F0B&quot;, &quot;\\u516B&quot;, &quot;\\u2F0C&quot;, &quot;\\u5182&quot;, &quot;\\u2F0D&quot;, &quot;\\u5196&quot;, &quot;\\u2F0E&quot;, &quot;\\u51AB&quot;, &quot;\\u2F0F&quot;, &quot;\\u51E0&quot;, &quot;\\u2F10&quot;, &quot;\\u51F5&quot;, &quot;\\u2F11&quot;, &quot;\\u5200&quot;, &quot;\\u2F12&quot;, &quot;\\u529B&quot;, &quot;\\u2F13&quot;, &quot;\\u52F9&quot;, &quot;\\u2F14&quot;, &quot;\\u5315&quot;, &quot;\\u2F15&quot;, &quot;\\u531A&quot;, &quot;\\u2F16&quot;, &quot;\\u5338&quot;, &quot;\\u2F17&quot;, &quot;\\u5341&quot;, &quot;\\u2F18&quot;, &quot;\\u535C&quot;, &quot;\\u2F19&quot;, &quot;\\u5369&quot;, &quot;\\u2F1A&quot;, &quot;\\u5382&quot;, &quot;\\u2F1B&quot;, &quot;\\u53B6&quot;, &quot;\\u2F1C&quot;, &quot;\\u53C8&quot;, &quot;\\u2F1D&quot;, &quot;\\u53E3&quot;, &quot;\\u2F1E&quot;, &quot;\\u56D7&quot;, &quot;\\u2F1F&quot;, &quot;\\u571F&quot;, &quot;\\u2F20&quot;, &quot;\\u58EB&quot;, &quot;\\u2F21&quot;, &quot;\\u5902&quot;, &quot;\\u2F22&quot;, &quot;\\u590A&quot;, &quot;\\u2F23&quot;, &quot;\\u5915&quot;, &quot;\\u2F24&quot;, &quot;\\u5927&quot;, &quot;\\u2F25&quot;, &quot;\\u5973&quot;, &quot;\\u2F26&quot;, &quot;\\u5B50&quot;, &quot;\\u2F27&quot;, &quot;\\u5B80&quot;, &quot;\\u2F28&quot;, &quot;\\u5BF8&quot;, &quot;\\u2F29&quot;, &quot;\\u5C0F&quot;, &quot;\\u2F2A&quot;, &quot;\\u5C22&quot;, &quot;\\u2F2B&quot;, &quot;\\u5C38&quot;, &quot;\\u2F2C&quot;, &quot;\\u5C6E&quot;, &quot;\\u2F2D&quot;, &quot;\\u5C71&quot;, &quot;\\u2F2E&quot;, &quot;\\u5DDB&quot;, &quot;\\u2F2F&quot;, &quot;\\u5DE5&quot;, &quot;\\u2F30&quot;, &quot;\\u5DF1&quot;, &quot;\\u2F31&quot;, &quot;\\u5DFE&quot;, &quot;\\u2F32&quot;, &quot;\\u5E72&quot;, &quot;\\u2F33&quot;, &quot;\\u5E7A&quot;, &quot;\\u2F34&quot;, &quot;\\u5E7F&quot;, &quot;\\u2F35&quot;, &quot;\\u5EF4&quot;, &quot;\\u2F36&quot;, &quot;\\u5EFE&quot;, &quot;\\u2F37&quot;, &quot;\\u5F0B&quot;, &quot;\\u2F38&quot;, &quot;\\u5F13&quot;, &quot;\\u2F39&quot;, &quot;\\u5F50&quot;, &quot;\\u2F3A&quot;, &quot;\\u5F61&quot;, &quot;\\u2F3B&quot;, &quot;\\u5F73&quot;, &quot;\\u2F3C&quot;, &quot;\\u5FC3&quot;, &quot;\\u2F3D&quot;, &quot;\\u6208&quot;, &quot;\\u2F3E&quot;, &quot;\\u6236&quot;, &quot;\\u2F3F&quot;, &quot;\\u624B&quot;, &quot;\\u2F40&quot;, &quot;\\u652F&quot;, &quot;\\u2F41&quot;, &quot;\\u6534&quot;, &quot;\\u2F42&quot;, &quot;\\u6587&quot;, &quot;\\u2F43&quot;, &quot;\\u6597&quot;, &quot;\\u2F44&quot;, &quot;\\u65A4&quot;, &quot;\\u2F45&quot;, &quot;\\u65B9&quot;, &quot;\\u2F46&quot;, &quot;\\u65E0&quot;, &quot;\\u2F47&quot;, &quot;\\u65E5&quot;, &quot;\\u2F48&quot;, &quot;\\u66F0&quot;, &quot;\\u2F49&quot;, &quot;\\u6708&quot;, &quot;\\u2F4A&quot;, &quot;\\u6728&quot;, &quot;\\u2F4B&quot;, &quot;\\u6B20&quot;, &quot;\\u2F4C&quot;, &quot;\\u6B62&quot;, &quot;\\u2F4D&quot;, &quot;\\u6B79&quot;, &quot;\\u2F4E&quot;, &quot;\\u6BB3&quot;, &quot;\\u2F4F&quot;, &quot;\\u6BCB&quot;, &quot;\\u2F50&quot;, &quot;\\u6BD4&quot;, &quot;\\u2F51&quot;, &quot;\\u6BDB&quot;, &quot;\\u2F52&quot;, &quot;\\u6C0F&quot;, &quot;\\u2F53&quot;, &quot;\\u6C14&quot;, &quot;\\u2F54&quot;, &quot;\\u6C34&quot;, &quot;\\u2F55&quot;, &quot;\\u706B&quot;, &quot;\\u2F56&quot;, &quot;\\u722A&quot;, &quot;\\u2F57&quot;, &quot;\\u7236&quot;, &quot;\\u2F58&quot;, &quot;\\u723B&quot;, &quot;\\u2F59&quot;, &quot;\\u723F&quot;, &quot;\\u2F5A&quot;, &quot;\\u7247&quot;, &quot;\\u2F5B&quot;, &quot;\\u7259&quot;, &quot;\\u2F5C&quot;, &quot;\\u725B&quot;, &quot;\\u2F5D&quot;, &quot;\\u72AC&quot;, &quot;\\u2F5E&quot;, &quot;\\u7384&quot;, &quot;\\u2F5F&quot;, &quot;\\u7389&quot;, &quot;\\u2F60&quot;, &quot;\\u74DC&quot;, &quot;\\u2F61&quot;, &quot;\\u74E6&quot;, &quot;\\u2F62&quot;, &quot;\\u7518&quot;, &quot;\\u2F63&quot;, &quot;\\u751F&quot;, &quot;\\u2F64&quot;, &quot;\\u7528&quot;, &quot;\\u2F65&quot;, &quot;\\u7530&quot;, &quot;\\u2F66&quot;, &quot;\\u758B&quot;, &quot;\\u2F67&quot;, &quot;\\u7592&quot;, &quot;\\u2F68&quot;, &quot;\\u7676&quot;, &quot;\\u2F69&quot;, &quot;\\u767D&quot;, &quot;\\u2F6A&quot;, &quot;\\u76AE&quot;, &quot;\\u2F6B&quot;, &quot;\\u76BF&quot;, &quot;\\u2F6C&quot;, &quot;\\u76EE&quot;, &quot;\\u2F6D&quot;, &quot;\\u77DB&quot;, &quot;\\u2F6E&quot;, &quot;\\u77E2&quot;, &quot;\\u2F6F&quot;, &quot;\\u77F3&quot;, &quot;\\u2F70&quot;, &quot;\\u793A&quot;, &quot;\\u2F71&quot;, &quot;\\u79B8&quot;, &quot;\\u2F72&quot;, &quot;\\u79BE&quot;, &quot;\\u2F73&quot;, &quot;\\u7A74&quot;, &quot;\\u2F74&quot;, &quot;\\u7ACB&quot;, &quot;\\u2F75&quot;, &quot;\\u7AF9&quot;, &quot;\\u2F76&quot;, &quot;\\u7C73&quot;, &quot;\\u2F77&quot;, &quot;\\u7CF8&quot;, &quot;\\u2F78&quot;, &quot;\\u7F36&quot;, &quot;\\u2F79&quot;, &quot;\\u7F51&quot;, &quot;\\u2F7A&quot;, &quot;\\u7F8A&quot;, &quot;\\u2F7B&quot;, &quot;\\u7FBD&quot;, &quot;\\u2F7C&quot;, &quot;\\u8001&quot;, &quot;\\u2F7D&quot;, &quot;\\u800C&quot;, &quot;\\u2F7E&quot;, &quot;\\u8012&quot;, &quot;\\u2F7F&quot;, &quot;\\u8033&quot;, &quot;\\u2F80&quot;, &quot;\\u807F&quot;, &quot;\\u2F81&quot;, &quot;\\u8089&quot;, &quot;\\u2F82&quot;, &quot;\\u81E3&quot;, &quot;\\u2F83&quot;, &quot;\\u81EA&quot;, &quot;\\u2F84&quot;, &quot;\\u81F3&quot;, &quot;\\u2F85&quot;, &quot;\\u81FC&quot;, &quot;\\u2F86&quot;, &quot;\\u820C&quot;, &quot;\\u2F87&quot;, &quot;\\u821B&quot;, &quot;\\u2F88&quot;, &quot;\\u821F&quot;, &quot;\\u2F89&quot;, &quot;\\u826E&quot;, &quot;\\u2F8A&quot;, &quot;\\u8272&quot;, &quot;\\u2F8B&quot;, &quot;\\u8278&quot;, &quot;\\u2F8C&quot;, &quot;\\u864D&quot;, &quot;\\u2F8D&quot;, &quot;\\u866B&quot;, &quot;\\u2F8E&quot;, &quot;\\u8840&quot;, &quot;\\u2F8F&quot;, &quot;\\u884C&quot;, &quot;\\u2F90&quot;, &quot;\\u8863&quot;, &quot;\\u2F91&quot;, &quot;\\u897E&quot;, &quot;\\u2F92&quot;, &quot;\\u898B&quot;, &quot;\\u2F93&quot;, &quot;\\u89D2&quot;, &quot;\\u2F94&quot;, &quot;\\u8A00&quot;, &quot;\\u2F95&quot;, &quot;\\u8C37&quot;, &quot;\\u2F96&quot;, &quot;\\u8C46&quot;, &quot;\\u2F97&quot;, &quot;\\u8C55&quot;, &quot;\\u2F98&quot;, &quot;\\u8C78&quot;, &quot;\\u2F99&quot;, &quot;\\u8C9D&quot;, &quot;\\u2F9A&quot;, &quot;\\u8D64&quot;, &quot;\\u2F9B&quot;, &quot;\\u8D70&quot;, &quot;\\u2F9C&quot;, &quot;\\u8DB3&quot;, &quot;\\u2F9D&quot;, &quot;\\u8EAB&quot;, &quot;\\u2F9E&quot;, &quot;\\u8ECA&quot;, &quot;\\u2F9F&quot;, &quot;\\u8F9B&quot;, &quot;\\u2FA0&quot;, &quot;\\u8FB0&quot;, &quot;\\u2FA1&quot;, &quot;\\u8FB5&quot;, &quot;\\u2FA2&quot;, &quot;\\u9091&quot;, &quot;\\u2FA3&quot;, &quot;\\u9149&quot;, &quot;\\u2FA4&quot;, &quot;\\u91C6&quot;, &quot;\\u2FA5&quot;, &quot;\\u91CC&quot;, &quot;\\u2FA6&quot;, &quot;\\u91D1&quot;, &quot;\\u2FA7&quot;, &quot;\\u9577&quot;, &quot;\\u2FA8&quot;, &quot;\\u9580&quot;, &quot;\\u2FA9&quot;, &quot;\\u961C&quot;, &quot;\\u2FAA&quot;, &quot;\\u96B6&quot;, &quot;\\u2FAB&quot;, &quot;\\u96B9&quot;, &quot;\\u2FAC&quot;, &quot;\\u96E8&quot;, &quot;\\u2FAD&quot;, &quot;\\u9751&quot;, &quot;\\u2FAE&quot;, &quot;\\u975E&quot;, &quot;\\u2FAF&quot;, &quot;\\u9762&quot;, &quot;\\u2FB0&quot;, &quot;\\u9769&quot;, &quot;\\u2FB1&quot;, &quot;\\u97CB&quot;, &quot;\\u2FB2&quot;, &quot;\\u97ED&quot;, &quot;\\u2FB3&quot;, &quot;\\u97F3&quot;, &quot;\\u2FB4&quot;, &quot;\\u9801&quot;, &quot;\\u2FB5&quot;, &quot;\\u98A8&quot;, &quot;\\u2FB6&quot;, &quot;\\u98DB&quot;, &quot;\\u2FB7&quot;, &quot;\\u98DF&quot;, &quot;\\u2FB8&quot;, &quot;\\u9996&quot;, &quot;\\u2FB9&quot;, &quot;\\u9999&quot;, &quot;\\u2FBA&quot;, &quot;\\u99AC&quot;, &quot;\\u2FBB&quot;, &quot;\\u9AA8&quot;, &quot;\\u2FBC&quot;, &quot;\\u9AD8&quot;, &quot;\\u2FBD&quot;, &quot;\\u9ADF&quot;, &quot;\\u2FBE&quot;, &quot;\\u9B25&quot;, &quot;\\u2FBF&quot;, &quot;\\u9B2F&quot;, &quot;\\u2FC0&quot;, &quot;\\u9B32&quot;, &quot;\\u2FC1&quot;, &quot;\\u9B3C&quot;, &quot;\\u2FC2&quot;, &quot;\\u9B5A&quot;, &quot;\\u2FC3&quot;, &quot;\\u9CE5&quot;, &quot;\\u2FC4&quot;, &quot;\\u9E75&quot;, &quot;\\u2FC5&quot;, &quot;\\u9E7F&quot;, &quot;\\u2FC6&quot;, &quot;\\u9EA5&quot;, &quot;\\u2FC7&quot;, &quot;\\u9EBB&quot;, &quot;\\u2FC8&quot;, &quot;\\u9EC3&quot;, &quot;\\u2FC9&quot;, &quot;\\u9ECD&quot;, &quot;\\u2FCA&quot;, &quot;\\u9ED1&quot;, &quot;\\u2FCB&quot;, &quot;\\u9EF9&quot;, &quot;\\u2FCC&quot;, &quot;\\u9EFD&quot;, &quot;\\u2FCD&quot;, &quot;\\u9F0E&quot;, &quot;\\u2FCE&quot;, &quot;\\u9F13&quot;, &quot;\\u2FCF&quot;, &quot;\\u9F20&quot;, &quot;\\u2FD0&quot;, &quot;\\u9F3B&quot;, &quot;\\u2FD1&quot;, &quot;\\u9F4A&quot;, &quot;\\u2FD2&quot;, &quot;\\u9F52&quot;, &quot;\\u2FD3&quot;, &quot;\\u9F8D&quot;, &quot;\\u2FD4&quot;, &quot;\\u9F9C&quot;, &quot;\\u2FD5&quot;, &quot;\\u9FA0&quot;, &quot;\\u3036&quot;, &quot;\\u3012&quot;, &quot;\\u3038&quot;, &quot;\\u5341&quot;, &quot;\\u3039&quot;, &quot;\\u5344&quot;, &quot;\\u303A&quot;, &quot;\\u5345&quot;, &quot;\\u309B&quot;, &quot;\\u0020\\u3099&quot;, &quot;\\u309C&quot;, &quot;\\u0020\\u309A&quot;, &quot;\\u3131&quot;, &quot;\\u1100&quot;, &quot;\\u3132&quot;, &quot;\\u1101&quot;, &quot;\\u3133&quot;, &quot;\\u11AA&quot;, &quot;\\u3134&quot;, &quot;\\u1102&quot;, &quot;\\u3135&quot;, &quot;\\u11AC&quot;, &quot;\\u3136&quot;, &quot;\\u11AD&quot;, &quot;\\u3137&quot;, &quot;\\u1103&quot;, &quot;\\u3138&quot;, &quot;\\u1104&quot;, &quot;\\u3139&quot;, &quot;\\u1105&quot;, &quot;\\u313A&quot;, &quot;\\u11B0&quot;, &quot;\\u313B&quot;, &quot;\\u11B1&quot;, &quot;\\u313C&quot;, &quot;\\u11B2&quot;, &quot;\\u313D&quot;, &quot;\\u11B3&quot;, &quot;\\u313E&quot;, &quot;\\u11B4&quot;, &quot;\\u313F&quot;, &quot;\\u11B5&quot;, &quot;\\u3140&quot;, &quot;\\u111A&quot;, &quot;\\u3141&quot;, &quot;\\u1106&quot;, &quot;\\u3142&quot;, &quot;\\u1107&quot;, &quot;\\u3143&quot;, &quot;\\u1108&quot;, &quot;\\u3144&quot;, &quot;\\u1121&quot;, &quot;\\u3145&quot;, &quot;\\u1109&quot;, &quot;\\u3146&quot;, &quot;\\u110A&quot;, &quot;\\u3147&quot;, &quot;\\u110B&quot;, &quot;\\u3148&quot;, &quot;\\u110C&quot;, &quot;\\u3149&quot;, &quot;\\u110D&quot;, &quot;\\u314A&quot;, &quot;\\u110E&quot;, &quot;\\u314B&quot;, &quot;\\u110F&quot;, &quot;\\u314C&quot;, &quot;\\u1110&quot;, &quot;\\u314D&quot;, &quot;\\u1111&quot;, &quot;\\u314E&quot;, &quot;\\u1112&quot;, &quot;\\u314F&quot;, &quot;\\u1161&quot;, &quot;\\u3150&quot;, &quot;\\u1162&quot;, &quot;\\u3151&quot;, &quot;\\u1163&quot;, &quot;\\u3152&quot;, &quot;\\u1164&quot;, &quot;\\u3153&quot;, &quot;\\u1165&quot;, &quot;\\u3154&quot;, &quot;\\u1166&quot;, &quot;\\u3155&quot;, &quot;\\u1167&quot;, &quot;\\u3156&quot;, &quot;\\u1168&quot;, &quot;\\u3157&quot;, &quot;\\u1169&quot;, &quot;\\u3158&quot;, &quot;\\u116A&quot;, &quot;\\u3159&quot;, &quot;\\u116B&quot;, &quot;\\u315A&quot;, &quot;\\u116C&quot;, &quot;\\u315B&quot;, &quot;\\u116D&quot;, &quot;\\u315C&quot;, &quot;\\u116E&quot;, &quot;\\u315D&quot;, &quot;\\u116F&quot;, &quot;\\u315E&quot;, &quot;\\u1170&quot;, &quot;\\u315F&quot;, &quot;\\u1171&quot;, &quot;\\u3160&quot;, &quot;\\u1172&quot;, &quot;\\u3161&quot;, &quot;\\u1173&quot;, &quot;\\u3162&quot;, &quot;\\u1174&quot;, &quot;\\u3163&quot;, &quot;\\u1175&quot;, &quot;\\u3164&quot;, &quot;\\u1160&quot;, &quot;\\u3165&quot;, &quot;\\u1114&quot;, &quot;\\u3166&quot;, &quot;\\u1115&quot;, &quot;\\u3167&quot;, &quot;\\u11C7&quot;, &quot;\\u3168&quot;, &quot;\\u11C8&quot;, &quot;\\u3169&quot;, &quot;\\u11CC&quot;, &quot;\\u316A&quot;, &quot;\\u11CE&quot;, &quot;\\u316B&quot;, &quot;\\u11D3&quot;, &quot;\\u316C&quot;, &quot;\\u11D7&quot;, &quot;\\u316D&quot;, &quot;\\u11D9&quot;, &quot;\\u316E&quot;, &quot;\\u111C&quot;, &quot;\\u316F&quot;, &quot;\\u11DD&quot;, &quot;\\u3170&quot;, &quot;\\u11DF&quot;, &quot;\\u3171&quot;, &quot;\\u111D&quot;, &quot;\\u3172&quot;, &quot;\\u111E&quot;, &quot;\\u3173&quot;, &quot;\\u1120&quot;, &quot;\\u3174&quot;, &quot;\\u1122&quot;, &quot;\\u3175&quot;, &quot;\\u1123&quot;, &quot;\\u3176&quot;, &quot;\\u1127&quot;, &quot;\\u3177&quot;, &quot;\\u1129&quot;, &quot;\\u3178&quot;, &quot;\\u112B&quot;, &quot;\\u3179&quot;, &quot;\\u112C&quot;, &quot;\\u317A&quot;, &quot;\\u112D&quot;, &quot;\\u317B&quot;, &quot;\\u112E&quot;, &quot;\\u317C&quot;, &quot;\\u112F&quot;, &quot;\\u317D&quot;, &quot;\\u1132&quot;, &quot;\\u317E&quot;, &quot;\\u1136&quot;, &quot;\\u317F&quot;, &quot;\\u1140&quot;, &quot;\\u3180&quot;, &quot;\\u1147&quot;, &quot;\\u3181&quot;, &quot;\\u114C&quot;, &quot;\\u3182&quot;, &quot;\\u11F1&quot;, &quot;\\u3183&quot;, &quot;\\u11F2&quot;, &quot;\\u3184&quot;, &quot;\\u1157&quot;, &quot;\\u3185&quot;, &quot;\\u1158&quot;, &quot;\\u3186&quot;, &quot;\\u1159&quot;, &quot;\\u3187&quot;, &quot;\\u1184&quot;, &quot;\\u3188&quot;, &quot;\\u1185&quot;, &quot;\\u3189&quot;, &quot;\\u1188&quot;, &quot;\\u318A&quot;, &quot;\\u1191&quot;, &quot;\\u318B&quot;, &quot;\\u1192&quot;, &quot;\\u318C&quot;, &quot;\\u1194&quot;, &quot;\\u318D&quot;, &quot;\\u119E&quot;, &quot;\\u318E&quot;, &quot;\\u11A1&quot;, &quot;\\u3200&quot;, &quot;\\u0028\\u1100\\u0029&quot;, &quot;\\u3201&quot;, &quot;\\u0028\\u1102\\u0029&quot;, &quot;\\u3202&quot;, &quot;\\u0028\\u1103\\u0029&quot;, &quot;\\u3203&quot;, &quot;\\u0028\\u1105\\u0029&quot;, &quot;\\u3204&quot;, &quot;\\u0028\\u1106\\u0029&quot;, &quot;\\u3205&quot;, &quot;\\u0028\\u1107\\u0029&quot;, &quot;\\u3206&quot;, &quot;\\u0028\\u1109\\u0029&quot;, &quot;\\u3207&quot;, &quot;\\u0028\\u110B\\u0029&quot;, &quot;\\u3208&quot;, &quot;\\u0028\\u110C\\u0029&quot;, &quot;\\u3209&quot;, &quot;\\u0028\\u110E\\u0029&quot;, &quot;\\u320A&quot;, &quot;\\u0028\\u110F\\u0029&quot;, &quot;\\u320B&quot;, &quot;\\u0028\\u1110\\u0029&quot;, &quot;\\u320C&quot;, &quot;\\u0028\\u1111\\u0029&quot;, &quot;\\u320D&quot;, &quot;\\u0028\\u1112\\u0029&quot;, &quot;\\u320E&quot;, &quot;\\u0028\\u1100\\u1161\\u0029&quot;, &quot;\\u320F&quot;, &quot;\\u0028\\u1102\\u1161\\u0029&quot;, &quot;\\u3210&quot;, &quot;\\u0028\\u1103\\u1161\\u0029&quot;, &quot;\\u3211&quot;, &quot;\\u0028\\u1105\\u1161\\u0029&quot;, &quot;\\u3212&quot;, &quot;\\u0028\\u1106\\u1161\\u0029&quot;, &quot;\\u3213&quot;, &quot;\\u0028\\u1107\\u1161\\u0029&quot;, &quot;\\u3214&quot;, &quot;\\u0028\\u1109\\u1161\\u0029&quot;, &quot;\\u3215&quot;, &quot;\\u0028\\u110B\\u1161\\u0029&quot;, &quot;\\u3216&quot;, &quot;\\u0028\\u110C\\u1161\\u0029&quot;, &quot;\\u3217&quot;, &quot;\\u0028\\u110E\\u1161\\u0029&quot;, &quot;\\u3218&quot;, &quot;\\u0028\\u110F\\u1161\\u0029&quot;, &quot;\\u3219&quot;, &quot;\\u0028\\u1110\\u1161\\u0029&quot;, &quot;\\u321A&quot;, &quot;\\u0028\\u1111\\u1161\\u0029&quot;, &quot;\\u321B&quot;, &quot;\\u0028\\u1112\\u1161\\u0029&quot;, &quot;\\u321C&quot;, &quot;\\u0028\\u110C\\u116E\\u0029&quot;, &quot;\\u321D&quot;, &quot;\\u0028\\u110B\\u1169\\u110C\\u1165\\u11AB\\u0029&quot;, &quot;\\u321E&quot;, &quot;\\u0028\\u110B\\u1169\\u1112\\u116E\\u0029&quot;, &quot;\\u3220&quot;, &quot;\\u0028\\u4E00\\u0029&quot;, &quot;\\u3221&quot;, &quot;\\u0028\\u4E8C\\u0029&quot;, &quot;\\u3222&quot;, &quot;\\u0028\\u4E09\\u0029&quot;, &quot;\\u3223&quot;, &quot;\\u0028\\u56DB\\u0029&quot;, &quot;\\u3224&quot;, &quot;\\u0028\\u4E94\\u0029&quot;, &quot;\\u3225&quot;, &quot;\\u0028\\u516D\\u0029&quot;, &quot;\\u3226&quot;, &quot;\\u0028\\u4E03\\u0029&quot;, &quot;\\u3227&quot;, &quot;\\u0028\\u516B\\u0029&quot;, &quot;\\u3228&quot;, &quot;\\u0028\\u4E5D\\u0029&quot;, &quot;\\u3229&quot;, &quot;\\u0028\\u5341\\u0029&quot;, &quot;\\u322A&quot;, &quot;\\u0028\\u6708\\u0029&quot;, &quot;\\u322B&quot;, &quot;\\u0028\\u706B\\u0029&quot;, &quot;\\u322C&quot;, &quot;\\u0028\\u6C34\\u0029&quot;, &quot;\\u322D&quot;, &quot;\\u0028\\u6728\\u0029&quot;, &quot;\\u322E&quot;, &quot;\\u0028\\u91D1\\u0029&quot;, &quot;\\u322F&quot;, &quot;\\u0028\\u571F\\u0029&quot;, &quot;\\u3230&quot;, &quot;\\u0028\\u65E5\\u0029&quot;, &quot;\\u3231&quot;, &quot;\\u0028\\u682A\\u0029&quot;, &quot;\\u3232&quot;, &quot;\\u0028\\u6709\\u0029&quot;, &quot;\\u3233&quot;, &quot;\\u0028\\u793E\\u0029&quot;, &quot;\\u3234&quot;, &quot;\\u0028\\u540D\\u0029&quot;, &quot;\\u3235&quot;, &quot;\\u0028\\u7279\\u0029&quot;, &quot;\\u3236&quot;, &quot;\\u0028\\u8CA1\\u0029&quot;, &quot;\\u3237&quot;, &quot;\\u0028\\u795D\\u0029&quot;, &quot;\\u3238&quot;, &quot;\\u0028\\u52B4\\u0029&quot;, &quot;\\u3239&quot;, &quot;\\u0028\\u4EE3\\u0029&quot;, &quot;\\u323A&quot;, &quot;\\u0028\\u547C\\u0029&quot;, &quot;\\u323B&quot;, &quot;\\u0028\\u5B66\\u0029&quot;, &quot;\\u323C&quot;, &quot;\\u0028\\u76E3\\u0029&quot;, &quot;\\u323D&quot;, &quot;\\u0028\\u4F01\\u0029&quot;, &quot;\\u323E&quot;, &quot;\\u0028\\u8CC7\\u0029&quot;, &quot;\\u323F&quot;, &quot;\\u0028\\u5354\\u0029&quot;, &quot;\\u3240&quot;, &quot;\\u0028\\u796D\\u0029&quot;, &quot;\\u3241&quot;, &quot;\\u0028\\u4F11\\u0029&quot;, &quot;\\u3242&quot;, &quot;\\u0028\\u81EA\\u0029&quot;, &quot;\\u3243&quot;, &quot;\\u0028\\u81F3\\u0029&quot;, &quot;\\u32C0&quot;, &quot;\\u0031\\u6708&quot;, &quot;\\u32C1&quot;, &quot;\\u0032\\u6708&quot;, &quot;\\u32C2&quot;, &quot;\\u0033\\u6708&quot;, &quot;\\u32C3&quot;, &quot;\\u0034\\u6708&quot;, &quot;\\u32C4&quot;, &quot;\\u0035\\u6708&quot;, &quot;\\u32C5&quot;, &quot;\\u0036\\u6708&quot;, &quot;\\u32C6&quot;, &quot;\\u0037\\u6708&quot;, &quot;\\u32C7&quot;, &quot;\\u0038\\u6708&quot;, &quot;\\u32C8&quot;, &quot;\\u0039\\u6708&quot;, &quot;\\u32C9&quot;, &quot;\\u0031\\u0030\\u6708&quot;, &quot;\\u32CA&quot;, &quot;\\u0031\\u0031\\u6708&quot;, &quot;\\u32CB&quot;, &quot;\\u0031\\u0032\\u6708&quot;, &quot;\\u3358&quot;, &quot;\\u0030\\u70B9&quot;, &quot;\\u3359&quot;, &quot;\\u0031\\u70B9&quot;, &quot;\\u335A&quot;, &quot;\\u0032\\u70B9&quot;, &quot;\\u335B&quot;, &quot;\\u0033\\u70B9&quot;, &quot;\\u335C&quot;, &quot;\\u0034\\u70B9&quot;, &quot;\\u335D&quot;, &quot;\\u0035\\u70B9&quot;, &quot;\\u335E&quot;, &quot;\\u0036\\u70B9&quot;, &quot;\\u335F&quot;, &quot;\\u0037\\u70B9&quot;, &quot;\\u3360&quot;, &quot;\\u0038\\u70B9&quot;, &quot;\\u3361&quot;, &quot;\\u0039\\u70B9&quot;, &quot;\\u3362&quot;, &quot;\\u0031\\u0030\\u70B9&quot;, &quot;\\u3363&quot;, &quot;\\u0031\\u0031\\u70B9&quot;, &quot;\\u3364&quot;, &quot;\\u0031\\u0032\\u70B9&quot;, &quot;\\u3365&quot;, &quot;\\u0031\\u0033\\u70B9&quot;, &quot;\\u3366&quot;, &quot;\\u0031\\u0034\\u70B9&quot;, &quot;\\u3367&quot;, &quot;\\u0031\\u0035\\u70B9&quot;, &quot;\\u3368&quot;, &quot;\\u0031\\u0036\\u70B9&quot;, &quot;\\u3369&quot;, &quot;\\u0031\\u0037\\u70B9&quot;, &quot;\\u336A&quot;, &quot;\\u0031\\u0038\\u70B9&quot;, &quot;\\u336B&quot;, &quot;\\u0031\\u0039\\u70B9&quot;, &quot;\\u336C&quot;, &quot;\\u0032\\u0030\\u70B9&quot;, &quot;\\u336D&quot;, &quot;\\u0032\\u0031\\u70B9&quot;, &quot;\\u336E&quot;, &quot;\\u0032\\u0032\\u70B9&quot;, &quot;\\u336F&quot;, &quot;\\u0032\\u0033\\u70B9&quot;, &quot;\\u3370&quot;, &quot;\\u0032\\u0034\\u70B9&quot;, &quot;\\u33E0&quot;, &quot;\\u0031\\u65E5&quot;, &quot;\\u33E1&quot;, &quot;\\u0032\\u65E5&quot;, &quot;\\u33E2&quot;, &quot;\\u0033\\u65E5&quot;, &quot;\\u33E3&quot;, &quot;\\u0034\\u65E5&quot;, &quot;\\u33E4&quot;, &quot;\\u0035\\u65E5&quot;, &quot;\\u33E5&quot;, &quot;\\u0036\\u65E5&quot;, &quot;\\u33E6&quot;, &quot;\\u0037\\u65E5&quot;, &quot;\\u33E7&quot;, &quot;\\u0038\\u65E5&quot;, &quot;\\u33E8&quot;, &quot;\\u0039\\u65E5&quot;, &quot;\\u33E9&quot;, &quot;\\u0031\\u0030\\u65E5&quot;, &quot;\\u33EA&quot;, &quot;\\u0031\\u0031\\u65E5&quot;, &quot;\\u33EB&quot;, &quot;\\u0031\\u0032\\u65E5&quot;, &quot;\\u33EC&quot;, &quot;\\u0031\\u0033\\u65E5&quot;, &quot;\\u33ED&quot;, &quot;\\u0031\\u0034\\u65E5&quot;, &quot;\\u33EE&quot;, &quot;\\u0031\\u0035\\u65E5&quot;, &quot;\\u33EF&quot;, &quot;\\u0031\\u0036\\u65E5&quot;, &quot;\\u33F0&quot;, &quot;\\u0031\\u0037\\u65E5&quot;, &quot;\\u33F1&quot;, &quot;\\u0031\\u0038\\u65E5&quot;, &quot;\\u33F2&quot;, &quot;\\u0031\\u0039\\u65E5&quot;, &quot;\\u33F3&quot;, &quot;\\u0032\\u0030\\u65E5&quot;, &quot;\\u33F4&quot;, &quot;\\u0032\\u0031\\u65E5&quot;, &quot;\\u33F5&quot;, &quot;\\u0032\\u0032\\u65E5&quot;, &quot;\\u33F6&quot;, &quot;\\u0032\\u0033\\u65E5&quot;, &quot;\\u33F7&quot;, &quot;\\u0032\\u0034\\u65E5&quot;, &quot;\\u33F8&quot;, &quot;\\u0032\\u0035\\u65E5&quot;, &quot;\\u33F9&quot;, &quot;\\u0032\\u0036\\u65E5&quot;, &quot;\\u33FA&quot;, &quot;\\u0032\\u0037\\u65E5&quot;, &quot;\\u33FB&quot;, &quot;\\u0032\\u0038\\u65E5&quot;, &quot;\\u33FC&quot;, &quot;\\u0032\\u0039\\u65E5&quot;, &quot;\\u33FD&quot;, &quot;\\u0033\\u0030\\u65E5&quot;, &quot;\\u33FE&quot;, &quot;\\u0033\\u0031\\u65E5&quot;, &quot;\\uFB00&quot;, &quot;\\u0066\\u0066&quot;, &quot;\\uFB01&quot;, &quot;\\u0066\\u0069&quot;, &quot;\\uFB02&quot;, &quot;\\u0066\\u006C&quot;, &quot;\\uFB03&quot;, &quot;\\u0066\\u0066\\u0069&quot;, &quot;\\uFB04&quot;, &quot;\\u0066\\u0066\\u006C&quot;, &quot;\\uFB05&quot;, &quot;\\u017F\\u0074&quot;, &quot;\\uFB06&quot;, &quot;\\u0073\\u0074&quot;, &quot;\\uFB13&quot;, &quot;\\u0574\\u0576&quot;, &quot;\\uFB14&quot;, &quot;\\u0574\\u0565&quot;, &quot;\\uFB15&quot;, &quot;\\u0574\\u056B&quot;, &quot;\\uFB16&quot;, &quot;\\u057E\\u0576&quot;, &quot;\\uFB17&quot;, &quot;\\u0574\\u056D&quot;, &quot;\\uFB4F&quot;, &quot;\\u05D0\\u05DC&quot;, &quot;\\uFB50&quot;, &quot;\\u0671&quot;, &quot;\\uFB51&quot;, &quot;\\u0671&quot;, &quot;\\uFB52&quot;, &quot;\\u067B&quot;, &quot;\\uFB53&quot;, &quot;\\u067B&quot;, &quot;\\uFB54&quot;, &quot;\\u067B&quot;, &quot;\\uFB55&quot;, &quot;\\u067B&quot;, &quot;\\uFB56&quot;, &quot;\\u067E&quot;, &quot;\\uFB57&quot;, &quot;\\u067E&quot;, &quot;\\uFB58&quot;, &quot;\\u067E&quot;, &quot;\\uFB59&quot;, &quot;\\u067E&quot;, &quot;\\uFB5A&quot;, &quot;\\u0680&quot;, &quot;\\uFB5B&quot;, &quot;\\u0680&quot;, &quot;\\uFB5C&quot;, &quot;\\u0680&quot;, &quot;\\uFB5D&quot;, &quot;\\u0680&quot;, &quot;\\uFB5E&quot;, &quot;\\u067A&quot;, &quot;\\uFB5F&quot;, &quot;\\u067A&quot;, &quot;\\uFB60&quot;, &quot;\\u067A&quot;, &quot;\\uFB61&quot;, &quot;\\u067A&quot;, &quot;\\uFB62&quot;, &quot;\\u067F&quot;, &quot;\\uFB63&quot;, &quot;\\u067F&quot;, &quot;\\uFB64&quot;, &quot;\\u067F&quot;, &quot;\\uFB65&quot;, &quot;\\u067F&quot;, &quot;\\uFB66&quot;, &quot;\\u0679&quot;, &quot;\\uFB67&quot;, &quot;\\u0679&quot;, &quot;\\uFB68&quot;, &quot;\\u0679&quot;, &quot;\\uFB69&quot;, &quot;\\u0679&quot;, &quot;\\uFB6A&quot;, &quot;\\u06A4&quot;, &quot;\\uFB6B&quot;, &quot;\\u06A4&quot;, &quot;\\uFB6C&quot;, &quot;\\u06A4&quot;, &quot;\\uFB6D&quot;, &quot;\\u06A4&quot;, &quot;\\uFB6E&quot;, &quot;\\u06A6&quot;, &quot;\\uFB6F&quot;, &quot;\\u06A6&quot;, &quot;\\uFB70&quot;, &quot;\\u06A6&quot;, &quot;\\uFB71&quot;, &quot;\\u06A6&quot;, &quot;\\uFB72&quot;, &quot;\\u0684&quot;, &quot;\\uFB73&quot;, &quot;\\u0684&quot;, &quot;\\uFB74&quot;, &quot;\\u0684&quot;, &quot;\\uFB75&quot;, &quot;\\u0684&quot;, &quot;\\uFB76&quot;, &quot;\\u0683&quot;, &quot;\\uFB77&quot;, &quot;\\u0683&quot;, &quot;\\uFB78&quot;, &quot;\\u0683&quot;, &quot;\\uFB79&quot;, &quot;\\u0683&quot;, &quot;\\uFB7A&quot;, &quot;\\u0686&quot;, &quot;\\uFB7B&quot;, &quot;\\u0686&quot;, &quot;\\uFB7C&quot;, &quot;\\u0686&quot;, &quot;\\uFB7D&quot;, &quot;\\u0686&quot;, &quot;\\uFB7E&quot;, &quot;\\u0687&quot;, &quot;\\uFB7F&quot;, &quot;\\u0687&quot;, &quot;\\uFB80&quot;, &quot;\\u0687&quot;, &quot;\\uFB81&quot;, &quot;\\u0687&quot;, &quot;\\uFB82&quot;, &quot;\\u068D&quot;, &quot;\\uFB83&quot;, &quot;\\u068D&quot;, &quot;\\uFB84&quot;, &quot;\\u068C&quot;, &quot;\\uFB85&quot;, &quot;\\u068C&quot;, &quot;\\uFB86&quot;, &quot;\\u068E&quot;, &quot;\\uFB87&quot;, &quot;\\u068E&quot;, &quot;\\uFB88&quot;, &quot;\\u0688&quot;, &quot;\\uFB89&quot;, &quot;\\u0688&quot;, &quot;\\uFB8A&quot;, &quot;\\u0698&quot;, &quot;\\uFB8B&quot;, &quot;\\u0698&quot;, &quot;\\uFB8C&quot;, &quot;\\u0691&quot;, &quot;\\uFB8D&quot;, &quot;\\u0691&quot;, &quot;\\uFB8E&quot;, &quot;\\u06A9&quot;, &quot;\\uFB8F&quot;, &quot;\\u06A9&quot;, &quot;\\uFB90&quot;, &quot;\\u06A9&quot;, &quot;\\uFB91&quot;, &quot;\\u06A9&quot;, &quot;\\uFB92&quot;, &quot;\\u06AF&quot;, &quot;\\uFB93&quot;, &quot;\\u06AF&quot;, &quot;\\uFB94&quot;, &quot;\\u06AF&quot;, &quot;\\uFB95&quot;, &quot;\\u06AF&quot;, &quot;\\uFB96&quot;, &quot;\\u06B3&quot;, &quot;\\uFB97&quot;, &quot;\\u06B3&quot;, &quot;\\uFB98&quot;, &quot;\\u06B3&quot;, &quot;\\uFB99&quot;, &quot;\\u06B3&quot;, &quot;\\uFB9A&quot;, &quot;\\u06B1&quot;, &quot;\\uFB9B&quot;, &quot;\\u06B1&quot;, &quot;\\uFB9C&quot;, &quot;\\u06B1&quot;, &quot;\\uFB9D&quot;, &quot;\\u06B1&quot;, &quot;\\uFB9E&quot;, &quot;\\u06BA&quot;, &quot;\\uFB9F&quot;, &quot;\\u06BA&quot;, &quot;\\uFBA0&quot;, &quot;\\u06BB&quot;, &quot;\\uFBA1&quot;, &quot;\\u06BB&quot;, &quot;\\uFBA2&quot;, &quot;\\u06BB&quot;, &quot;\\uFBA3&quot;, &quot;\\u06BB&quot;, &quot;\\uFBA4&quot;, &quot;\\u06C0&quot;, &quot;\\uFBA5&quot;, &quot;\\u06C0&quot;, &quot;\\uFBA6&quot;, &quot;\\u06C1&quot;, &quot;\\uFBA7&quot;, &quot;\\u06C1&quot;, &quot;\\uFBA8&quot;, &quot;\\u06C1&quot;, &quot;\\uFBA9&quot;, &quot;\\u06C1&quot;, &quot;\\uFBAA&quot;, &quot;\\u06BE&quot;, &quot;\\uFBAB&quot;, &quot;\\u06BE&quot;, &quot;\\uFBAC&quot;, &quot;\\u06BE&quot;, &quot;\\uFBAD&quot;, &quot;\\u06BE&quot;, &quot;\\uFBAE&quot;, &quot;\\u06D2&quot;, &quot;\\uFBAF&quot;, &quot;\\u06D2&quot;, &quot;\\uFBB0&quot;, &quot;\\u06D3&quot;, &quot;\\uFBB1&quot;, &quot;\\u06D3&quot;, &quot;\\uFBD3&quot;, &quot;\\u06AD&quot;, &quot;\\uFBD4&quot;, &quot;\\u06AD&quot;, &quot;\\uFBD5&quot;, &quot;\\u06AD&quot;, &quot;\\uFBD6&quot;, &quot;\\u06AD&quot;, &quot;\\uFBD7&quot;, &quot;\\u06C7&quot;, &quot;\\uFBD8&quot;, &quot;\\u06C7&quot;, &quot;\\uFBD9&quot;, &quot;\\u06C6&quot;, &quot;\\uFBDA&quot;, &quot;\\u06C6&quot;, &quot;\\uFBDB&quot;, &quot;\\u06C8&quot;, &quot;\\uFBDC&quot;, &quot;\\u06C8&quot;, &quot;\\uFBDD&quot;, &quot;\\u0677&quot;, &quot;\\uFBDE&quot;, &quot;\\u06CB&quot;, &quot;\\uFBDF&quot;, &quot;\\u06CB&quot;, &quot;\\uFBE0&quot;, &quot;\\u06C5&quot;, &quot;\\uFBE1&quot;, &quot;\\u06C5&quot;, &quot;\\uFBE2&quot;, &quot;\\u06C9&quot;, &quot;\\uFBE3&quot;, &quot;\\u06C9&quot;, &quot;\\uFBE4&quot;, &quot;\\u06D0&quot;, &quot;\\uFBE5&quot;, &quot;\\u06D0&quot;, &quot;\\uFBE6&quot;, &quot;\\u06D0&quot;, &quot;\\uFBE7&quot;, &quot;\\u06D0&quot;, &quot;\\uFBE8&quot;, &quot;\\u0649&quot;, &quot;\\uFBE9&quot;, &quot;\\u0649&quot;, &quot;\\uFBEA&quot;, &quot;\\u0626\\u0627&quot;, &quot;\\uFBEB&quot;, &quot;\\u0626\\u0627&quot;, &quot;\\uFBEC&quot;, &quot;\\u0626\\u06D5&quot;, &quot;\\uFBED&quot;, &quot;\\u0626\\u06D5&quot;, &quot;\\uFBEE&quot;, &quot;\\u0626\\u0648&quot;, &quot;\\uFBEF&quot;, &quot;\\u0626\\u0648&quot;, &quot;\\uFBF0&quot;, &quot;\\u0626\\u06C7&quot;, &quot;\\uFBF1&quot;, &quot;\\u0626\\u06C7&quot;, &quot;\\uFBF2&quot;, &quot;\\u0626\\u06C6&quot;, &quot;\\uFBF3&quot;, &quot;\\u0626\\u06C6&quot;, &quot;\\uFBF4&quot;, &quot;\\u0626\\u06C8&quot;, &quot;\\uFBF5&quot;, &quot;\\u0626\\u06C8&quot;, &quot;\\uFBF6&quot;, &quot;\\u0626\\u06D0&quot;, &quot;\\uFBF7&quot;, &quot;\\u0626\\u06D0&quot;, &quot;\\uFBF8&quot;, &quot;\\u0626\\u06D0&quot;, &quot;\\uFBF9&quot;, &quot;\\u0626\\u0649&quot;, &quot;\\uFBFA&quot;, &quot;\\u0626\\u0649&quot;, &quot;\\uFBFB&quot;, &quot;\\u0626\\u0649&quot;, &quot;\\uFBFC&quot;, &quot;\\u06CC&quot;, &quot;\\uFBFD&quot;, &quot;\\u06CC&quot;, &quot;\\uFBFE&quot;, &quot;\\u06CC&quot;, &quot;\\uFBFF&quot;, &quot;\\u06CC&quot;, &quot;\\uFC00&quot;, &quot;\\u0626\\u062C&quot;, &quot;\\uFC01&quot;, &quot;\\u0626\\u062D&quot;, &quot;\\uFC02&quot;, &quot;\\u0626\\u0645&quot;, &quot;\\uFC03&quot;, &quot;\\u0626\\u0649&quot;, &quot;\\uFC04&quot;, &quot;\\u0626\\u064A&quot;, &quot;\\uFC05&quot;, &quot;\\u0628\\u062C&quot;, &quot;\\uFC06&quot;, &quot;\\u0628\\u062D&quot;, &quot;\\uFC07&quot;, &quot;\\u0628\\u062E&quot;, &quot;\\uFC08&quot;, &quot;\\u0628\\u0645&quot;, &quot;\\uFC09&quot;, &quot;\\u0628\\u0649&quot;, &quot;\\uFC0A&quot;, &quot;\\u0628\\u064A&quot;, &quot;\\uFC0B&quot;, &quot;\\u062A\\u062C&quot;, &quot;\\uFC0C&quot;, &quot;\\u062A\\u062D&quot;, &quot;\\uFC0D&quot;, &quot;\\u062A\\u062E&quot;, &quot;\\uFC0E&quot;, &quot;\\u062A\\u0645&quot;, &quot;\\uFC0F&quot;, &quot;\\u062A\\u0649&quot;, &quot;\\uFC10&quot;, &quot;\\u062A\\u064A&quot;, &quot;\\uFC11&quot;, &quot;\\u062B\\u062C&quot;, &quot;\\uFC12&quot;, &quot;\\u062B\\u0645&quot;, &quot;\\uFC13&quot;, &quot;\\u062B\\u0649&quot;, &quot;\\uFC14&quot;, &quot;\\u062B\\u064A&quot;, &quot;\\uFC15&quot;, &quot;\\u062C\\u062D&quot;, &quot;\\uFC16&quot;, &quot;\\u062C\\u0645&quot;, &quot;\\uFC17&quot;, &quot;\\u062D\\u062C&quot;, &quot;\\uFC18&quot;, &quot;\\u062D\\u0645&quot;, &quot;\\uFC19&quot;, &quot;\\u062E\\u062C&quot;, &quot;\\uFC1A&quot;, &quot;\\u062E\\u062D&quot;, &quot;\\uFC1B&quot;, &quot;\\u062E\\u0645&quot;, &quot;\\uFC1C&quot;, &quot;\\u0633\\u062C&quot;, &quot;\\uFC1D&quot;, &quot;\\u0633\\u062D&quot;, &quot;\\uFC1E&quot;, &quot;\\u0633\\u062E&quot;, &quot;\\uFC1F&quot;, &quot;\\u0633\\u0645&quot;, &quot;\\uFC20&quot;, &quot;\\u0635\\u062D&quot;, &quot;\\uFC21&quot;, &quot;\\u0635\\u0645&quot;, &quot;\\uFC22&quot;, &quot;\\u0636\\u062C&quot;, &quot;\\uFC23&quot;, &quot;\\u0636\\u062D&quot;, &quot;\\uFC24&quot;, &quot;\\u0636\\u062E&quot;, &quot;\\uFC25&quot;, &quot;\\u0636\\u0645&quot;, &quot;\\uFC26&quot;, &quot;\\u0637\\u062D&quot;, &quot;\\uFC27&quot;, &quot;\\u0637\\u0645&quot;, &quot;\\uFC28&quot;, &quot;\\u0638\\u0645&quot;, &quot;\\uFC29&quot;, &quot;\\u0639\\u062C&quot;, &quot;\\uFC2A&quot;, &quot;\\u0639\\u0645&quot;, &quot;\\uFC2B&quot;, &quot;\\u063A\\u062C&quot;, &quot;\\uFC2C&quot;, &quot;\\u063A\\u0645&quot;, &quot;\\uFC2D&quot;, &quot;\\u0641\\u062C&quot;, &quot;\\uFC2E&quot;, &quot;\\u0641\\u062D&quot;, &quot;\\uFC2F&quot;, &quot;\\u0641\\u062E&quot;, &quot;\\uFC30&quot;, &quot;\\u0641\\u0645&quot;, &quot;\\uFC31&quot;, &quot;\\u0641\\u0649&quot;, &quot;\\uFC32&quot;, &quot;\\u0641\\u064A&quot;, &quot;\\uFC33&quot;, &quot;\\u0642\\u062D&quot;, &quot;\\uFC34&quot;, &quot;\\u0642\\u0645&quot;, &quot;\\uFC35&quot;, &quot;\\u0642\\u0649&quot;, &quot;\\uFC36&quot;, &quot;\\u0642\\u064A&quot;, &quot;\\uFC37&quot;, &quot;\\u0643\\u0627&quot;, &quot;\\uFC38&quot;, &quot;\\u0643\\u062C&quot;, &quot;\\uFC39&quot;, &quot;\\u0643\\u062D&quot;, &quot;\\uFC3A&quot;, &quot;\\u0643\\u062E&quot;, &quot;\\uFC3B&quot;, &quot;\\u0643\\u0644&quot;, &quot;\\uFC3C&quot;, &quot;\\u0643\\u0645&quot;, &quot;\\uFC3D&quot;, &quot;\\u0643\\u0649&quot;, &quot;\\uFC3E&quot;, &quot;\\u0643\\u064A&quot;, &quot;\\uFC3F&quot;, &quot;\\u0644\\u062C&quot;, &quot;\\uFC40&quot;, &quot;\\u0644\\u062D&quot;, &quot;\\uFC41&quot;, &quot;\\u0644\\u062E&quot;, &quot;\\uFC42&quot;, &quot;\\u0644\\u0645&quot;, &quot;\\uFC43&quot;, &quot;\\u0644\\u0649&quot;, &quot;\\uFC44&quot;, &quot;\\u0644\\u064A&quot;, &quot;\\uFC45&quot;, &quot;\\u0645\\u062C&quot;, &quot;\\uFC46&quot;, &quot;\\u0645\\u062D&quot;, &quot;\\uFC47&quot;, &quot;\\u0645\\u062E&quot;, &quot;\\uFC48&quot;, &quot;\\u0645\\u0645&quot;, &quot;\\uFC49&quot;, &quot;\\u0645\\u0649&quot;, &quot;\\uFC4A&quot;, &quot;\\u0645\\u064A&quot;, &quot;\\uFC4B&quot;, &quot;\\u0646\\u062C&quot;, &quot;\\uFC4C&quot;, &quot;\\u0646\\u062D&quot;, &quot;\\uFC4D&quot;, &quot;\\u0646\\u062E&quot;, &quot;\\uFC4E&quot;, &quot;\\u0646\\u0645&quot;, &quot;\\uFC4F&quot;, &quot;\\u0646\\u0649&quot;, &quot;\\uFC50&quot;, &quot;\\u0646\\u064A&quot;, &quot;\\uFC51&quot;, &quot;\\u0647\\u062C&quot;, &quot;\\uFC52&quot;, &quot;\\u0647\\u0645&quot;, &quot;\\uFC53&quot;, &quot;\\u0647\\u0649&quot;, &quot;\\uFC54&quot;, &quot;\\u0647\\u064A&quot;, &quot;\\uFC55&quot;, &quot;\\u064A\\u062C&quot;, &quot;\\uFC56&quot;, &quot;\\u064A\\u062D&quot;, &quot;\\uFC57&quot;, &quot;\\u064A\\u062E&quot;, &quot;\\uFC58&quot;, &quot;\\u064A\\u0645&quot;, &quot;\\uFC59&quot;, &quot;\\u064A\\u0649&quot;, &quot;\\uFC5A&quot;, &quot;\\u064A\\u064A&quot;, &quot;\\uFC5B&quot;, &quot;\\u0630\\u0670&quot;, &quot;\\uFC5C&quot;, &quot;\\u0631\\u0670&quot;, &quot;\\uFC5D&quot;, &quot;\\u0649\\u0670&quot;, &quot;\\uFC5E&quot;, &quot;\\u0020\\u064C\\u0651&quot;, &quot;\\uFC5F&quot;, &quot;\\u0020\\u064D\\u0651&quot;, &quot;\\uFC60&quot;, &quot;\\u0020\\u064E\\u0651&quot;, &quot;\\uFC61&quot;, &quot;\\u0020\\u064F\\u0651&quot;, &quot;\\uFC62&quot;, &quot;\\u0020\\u0650\\u0651&quot;, &quot;\\uFC63&quot;, &quot;\\u0020\\u0651\\u0670&quot;, &quot;\\uFC64&quot;, &quot;\\u0626\\u0631&quot;, &quot;\\uFC65&quot;, &quot;\\u0626\\u0632&quot;, &quot;\\uFC66&quot;, &quot;\\u0626\\u0645&quot;, &quot;\\uFC67&quot;, &quot;\\u0626\\u0646&quot;, &quot;\\uFC68&quot;, &quot;\\u0626\\u0649&quot;, &quot;\\uFC69&quot;, &quot;\\u0626\\u064A&quot;, &quot;\\uFC6A&quot;, &quot;\\u0628\\u0631&quot;, &quot;\\uFC6B&quot;, &quot;\\u0628\\u0632&quot;, &quot;\\uFC6C&quot;, &quot;\\u0628\\u0645&quot;, &quot;\\uFC6D&quot;, &quot;\\u0628\\u0646&quot;, &quot;\\uFC6E&quot;, &quot;\\u0628\\u0649&quot;, &quot;\\uFC6F&quot;, &quot;\\u0628\\u064A&quot;, &quot;\\uFC70&quot;, &quot;\\u062A\\u0631&quot;, &quot;\\uFC71&quot;, &quot;\\u062A\\u0632&quot;, &quot;\\uFC72&quot;, &quot;\\u062A\\u0645&quot;, &quot;\\uFC73&quot;, &quot;\\u062A\\u0646&quot;, &quot;\\uFC74&quot;, &quot;\\u062A\\u0649&quot;, &quot;\\uFC75&quot;, &quot;\\u062A\\u064A&quot;, &quot;\\uFC76&quot;, &quot;\\u062B\\u0631&quot;, &quot;\\uFC77&quot;, &quot;\\u062B\\u0632&quot;, &quot;\\uFC78&quot;, &quot;\\u062B\\u0645&quot;, &quot;\\uFC79&quot;, &quot;\\u062B\\u0646&quot;, &quot;\\uFC7A&quot;, &quot;\\u062B\\u0649&quot;, &quot;\\uFC7B&quot;, &quot;\\u062B\\u064A&quot;, &quot;\\uFC7C&quot;, &quot;\\u0641\\u0649&quot;, &quot;\\uFC7D&quot;, &quot;\\u0641\\u064A&quot;, &quot;\\uFC7E&quot;, &quot;\\u0642\\u0649&quot;, &quot;\\uFC7F&quot;, &quot;\\u0642\\u064A&quot;, &quot;\\uFC80&quot;, &quot;\\u0643\\u0627&quot;, &quot;\\uFC81&quot;, &quot;\\u0643\\u0644&quot;, &quot;\\uFC82&quot;, &quot;\\u0643\\u0645&quot;, &quot;\\uFC83&quot;, &quot;\\u0643\\u0649&quot;, &quot;\\uFC84&quot;, &quot;\\u0643\\u064A&quot;, &quot;\\uFC85&quot;, &quot;\\u0644\\u0645&quot;, &quot;\\uFC86&quot;, &quot;\\u0644\\u0649&quot;, &quot;\\uFC87&quot;, &quot;\\u0644\\u064A&quot;, &quot;\\uFC88&quot;, &quot;\\u0645\\u0627&quot;, &quot;\\uFC89&quot;, &quot;\\u0645\\u0645&quot;, &quot;\\uFC8A&quot;, &quot;\\u0646\\u0631&quot;, &quot;\\uFC8B&quot;, &quot;\\u0646\\u0632&quot;, &quot;\\uFC8C&quot;, &quot;\\u0646\\u0645&quot;, &quot;\\uFC8D&quot;, &quot;\\u0646\\u0646&quot;, &quot;\\uFC8E&quot;, &quot;\\u0646\\u0649&quot;, &quot;\\uFC8F&quot;, &quot;\\u0646\\u064A&quot;, &quot;\\uFC90&quot;, &quot;\\u0649\\u0670&quot;, &quot;\\uFC91&quot;, &quot;\\u064A\\u0631&quot;, &quot;\\uFC92&quot;, &quot;\\u064A\\u0632&quot;, &quot;\\uFC93&quot;, &quot;\\u064A\\u0645&quot;, &quot;\\uFC94&quot;, &quot;\\u064A\\u0646&quot;, &quot;\\uFC95&quot;, &quot;\\u064A\\u0649&quot;, &quot;\\uFC96&quot;, &quot;\\u064A\\u064A&quot;, &quot;\\uFC97&quot;, &quot;\\u0626\\u062C&quot;, &quot;\\uFC98&quot;, &quot;\\u0626\\u062D&quot;, &quot;\\uFC99&quot;, &quot;\\u0626\\u062E&quot;, &quot;\\uFC9A&quot;, &quot;\\u0626\\u0645&quot;, &quot;\\uFC9B&quot;, &quot;\\u0626\\u0647&quot;, &quot;\\uFC9C&quot;, &quot;\\u0628\\u062C&quot;, &quot;\\uFC9D&quot;, &quot;\\u0628\\u062D&quot;, &quot;\\uFC9E&quot;, &quot;\\u0628\\u062E&quot;, &quot;\\uFC9F&quot;, &quot;\\u0628\\u0645&quot;, &quot;\\uFCA0&quot;, &quot;\\u0628\\u0647&quot;, &quot;\\uFCA1&quot;, &quot;\\u062A\\u062C&quot;, &quot;\\uFCA2&quot;, &quot;\\u062A\\u062D&quot;, &quot;\\uFCA3&quot;, &quot;\\u062A\\u062E&quot;, &quot;\\uFCA4&quot;, &quot;\\u062A\\u0645&quot;, &quot;\\uFCA5&quot;, &quot;\\u062A\\u0647&quot;, &quot;\\uFCA6&quot;, &quot;\\u062B\\u0645&quot;, &quot;\\uFCA7&quot;, &quot;\\u062C\\u062D&quot;, &quot;\\uFCA8&quot;, &quot;\\u062C\\u0645&quot;, &quot;\\uFCA9&quot;, &quot;\\u062D\\u062C&quot;, &quot;\\uFCAA&quot;, &quot;\\u062D\\u0645&quot;, &quot;\\uFCAB&quot;, &quot;\\u062E\\u062C&quot;, &quot;\\uFCAC&quot;, &quot;\\u062E\\u0645&quot;, &quot;\\uFCAD&quot;, &quot;\\u0633\\u062C&quot;, &quot;\\uFCAE&quot;, &quot;\\u0633\\u062D&quot;, &quot;\\uFCAF&quot;, &quot;\\u0633\\u062E&quot;, &quot;\\uFCB0&quot;, &quot;\\u0633\\u0645&quot;, &quot;\\uFCB1&quot;, &quot;\\u0635\\u062D&quot;, &quot;\\uFCB2&quot;, &quot;\\u0635\\u062E&quot;, &quot;\\uFCB3&quot;, &quot;\\u0635\\u0645&quot;, &quot;\\uFCB4&quot;, &quot;\\u0636\\u062C&quot;, &quot;\\uFCB5&quot;, &quot;\\u0636\\u062D&quot;, &quot;\\uFCB6&quot;, &quot;\\u0636\\u062E&quot;, &quot;\\uFCB7&quot;, &quot;\\u0636\\u0645&quot;, &quot;\\uFCB8&quot;, &quot;\\u0637\\u062D&quot;, &quot;\\uFCB9&quot;, &quot;\\u0638\\u0645&quot;, &quot;\\uFCBA&quot;, &quot;\\u0639\\u062C&quot;, &quot;\\uFCBB&quot;, &quot;\\u0639\\u0645&quot;, &quot;\\uFCBC&quot;, &quot;\\u063A\\u062C&quot;, &quot;\\uFCBD&quot;, &quot;\\u063A\\u0645&quot;, &quot;\\uFCBE&quot;, &quot;\\u0641\\u062C&quot;, &quot;\\uFCBF&quot;, &quot;\\u0641\\u062D&quot;, &quot;\\uFCC0&quot;, &quot;\\u0641\\u062E&quot;, &quot;\\uFCC1&quot;, &quot;\\u0641\\u0645&quot;, &quot;\\uFCC2&quot;, &quot;\\u0642\\u062D&quot;, &quot;\\uFCC3&quot;, &quot;\\u0642\\u0645&quot;, &quot;\\uFCC4&quot;, &quot;\\u0643\\u062C&quot;, &quot;\\uFCC5&quot;, &quot;\\u0643\\u062D&quot;, &quot;\\uFCC6&quot;, &quot;\\u0643\\u062E&quot;, &quot;\\uFCC7&quot;, &quot;\\u0643\\u0644&quot;, &quot;\\uFCC8&quot;, &quot;\\u0643\\u0645&quot;, &quot;\\uFCC9&quot;, &quot;\\u0644\\u062C&quot;, &quot;\\uFCCA&quot;, &quot;\\u0644\\u062D&quot;, &quot;\\uFCCB&quot;, &quot;\\u0644\\u062E&quot;, &quot;\\uFCCC&quot;, &quot;\\u0644\\u0645&quot;, &quot;\\uFCCD&quot;, &quot;\\u0644\\u0647&quot;, &quot;\\uFCCE&quot;, &quot;\\u0645\\u062C&quot;, &quot;\\uFCCF&quot;, &quot;\\u0645\\u062D&quot;, &quot;\\uFCD0&quot;, &quot;\\u0645\\u062E&quot;, &quot;\\uFCD1&quot;, &quot;\\u0645\\u0645&quot;, &quot;\\uFCD2&quot;, &quot;\\u0646\\u062C&quot;, &quot;\\uFCD3&quot;, &quot;\\u0646\\u062D&quot;, &quot;\\uFCD4&quot;, &quot;\\u0646\\u062E&quot;, &quot;\\uFCD5&quot;, &quot;\\u0646\\u0645&quot;, &quot;\\uFCD6&quot;, &quot;\\u0646\\u0647&quot;, &quot;\\uFCD7&quot;, &quot;\\u0647\\u062C&quot;, &quot;\\uFCD8&quot;, &quot;\\u0647\\u0645&quot;, &quot;\\uFCD9&quot;, &quot;\\u0647\\u0670&quot;, &quot;\\uFCDA&quot;, &quot;\\u064A\\u062C&quot;, &quot;\\uFCDB&quot;, &quot;\\u064A\\u062D&quot;, &quot;\\uFCDC&quot;, &quot;\\u064A\\u062E&quot;, &quot;\\uFCDD&quot;, &quot;\\u064A\\u0645&quot;, &quot;\\uFCDE&quot;, &quot;\\u064A\\u0647&quot;, &quot;\\uFCDF&quot;, &quot;\\u0626\\u0645&quot;, &quot;\\uFCE0&quot;, &quot;\\u0626\\u0647&quot;, &quot;\\uFCE1&quot;, &quot;\\u0628\\u0645&quot;, &quot;\\uFCE2&quot;, &quot;\\u0628\\u0647&quot;, &quot;\\uFCE3&quot;, &quot;\\u062A\\u0645&quot;, &quot;\\uFCE4&quot;, &quot;\\u062A\\u0647&quot;, &quot;\\uFCE5&quot;, &quot;\\u062B\\u0645&quot;, &quot;\\uFCE6&quot;, &quot;\\u062B\\u0647&quot;, &quot;\\uFCE7&quot;, &quot;\\u0633\\u0645&quot;, &quot;\\uFCE8&quot;, &quot;\\u0633\\u0647&quot;, &quot;\\uFCE9&quot;, &quot;\\u0634\\u0645&quot;, &quot;\\uFCEA&quot;, &quot;\\u0634\\u0647&quot;, &quot;\\uFCEB&quot;, &quot;\\u0643\\u0644&quot;, &quot;\\uFCEC&quot;, &quot;\\u0643\\u0645&quot;, &quot;\\uFCED&quot;, &quot;\\u0644\\u0645&quot;, &quot;\\uFCEE&quot;, &quot;\\u0646\\u0645&quot;, &quot;\\uFCEF&quot;, &quot;\\u0646\\u0647&quot;, &quot;\\uFCF0&quot;, &quot;\\u064A\\u0645&quot;, &quot;\\uFCF1&quot;, &quot;\\u064A\\u0647&quot;, &quot;\\uFCF2&quot;, &quot;\\u0640\\u064E\\u0651&quot;, &quot;\\uFCF3&quot;, &quot;\\u0640\\u064F\\u0651&quot;, &quot;\\uFCF4&quot;, &quot;\\u0640\\u0650\\u0651&quot;, &quot;\\uFCF5&quot;, &quot;\\u0637\\u0649&quot;, &quot;\\uFCF6&quot;, &quot;\\u0637\\u064A&quot;, &quot;\\uFCF7&quot;, &quot;\\u0639\\u0649&quot;, &quot;\\uFCF8&quot;, &quot;\\u0639\\u064A&quot;, &quot;\\uFCF9&quot;, &quot;\\u063A\\u0649&quot;, &quot;\\uFCFA&quot;, &quot;\\u063A\\u064A&quot;, &quot;\\uFCFB&quot;, &quot;\\u0633\\u0649&quot;, &quot;\\uFCFC&quot;, &quot;\\u0633\\u064A&quot;, &quot;\\uFCFD&quot;, &quot;\\u0634\\u0649&quot;, &quot;\\uFCFE&quot;, &quot;\\u0634\\u064A&quot;, &quot;\\uFCFF&quot;, &quot;\\u062D\\u0649&quot;, &quot;\\uFD00&quot;, &quot;\\u062D\\u064A&quot;, &quot;\\uFD01&quot;, &quot;\\u062C\\u0649&quot;, &quot;\\uFD02&quot;, &quot;\\u062C\\u064A&quot;, &quot;\\uFD03&quot;, &quot;\\u062E\\u0649&quot;, &quot;\\uFD04&quot;, &quot;\\u062E\\u064A&quot;, &quot;\\uFD05&quot;, &quot;\\u0635\\u0649&quot;, &quot;\\uFD06&quot;, &quot;\\u0635\\u064A&quot;, &quot;\\uFD07&quot;, &quot;\\u0636\\u0649&quot;, &quot;\\uFD08&quot;, &quot;\\u0636\\u064A&quot;, &quot;\\uFD09&quot;, &quot;\\u0634\\u062C&quot;, &quot;\\uFD0A&quot;, &quot;\\u0634\\u062D&quot;, &quot;\\uFD0B&quot;, &quot;\\u0634\\u062E&quot;, &quot;\\uFD0C&quot;, &quot;\\u0634\\u0645&quot;, &quot;\\uFD0D&quot;, &quot;\\u0634\\u0631&quot;, &quot;\\uFD0E&quot;, &quot;\\u0633\\u0631&quot;, &quot;\\uFD0F&quot;, &quot;\\u0635\\u0631&quot;, &quot;\\uFD10&quot;, &quot;\\u0636\\u0631&quot;, &quot;\\uFD11&quot;, &quot;\\u0637\\u0649&quot;, &quot;\\uFD12&quot;, &quot;\\u0637\\u064A&quot;, &quot;\\uFD13&quot;, &quot;\\u0639\\u0649&quot;, &quot;\\uFD14&quot;, &quot;\\u0639\\u064A&quot;, &quot;\\uFD15&quot;, &quot;\\u063A\\u0649&quot;, &quot;\\uFD16&quot;, &quot;\\u063A\\u064A&quot;, &quot;\\uFD17&quot;, &quot;\\u0633\\u0649&quot;, &quot;\\uFD18&quot;, &quot;\\u0633\\u064A&quot;, &quot;\\uFD19&quot;, &quot;\\u0634\\u0649&quot;, &quot;\\uFD1A&quot;, &quot;\\u0634\\u064A&quot;, &quot;\\uFD1B&quot;, &quot;\\u062D\\u0649&quot;, &quot;\\uFD1C&quot;, &quot;\\u062D\\u064A&quot;, &quot;\\uFD1D&quot;, &quot;\\u062C\\u0649&quot;, &quot;\\uFD1E&quot;, &quot;\\u062C\\u064A&quot;, &quot;\\uFD1F&quot;, &quot;\\u062E\\u0649&quot;, &quot;\\uFD20&quot;, &quot;\\u062E\\u064A&quot;, &quot;\\uFD21&quot;, &quot;\\u0635\\u0649&quot;, &quot;\\uFD22&quot;, &quot;\\u0635\\u064A&quot;, &quot;\\uFD23&quot;, &quot;\\u0636\\u0649&quot;, &quot;\\uFD24&quot;, &quot;\\u0636\\u064A&quot;, &quot;\\uFD25&quot;, &quot;\\u0634\\u062C&quot;, &quot;\\uFD26&quot;, &quot;\\u0634\\u062D&quot;, &quot;\\uFD27&quot;, &quot;\\u0634\\u062E&quot;, &quot;\\uFD28&quot;, &quot;\\u0634\\u0645&quot;, &quot;\\uFD29&quot;, &quot;\\u0634\\u0631&quot;, &quot;\\uFD2A&quot;, &quot;\\u0633\\u0631&quot;, &quot;\\uFD2B&quot;, &quot;\\u0635\\u0631&quot;, &quot;\\uFD2C&quot;, &quot;\\u0636\\u0631&quot;, &quot;\\uFD2D&quot;, &quot;\\u0634\\u062C&quot;, &quot;\\uFD2E&quot;, &quot;\\u0634\\u062D&quot;, &quot;\\uFD2F&quot;, &quot;\\u0634\\u062E&quot;, &quot;\\uFD30&quot;, &quot;\\u0634\\u0645&quot;, &quot;\\uFD31&quot;, &quot;\\u0633\\u0647&quot;, &quot;\\uFD32&quot;, &quot;\\u0634\\u0647&quot;, &quot;\\uFD33&quot;, &quot;\\u0637\\u0645&quot;, &quot;\\uFD34&quot;, &quot;\\u0633\\u062C&quot;, &quot;\\uFD35&quot;, &quot;\\u0633\\u062D&quot;, &quot;\\uFD36&quot;, &quot;\\u0633\\u062E&quot;, &quot;\\uFD37&quot;, &quot;\\u0634\\u062C&quot;, &quot;\\uFD38&quot;, &quot;\\u0634\\u062D&quot;, &quot;\\uFD39&quot;, &quot;\\u0634\\u062E&quot;, &quot;\\uFD3A&quot;, &quot;\\u0637\\u0645&quot;, &quot;\\uFD3B&quot;, &quot;\\u0638\\u0645&quot;, &quot;\\uFD3C&quot;, &quot;\\u0627\\u064B&quot;, &quot;\\uFD3D&quot;, &quot;\\u0627\\u064B&quot;, &quot;\\uFD50&quot;, &quot;\\u062A\\u062C\\u0645&quot;, &quot;\\uFD51&quot;, &quot;\\u062A\\u062D\\u062C&quot;, &quot;\\uFD52&quot;, &quot;\\u062A\\u062D\\u062C&quot;, &quot;\\uFD53&quot;, &quot;\\u062A\\u062D\\u0645&quot;, &quot;\\uFD54&quot;, &quot;\\u062A\\u062E\\u0645&quot;, &quot;\\uFD55&quot;, &quot;\\u062A\\u0645\\u062C&quot;, &quot;\\uFD56&quot;, &quot;\\u062A\\u0645\\u062D&quot;, &quot;\\uFD57&quot;, &quot;\\u062A\\u0645\\u062E&quot;, &quot;\\uFD58&quot;, &quot;\\u062C\\u0645\\u062D&quot;, &quot;\\uFD59&quot;, &quot;\\u062C\\u0645\\u062D&quot;, &quot;\\uFD5A&quot;, &quot;\\u062D\\u0645\\u064A&quot;, &quot;\\uFD5B&quot;, &quot;\\u062D\\u0645\\u0649&quot;, &quot;\\uFD5C&quot;, &quot;\\u0633\\u062D\\u062C&quot;, &quot;\\uFD5D&quot;, &quot;\\u0633\\u062C\\u062D&quot;, &quot;\\uFD5E&quot;, &quot;\\u0633\\u062C\\u0649&quot;, &quot;\\uFD5F&quot;, &quot;\\u0633\\u0645\\u062D&quot;, &quot;\\uFD60&quot;, &quot;\\u0633\\u0645\\u062D&quot;, &quot;\\uFD61&quot;, &quot;\\u0633\\u0645\\u062C&quot;, &quot;\\uFD62&quot;, &quot;\\u0633\\u0645\\u0645&quot;, &quot;\\uFD63&quot;, &quot;\\u0633\\u0645\\u0645&quot;, &quot;\\uFD64&quot;, &quot;\\u0635\\u062D\\u062D&quot;, &quot;\\uFD65&quot;, &quot;\\u0635\\u062D\\u062D&quot;, &quot;\\uFD66&quot;, &quot;\\u0635\\u0645\\u0645&quot;, &quot;\\uFD67&quot;, &quot;\\u0634\\u062D\\u0645&quot;, &quot;\\uFD68&quot;, &quot;\\u0634\\u062D\\u0645&quot;, &quot;\\uFD69&quot;, &quot;\\u0634\\u062C\\u064A&quot;, &quot;\\uFD6A&quot;, &quot;\\u0634\\u0645\\u062E&quot;, &quot;\\uFD6B&quot;, &quot;\\u0634\\u0645\\u062E&quot;, &quot;\\uFD6C&quot;, &quot;\\u0634\\u0645\\u0645&quot;, &quot;\\uFD6D&quot;, &quot;\\u0634\\u0645\\u0645&quot;, &quot;\\uFD6E&quot;, &quot;\\u0636\\u062D\\u0649&quot;, &quot;\\uFD6F&quot;, &quot;\\u0636\\u062E\\u0645&quot;, &quot;\\uFD70&quot;, &quot;\\u0636\\u062E\\u0645&quot;, &quot;\\uFD71&quot;, &quot;\\u0637\\u0645\\u062D&quot;, &quot;\\uFD72&quot;, &quot;\\u0637\\u0645\\u062D&quot;, &quot;\\uFD73&quot;, &quot;\\u0637\\u0645\\u0645&quot;, &quot;\\uFD74&quot;, &quot;\\u0637\\u0645\\u064A&quot;, &quot;\\uFD75&quot;, &quot;\\u0639\\u062C\\u0645&quot;, &quot;\\uFD76&quot;, &quot;\\u0639\\u0645\\u0645&quot;, &quot;\\uFD77&quot;, &quot;\\u0639\\u0645\\u0645&quot;, &quot;\\uFD78&quot;, &quot;\\u0639\\u0645\\u0649&quot;, &quot;\\uFD79&quot;, &quot;\\u063A\\u0645\\u0645&quot;, &quot;\\uFD7A&quot;, &quot;\\u063A\\u0645\\u064A&quot;, &quot;\\uFD7B&quot;, &quot;\\u063A\\u0645\\u0649&quot;, &quot;\\uFD7C&quot;, &quot;\\u0641\\u062E\\u0645&quot;, &quot;\\uFD7D&quot;, &quot;\\u0641\\u062E\\u0645&quot;, &quot;\\uFD7E&quot;, &quot;\\u0642\\u0645\\u062D&quot;, &quot;\\uFD7F&quot;, &quot;\\u0642\\u0645\\u0645&quot;, &quot;\\uFD80&quot;, &quot;\\u0644\\u062D\\u0645&quot;, &quot;\\uFD81&quot;, &quot;\\u0644\\u062D\\u064A&quot;, &quot;\\uFD82&quot;, &quot;\\u0644\\u062D\\u0649&quot;, &quot;\\uFD83&quot;, &quot;\\u0644\\u062C\\u062C&quot;, &quot;\\uFD84&quot;, &quot;\\u0644\\u062C\\u062C&quot;, &quot;\\uFD85&quot;, &quot;\\u0644\\u062E\\u0645&quot;, &quot;\\uFD86&quot;, &quot;\\u0644\\u062E\\u0645&quot;, &quot;\\uFD87&quot;, &quot;\\u0644\\u0645\\u062D&quot;, &quot;\\uFD88&quot;, &quot;\\u0644\\u0645\\u062D&quot;, &quot;\\uFD89&quot;, &quot;\\u0645\\u062D\\u062C&quot;, &quot;\\uFD8A&quot;, &quot;\\u0645\\u062D\\u0645&quot;, &quot;\\uFD8B&quot;, &quot;\\u0645\\u062D\\u064A&quot;, &quot;\\uFD8C&quot;, &quot;\\u0645\\u062C\\u062D&quot;, &quot;\\uFD8D&quot;, &quot;\\u0645\\u062C\\u0645&quot;, &quot;\\uFD8E&quot;, &quot;\\u0645\\u062E\\u062C&quot;, &quot;\\uFD8F&quot;, &quot;\\u0645\\u062E\\u0645&quot;, &quot;\\uFD92&quot;, &quot;\\u0645\\u062C\\u062E&quot;, &quot;\\uFD93&quot;, &quot;\\u0647\\u0645\\u062C&quot;, &quot;\\uFD94&quot;, &quot;\\u0647\\u0645\\u0645&quot;, &quot;\\uFD95&quot;, &quot;\\u0646\\u062D\\u0645&quot;, &quot;\\uFD96&quot;, &quot;\\u0646\\u062D\\u0649&quot;, &quot;\\uFD97&quot;, &quot;\\u0646\\u062C\\u0645&quot;, &quot;\\uFD98&quot;, &quot;\\u0646\\u062C\\u0645&quot;, &quot;\\uFD99&quot;, &quot;\\u0646\\u062C\\u0649&quot;, &quot;\\uFD9A&quot;, &quot;\\u0646\\u0645\\u064A&quot;, &quot;\\uFD9B&quot;, &quot;\\u0646\\u0645\\u0649&quot;, &quot;\\uFD9C&quot;, &quot;\\u064A\\u0645\\u0645&quot;, &quot;\\uFD9D&quot;, &quot;\\u064A\\u0645\\u0645&quot;, &quot;\\uFD9E&quot;, &quot;\\u0628\\u062E\\u064A&quot;, &quot;\\uFD9F&quot;, &quot;\\u062A\\u062C\\u064A&quot;, &quot;\\uFDA0&quot;, &quot;\\u062A\\u062C\\u0649&quot;, &quot;\\uFDA1&quot;, &quot;\\u062A\\u062E\\u064A&quot;, &quot;\\uFDA2&quot;, &quot;\\u062A\\u062E\\u0649&quot;, &quot;\\uFDA3&quot;, &quot;\\u062A\\u0645\\u064A&quot;, &quot;\\uFDA4&quot;, &quot;\\u062A\\u0645\\u0649&quot;, &quot;\\uFDA5&quot;, &quot;\\u062C\\u0645\\u064A&quot;, &quot;\\uFDA6&quot;, &quot;\\u062C\\u062D\\u0649&quot;, &quot;\\uFDA7&quot;, &quot;\\u062C\\u0645\\u0649&quot;, &quot;\\uFDA8&quot;, &quot;\\u0633\\u062E\\u0649&quot;, &quot;\\uFDA9&quot;, &quot;\\u0635\\u062D\\u064A&quot;, &quot;\\uFDAA&quot;, &quot;\\u0634\\u062D\\u064A&quot;, &quot;\\uFDAB&quot;, &quot;\\u0636\\u062D\\u064A&quot;, &quot;\\uFDAC&quot;, &quot;\\u0644\\u062C\\u064A&quot;, &quot;\\uFDAD&quot;, &quot;\\u0644\\u0645\\u064A&quot;, &quot;\\uFDAE&quot;, &quot;\\u064A\\u062D\\u064A&quot;, &quot;\\uFDAF&quot;, &quot;\\u064A\\u062C\\u064A&quot;, &quot;\\uFDB0&quot;, &quot;\\u064A\\u0645\\u064A&quot;, &quot;\\uFDB1&quot;, &quot;\\u0645\\u0645\\u064A&quot;, &quot;\\uFDB2&quot;, &quot;\\u0642\\u0645\\u064A&quot;, &quot;\\uFDB3&quot;, &quot;\\u0646\\u062D\\u064A&quot;, &quot;\\uFDB4&quot;, &quot;\\u0642\\u0645\\u062D&quot;, &quot;\\uFDB5&quot;, &quot;\\u0644\\u062D\\u0645&quot;, &quot;\\uFDB6&quot;, &quot;\\u0639\\u0645\\u064A&quot;, &quot;\\uFDB7&quot;, &quot;\\u0643\\u0645\\u064A&quot;, &quot;\\uFDB8&quot;, &quot;\\u0646\\u062C\\u062D&quot;, &quot;\\uFDB9&quot;, &quot;\\u0645\\u062E\\u064A&quot;, &quot;\\uFDBA&quot;, &quot;\\u0644\\u062C\\u0645&quot;, &quot;\\uFDBB&quot;, &quot;\\u0643\\u0645\\u0645&quot;, &quot;\\uFDBC&quot;, &quot;\\u0644\\u062C\\u0645&quot;, &quot;\\uFDBD&quot;, &quot;\\u0646\\u062C\\u062D&quot;, &quot;\\uFDBE&quot;, &quot;\\u062C\\u062D\\u064A&quot;, &quot;\\uFDBF&quot;, &quot;\\u062D\\u062C\\u064A&quot;, &quot;\\uFDC0&quot;, &quot;\\u0645\\u062C\\u064A&quot;, &quot;\\uFDC1&quot;, &quot;\\u0641\\u0645\\u064A&quot;, &quot;\\uFDC2&quot;, &quot;\\u0628\\u062D\\u064A&quot;, &quot;\\uFDC3&quot;, &quot;\\u0643\\u0645\\u0645&quot;, &quot;\\uFDC4&quot;, &quot;\\u0639\\u062C\\u0645&quot;, &quot;\\uFDC5&quot;, &quot;\\u0635\\u0645\\u0645&quot;, &quot;\\uFDC6&quot;, &quot;\\u0633\\u062E\\u064A&quot;, &quot;\\uFDC7&quot;, &quot;\\u0646\\u062C\\u064A&quot;, &quot;\\uFE49&quot;, &quot;\\u203E&quot;, &quot;\\uFE4A&quot;, &quot;\\u203E&quot;, &quot;\\uFE4B&quot;, &quot;\\u203E&quot;, &quot;\\uFE4C&quot;, &quot;\\u203E&quot;, &quot;\\uFE4D&quot;, &quot;\\u005F&quot;, &quot;\\uFE4E&quot;, &quot;\\u005F&quot;, &quot;\\uFE4F&quot;, &quot;\\u005F&quot;, &quot;\\uFE80&quot;, &quot;\\u0621&quot;, &quot;\\uFE81&quot;, &quot;\\u0622&quot;, &quot;\\uFE82&quot;, &quot;\\u0622&quot;, &quot;\\uFE83&quot;, &quot;\\u0623&quot;, &quot;\\uFE84&quot;, &quot;\\u0623&quot;, &quot;\\uFE85&quot;, &quot;\\u0624&quot;, &quot;\\uFE86&quot;, &quot;\\u0624&quot;, &quot;\\uFE87&quot;, &quot;\\u0625&quot;, &quot;\\uFE88&quot;, &quot;\\u0625&quot;, &quot;\\uFE89&quot;, &quot;\\u0626&quot;, &quot;\\uFE8A&quot;, &quot;\\u0626&quot;, &quot;\\uFE8B&quot;, &quot;\\u0626&quot;, &quot;\\uFE8C&quot;, &quot;\\u0626&quot;, &quot;\\uFE8D&quot;, &quot;\\u0627&quot;, &quot;\\uFE8E&quot;, &quot;\\u0627&quot;, &quot;\\uFE8F&quot;, &quot;\\u0628&quot;, &quot;\\uFE90&quot;, &quot;\\u0628&quot;, &quot;\\uFE91&quot;, &quot;\\u0628&quot;, &quot;\\uFE92&quot;, &quot;\\u0628&quot;, &quot;\\uFE93&quot;, &quot;\\u0629&quot;, &quot;\\uFE94&quot;, &quot;\\u0629&quot;, &quot;\\uFE95&quot;, &quot;\\u062A&quot;, &quot;\\uFE96&quot;, &quot;\\u062A&quot;, &quot;\\uFE97&quot;, &quot;\\u062A&quot;, &quot;\\uFE98&quot;, &quot;\\u062A&quot;, &quot;\\uFE99&quot;, &quot;\\u062B&quot;, &quot;\\uFE9A&quot;, &quot;\\u062B&quot;, &quot;\\uFE9B&quot;, &quot;\\u062B&quot;, &quot;\\uFE9C&quot;, &quot;\\u062B&quot;, &quot;\\uFE9D&quot;, &quot;\\u062C&quot;, &quot;\\uFE9E&quot;, &quot;\\u062C&quot;, &quot;\\uFE9F&quot;, &quot;\\u062C&quot;, &quot;\\uFEA0&quot;, &quot;\\u062C&quot;, &quot;\\uFEA1&quot;, &quot;\\u062D&quot;, &quot;\\uFEA2&quot;, &quot;\\u062D&quot;, &quot;\\uFEA3&quot;, &quot;\\u062D&quot;, &quot;\\uFEA4&quot;, &quot;\\u062D&quot;, &quot;\\uFEA5&quot;, &quot;\\u062E&quot;, &quot;\\uFEA6&quot;, &quot;\\u062E&quot;, &quot;\\uFEA7&quot;, &quot;\\u062E&quot;, &quot;\\uFEA8&quot;, &quot;\\u062E&quot;, &quot;\\uFEA9&quot;, &quot;\\u062F&quot;, &quot;\\uFEAA&quot;, &quot;\\u062F&quot;, &quot;\\uFEAB&quot;, &quot;\\u0630&quot;, &quot;\\uFEAC&quot;, &quot;\\u0630&quot;, &quot;\\uFEAD&quot;, &quot;\\u0631&quot;, &quot;\\uFEAE&quot;, &quot;\\u0631&quot;, &quot;\\uFEAF&quot;, &quot;\\u0632&quot;, &quot;\\uFEB0&quot;, &quot;\\u0632&quot;, &quot;\\uFEB1&quot;, &quot;\\u0633&quot;, &quot;\\uFEB2&quot;, &quot;\\u0633&quot;, &quot;\\uFEB3&quot;, &quot;\\u0633&quot;, &quot;\\uFEB4&quot;, &quot;\\u0633&quot;, &quot;\\uFEB5&quot;, &quot;\\u0634&quot;, &quot;\\uFEB6&quot;, &quot;\\u0634&quot;, &quot;\\uFEB7&quot;, &quot;\\u0634&quot;, &quot;\\uFEB8&quot;, &quot;\\u0634&quot;, &quot;\\uFEB9&quot;, &quot;\\u0635&quot;, &quot;\\uFEBA&quot;, &quot;\\u0635&quot;, &quot;\\uFEBB&quot;, &quot;\\u0635&quot;, &quot;\\uFEBC&quot;, &quot;\\u0635&quot;, &quot;\\uFEBD&quot;, &quot;\\u0636&quot;, &quot;\\uFEBE&quot;, &quot;\\u0636&quot;, &quot;\\uFEBF&quot;, &quot;\\u0636&quot;, &quot;\\uFEC0&quot;, &quot;\\u0636&quot;, &quot;\\uFEC1&quot;, &quot;\\u0637&quot;, &quot;\\uFEC2&quot;, &quot;\\u0637&quot;, &quot;\\uFEC3&quot;, &quot;\\u0637&quot;, &quot;\\uFEC4&quot;, &quot;\\u0637&quot;, &quot;\\uFEC5&quot;, &quot;\\u0638&quot;, &quot;\\uFEC6&quot;, &quot;\\u0638&quot;, &quot;\\uFEC7&quot;, &quot;\\u0638&quot;, &quot;\\uFEC8&quot;, &quot;\\u0638&quot;, &quot;\\uFEC9&quot;, &quot;\\u0639&quot;, &quot;\\uFECA&quot;, &quot;\\u0639&quot;, &quot;\\uFECB&quot;, &quot;\\u0639&quot;, &quot;\\uFECC&quot;, &quot;\\u0639&quot;, &quot;\\uFECD&quot;, &quot;\\u063A&quot;, &quot;\\uFECE&quot;, &quot;\\u063A&quot;, &quot;\\uFECF&quot;, &quot;\\u063A&quot;, &quot;\\uFED0&quot;, &quot;\\u063A&quot;, &quot;\\uFED1&quot;, &quot;\\u0641&quot;, &quot;\\uFED2&quot;, &quot;\\u0641&quot;, &quot;\\uFED3&quot;, &quot;\\u0641&quot;, &quot;\\uFED4&quot;, &quot;\\u0641&quot;, &quot;\\uFED5&quot;, &quot;\\u0642&quot;, &quot;\\uFED6&quot;, &quot;\\u0642&quot;, &quot;\\uFED7&quot;, &quot;\\u0642&quot;, &quot;\\uFED8&quot;, &quot;\\u0642&quot;, &quot;\\uFED9&quot;, &quot;\\u0643&quot;, &quot;\\uFEDA&quot;, &quot;\\u0643&quot;, &quot;\\uFEDB&quot;, &quot;\\u0643&quot;, &quot;\\uFEDC&quot;, &quot;\\u0643&quot;, &quot;\\uFEDD&quot;, &quot;\\u0644&quot;, &quot;\\uFEDE&quot;, &quot;\\u0644&quot;, &quot;\\uFEDF&quot;, &quot;\\u0644&quot;, &quot;\\uFEE0&quot;, &quot;\\u0644&quot;, &quot;\\uFEE1&quot;, &quot;\\u0645&quot;, &quot;\\uFEE2&quot;, &quot;\\u0645&quot;, &quot;\\uFEE3&quot;, &quot;\\u0645&quot;, &quot;\\uFEE4&quot;, &quot;\\u0645&quot;, &quot;\\uFEE5&quot;, &quot;\\u0646&quot;, &quot;\\uFEE6&quot;, &quot;\\u0646&quot;, &quot;\\uFEE7&quot;, &quot;\\u0646&quot;, &quot;\\uFEE8&quot;, &quot;\\u0646&quot;, &quot;\\uFEE9&quot;, &quot;\\u0647&quot;, &quot;\\uFEEA&quot;, &quot;\\u0647&quot;, &quot;\\uFEEB&quot;, &quot;\\u0647&quot;, &quot;\\uFEEC&quot;, &quot;\\u0647&quot;, &quot;\\uFEED&quot;, &quot;\\u0648&quot;, &quot;\\uFEEE&quot;, &quot;\\u0648&quot;, &quot;\\uFEEF&quot;, &quot;\\u0649&quot;, &quot;\\uFEF0&quot;, &quot;\\u0649&quot;, &quot;\\uFEF1&quot;, &quot;\\u064A&quot;, &quot;\\uFEF2&quot;, &quot;\\u064A&quot;, &quot;\\uFEF3&quot;, &quot;\\u064A&quot;, &quot;\\uFEF4&quot;, &quot;\\u064A&quot;, &quot;\\uFEF5&quot;, &quot;\\u0644\\u0622&quot;, &quot;\\uFEF6&quot;, &quot;\\u0644\\u0622&quot;, &quot;\\uFEF7&quot;, &quot;\\u0644\\u0623&quot;, &quot;\\uFEF8&quot;, &quot;\\u0644\\u0623&quot;, &quot;\\uFEF9&quot;, &quot;\\u0644\\u0625&quot;, &quot;\\uFEFA&quot;, &quot;\\u0644\\u0625&quot;, &quot;\\uFEFB&quot;, &quot;\\u0644\\u0627&quot;, &quot;\\uFEFC&quot;, &quot;\\u0644\\u0627&quot; ]; }); function reverseIfRtl(chars) { const charsLength = chars.length; if (charsLength &lt;= 1 || !isRTLRangeFor(chars.charCodeAt(0))) { return chars; } const buf = []; for (let ii = charsLength - 1; ii &gt;= 0; ii--) { buf.push(chars[ii]); } return buf.join(&quot;&quot;); } const SpecialCharRegExp = new RegExp(&quot;^(\\\\s)|(\\\\p{Mn})|(\\\\p{Cf})$&quot;, &quot;u&quot;); const CategoryCache = new Map(); function getCharUnicodeCategory(char) { const cachedCategory = CategoryCache.get(char); if (cachedCategory) { return cachedCategory; } const groups = char.match(SpecialCharRegExp); const category = { isWhitespace: !!(groups &amp;&amp; groups[1]), isZeroWidthDiacritic: !!(groups &amp;&amp; groups[2]), isInvisibleFormatMark: !!(groups &amp;&amp; groups[3]) }; CategoryCache.set(char, category); return category; } function clearUnicodeCaches() { CategoryCache.clear(); } /***/ }), /* 39 */ /***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) =&gt; { Object.defineProperty(exports, &quot;__esModule&quot;, ({ value: true })); exports.getSerifFonts = exports.getNonStdFontMap = exports.getGlyphMapForStandardFonts = exports.getFontNameToFileMap = void 0; exports.getStandardFontName = getStandardFontName; exports.getSymbolsFonts = exports.getSupplementalGlyphMapForCalibri = exports.getSupplementalGlyphMapForArialBlack = exports.getStdFontMap = void 0; var _core_utils = __w_pdfjs_require__(4); var _fonts_utils = __w_pdfjs_require__(36); const getStdFontMap = (0, _core_utils.getLookupTableFactory)(function (t) { t[&quot;Times-Roman&quot;] = &quot;Times-Roman&quot;; t.Helvetica = &quot;Helvetica&quot;; t.Courier = &quot;Courier&quot;; t.Symbol = &quot;Symbol&quot;; t[&quot;Times-Bold&quot;] = &quot;Times-Bold&quot;; t[&quot;Helvetica-Bold&quot;] = &quot;Helvetica-Bold&quot;; t[&quot;Courier-Bold&quot;] = &quot;Courier-Bold&quot;; t.ZapfDingbats = &quot;ZapfDingbats&quot;; t[&quot;Times-Italic&quot;] = &quot;Times-Italic&quot;; t[&quot;Helvetica-Oblique&quot;] = &quot;Helvetica-Oblique&quot;; t[&quot;Courier-Oblique&quot;] = &quot;Courier-Oblique&quot;; t[&quot;Times-BoldItalic&quot;] = &quot;Times-BoldItalic&quot;; t[&quot;Helvetica-BoldOblique&quot;] = &quot;Helvetica-BoldOblique&quot;; t[&quot;Courier-BoldOblique&quot;] = &quot;Courier-BoldOblique&quot;; t.ArialNarrow = &quot;Helvetica&quot;; t[&quot;ArialNarrow-Bold&quot;] = &quot;Helvetica-Bold&quot;; t[&quot;ArialNarrow-BoldItalic&quot;] = &quot;Helvetica-BoldOblique&quot;; t[&quot;ArialNarrow-Italic&quot;] = &quot;Helvetica-Oblique&quot;; t.ArialBlack = &quot;Helvetica&quot;; t[&quot;ArialBlack-Bold&quot;] = &quot;Helvetica-Bold&quot;; t[&quot;ArialBlack-BoldItalic&quot;] = &quot;Helvetica-BoldOblique&quot;; t[&quot;ArialBlack-Italic&quot;] = &quot;Helvetica-Oblique&quot;; t[&quot;Arial-Black&quot;] = &quot;Helvetica&quot;; t[&quot;Arial-Black-Bold&quot;] = &quot;Helvetica-Bold&quot;; t[&quot;Arial-Black-BoldItalic&quot;] = &quot;Helvetica-BoldOblique&quot;; t[&quot;Arial-Black-Italic&quot;] = &quot;Helvetica-Oblique&quot;; t.Arial = &quot;Helvetica&quot;; t[&quot;Arial-Bold&quot;] = &quot;Helvetica-Bold&quot;; t[&quot;Arial-BoldItalic&quot;] = &quot;Helvetica-BoldOblique&quot;; t[&quot;Arial-Italic&quot;] = &quot;Helvetica-Oblique&quot;; t.ArialMT = &quot;Helvetica&quot;; t[&quot;Arial-BoldItalicMT&quot;] = &quot;Helvetica-BoldOblique&quot;; t[&quot;Arial-BoldMT&quot;] = &quot;Helvetica-Bold&quot;; t[&quot;Arial-ItalicMT&quot;] = &quot;Helvetica-Oblique&quot;; t.ArialUnicodeMS = &quot;Helvetica&quot;; t[&quot;ArialUnicodeMS-Bold&quot;] = &quot;Helvetica-Bold&quot;; t[&quot;ArialUnicodeMS-BoldItalic&quot;] = &quot;Helvetica-BoldOblique&quot;; t[&quot;ArialUnicodeMS-Italic&quot;] = &quot;Helvetica-Oblique&quot;; t[&quot;Courier-BoldItalic&quot;] = &quot;Courier-BoldOblique&quot;; t[&quot;Courier-Italic&quot;] = &quot;Courier-Oblique&quot;; t.CourierNew = &quot;Courier&quot;; t[&quot;CourierNew-Bold&quot;] = &quot;Courier-Bold&quot;; t[&quot;CourierNew-BoldItalic&quot;] = &quot;Courier-BoldOblique&quot;; t[&quot;CourierNew-Italic&quot;] = &quot;Courier-Oblique&quot;; t[&quot;CourierNewPS-BoldItalicMT&quot;] = &quot;Courier-BoldOblique&quot;; t[&quot;CourierNewPS-BoldMT&quot;] = &quot;Courier-Bold&quot;; t[&quot;CourierNewPS-ItalicMT&quot;] = &quot;Courier-Oblique&quot;; t.CourierNewPSMT = &quot;Courier&quot;; t[&quot;Helvetica-BoldItalic&quot;] = &quot;Helvetica-BoldOblique&quot;; t[&quot;Helvetica-Italic&quot;] = &quot;Helvetica-Oblique&quot;; t[&quot;Symbol-Bold&quot;] = &quot;Symbol&quot;; t[&quot;Symbol-BoldItalic&quot;] = &quot;Symbol&quot;; t[&quot;Symbol-Italic&quot;] = &quot;Symbol&quot;; t.TimesNewRoman = &quot;Times-Roman&quot;; t[&quot;TimesNewRoman-Bold&quot;] = &quot;Times-Bold&quot;; t[&quot;TimesNewRoman-BoldItalic&quot;] = &quot;Times-BoldItalic&quot;; t[&quot;TimesNewRoman-Italic&quot;] = &quot;Times-Italic&quot;; t.TimesNewRomanPS = &quot;Times-Roman&quot;; t[&quot;TimesNewRomanPS-Bold&quot;] = &quot;Times-Bold&quot;; t[&quot;TimesNewRomanPS-BoldItalic&quot;] = &quot;Times-BoldItalic&quot;; t[&quot;TimesNewRomanPS-BoldItalicMT&quot;] = &quot;Times-BoldItalic&quot;; t[&quot;TimesNewRomanPS-BoldMT&quot;] = &quot;Times-Bold&quot;; t[&quot;TimesNewRomanPS-Italic&quot;] = &quot;Times-Italic&quot;; t[&quot;TimesNewRomanPS-ItalicMT&quot;] = &quot;Times-Italic&quot;; t.TimesNewRomanPSMT = &quot;Times-Roman&quot;; t[&quot;TimesNewRomanPSMT-Bold&quot;] = &quot;Times-Bold&quot;; t[&quot;TimesNewRomanPSMT-BoldItalic&quot;] = &quot;Times-BoldItalic&quot;; t[&quot;TimesNewRomanPSMT-Italic&quot;] = &quot;Times-Italic&quot;; }); exports.getStdFontMap = getStdFontMap; const getFontNameToFileMap = (0, _core_utils.getLookupTableFactory)(function (t) { t.Courier = &quot;FoxitFixed.pfb&quot;; t[&quot;Courier-Bold&quot;] = &quot;FoxitFixedBold.pfb&quot;; t[&quot;Courier-BoldOblique&quot;] = &quot;FoxitFixedBoldItalic.pfb&quot;; t[&quot;Courier-Oblique&quot;] = &quot;FoxitFixedItalic.pfb&quot;; t.Helvetica = &quot;FoxitSans.pfb&quot;; t[&quot;Helvetica-Bold&quot;] = &quot;FoxitSansBold.pfb&quot;; t[&quot;Helvetica-BoldOblique&quot;] = &quot;FoxitSansBoldItalic.pfb&quot;; t[&quot;Helvetica-Oblique&quot;] = &quot;FoxitSansItalic.pfb&quot;; t[&quot;Times-Roman&quot;] = &quot;FoxitSerif.pfb&quot;; t[&quot;Times-Bold&quot;] = &quot;FoxitSerifBold.pfb&quot;; t[&quot;Times-BoldItalic&quot;] = &quot;FoxitSerifBoldItalic.pfb&quot;; t[&quot;Times-Italic&quot;] = &quot;FoxitSerifItalic.pfb&quot;; t.Symbol = &quot;FoxitSymbol.pfb&quot;; t.ZapfDingbats = &quot;FoxitDingbats.pfb&quot;; t[&quot;LiberationSans-Regular&quot;] = &quot;LiberationSans-Regular.ttf&quot;; t[&quot;LiberationSans-Bold&quot;] = &quot;LiberationSans-Bold.ttf&quot;; t[&quot;LiberationSans-Italic&quot;] = &quot;LiberationSans-Italic.ttf&quot;; t[&quot;LiberationSans-BoldItalic&quot;] = &quot;LiberationSans-BoldItalic.ttf&quot;; }); exports.getFontNameToFileMap = getFontNameToFileMap; const getNonStdFontMap = (0, _core_utils.getLookupTableFactory)(function (t) { t.Calibri = &quot;Helvetica&quot;; t[&quot;Calibri-Bold&quot;] = &quot;Helvetica-Bold&quot;; t[&quot;Calibri-BoldItalic&quot;] = &quot;Helvetica-BoldOblique&quot;; t[&quot;Calibri-Italic&quot;] = &quot;Helvetica-Oblique&quot;; t.CenturyGothic = &quot;Helvetica&quot;; t[&quot;CenturyGothic-Bold&quot;] = &quot;Helvetica-Bold&quot;; t[&quot;CenturyGothic-BoldItalic&quot;] = &quot;Helvetica-BoldOblique&quot;; t[&quot;CenturyGothic-Italic&quot;] = &quot;Helvetica-Oblique&quot;; t.ComicSansMS = &quot;Comic Sans MS&quot;; t[&quot;ComicSansMS-Bold&quot;] = &quot;Comic Sans MS-Bold&quot;; t[&quot;ComicSansMS-BoldItalic&quot;] = &quot;Comic Sans MS-BoldItalic&quot;; t[&quot;ComicSansMS-Italic&quot;] = &quot;Comic Sans MS-Italic&quot;; t[&quot;ItcSymbol-Bold&quot;] = &quot;Helvetica-Bold&quot;; t[&quot;ItcSymbol-BoldItalic&quot;] = &quot;Helvetica-BoldOblique&quot;; t[&quot;ItcSymbol-Book&quot;] = &quot;Helvetica&quot;; t[&quot;ItcSymbol-BookItalic&quot;] = &quot;Helvetica-Oblique&quot;; t[&quot;ItcSymbol-Medium&quot;] = &quot;Helvetica&quot;; t[&quot;ItcSymbol-MediumItalic&quot;] = &quot;Helvetica-Oblique&quot;; t.LucidaConsole = &quot;Courier&quot;; t[&quot;LucidaConsole-Bold&quot;] = &quot;Courier-Bold&quot;; t[&quot;LucidaConsole-BoldItalic&quot;] = &quot;Courier-BoldOblique&quot;; t[&quot;LucidaConsole-Italic&quot;] = &quot;Courier-Oblique&quot;; t[&quot;LucidaSans-Demi&quot;] = &quot;Helvetica-Bold&quot;; t[&quot;MS-Gothic&quot;] = &quot;MS Gothic&quot;; t[&quot;MS-Gothic-Bold&quot;] = &quot;MS Gothic-Bold&quot;; t[&quot;MS-Gothic-BoldItalic&quot;] = &quot;MS Gothic-BoldItalic&quot;; t[&quot;MS-Gothic-Italic&quot;] = &quot;MS Gothic-Italic&quot;; t[&quot;MS-Mincho&quot;] = &quot;MS Mincho&quot;; t[&quot;MS-Mincho-Bold&quot;] = &quot;MS Mincho-Bold&quot;; t[&quot;MS-Mincho-BoldItalic&quot;] = &quot;MS Mincho-BoldItalic&quot;; t[&quot;MS-Mincho-Italic&quot;] = &quot;MS Mincho-Italic&quot;; t[&quot;MS-PGothic&quot;] = &quot;MS PGothic&quot;; t[&quot;MS-PGothic-Bold&quot;] = &quot;MS PGothic-Bold&quot;; t[&quot;MS-PGothic-BoldItalic&quot;] = &quot;MS PGothic-BoldItalic&quot;; t[&quot;MS-PGothic-Italic&quot;] = &quot;MS PGothic-Italic&quot;; t[&quot;MS-PMincho&quot;] = &quot;MS PMincho&quot;; t[&quot;MS-PMincho-Bold&quot;] = &quot;MS PMincho-Bold&quot;; t[&quot;MS-PMincho-BoldItalic&quot;] = &quot;MS PMincho-BoldItalic&quot;; t[&quot;MS-PMincho-Italic&quot;] = &quot;MS PMincho-Italic&quot;; t.NuptialScript = &quot;Times-Italic&quot;; t.SegoeUISymbol = &quot;Helvetica&quot;; t.Wingdings = &quot;ZapfDingbats&quot;; t[&quot;Wingdings-Regular&quot;] = &quot;ZapfDingbats&quot;; }); exports.getNonStdFontMap = getNonStdFontMap; const getSerifFonts = (0, _core_utils.getLookupTableFactory)(function (t) { t[&quot;Adobe Jenson&quot;] = true; t[&quot;Adobe Text&quot;] = true; t.Albertus = true; t.Aldus = true; t.Alexandria = true; t.Algerian = true; t[&quot;American Typewriter&quot;] = true; t.Antiqua = true; t.Apex = true; t.Arno = true; t.Aster = true; t.Aurora = true; t.Baskerville = true; t.Bell = true; t.Bembo = true; t[&quot;Bembo Schoolbook&quot;] = true; t.Benguiat = true; t[&quot;Berkeley Old Style&quot;] = true; t[&quot;Bernhard Modern&quot;] = true; t[&quot;Berthold City&quot;] = true; t.Bodoni = true; t[&quot;Bauer Bodoni&quot;] = true; t[&quot;Book Antiqua&quot;] = true; t.Bookman = true; t[&quot;Bordeaux Roman&quot;] = true; t[&quot;Californian FB&quot;] = true; t.Calisto = true; t.Calvert = true; t.Capitals = true; t.Cambria = true; t.Cartier = true; t.Caslon = true; t.Catull = true; t.Centaur = true; t[&quot;Century Old Style&quot;] = true; t[&quot;Century Schoolbook&quot;] = true; t.Chaparral = true; t[&quot;Charis SIL&quot;] = true; t.Cheltenham = true; t[&quot;Cholla Slab&quot;] = true; t.Clarendon = true; t.Clearface = true; t.Cochin = true; t.Colonna = true; t[&quot;Computer Modern&quot;] = true; t[&quot;Concrete Roman&quot;] = true; t.Constantia = true; t[&quot;Cooper Black&quot;] = true; t.Corona = true; t.Ecotype = true; t.Egyptienne = true; t.Elephant = true; t.Excelsior = true; t.Fairfield = true; t[&quot;FF Scala&quot;] = true; t.Folkard = true; t.Footlight = true; t.FreeSerif = true; t[&quot;Friz Quadrata&quot;] = true; t.Garamond = true; t.Gentium = true; t.Georgia = true; t.Gloucester = true; t[&quot;Goudy Old Style&quot;] = true; t[&quot;Goudy Schoolbook&quot;] = true; t[&quot;Goudy Pro Font&quot;] = true; t.Granjon = true; t[&quot;Guardian Egyptian&quot;] = true; t.Heather = true; t.Hercules = true; t[&quot;High Tower Text&quot;] = true; t.Hiroshige = true; t[&quot;Hoefler Text&quot;] = true; t[&quot;Humana Serif&quot;] = true; t.Imprint = true; t[&quot;Ionic No. 5&quot;] = true; t.Janson = true; t.Joanna = true; t.Korinna = true; t.Lexicon = true; t.LiberationSerif = true; t[&quot;Liberation Serif&quot;] = true; t[&quot;Linux Libertine&quot;] = true; t.Literaturnaya = true; t.Lucida = true; t[&quot;Lucida Bright&quot;] = true; t.Melior = true; t.Memphis = true; t.Miller = true; t.Minion = true; t.Modern = true; t[&quot;Mona Lisa&quot;] = true; t[&quot;Mrs Eaves&quot;] = true; t[&quot;MS Serif&quot;] = true; t[&quot;Museo Slab&quot;] = true; t[&quot;New York&quot;] = true; t[&quot;Nimbus Roman&quot;] = true; t[&quot;NPS Rawlinson Roadway&quot;] = true; t.NuptialScript = true; t.Palatino = true; t.Perpetua = true; t.Plantin = true; t[&quot;Plantin Schoolbook&quot;] = true; t.Playbill = true; t[&quot;Poor Richard&quot;] = true; t[&quot;Rawlinson Roadway&quot;] = true; t.Renault = true; t.Requiem = true; t.Rockwell = true; t.Roman = true; t[&quot;Rotis Serif&quot;] = true; t.Sabon = true; t.Scala = true; t.Seagull = true; t.Sistina = true; t.Souvenir = true; t.STIX = true; t[&quot;Stone Informal&quot;] = true; t[&quot;Stone Serif&quot;] = true; t.Sylfaen = true; t.Times = true; t.Trajan = true; t[&quot;Trinité&quot;] = true; t[&quot;Trump Mediaeval&quot;] = true; t.Utopia = true; t[&quot;Vale Type&quot;] = true; t[&quot;Bitstream Vera&quot;] = true; t[&quot;Vera Serif&quot;] = true; t.Versailles = true; t.Wanted = true; t.Weiss = true; t[&quot;Wide Latin&quot;] = true; t.Windsor = true; t.XITS = true; }); exports.getSerifFonts = getSerifFonts; const getSymbolsFonts = (0, _core_utils.getLookupTableFactory)(function (t) { t.Dingbats = true; t.Symbol = true; t.ZapfDingbats = true; }); exports.getSymbolsFonts = getSymbolsFonts; const getGlyphMapForStandardFonts = (0, _core_utils.getLookupTableFactory)(function (t) { t[2] = 10; t[3] = 32; t[4] = 33; t[5] = 34; t[6] = 35; t[7] = 36; t[8] = 37; t[9] = 38; t[10] = 39; t[11] = 40; t[12] = 41; t[13] = 42; t[14] = 43; t[15] = 44; t[16] = 45; t[17] = 46; t[18] = 47; t[19] = 48; t[20] = 49; t[21] = 50; t[22] = 51; t[23] = 52; t[24] = 53; t[25] = 54; t[26] = 55; t[27] = 56; t[28] = 57; t[29] = 58; t[30] = 894; t[31] = 60; t[32] = 61; t[33] = 62; t[34] = 63; t[35] = 64; t[36] = 65; t[37] = 66; t[38] = 67; t[39] = 68; t[40] = 69; t[41] = 70; t[42] = 71; t[43] = 72; t[44] = 73; t[45] = 74; t[46] = 75; t[47] = 76; t[48] = 77; t[49] = 78; t[50] = 79; t[51] = 80; t[52] = 81; t[53] = 82; t[54] = 83; t[55] = 84; t[56] = 85; t[57] = 86; t[58] = 87; t[59] = 88; t[60] = 89; t[61] = 90; t[62] = 91; t[63] = 92; t[64] = 93; t[65] = 94; t[66] = 95; t[67] = 96; t[68] = 97; t[69] = 98; t[70] = 99; t[71] = 100; t[72] = 101; t[73] = 102; t[74] = 103; t[75] = 104; t[76] = 105; t[77] = 106; t[78] = 107; t[79] = 108; t[80] = 109; t[81] = 110; t[82] = 111; t[83] = 112; t[84] = 113; t[85] = 114; t[86] = 115; t[87] = 116; t[88] = 117; t[89] = 118; t[90] = 119; t[91] = 120; t[92] = 121; t[93] = 122; t[94] = 123; t[95] = 124; t[96] = 125; t[97] = 126; t[98] = 196; t[99] = 197; t[100] = 199; t[101] = 201; t[102] = 209; t[103] = 214; t[104] = 220; t[105] = 225; t[106] = 224; t[107] = 226; t[108] = 228; t[109] = 227; t[110] = 229; t[111] = 231; t[112] = 233; t[113] = 232; t[114] = 234; t[115] = 235; t[116] = 237; t[117] = 236; t[118] = 238; t[119] = 239; t[120] = 241; t[121] = 243; t[122] = 242; t[123] = 244; t[124] = 246; t[125] = 245; t[126] = 250; t[127] = 249; t[128] = 251; t[129] = 252; t[130] = 8224; t[131] = 176; t[132] = 162; t[133] = 163; t[134] = 167; t[135] = 8226; t[136] = 182; t[137] = 223; t[138] = 174; t[139] = 169; t[140] = 8482; t[141] = 180; t[142] = 168; t[143] = 8800; t[144] = 198; t[145] = 216; t[146] = 8734; t[147] = 177; t[148] = 8804; t[149] = 8805; t[150] = 165; t[151] = 181; t[152] = 8706; t[153] = 8721; t[154] = 8719; t[156] = 8747; t[157] = 170; t[158] = 186; t[159] = 8486; t[160] = 230; t[161] = 248; t[162] = 191; t[163] = 161; t[164] = 172; t[165] = 8730; t[166] = 402; t[167] = 8776; t[168] = 8710; t[169] = 171; t[170] = 187; t[171] = 8230; t[179] = 8220; t[180] = 8221; t[181] = 8216; t[182] = 8217; t[200] = 193; t[203] = 205; t[210] = 218; t[223] = 711; t[224] = 321; t[225] = 322; t[226] = 352; t[227] = 353; t[228] = 381; t[229] = 382; t[233] = 221; t[234] = 253; t[252] = 263; t[253] = 268; t[254] = 269; t[258] = 258; t[260] = 260; t[261] = 261; t[265] = 280; t[266] = 281; t[267] = 282; t[268] = 283; t[269] = 313; t[275] = 323; t[276] = 324; t[278] = 328; t[283] = 344; t[284] = 345; t[285] = 346; t[286] = 347; t[292] = 367; t[295] = 377; t[296] = 378; t[298] = 380; t[305] = 963; t[306] = 964; t[307] = 966; t[308] = 8215; t[309] = 8252; t[310] = 8319; t[311] = 8359; t[312] = 8592; t[313] = 8593; t[337] = 9552; t[493] = 1039; t[494] = 1040; t[672] = 1488; t[673] = 1489; t[674] = 1490; t[675] = 1491; t[676] = 1492; t[677] = 1493; t[678] = 1494; t[679] = 1495; t[680] = 1496; t[681] = 1497; t[682] = 1498; t[683] = 1499; t[684] = 1500; t[685] = 1501; t[686] = 1502; t[687] = 1503; t[688] = 1504; t[689] = 1505; t[690] = 1506; t[691] = 1507; t[692] = 1508; t[693] = 1509; t[694] = 1510; t[695] = 1511; t[696] = 1512; t[697] = 1513; t[698] = 1514; t[705] = 1524; t[706] = 8362; t[710] = 64288; t[711] = 64298; t[759] = 1617; t[761] = 1776; t[763] = 1778; t[775] = 1652; t[777] = 1764; t[778] = 1780; t[779] = 1781; t[780] = 1782; t[782] = 771; t[783] = 64726; t[786] = 8363; t[788] = 8532; t[790] = 768; t[791] = 769; t[792] = 768; t[795] = 803; t[797] = 64336; t[798] = 64337; t[799] = 64342; t[800] = 64343; t[801] = 64344; t[802] = 64345; t[803] = 64362; t[804] = 64363; t[805] = 64364; t[2424] = 7821; t[2425] = 7822; t[2426] = 7823; t[2427] = 7824; t[2428] = 7825; t[2429] = 7826; t[2430] = 7827; t[2433] = 7682; t[2678] = 8045; t[2679] = 8046; t[2830] = 1552; t[2838] = 686; t[2840] = 751; t[2842] = 753; t[2843] = 754; t[2844] = 755; t[2846] = 757; t[2856] = 767; t[2857] = 848; t[2858] = 849; t[2862] = 853; t[2863] = 854; t[2864] = 855; t[2865] = 861; t[2866] = 862; t[2906] = 7460; t[2908] = 7462; t[2909] = 7463; t[2910] = 7464; t[2912] = 7466; t[2913] = 7467; t[2914] = 7468; t[2916] = 7470; t[2917] = 7471; t[2918] = 7472; t[2920] = 7474; t[2921] = 7475; t[2922] = 7476; t[2924] = 7478; t[2925] = 7479; t[2926] = 7480; t[2928] = 7482; t[2929] = 7483; t[2930] = 7484; t[2932] = 7486; t[2933] = 7487; t[2934] = 7488; t[2936] = 7490; t[2937] = 7491; t[2938] = 7492; t[2940] = 7494; t[2941] = 7495; t[2942] = 7496; t[2944] = 7498; t[2946] = 7500; t[2948] = 7502; t[2950] = 7504; t[2951] = 7505; t[2952] = 7506; t[2954] = 7508; t[2955] = 7509; t[2956] = 7510; t[2958] = 7512; t[2959] = 7513; t[2960] = 7514; t[2962] = 7516; t[2963] = 7517; t[2964] = 7518; t[2966] = 7520; t[2967] = 7521; t[2968] = 7522; t[2970] = 7524; t[2971] = 7525; t[2972] = 7526; t[2974] = 7528; t[2975] = 7529; t[2976] = 7530; t[2978] = 1537; t[2979] = 1538; t[2980] = 1539; t[2982] = 1549; t[2983] = 1551; t[2984] = 1552; t[2986] = 1554; t[2987] = 1555; t[2988] = 1556; t[2990] = 1623; t[2991] = 1624; t[2995] = 1775; t[2999] = 1791; t[3002] = 64290; t[3003] = 64291; t[3004] = 64292; t[3006] = 64294; t[3007] = 64295; t[3008] = 64296; t[3011] = 1900; t[3014] = 8223; t[3015] = 8244; t[3017] = 7532; t[3018] = 7533; t[3019] = 7534; t[3075] = 7590; t[3076] = 7591; t[3079] = 7594; t[3080] = 7595; t[3083] = 7598; t[3084] = 7599; t[3087] = 7602; t[3088] = 7603; t[3091] = 7606; t[3092] = 7607; t[3095] = 7610; t[3096] = 7611; t[3099] = 7614; t[3100] = 7615; t[3103] = 7618; t[3104] = 7619; t[3107] = 8337; t[3108] = 8338; t[3116] = 1884; t[3119] = 1885; t[3120] = 1885; t[3123] = 1886; t[3124] = 1886; t[3127] = 1887; t[3128] = 1887; t[3131] = 1888; t[3132] = 1888; t[3135] = 1889; t[3136] = 1889; t[3139] = 1890; t[3140] = 1890; t[3143] = 1891; t[3144] = 1891; t[3147] = 1892; t[3148] = 1892; t[3153] = 580; t[3154] = 581; t[3157] = 584; t[3158] = 585; t[3161] = 588; t[3162] = 589; t[3165] = 891; t[3166] = 892; t[3169] = 1274; t[3170] = 1275; t[3173] = 1278; t[3174] = 1279; t[3181] = 7622; t[3182] = 7623; t[3282] = 11799; t[3316] = 578; t[3379] = 42785; t[3393] = 1159; t[3416] = 8377; }); exports.getGlyphMapForStandardFonts = getGlyphMapForStandardFonts; const getSupplementalGlyphMapForArialBlack = (0, _core_utils.getLookupTableFactory)(function (t) { t[227] = 322; t[264] = 261; t[291] = 346; }); exports.getSupplementalGlyphMapForArialBlack = getSupplementalGlyphMapForArialBlack; const getSupplementalGlyphMapForCalibri = (0, _core_utils.getLookupTableFactory)(function (t) { t[1] = 32; t[4] = 65; t[5] = 192; t[6] = 193; t[9] = 196; t[17] = 66; t[18] = 67; t[21] = 268; t[24] = 68; t[28] = 69; t[29] = 200; t[30] = 201; t[32] = 282; t[38] = 70; t[39] = 71; t[44] = 72; t[47] = 73; t[48] = 204; t[49] = 205; t[58] = 74; t[60] = 75; t[62] = 76; t[68] = 77; t[69] = 78; t[75] = 79; t[76] = 210; t[80] = 214; t[87] = 80; t[89] = 81; t[90] = 82; t[92] = 344; t[94] = 83; t[97] = 352; t[100] = 84; t[104] = 85; t[109] = 220; t[115] = 86; t[116] = 87; t[121] = 88; t[122] = 89; t[124] = 221; t[127] = 90; t[129] = 381; t[258] = 97; t[259] = 224; t[260] = 225; t[263] = 228; t[268] = 261; t[271] = 98; t[272] = 99; t[273] = 263; t[275] = 269; t[282] = 100; t[286] = 101; t[287] = 232; t[288] = 233; t[290] = 283; t[295] = 281; t[296] = 102; t[336] = 103; t[346] = 104; t[349] = 105; t[350] = 236; t[351] = 237; t[361] = 106; t[364] = 107; t[367] = 108; t[371] = 322; t[373] = 109; t[374] = 110; t[381] = 111; t[382] = 242; t[383] = 243; t[386] = 246; t[393] = 112; t[395] = 113; t[396] = 114; t[398] = 345; t[400] = 115; t[401] = 347; t[403] = 353; t[410] = 116; t[437] = 117; t[442] = 252; t[448] = 118; t[449] = 119; t[454] = 120; t[455] = 121; t[457] = 253; t[460] = 122; t[462] = 382; t[463] = 380; t[853] = 44; t[855] = 58; t[856] = 46; t[876] = 47; t[878] = 45; t[882] = 45; t[894] = 40; t[895] = 41; t[896] = 91; t[897] = 93; t[923] = 64; t[1004] = 48; t[1005] = 49; t[1006] = 50; t[1007] = 51; t[1008] = 52; t[1009] = 53; t[1010] = 54; t[1011] = 55; t[1012] = 56; t[1013] = 57; t[1081] = 37; t[1085] = 43; t[1086] = 45; }); exports.getSupplementalGlyphMapForCalibri = getSupplementalGlyphMapForCalibri; function getStandardFontName(name) { const fontName = (0, _fonts_utils.normalizeFontName)(name); const stdFontMap = getStdFontMap(); return stdFontMap[fontName]; } /***/ }), /* 40 */ /***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) =&gt; { Object.defineProperty(exports, &quot;__esModule&quot;, ({ value: true })); exports.ToUnicodeMap = exports.IdentityToUnicodeMap = void 0; var _util = __w_pdfjs_require__(2); class ToUnicodeMap { constructor(cmap = []) { this._map = cmap; } get length() { return this._map.length; } forEach(callback) { for (const charCode in this._map) { callback(charCode, this._map[charCode].charCodeAt(0)); } } has(i) { return this._map[i] !== undefined; } get(i) { return this._map[i]; } charCodeOf(value) { const map = this._map; if (map.length &lt;= 0x10000) { return map.indexOf(value); } for (const charCode in map) { if (map[charCode] === value) { return charCode | 0; } } return -1; } amend(map) { for (const charCode in map) { this._map[charCode] = map[charCode]; } } } exports.ToUnicodeMap = ToUnicodeMap; class IdentityToUnicodeMap { constructor(firstChar, lastChar) { this.firstChar = firstChar; this.lastChar = lastChar; } get length() { return this.lastChar + 1 - this.firstChar; } forEach(callback) { for (let i = this.firstChar, ii = this.lastChar; i &lt;= ii; i++) { callback(i, i); } } has(i) { return this.firstChar &lt;= i &amp;&amp; i &lt;= this.lastChar; } get(i) { if (this.firstChar &lt;= i &amp;&amp; i &lt;= this.lastChar) { return String.fromCharCode(i); } return undefined; } charCodeOf(v) { return Number.isInteger(v) &amp;&amp; v &gt;= this.firstChar &amp;&amp; v &lt;= this.lastChar ? v : -1; } amend(map) { (0, _util.unreachable)(&quot;Should not call amend()&quot;); } } exports.IdentityToUnicodeMap = IdentityToUnicodeMap; /***/ }), /* 41 */ /***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) =&gt; { Object.defineProperty(exports, &quot;__esModule&quot;, ({ value: true })); exports.CFFFont = void 0; var _cff_parser = __w_pdfjs_require__(33); var _fonts_utils = __w_pdfjs_require__(36); var _util = __w_pdfjs_require__(2); class CFFFont { constructor(file, properties) { this.properties = properties; const parser = new _cff_parser.CFFParser(file, properties, _fonts_utils.SEAC_ANALYSIS_ENABLED); this.cff = parser.parse(); this.cff.duplicateFirstGlyph(); const compiler = new _cff_parser.CFFCompiler(this.cff); this.seacs = this.cff.seacs; try { this.data = compiler.compile(); } catch (e) { (0, _util.warn)(&quot;Failed to compile font &quot; + properties.loadedName); this.data = file; } this._createBuiltInEncoding(); } get numGlyphs() { return this.cff.charStrings.count; } getCharset() { return this.cff.charset.charset; } getGlyphMapping() { const cff = this.cff; const properties = this.properties; const { cidToGidMap, cMap } = properties; const charsets = cff.charset.charset; let charCodeToGlyphId; let glyphId; if (properties.composite) { let invCidToGidMap; if (cidToGidMap &amp;&amp; cidToGidMap.length &gt; 0) { invCidToGidMap = Object.create(null); for (let i = 0, ii = cidToGidMap.length; i &lt; ii; i++) { const gid = cidToGidMap[i]; if (gid !== undefined) { invCidToGidMap[gid] = i; } } } charCodeToGlyphId = Object.create(null); let charCode; if (cff.isCIDFont) { for (glyphId = 0; glyphId &lt; charsets.length; glyphId++) { const cid = charsets[glyphId]; charCode = cMap.charCodeOf(cid); if (invCidToGidMap &amp;&amp; invCidToGidMap[charCode] !== undefined) { charCode = invCidToGidMap[charCode]; } charCodeToGlyphId[charCode] = glyphId; } } else { for (glyphId = 0; glyphId &lt; cff.charStrings.count; glyphId++) { charCode = cMap.charCodeOf(glyphId); charCodeToGlyphId[charCode] = glyphId; } } return charCodeToGlyphId; } let encoding = cff.encoding ? cff.encoding.encoding : null; if (properties.isInternalFont) { encoding = properties.defaultEncoding; } charCodeToGlyphId = (0, _fonts_utils.type1FontGlyphMapping)(properties, encoding, charsets); return charCodeToGlyphId; } hasGlyphId(id) { return this.cff.hasGlyphId(id); } _createBuiltInEncoding() { const { charset, encoding } = this.cff; if (!charset || !encoding) { return; } const charsets = charset.charset, encodings = encoding.encoding; const map = []; for (const charCode in encodings) { const glyphId = encodings[charCode]; if (glyphId &gt;= 0) { const glyphName = charsets[glyphId]; if (glyphName) { map[charCode] = glyphName; } } } if (map.length &gt; 0) { this.properties.builtInEncoding = map; } } } exports.CFFFont = CFFFont; /***/ }), /* 42 */ /***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) =&gt; { Object.defineProperty(exports, &quot;__esModule&quot;, ({ value: true })); exports.FontRendererFactory = void 0; var _util = __w_pdfjs_require__(2); var _cff_parser = __w_pdfjs_require__(33); var _glyphlist = __w_pdfjs_require__(37); var _encodings = __w_pdfjs_require__(35); var _stream = __w_pdfjs_require__(8); function getUint32(data, offset) { return (data[offset] &lt;&lt; 24 | data[offset + 1] &lt;&lt; 16 | data[offset + 2] &lt;&lt; 8 | data[offset + 3]) &gt;&gt;&gt; 0; } function getUint16(data, offset) { return data[offset] &lt;&lt; 8 | data[offset + 1]; } function getInt16(data, offset) { return (data[offset] &lt;&lt; 24 | data[offset + 1] &lt;&lt; 16) &gt;&gt; 16; } function getInt8(data, offset) { return data[offset] &lt;&lt; 24 &gt;&gt; 24; } function getFloat214(data, offset) { return getInt16(data, offset) / 16384; } function getSubroutineBias(subrs) { const numSubrs = subrs.length; let bias = 32768; if (numSubrs &lt; 1240) { bias = 107; } else if (numSubrs &lt; 33900) { bias = 1131; } return bias; } function parseCmap(data, start, end) { const offset = getUint16(data, start + 2) === 1 ? getUint32(data, start + 8) : getUint32(data, start + 16); const format = getUint16(data, start + offset); let ranges, p, i; if (format === 4) { getUint16(data, start + offset + 2); const segCount = getUint16(data, start + offset + 6) &gt;&gt; 1; p = start + offset + 14; ranges = []; for (i = 0; i &lt; segCount; i++, p += 2) { ranges[i] = { end: getUint16(data, p) }; } p += 2; for (i = 0; i &lt; segCount; i++, p += 2) { ranges[i].start = getUint16(data, p); } for (i = 0; i &lt; segCount; i++, p += 2) { ranges[i].idDelta = getUint16(data, p); } for (i = 0; i &lt; segCount; i++, p += 2) { let idOffset = getUint16(data, p); if (idOffset === 0) { continue; } ranges[i].ids = []; for (let j = 0, jj = ranges[i].end - ranges[i].start + 1; j &lt; jj; j++) { ranges[i].ids[j] = getUint16(data, p + idOffset); idOffset += 2; } } return ranges; } else if (format === 12) { const groups = getUint32(data, start + offset + 12); p = start + offset + 16; ranges = []; for (i = 0; i &lt; groups; i++) { start = getUint32(data, p); ranges.push({ start, end: getUint32(data, p + 4), idDelta: getUint32(data, p + 8) - start }); p += 12; } return ranges; } throw new _util.FormatError(`unsupported cmap: ${format}`); } function parseCff(data, start, end, seacAnalysisEnabled) { const properties = {}; const parser = new _cff_parser.CFFParser(new _stream.Stream(data, start, end - start), properties, seacAnalysisEnabled); const cff = parser.parse(); return { glyphs: cff.charStrings.objects, subrs: cff.topDict.privateDict &amp;&amp; cff.topDict.privateDict.subrsIndex &amp;&amp; cff.topDict.privateDict.subrsIndex.objects, gsubrs: cff.globalSubrIndex &amp;&amp; cff.globalSubrIndex.objects, isCFFCIDFont: cff.isCIDFont, fdSelect: cff.fdSelect, fdArray: cff.fdArray }; } function parseGlyfTable(glyf, loca, isGlyphLocationsLong) { let itemSize, itemDecode; if (isGlyphLocationsLong) { itemSize = 4; itemDecode = getUint32; } else { itemSize = 2; itemDecode = (data, offset) =&gt; 2 * getUint16(data, offset); } const glyphs = []; let startOffset = itemDecode(loca, 0); for (let j = itemSize; j &lt; loca.length; j += itemSize) { const endOffset = itemDecode(loca, j); glyphs.push(glyf.subarray(startOffset, endOffset)); startOffset = endOffset; } return glyphs; } function lookupCmap(ranges, unicode) { const code = unicode.codePointAt(0); let gid = 0, l = 0, r = ranges.length - 1; while (l &lt; r) { const c = l + r + 1 &gt;&gt; 1; if (code &lt; ranges[c].start) { r = c - 1; } else { l = c; } } if (ranges[l].start &lt;= code &amp;&amp; code &lt;= ranges[l].end) { gid = ranges[l].idDelta + (ranges[l].ids ? ranges[l].ids[code - ranges[l].start] : code) &amp; 0xffff; } return { charCode: code, glyphId: gid }; } function compileGlyf(code, cmds, font) { function moveTo(x, y) { cmds.push({ cmd: &quot;moveTo&quot;, args: [x, y] }); } function lineTo(x, y) { cmds.push({ cmd: &quot;lineTo&quot;, args: [x, y] }); } function quadraticCurveTo(xa, ya, x, y) { cmds.push({ cmd: &quot;quadraticCurveTo&quot;, args: [xa, ya, x, y] }); } let i = 0; const numberOfContours = getInt16(code, i); let flags; let x = 0, y = 0; i += 10; if (numberOfContours &lt; 0) { do { flags = getUint16(code, i); const glyphIndex = getUint16(code, i + 2); i += 4; let arg1, arg2; if (flags &amp; 0x01) { if (flags &amp; 0x02) { arg1 = getInt16(code, i); arg2 = getInt16(code, i + 2); } else { arg1 = getUint16(code, i); arg2 = getUint16(code, i + 2); } i += 4; } else { if (flags &amp; 0x02) { arg1 = getInt8(code, i++); arg2 = getInt8(code, i++); } else { arg1 = code[i++]; arg2 = code[i++]; } } if (flags &amp; 0x02) { x = arg1; y = arg2; } else { x = 0; y = 0; } let scaleX = 1, scaleY = 1, scale01 = 0, scale10 = 0; if (flags &amp; 0x08) { scaleX = scaleY = getFloat214(code, i); i += 2; } else if (flags &amp; 0x40) { scaleX = getFloat214(code, i); scaleY = getFloat214(code, i + 2); i += 4; } else if (flags &amp; 0x80) { scaleX = getFloat214(code, i); scale01 = getFloat214(code, i + 2); scale10 = getFloat214(code, i + 4); scaleY = getFloat214(code, i + 6); i += 8; } const subglyph = font.glyphs[glyphIndex]; if (subglyph) { cmds.push({ cmd: &quot;save&quot; }, { cmd: &quot;transform&quot;, args: [scaleX, scale01, scale10, scaleY, x, y] }); if (!(flags &amp; 0x02)) {} compileGlyf(subglyph, cmds, font); cmds.push({ cmd: &quot;restore&quot; }); } } while (flags &amp; 0x20); } else { const endPtsOfContours = []; let j, jj; for (j = 0; j &lt; numberOfContours; j++) { endPtsOfContours.push(getUint16(code, i)); i += 2; } const instructionLength = getUint16(code, i); i += 2 + instructionLength; const numberOfPoints = endPtsOfContours.at(-1) + 1; const points = []; while (points.length &lt; numberOfPoints) { flags = code[i++]; let repeat = 1; if (flags &amp; 0x08) { repeat += code[i++]; } while (repeat-- &gt; 0) { points.push({ flags }); } } for (j = 0; j &lt; numberOfPoints; j++) { switch (points[j].flags &amp; 0x12) { case 0x00: x += getInt16(code, i); i += 2; break; case 0x02: x -= code[i++]; break; case 0x12: x += code[i++]; break; } points[j].x = x; } for (j = 0; j &lt; numberOfPoints; j++) { switch (points[j].flags &amp; 0x24) { case 0x00: y += getInt16(code, i); i += 2; break; case 0x04: y -= code[i++]; break; case 0x24: y += code[i++]; break; } points[j].y = y; } let startPoint = 0; for (i = 0; i &lt; numberOfContours; i++) { const endPoint = endPtsOfContours[i]; const contour = points.slice(startPoint, endPoint + 1); if (contour[0].flags &amp; 1) { contour.push(contour[0]); } else if (contour.at(-1).flags &amp; 1) { contour.unshift(contour.at(-1)); } else { const p = { flags: 1, x: (contour[0].x + contour.at(-1).x) / 2, y: (contour[0].y + contour.at(-1).y) / 2 }; contour.unshift(p); contour.push(p); } moveTo(contour[0].x, contour[0].y); for (j = 1, jj = contour.length; j &lt; jj; j++) { if (contour[j].flags &amp; 1) { lineTo(contour[j].x, contour[j].y); } else if (contour[j + 1].flags &amp; 1) { quadraticCurveTo(contour[j].x, contour[j].y, contour[j + 1].x, contour[j + 1].y); j++; } else { quadraticCurveTo(contour[j].x, contour[j].y, (contour[j].x + contour[j + 1].x) / 2, (contour[j].y + contour[j + 1].y) / 2); } } startPoint = endPoint + 1; } } } function compileCharString(charStringCode, cmds, font, glyphId) { function moveTo(x, y) { cmds.push({ cmd: &quot;moveTo&quot;, args: [x, y] }); } function lineTo(x, y) { cmds.push({ cmd: &quot;lineTo&quot;, args: [x, y] }); } function bezierCurveTo(x1, y1, x2, y2, x, y) { cmds.push({ cmd: &quot;bezierCurveTo&quot;, args: [x1, y1, x2, y2, x, y] }); } const stack = []; let x = 0, y = 0; let stems = 0; function parse(code) { let i = 0; while (i &lt; code.length) { let stackClean = false; let v = code[i++]; let xa, xb, ya, yb, y1, y2, y3, n, subrCode; switch (v) { case 1: stems += stack.length &gt;&gt; 1; stackClean = true; break; case 3: stems += stack.length &gt;&gt; 1; stackClean = true; break; case 4: y += stack.pop(); moveTo(x, y); stackClean = true; break; case 5: while (stack.length &gt; 0) { x += stack.shift(); y += stack.shift(); lineTo(x, y); } break; case 6: while (stack.length &gt; 0) { x += stack.shift(); lineTo(x, y); if (stack.length === 0) { break; } y += stack.shift(); lineTo(x, y); } break; case 7: while (stack.length &gt; 0) { y += stack.shift(); lineTo(x, y); if (stack.length === 0) { break; } x += stack.shift(); lineTo(x, y); } break; case 8: while (stack.length &gt; 0) { xa = x + stack.shift(); ya = y + stack.shift(); xb = xa + stack.shift(); yb = ya + stack.shift(); x = xb + stack.shift(); y = yb + stack.shift(); bezierCurveTo(xa, ya, xb, yb, x, y); } break; case 10: n = stack.pop(); subrCode = null; if (font.isCFFCIDFont) { const fdIndex = font.fdSelect.getFDIndex(glyphId); if (fdIndex &gt;= 0 &amp;&amp; fdIndex &lt; font.fdArray.length) { const fontDict = font.fdArray[fdIndex]; let subrs; if (fontDict.privateDict &amp;&amp; fontDict.privateDict.subrsIndex) { subrs = fontDict.privateDict.subrsIndex.objects; } if (subrs) { n += getSubroutineBias(subrs); subrCode = subrs[n]; } } else { (0, _util.warn)(&quot;Invalid fd index for glyph index.&quot;); } } else { subrCode = font.subrs[n + font.subrsBias]; } if (subrCode) { parse(subrCode); } break; case 11: return; case 12: v = code[i++]; switch (v) { case 34: xa = x + stack.shift(); xb = xa + stack.shift(); y1 = y + stack.shift(); x = xb + stack.shift(); bezierCurveTo(xa, y, xb, y1, x, y1); xa = x + stack.shift(); xb = xa + stack.shift(); x = xb + stack.shift(); bezierCurveTo(xa, y1, xb, y, x, y); break; case 35: xa = x + stack.shift(); ya = y + stack.shift(); xb = xa + stack.shift(); yb = ya + stack.shift(); x = xb + stack.shift(); y = yb + stack.shift(); bezierCurveTo(xa, ya, xb, yb, x, y); xa = x + stack.shift(); ya = y + stack.shift(); xb = xa + stack.shift(); yb = ya + stack.shift(); x = xb + stack.shift(); y = yb + stack.shift(); bezierCurveTo(xa, ya, xb, yb, x, y); stack.pop(); break; case 36: xa = x + stack.shift(); y1 = y + stack.shift(); xb = xa + stack.shift(); y2 = y1 + stack.shift(); x = xb + stack.shift(); bezierCurveTo(xa, y1, xb, y2, x, y2); xa = x + stack.shift(); xb = xa + stack.shift(); y3 = y2 + stack.shift(); x = xb + stack.shift(); bezierCurveTo(xa, y2, xb, y3, x, y); break; case 37: const x0 = x, y0 = y; xa = x + stack.shift(); ya = y + stack.shift(); xb = xa + stack.shift(); yb = ya + stack.shift(); x = xb + stack.shift(); y = yb + stack.shift(); bezierCurveTo(xa, ya, xb, yb, x, y); xa = x + stack.shift(); ya = y + stack.shift(); xb = xa + stack.shift(); yb = ya + stack.shift(); x = xb; y = yb; if (Math.abs(x - x0) &gt; Math.abs(y - y0)) { x += stack.shift(); } else { y += stack.shift(); } bezierCurveTo(xa, ya, xb, yb, x, y); break; default: throw new _util.FormatError(`unknown operator: 12 ${v}`); } break; case 14: if (stack.length &gt;= 4) { const achar = stack.pop(); const bchar = stack.pop(); y = stack.pop(); x = stack.pop(); cmds.push({ cmd: &quot;save&quot; }, { cmd: &quot;translate&quot;, args: [x, y] }); let cmap = lookupCmap(font.cmap, String.fromCharCode(font.glyphNameMap[_encodings.StandardEncoding[achar]])); compileCharString(font.glyphs[cmap.glyphId], cmds, font, cmap.glyphId); cmds.push({ cmd: &quot;restore&quot; }); cmap = lookupCmap(font.cmap, String.fromCharCode(font.glyphNameMap[_encodings.StandardEncoding[bchar]])); compileCharString(font.glyphs[cmap.glyphId], cmds, font, cmap.glyphId); } return; case 18: stems += stack.length &gt;&gt; 1; stackClean = true; break; case 19: stems += stack.length &gt;&gt; 1; i += stems + 7 &gt;&gt; 3; stackClean = true; break; case 20: stems += stack.length &gt;&gt; 1; i += stems + 7 &gt;&gt; 3; stackClean = true; break; case 21: y += stack.pop(); x += stack.pop(); moveTo(x, y); stackClean = true; break; case 22: x += stack.pop(); moveTo(x, y); stackClean = true; break; case 23: stems += stack.length &gt;&gt; 1; stackClean = true; break; case 24: while (stack.length &gt; 2) { xa = x + stack.shift(); ya = y + stack.shift(); xb = xa + stack.shift(); yb = ya + stack.shift(); x = xb + stack.shift(); y = yb + stack.shift(); bezierCurveTo(xa, ya, xb, yb, x, y); } x += stack.shift(); y += stack.shift(); lineTo(x, y); break; case 25: while (stack.length &gt; 6) { x += stack.shift(); y += stack.shift(); lineTo(x, y); } xa = x + stack.shift(); ya = y + stack.shift(); xb = xa + stack.shift(); yb = ya + stack.shift(); x = xb + stack.shift(); y = yb + stack.shift(); bezierCurveTo(xa, ya, xb, yb, x, y); break; case 26: if (stack.length % 2) { x += stack.shift(); } while (stack.length &gt; 0) { xa = x; ya = y + stack.shift(); xb = xa + stack.shift(); yb = ya + stack.shift(); x = xb; y = yb + stack.shift(); bezierCurveTo(xa, ya, xb, yb, x, y); } break; case 27: if (stack.length % 2) { y += stack.shift(); } while (stack.length &gt; 0) { xa = x + stack.shift(); ya = y; xb = xa + stack.shift(); yb = ya + stack.shift(); x = xb + stack.shift(); y = yb; bezierCurveTo(xa, ya, xb, yb, x, y); } break; case 28: stack.push((code[i] &lt;&lt; 24 | code[i + 1] &lt;&lt; 16) &gt;&gt; 16); i += 2; break; case 29: n = stack.pop() + font.gsubrsBias; subrCode = font.gsubrs[n]; if (subrCode) { parse(subrCode); } break; case 30: while (stack.length &gt; 0) { xa = x; ya = y + stack.shift(); xb = xa + stack.shift(); yb = ya + stack.shift(); x = xb + stack.shift(); y = yb + (stack.length === 1 ? stack.shift() : 0); bezierCurveTo(xa, ya, xb, yb, x, y); if (stack.length === 0) { break; } xa = x + stack.shift(); ya = y; xb = xa + stack.shift(); yb = ya + stack.shift(); y = yb + stack.shift(); x = xb + (stack.length === 1 ? stack.shift() : 0); bezierCurveTo(xa, ya, xb, yb, x, y); } break; case 31: while (stack.length &gt; 0) { xa = x + stack.shift(); ya = y; xb = xa + stack.shift(); yb = ya + stack.shift(); y = yb + stack.shift(); x = xb + (stack.length === 1 ? stack.shift() : 0); bezierCurveTo(xa, ya, xb, yb, x, y); if (stack.length === 0) { break; } xa = x; ya = y + stack.shift(); xb = xa + stack.shift(); yb = ya + stack.shift(); x = xb + stack.shift(); y = yb + (stack.length === 1 ? stack.shift() : 0); bezierCurveTo(xa, ya, xb, yb, x, y); } break; default: if (v &lt; 32) { throw new _util.FormatError(`unknown operator: ${v}`); } if (v &lt; 247) { stack.push(v - 139); } else if (v &lt; 251) { stack.push((v - 247) * 256 + code[i++] + 108); } else if (v &lt; 255) { stack.push(-(v - 251) * 256 - code[i++] - 108); } else { stack.push((code[i] &lt;&lt; 24 | code[i + 1] &lt;&lt; 16 | code[i + 2] &lt;&lt; 8 | code[i + 3]) / 65536); i += 4; } break; } if (stackClean) { stack.length = 0; } } } parse(charStringCode); } const NOOP = []; class CompiledFont { constructor(fontMatrix) { if (this.constructor === CompiledFont) { (0, _util.unreachable)(&quot;Cannot initialize CompiledFont.&quot;); } this.fontMatrix = fontMatrix; this.compiledGlyphs = Object.create(null); this.compiledCharCodeToGlyphId = Object.create(null); } getPathJs(unicode) { const { charCode, glyphId } = lookupCmap(this.cmap, unicode); let fn = this.compiledGlyphs[glyphId]; if (!fn) { try { fn = this.compileGlyph(this.glyphs[glyphId], glyphId); this.compiledGlyphs[glyphId] = fn; } catch (ex) { this.compiledGlyphs[glyphId] = NOOP; if (this.compiledCharCodeToGlyphId[charCode] === undefined) { this.compiledCharCodeToGlyphId[charCode] = glyphId; } throw ex; } } if (this.compiledCharCodeToGlyphId[charCode] === undefined) { this.compiledCharCodeToGlyphId[charCode] = glyphId; } return fn; } compileGlyph(code, glyphId) { if (!code || code.length === 0 || code[0] === 14) { return NOOP; } let fontMatrix = this.fontMatrix; if (this.isCFFCIDFont) { const fdIndex = this.fdSelect.getFDIndex(glyphId); if (fdIndex &gt;= 0 &amp;&amp; fdIndex &lt; this.fdArray.length) { const fontDict = this.fdArray[fdIndex]; fontMatrix = fontDict.getByName(&quot;FontMatrix&quot;) || _util.FONT_IDENTITY_MATRIX; } else { (0, _util.warn)(&quot;Invalid fd index for glyph index.&quot;); } } const cmds = [{ cmd: &quot;save&quot; }, { cmd: &quot;transform&quot;, args: fontMatrix.slice() }, { cmd: &quot;scale&quot;, args: [&quot;size&quot;, &quot;-size&quot;] }]; this.compileGlyphImpl(code, cmds, glyphId); cmds.push({ cmd: &quot;restore&quot; }); return cmds; } compileGlyphImpl() { (0, _util.unreachable)(&quot;Children classes should implement this.&quot;); } hasBuiltPath(unicode) { const { charCode, glyphId } = lookupCmap(this.cmap, unicode); return this.compiledGlyphs[glyphId] !== undefined &amp;&amp; this.compiledCharCodeToGlyphId[charCode] !== undefined; } } class TrueTypeCompiled extends CompiledFont { constructor(glyphs, cmap, fontMatrix) { super(fontMatrix || [0.000488, 0, 0, 0.000488, 0, 0]); this.glyphs = glyphs; this.cmap = cmap; } compileGlyphImpl(code, cmds) { compileGlyf(code, cmds, this); } } class Type2Compiled extends CompiledFont { constructor(cffInfo, cmap, fontMatrix, glyphNameMap) { super(fontMatrix || [0.001, 0, 0, 0.001, 0, 0]); this.glyphs = cffInfo.glyphs; this.gsubrs = cffInfo.gsubrs || []; this.subrs = cffInfo.subrs || []; this.cmap = cmap; this.glyphNameMap = glyphNameMap || (0, _glyphlist.getGlyphsUnicode)(); this.gsubrsBias = getSubroutineBias(this.gsubrs); this.subrsBias = getSubroutineBias(this.subrs); this.isCFFCIDFont = cffInfo.isCFFCIDFont; this.fdSelect = cffInfo.fdSelect; this.fdArray = cffInfo.fdArray; } compileGlyphImpl(code, cmds, glyphId) { compileCharString(code, cmds, this, glyphId); } } class FontRendererFactory { static create(font, seacAnalysisEnabled) { const data = new Uint8Array(font.data); let cmap, glyf, loca, cff, indexToLocFormat, unitsPerEm; const numTables = getUint16(data, 4); for (let i = 0, p = 12; i &lt; numTables; i++, p += 16) { const tag = (0, _util.bytesToString)(data.subarray(p, p + 4)); const offset = getUint32(data, p + 8); const length = getUint32(data, p + 12); switch (tag) { case &quot;cmap&quot;: cmap = parseCmap(data, offset, offset + length); break; case &quot;glyf&quot;: glyf = data.subarray(offset, offset + length); break; case &quot;loca&quot;: loca = data.subarray(offset, offset + length); break; case &quot;head&quot;: unitsPerEm = getUint16(data, offset + 18); indexToLocFormat = getUint16(data, offset + 50); break; case &quot;CFF &quot;: cff = parseCff(data, offset, offset + length, seacAnalysisEnabled); break; } } if (glyf) { const fontMatrix = !unitsPerEm ? font.fontMatrix : [1 / unitsPerEm, 0, 0, 1 / unitsPerEm, 0, 0]; return new TrueTypeCompiled(parseGlyfTable(glyf, loca, indexToLocFormat), cmap, fontMatrix); } return new Type2Compiled(cff, cmap, font.fontMatrix, font.glyphNameMap); } } exports.FontRendererFactory = FontRendererFactory; /***/ }), /* 43 */ /***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) =&gt; { Object.defineProperty(exports, &quot;__esModule&quot;, ({ value: true })); exports.getMetrics = exports.getFontBasicMetrics = void 0; var _core_utils = __w_pdfjs_require__(4); const getMetrics = (0, _core_utils.getLookupTableFactory)(function (t) { t.Courier = 600; t[&quot;Courier-Bold&quot;] = 600; t[&quot;Courier-BoldOblique&quot;] = 600; t[&quot;Courier-Oblique&quot;] = 600; t.Helvetica = (0, _core_utils.getLookupTableFactory)(function (t) { t.space = 278; t.exclam = 278; t.quotedbl = 355; t.numbersign = 556; t.dollar = 556; t.percent = 889; t.ampersand = 667; t.quoteright = 222; t.parenleft = 333; t.parenright = 333; t.asterisk = 389; t.plus = 584; t.comma = 278; t.hyphen = 333; t.period = 278; t.slash = 278; t.zero = 556; t.one = 556; t.two = 556; t.three = 556; t.four = 556; t.five = 556; t.six = 556; t.seven = 556; t.eight = 556; t.nine = 556; t.colon = 278; t.semicolon = 278; t.less = 584; t.equal = 584; t.greater = 584; t.question = 556; t.at = 1015; t.A = 667; t.B = 667; t.C = 722; t.D = 722; t.E = 667; t.F = 611; t.G = 778; t.H = 722; t.I = 278; t.J = 500; t.K = 667; t.L = 556; t.M = 833; t.N = 722; t.O = 778; t.P = 667; t.Q = 778; t.R = 722; t.S = 667; t.T = 611; t.U = 722; t.V = 667; t.W = 944; t.X = 667; t.Y = 667; t.Z = 611; t.bracketleft = 278; t.backslash = 278; t.bracketright = 278; t.asciicircum = 469; t.underscore = 556; t.quoteleft = 222; t.a = 556; t.b = 556; t.c = 500; t.d = 556; t.e = 556; t.f = 278; t.g = 556; t.h = 556; t.i = 222; t.j = 222; t.k = 500; t.l = 222; t.m = 833; t.n = 556; t.o = 556; t.p = 556; t.q = 556; t.r = 333; t.s = 500; t.t = 278; t.u = 556; t.v = 500; t.w = 722; t.x = 500; t.y = 500; t.z = 500; t.braceleft = 334; t.bar = 260; t.braceright = 334; t.asciitilde = 584; t.exclamdown = 333; t.cent = 556; t.sterling = 556; t.fraction = 167; t.yen = 556; t.florin = 556; t.section = 556; t.currency = 556; t.quotesingle = 191; t.quotedblleft = 333; t.guillemotleft = 556; t.guilsinglleft = 333; t.guilsinglright = 333; t.fi = 500; t.fl = 500; t.endash = 556; t.dagger = 556; t.daggerdbl = 556; t.periodcentered = 278; t.paragraph = 537; t.bullet = 350; t.quotesinglbase = 222; t.quotedblbase = 333; t.quotedblright = 333; t.guillemotright = 556; t.ellipsis = 1000; t.perthousand = 1000; t.questiondown = 611; t.grave = 333; t.acute = 333; t.circumflex = 333; t.tilde = 333; t.macron = 333; t.breve = 333; t.dotaccent = 333; t.dieresis = 333; t.ring = 333; t.cedilla = 333; t.hungarumlaut = 333; t.ogonek = 333; t.caron = 333; t.emdash = 1000; t.AE = 1000; t.ordfeminine = 370; t.Lslash = 556; t.Oslash = 778; t.OE = 1000; t.ordmasculine = 365; t.ae = 889; t.dotlessi = 278; t.lslash = 222; t.oslash = 611; t.oe = 944; t.germandbls = 611; t.Idieresis = 278; t.eacute = 556; t.abreve = 556; t.uhungarumlaut = 556; t.ecaron = 556; t.Ydieresis = 667; t.divide = 584; t.Yacute = 667; t.Acircumflex = 667; t.aacute = 556; t.Ucircumflex = 722; t.yacute = 500; t.scommaaccent = 500; t.ecircumflex = 556; t.Uring = 722; t.Udieresis = 722; t.aogonek = 556; t.Uacute = 722; t.uogonek = 556; t.Edieresis = 667; t.Dcroat = 722; t.commaaccent = 250; t.copyright = 737; t.Emacron = 667; t.ccaron = 500; t.aring = 556; t.Ncommaaccent = 722; t.lacute = 222; t.agrave = 556; t.Tcommaaccent = 611; t.Cacute = 722; t.atilde = 556; t.Edotaccent = 667; t.scaron = 500; t.scedilla = 500; t.iacute = 278; t.lozenge = 471; t.Rcaron = 722; t.Gcommaaccent = 778; t.ucircumflex = 556; t.acircumflex = 556; t.Amacron = 667; t.rcaron = 333; t.ccedilla = 500; t.Zdotaccent = 611; t.Thorn = 667; t.Omacron = 778; t.Racute = 722; t.Sacute = 667; t.dcaron = 643; t.Umacron = 722; t.uring = 556; t.threesuperior = 333; t.Ograve = 778; t.Agrave = 667; t.Abreve = 667; t.multiply = 584; t.uacute = 556; t.Tcaron = 611; t.partialdiff = 476; t.ydieresis = 500; t.Nacute = 722; t.icircumflex = 278; t.Ecircumflex = 667; t.adieresis = 556; t.edieresis = 556; t.cacute = 500; t.nacute = 556; t.umacron = 556; t.Ncaron = 722; t.Iacute = 278; t.plusminus = 584; t.brokenbar = 260; t.registered = 737; t.Gbreve = 778; t.Idotaccent = 278; t.summation = 600; t.Egrave = 667; t.racute = 333; t.omacron = 556; t.Zacute = 611; t.Zcaron = 611; t.greaterequal = 549; t.Eth = 722; t.Ccedilla = 722; t.lcommaaccent = 222; t.tcaron = 317; t.eogonek = 556; t.Uogonek = 722; t.Aacute = 667; t.Adieresis = 667; t.egrave = 556; t.zacute = 500; t.iogonek = 222; t.Oacute = 778; t.oacute = 556; t.amacron = 556; t.sacute = 500; t.idieresis = 278; t.Ocircumflex = 778; t.Ugrave = 722; t.Delta = 612; t.thorn = 556; t.twosuperior = 333; t.Odieresis = 778; t.mu = 556; t.igrave = 278; t.ohungarumlaut = 556; t.Eogonek = 667; t.dcroat = 556; t.threequarters = 834; t.Scedilla = 667; t.lcaron = 299; t.Kcommaaccent = 667; t.Lacute = 556; t.trademark = 1000; t.edotaccent = 556; t.Igrave = 278; t.Imacron = 278; t.Lcaron = 556; t.onehalf = 834; t.lessequal = 549; t.ocircumflex = 556; t.ntilde = 556; t.Uhungarumlaut = 722; t.Eacute = 667; t.emacron = 556; t.gbreve = 556; t.onequarter = 834; t.Scaron = 667; t.Scommaaccent = 667; t.Ohungarumlaut = 778; t.degree = 400; t.ograve = 556; t.Ccaron = 722; t.ugrave = 556; t.radical = 453; t.Dcaron = 722; t.rcommaaccent = 333; t.Ntilde = 722; t.otilde = 556; t.Rcommaaccent = 722; t.Lcommaaccent = 556; t.Atilde = 667; t.Aogonek = 667; t.Aring = 667; t.Otilde = 778; t.zdotaccent = 500; t.Ecaron = 667; t.Iogonek = 278; t.kcommaaccent = 500; t.minus = 584; t.Icircumflex = 278; t.ncaron = 556; t.tcommaaccent = 278; t.logicalnot = 584; t.odieresis = 556; t.udieresis = 556; t.notequal = 549; t.gcommaaccent = 556; t.eth = 556; t.zcaron = 500; t.ncommaaccent = 556; t.onesuperior = 333; t.imacron = 278; t.Euro = 556; }); t[&quot;Helvetica-Bold&quot;] = (0, _core_utils.getLookupTableFactory)(function (t) { t.space = 278; t.exclam = 333; t.quotedbl = 474; t.numbersign = 556; t.dollar = 556; t.percent = 889; t.ampersand = 722; t.quoteright = 278; t.parenleft = 333; t.parenright = 333; t.asterisk = 389; t.plus = 584; t.comma = 278; t.hyphen = 333; t.period = 278; t.slash = 278; t.zero = 556; t.one = 556; t.two = 556; t.three = 556; t.four = 556; t.five = 556; t.six = 556; t.seven = 556; t.eight = 556; t.nine = 556; t.colon = 333; t.semicolon = 333; t.less = 584; t.equal = 584; t.greater = 584; t.question = 611; t.at = 975; t.A = 722; t.B = 722; t.C = 722; t.D = 722; t.E = 667; t.F = 611; t.G = 778; t.H = 722; t.I = 278; t.J = 556; t.K = 722; t.L = 611; t.M = 833; t.N = 722; t.O = 778; t.P = 667; t.Q = 778; t.R = 722; t.S = 667; t.T = 611; t.U = 722; t.V = 667; t.W = 944; t.X = 667; t.Y = 667; t.Z = 611; t.bracketleft = 333; t.backslash = 278; t.bracketright = 333; t.asciicircum = 584; t.underscore = 556; t.quoteleft = 278; t.a = 556; t.b = 611; t.c = 556; t.d = 611; t.e = 556; t.f = 333; t.g = 611; t.h = 611; t.i = 278; t.j = 278; t.k = 556; t.l = 278; t.m = 889; t.n = 611; t.o = 611; t.p = 611; t.q = 611; t.r = 389; t.s = 556; t.t = 333; t.u = 611; t.v = 556; t.w = 778; t.x = 556; t.y = 556; t.z = 500; t.braceleft = 389; t.bar = 280; t.braceright = 389; t.asciitilde = 584; t.exclamdown = 333; t.cent = 556; t.sterling = 556; t.fraction = 167; t.yen = 556; t.florin = 556; t.section = 556; t.currency = 556; t.quotesingle = 238; t.quotedblleft = 500; t.guillemotleft = 556; t.guilsinglleft = 333; t.guilsinglright = 333; t.fi = 611; t.fl = 611; t.endash = 556; t.dagger = 556; t.daggerdbl = 556; t.periodcentered = 278; t.paragraph = 556; t.bullet = 350; t.quotesinglbase = 278; t.quotedblbase = 500; t.quotedblright = 500; t.guillemotright = 556; t.ellipsis = 1000; t.perthousand = 1000; t.questiondown = 611; t.grave = 333; t.acute = 333; t.circumflex = 333; t.tilde = 333; t.macron = 333; t.breve = 333; t.dotaccent = 333; t.dieresis = 333; t.ring = 333; t.cedilla = 333; t.hungarumlaut = 333; t.ogonek = 333; t.caron = 333; t.emdash = 1000; t.AE = 1000; t.ordfeminine = 370; t.Lslash = 611; t.Oslash = 778; t.OE = 1000; t.ordmasculine = 365; t.ae = 889; t.dotlessi = 278; t.lslash = 278; t.oslash = 611; t.oe = 944; t.germandbls = 611; t.Idieresis = 278; t.eacute = 556; t.abreve = 556; t.uhungarumlaut = 611; t.ecaron = 556; t.Ydieresis = 667; t.divide = 584; t.Yacute = 667; t.Acircumflex = 722; t.aacute = 556; t.Ucircumflex = 722; t.yacute = 556; t.scommaaccent = 556; t.ecircumflex = 556; t.Uring = 722; t.Udieresis = 722; t.aogonek = 556; t.Uacute = 722; t.uogonek = 611; t.Edieresis = 667; t.Dcroat = 722; t.commaaccent = 250; t.copyright = 737; t.Emacron = 667; t.ccaron = 556; t.aring = 556; t.Ncommaaccent = 722; t.lacute = 278; t.agrave = 556; t.Tcommaaccent = 611; t.Cacute = 722; t.atilde = 556; t.Edotaccent = 667; t.scaron = 556; t.scedilla = 556; t.iacute = 278; t.lozenge = 494; t.Rcaron = 722; t.Gcommaaccent = 778; t.ucircumflex = 611; t.acircumflex = 556; t.Amacron = 722; t.rcaron = 389; t.ccedilla = 556; t.Zdotaccent = 611; t.Thorn = 667; t.Omacron = 778; t.Racute = 722; t.Sacute = 667; t.dcaron = 743; t.Umacron = 722; t.uring = 611; t.threesuperior = 333; t.Ograve = 778; t.Agrave = 722; t.Abreve = 722; t.multiply = 584; t.uacute = 611; t.Tcaron = 611; t.partialdiff = 494; t.ydieresis = 556; t.Nacute = 722; t.icircumflex = 278; t.Ecircumflex = 667; t.adieresis = 556; t.edieresis = 556; t.cacute = 556; t.nacute = 611; t.umacron = 611; t.Ncaron = 722; t.Iacute = 278; t.plusminus = 584; t.brokenbar = 280; t.registered = 737; t.Gbreve = 778; t.Idotaccent = 278; t.summation = 600; t.Egrave = 667; t.racute = 389; t.omacron = 611; t.Zacute = 611; t.Zcaron = 611; t.greaterequal = 549; t.Eth = 722; t.Ccedilla = 722; t.lcommaaccent = 278; t.tcaron = 389; t.eogonek = 556; t.Uogonek = 722; t.Aacute = 722; t.Adieresis = 722; t.egrave = 556; t.zacute = 500; t.iogonek = 278; t.Oacute = 778; t.oacute = 611; t.amacron = 556; t.sacute = 556; t.idieresis = 278; t.Ocircumflex = 778; t.Ugrave = 722; t.Delta = 612; t.thorn = 611; t.twosuperior = 333; t.Odieresis = 778; t.mu = 611; t.igrave = 278; t.ohungarumlaut = 611; t.Eogonek = 667; t.dcroat = 611; t.threequarters = 834; t.Scedilla = 667; t.lcaron = 400; t.Kcommaaccent = 722; t.Lacute = 611; t.trademark = 1000; t.edotaccent = 556; t.Igrave = 278; t.Imacron = 278; t.Lcaron = 611; t.onehalf = 834; t.lessequal = 549; t.ocircumflex = 611; t.ntilde = 611; t.Uhungarumlaut = 722; t.Eacute = 667; t.emacron = 556; t.gbreve = 611; t.onequarter = 834; t.Scaron = 667; t.Scommaaccent = 667; t.Ohungarumlaut = 778; t.degree = 400; t.ograve = 611; t.Ccaron = 722; t.ugrave = 611; t.radical = 549; t.Dcaron = 722; t.rcommaaccent = 389; t.Ntilde = 722; t.otilde = 611; t.Rcommaaccent = 722; t.Lcommaaccent = 611; t.Atilde = 722; t.Aogonek = 722; t.Aring = 722; t.Otilde = 778; t.zdotaccent = 500; t.Ecaron = 667; t.Iogonek = 278; t.kcommaaccent = 556; t.minus = 584; t.Icircumflex = 278; t.ncaron = 611; t.tcommaaccent = 333; t.logicalnot = 584; t.odieresis = 611; t.udieresis = 611; t.notequal = 549; t.gcommaaccent = 611; t.eth = 611; t.zcaron = 500; t.ncommaaccent = 611; t.onesuperior = 333; t.imacron = 278; t.Euro = 556; }); t[&quot;Helvetica-BoldOblique&quot;] = (0, _core_utils.getLookupTableFactory)(function (t) { t.space = 278; t.exclam = 333; t.quotedbl = 474; t.numbersign = 556; t.dollar = 556; t.percent = 889; t.ampersand = 722; t.quoteright = 278; t.parenleft = 333; t.parenright = 333; t.asterisk = 389; t.plus = 584; t.comma = 278; t.hyphen = 333; t.period = 278; t.slash = 278; t.zero = 556; t.one = 556; t.two = 556; t.three = 556; t.four = 556; t.five = 556; t.six = 556; t.seven = 556; t.eight = 556; t.nine = 556; t.colon = 333; t.semicolon = 333; t.less = 584; t.equal = 584; t.greater = 584; t.question = 611; t.at = 975; t.A = 722; t.B = 722; t.C = 722; t.D = 722; t.E = 667; t.F = 611; t.G = 778; t.H = 722; t.I = 278; t.J = 556; t.K = 722; t.L = 611; t.M = 833; t.N = 722; t.O = 778; t.P = 667; t.Q = 778; t.R = 722; t.S = 667; t.T = 611; t.U = 722; t.V = 667; t.W = 944; t.X = 667; t.Y = 667; t.Z = 611; t.bracketleft = 333; t.backslash = 278; t.bracketright = 333; t.asciicircum = 584; t.underscore = 556; t.quoteleft = 278; t.a = 556; t.b = 611; t.c = 556; t.d = 611; t.e = 556; t.f = 333; t.g = 611; t.h = 611; t.i = 278; t.j = 278; t.k = 556; t.l = 278; t.m = 889; t.n = 611; t.o = 611; t.p = 611; t.q = 611; t.r = 389; t.s = 556; t.t = 333; t.u = 611; t.v = 556; t.w = 778; t.x = 556; t.y = 556; t.z = 500; t.braceleft = 389; t.bar = 280; t.braceright = 389; t.asciitilde = 584; t.exclamdown = 333; t.cent = 556; t.sterling = 556; t.fraction = 167; t.yen = 556; t.florin = 556; t.section = 556; t.currency = 556; t.quotesingle = 238; t.quotedblleft = 500; t.guillemotleft = 556; t.guilsinglleft = 333; t.guilsinglright = 333; t.fi = 611; t.fl = 611; t.endash = 556; t.dagger = 556; t.daggerdbl = 556; t.periodcentered = 278; t.paragraph = 556; t.bullet = 350; t.quotesinglbase = 278; t.quotedblbase = 500; t.quotedblright = 500; t.guillemotright = 556; t.ellipsis = 1000; t.perthousand = 1000; t.questiondown = 611; t.grave = 333; t.acute = 333; t.circumflex = 333; t.tilde = 333; t.macron = 333; t.breve = 333; t.dotaccent = 333; t.dieresis = 333; t.ring = 333; t.cedilla = 333; t.hungarumlaut = 333; t.ogonek = 333; t.caron = 333; t.emdash = 1000; t.AE = 1000; t.ordfeminine = 370; t.Lslash = 611; t.Oslash = 778; t.OE = 1000; t.ordmasculine = 365; t.ae = 889; t.dotlessi = 278; t.lslash = 278; t.oslash = 611; t.oe = 944; t.germandbls = 611; t.Idieresis = 278; t.eacute = 556; t.abreve = 556; t.uhungarumlaut = 611; t.ecaron = 556; t.Ydieresis = 667; t.divide = 584; t.Yacute = 667; t.Acircumflex = 722; t.aacute = 556; t.Ucircumflex = 722; t.yacute = 556; t.scommaaccent = 556; t.ecircumflex = 556; t.Uring = 722; t.Udieresis = 722; t.aogonek = 556; t.Uacute = 722; t.uogonek = 611; t.Edieresis = 667; t.Dcroat = 722; t.commaaccent = 250; t.copyright = 737; t.Emacron = 667; t.ccaron = 556; t.aring = 556; t.Ncommaaccent = 722; t.lacute = 278; t.agrave = 556; t.Tcommaaccent = 611; t.Cacute = 722; t.atilde = 556; t.Edotaccent = 667; t.scaron = 556; t.scedilla = 556; t.iacute = 278; t.lozenge = 494; t.Rcaron = 722; t.Gcommaaccent = 778; t.ucircumflex = 611; t.acircumflex = 556; t.Amacron = 722; t.rcaron = 389; t.ccedilla = 556; t.Zdotaccent = 611; t.Thorn = 667; t.Omacron = 778; t.Racute = 722; t.Sacute = 667; t.dcaron = 743; t.Umacron = 722; t.uring = 611; t.threesuperior = 333; t.Ograve = 778; t.Agrave = 722; t.Abreve = 722; t.multiply = 584; t.uacute = 611; t.Tcaron = 611; t.partialdiff = 494; t.ydieresis = 556; t.Nacute = 722; t.icircumflex = 278; t.Ecircumflex = 667; t.adieresis = 556; t.edieresis = 556; t.cacute = 556; t.nacute = 611; t.umacron = 611; t.Ncaron = 722; t.Iacute = 278; t.plusminus = 584; t.brokenbar = 280; t.registered = 737; t.Gbreve = 778; t.Idotaccent = 278; t.summation = 600; t.Egrave = 667; t.racute = 389; t.omacron = 611; t.Zacute = 611; t.Zcaron = 611; t.greaterequal = 549; t.Eth = 722; t.Ccedilla = 722; t.lcommaaccent = 278; t.tcaron = 389; t.eogonek = 556; t.Uogonek = 722; t.Aacute = 722; t.Adieresis = 722; t.egrave = 556; t.zacute = 500; t.iogonek = 278; t.Oacute = 778; t.oacute = 611; t.amacron = 556; t.sacute = 556; t.idieresis = 278; t.Ocircumflex = 778; t.Ugrave = 722; t.Delta = 612; t.thorn = 611; t.twosuperior = 333; t.Odieresis = 778; t.mu = 611; t.igrave = 278; t.ohungarumlaut = 611; t.Eogonek = 667; t.dcroat = 611; t.threequarters = 834; t.Scedilla = 667; t.lcaron = 400; t.Kcommaaccent = 722; t.Lacute = 611; t.trademark = 1000; t.edotaccent = 556; t.Igrave = 278; t.Imacron = 278; t.Lcaron = 611; t.onehalf = 834; t.lessequal = 549; t.ocircumflex = 611; t.ntilde = 611; t.Uhungarumlaut = 722; t.Eacute = 667; t.emacron = 556; t.gbreve = 611; t.onequarter = 834; t.Scaron = 667; t.Scommaaccent = 667; t.Ohungarumlaut = 778; t.degree = 400; t.ograve = 611; t.Ccaron = 722; t.ugrave = 611; t.radical = 549; t.Dcaron = 722; t.rcommaaccent = 389; t.Ntilde = 722; t.otilde = 611; t.Rcommaaccent = 722; t.Lcommaaccent = 611; t.Atilde = 722; t.Aogonek = 722; t.Aring = 722; t.Otilde = 778; t.zdotaccent = 500; t.Ecaron = 667; t.Iogonek = 278; t.kcommaaccent = 556; t.minus = 584; t.Icircumflex = 278; t.ncaron = 611; t.tcommaaccent = 333; t.logicalnot = 584; t.odieresis = 611; t.udieresis = 611; t.notequal = 549; t.gcommaaccent = 611; t.eth = 611; t.zcaron = 500; t.ncommaaccent = 611; t.onesuperior = 333; t.imacron = 278; t.Euro = 556; }); t[&quot;Helvetica-Oblique&quot;] = (0, _core_utils.getLookupTableFactory)(function (t) { t.space = 278; t.exclam = 278; t.quotedbl = 355; t.numbersign = 556; t.dollar = 556; t.percent = 889; t.ampersand = 667; t.quoteright = 222; t.parenleft = 333; t.parenright = 333; t.asterisk = 389; t.plus = 584; t.comma = 278; t.hyphen = 333; t.period = 278; t.slash = 278; t.zero = 556; t.one = 556; t.two = 556; t.three = 556; t.four = 556; t.five = 556; t.six = 556; t.seven = 556; t.eight = 556; t.nine = 556; t.colon = 278; t.semicolon = 278; t.less = 584; t.equal = 584; t.greater = 584; t.question = 556; t.at = 1015; t.A = 667; t.B = 667; t.C = 722; t.D = 722; t.E = 667; t.F = 611; t.G = 778; t.H = 722; t.I = 278; t.J = 500; t.K = 667; t.L = 556; t.M = 833; t.N = 722; t.O = 778; t.P = 667; t.Q = 778; t.R = 722; t.S = 667; t.T = 611; t.U = 722; t.V = 667; t.W = 944; t.X = 667; t.Y = 667; t.Z = 611; t.bracketleft = 278; t.backslash = 278; t.bracketright = 278; t.asciicircum = 469; t.underscore = 556; t.quoteleft = 222; t.a = 556; t.b = 556; t.c = 500; t.d = 556; t.e = 556; t.f = 278; t.g = 556; t.h = 556; t.i = 222; t.j = 222; t.k = 500; t.l = 222; t.m = 833; t.n = 556; t.o = 556; t.p = 556; t.q = 556; t.r = 333; t.s = 500; t.t = 278; t.u = 556; t.v = 500; t.w = 722; t.x = 500; t.y = 500; t.z = 500; t.braceleft = 334; t.bar = 260; t.braceright = 334; t.asciitilde = 584; t.exclamdown = 333; t.cent = 556; t.sterling = 556; t.fraction = 167; t.yen = 556; t.florin = 556; t.section = 556; t.currency = 556; t.quotesingle = 191; t.quotedblleft = 333; t.guillemotleft = 556; t.guilsinglleft = 333; t.guilsinglright = 333; t.fi = 500; t.fl = 500; t.endash = 556; t.dagger = 556; t.daggerdbl = 556; t.periodcentered = 278; t.paragraph = 537; t.bullet = 350; t.quotesinglbase = 222; t.quotedblbase = 333; t.quotedblright = 333; t.guillemotright = 556; t.ellipsis = 1000; t.perthousand = 1000; t.questiondown = 611; t.grave = 333; t.acute = 333; t.circumflex = 333; t.tilde = 333; t.macron = 333; t.breve = 333; t.dotaccent = 333; t.dieresis = 333; t.ring = 333; t.cedilla = 333; t.hungarumlaut = 333; t.ogonek = 333; t.caron = 333; t.emdash = 1000; t.AE = 1000; t.ordfeminine = 370; t.Lslash = 556; t.Oslash = 778; t.OE = 1000; t.ordmasculine = 365; t.ae = 889; t.dotlessi = 278; t.lslash = 222; t.oslash = 611; t.oe = 944; t.germandbls = 611; t.Idieresis = 278; t.eacute = 556; t.abreve = 556; t.uhungarumlaut = 556; t.ecaron = 556; t.Ydieresis = 667; t.divide = 584; t.Yacute = 667; t.Acircumflex = 667; t.aacute = 556; t.Ucircumflex = 722; t.yacute = 500; t.scommaaccent = 500; t.ecircumflex = 556; t.Uring = 722; t.Udieresis = 722; t.aogonek = 556; t.Uacute = 722; t.uogonek = 556; t.Edieresis = 667; t.Dcroat = 722; t.commaaccent = 250; t.copyright = 737; t.Emacron = 667; t.ccaron = 500; t.aring = 556; t.Ncommaaccent = 722; t.lacute = 222; t.agrave = 556; t.Tcommaaccent = 611; t.Cacute = 722; t.atilde = 556; t.Edotaccent = 667; t.scaron = 500; t.scedilla = 500; t.iacute = 278; t.lozenge = 471; t.Rcaron = 722; t.Gcommaaccent = 778; t.ucircumflex = 556; t.acircumflex = 556; t.Amacron = 667; t.rcaron = 333; t.ccedilla = 500; t.Zdotaccent = 611; t.Thorn = 667; t.Omacron = 778; t.Racute = 722; t.Sacute = 667; t.dcaron = 643; t.Umacron = 722; t.uring = 556; t.threesuperior = 333; t.Ograve = 778; t.Agrave = 667; t.Abreve = 667; t.multiply = 584; t.uacute = 556; t.Tcaron = 611; t.partialdiff = 476; t.ydieresis = 500; t.Nacute = 722; t.icircumflex = 278; t.Ecircumflex = 667; t.adieresis = 556; t.edieresis = 556; t.cacute = 500; t.nacute = 556; t.umacron = 556; t.Ncaron = 722; t.Iacute = 278; t.plusminus = 584; t.brokenbar = 260; t.registered = 737; t.Gbreve = 778; t.Idotaccent = 278; t.summation = 600; t.Egrave = 667; t.racute = 333; t.omacron = 556; t.Zacute = 611; t.Zcaron = 611; t.greaterequal = 549; t.Eth = 722; t.Ccedilla = 722; t.lcommaaccent = 222; t.tcaron = 317; t.eogonek = 556; t.Uogonek = 722; t.Aacute = 667; t.Adieresis = 667; t.egrave = 556; t.zacute = 500; t.iogonek = 222; t.Oacute = 778; t.oacute = 556; t.amacron = 556; t.sacute = 500; t.idieresis = 278; t.Ocircumflex = 778; t.Ugrave = 722; t.Delta = 612; t.thorn = 556; t.twosuperior = 333; t.Odieresis = 778; t.mu = 556; t.igrave = 278; t.ohungarumlaut = 556; t.Eogonek = 667; t.dcroat = 556; t.threequarters = 834; t.Scedilla = 667; t.lcaron = 299; t.Kcommaaccent = 667; t.Lacute = 556; t.trademark = 1000; t.edotaccent = 556; t.Igrave = 278; t.Imacron = 278; t.Lcaron = 556; t.onehalf = 834; t.lessequal = 549; t.ocircumflex = 556; t.ntilde = 556; t.Uhungarumlaut = 722; t.Eacute = 667; t.emacron = 556; t.gbreve = 556; t.onequarter = 834; t.Scaron = 667; t.Scommaaccent = 667; t.Ohungarumlaut = 778; t.degree = 400; t.ograve = 556; t.Ccaron = 722; t.ugrave = 556; t.radical = 453; t.Dcaron = 722; t.rcommaaccent = 333; t.Ntilde = 722; t.otilde = 556; t.Rcommaaccent = 722; t.Lcommaaccent = 556; t.Atilde = 667; t.Aogonek = 667; t.Aring = 667; t.Otilde = 778; t.zdotaccent = 500; t.Ecaron = 667; t.Iogonek = 278; t.kcommaaccent = 500; t.minus = 584; t.Icircumflex = 278; t.ncaron = 556; t.tcommaaccent = 278; t.logicalnot = 584; t.odieresis = 556; t.udieresis = 556; t.notequal = 549; t.gcommaaccent = 556; t.eth = 556; t.zcaron = 500; t.ncommaaccent = 556; t.onesuperior = 333; t.imacron = 278; t.Euro = 556; }); t.Symbol = (0, _core_utils.getLookupTableFactory)(function (t) { t.space = 250; t.exclam = 333; t.universal = 713; t.numbersign = 500; t.existential = 549; t.percent = 833; t.ampersand = 778; t.suchthat = 439; t.parenleft = 333; t.parenright = 333; t.asteriskmath = 500; t.plus = 549; t.comma = 250; t.minus = 549; t.period = 250; t.slash = 278; t.zero = 500; t.one = 500; t.two = 500; t.three = 500; t.four = 500; t.five = 500; t.six = 500; t.seven = 500; t.eight = 500; t.nine = 500; t.colon = 278; t.semicolon = 278; t.less = 549; t.equal = 549; t.greater = 549; t.question = 444; t.congruent = 549; t.Alpha = 722; t.Beta = 667; t.Chi = 722; t.Delta = 612; t.Epsilon = 611; t.Phi = 763; t.Gamma = 603; t.Eta = 722; t.Iota = 333; t.theta1 = 631; t.Kappa = 722; t.Lambda = 686; t.Mu = 889; t.Nu = 722; t.Omicron = 722; t.Pi = 768; t.Theta = 741; t.Rho = 556; t.Sigma = 592; t.Tau = 611; t.Upsilon = 690; t.sigma1 = 439; t.Omega = 768; t.Xi = 645; t.Psi = 795; t.Zeta = 611; t.bracketleft = 333; t.therefore = 863; t.bracketright = 333; t.perpendicular = 658; t.underscore = 500; t.radicalex = 500; t.alpha = 631; t.beta = 549; t.chi = 549; t.delta = 494; t.epsilon = 439; t.phi = 521; t.gamma = 411; t.eta = 603; t.iota = 329; t.phi1 = 603; t.kappa = 549; t.lambda = 549; t.mu = 576; t.nu = 521; t.omicron = 549; t.pi = 549; t.theta = 521; t.rho = 549; t.sigma = 603; t.tau = 439; t.upsilon = 576; t.omega1 = 713; t.omega = 686; t.xi = 493; t.psi = 686; t.zeta = 494; t.braceleft = 480; t.bar = 200; t.braceright = 480; t.similar = 549; t.Euro = 750; t.Upsilon1 = 620; t.minute = 247; t.lessequal = 549; t.fraction = 167; t.infinity = 713; t.florin = 500; t.club = 753; t.diamond = 753; t.heart = 753; t.spade = 753; t.arrowboth = 1042; t.arrowleft = 987; t.arrowup = 603; t.arrowright = 987; t.arrowdown = 603; t.degree = 400; t.plusminus = 549; t.second = 411; t.greaterequal = 549; t.multiply = 549; t.proportional = 713; t.partialdiff = 494; t.bullet = 460; t.divide = 549; t.notequal = 549; t.equivalence = 549; t.approxequal = 549; t.ellipsis = 1000; t.arrowvertex = 603; t.arrowhorizex = 1000; t.carriagereturn = 658; t.aleph = 823; t.Ifraktur = 686; t.Rfraktur = 795; t.weierstrass = 987; t.circlemultiply = 768; t.circleplus = 768; t.emptyset = 823; t.intersection = 768; t.union = 768; t.propersuperset = 713; t.reflexsuperset = 713; t.notsubset = 713; t.propersubset = 713; t.reflexsubset = 713; t.element = 713; t.notelement = 713; t.angle = 768; t.gradient = 713; t.registerserif = 790; t.copyrightserif = 790; t.trademarkserif = 890; t.product = 823; t.radical = 549; t.dotmath = 250; t.logicalnot = 713; t.logicaland = 603; t.logicalor = 603; t.arrowdblboth = 1042; t.arrowdblleft = 987; t.arrowdblup = 603; t.arrowdblright = 987; t.arrowdbldown = 603; t.lozenge = 494; t.angleleft = 329; t.registersans = 790; t.copyrightsans = 790; t.trademarksans = 786; t.summation = 713; t.parenlefttp = 384; t.parenleftex = 384; t.parenleftbt = 384; t.bracketlefttp = 384; t.bracketleftex = 384; t.bracketleftbt = 384; t.bracelefttp = 494; t.braceleftmid = 494; t.braceleftbt = 494; t.braceex = 494; t.angleright = 329; t.integral = 274; t.integraltp = 686; t.integralex = 686; t.integralbt = 686; t.parenrighttp = 384; t.parenrightex = 384; t.parenrightbt = 384; t.bracketrighttp = 384; t.bracketrightex = 384; t.bracketrightbt = 384; t.bracerighttp = 494; t.bracerightmid = 494; t.bracerightbt = 494; t.apple = 790; }); t[&quot;Times-Roman&quot;] = (0, _core_utils.getLookupTableFactory)(function (t) { t.space = 250; t.exclam = 333; t.quotedbl = 408; t.numbersign = 500; t.dollar = 500; t.percent = 833; t.ampersand = 778; t.quoteright = 333; t.parenleft = 333; t.parenright = 333; t.asterisk = 500; t.plus = 564; t.comma = 250; t.hyphen = 333; t.period = 250; t.slash = 278; t.zero = 500; t.one = 500; t.two = 500; t.three = 500; t.four = 500; t.five = 500; t.six = 500; t.seven = 500; t.eight = 500; t.nine = 500; t.colon = 278; t.semicolon = 278; t.less = 564; t.equal = 564; t.greater = 564; t.question = 444; t.at = 921; t.A = 722; t.B = 667; t.C = 667; t.D = 722; t.E = 611; t.F = 556; t.G = 722; t.H = 722; t.I = 333; t.J = 389; t.K = 722; t.L = 611; t.M = 889; t.N = 722; t.O = 722; t.P = 556; t.Q = 722; t.R = 667; t.S = 556; t.T = 611; t.U = 722; t.V = 722; t.W = 944; t.X = 722; t.Y = 722; t.Z = 611; t.bracketleft = 333; t.backslash = 278; t.bracketright = 333; t.asciicircum = 469; t.underscore = 500; t.quoteleft = 333; t.a = 444; t.b = 500; t.c = 444; t.d = 500; t.e = 444; t.f = 333; t.g = 500; t.h = 500; t.i = 278; t.j = 278; t.k = 500; t.l = 278; t.m = 778; t.n = 500; t.o = 500; t.p = 500; t.q = 500; t.r = 333; t.s = 389; t.t = 278; t.u = 500; t.v = 500; t.w = 722; t.x = 500; t.y = 500; t.z = 444; t.braceleft = 480; t.bar = 200; t.braceright = 480; t.asciitilde = 541; t.exclamdown = 333; t.cent = 500; t.sterling = 500; t.fraction = 167; t.yen = 500; t.florin = 500; t.section = 500; t.currency = 500; t.quotesingle = 180; t.quotedblleft = 444; t.guillemotleft = 500; t.guilsinglleft = 333; t.guilsinglright = 333; t.fi = 556; t.fl = 556; t.endash = 500; t.dagger = 500; t.daggerdbl = 500; t.periodcentered = 250; t.paragraph = 453; t.bullet = 350; t.quotesinglbase = 333; t.quotedblbase = 444; t.quotedblright = 444; t.guillemotright = 500; t.ellipsis = 1000; t.perthousand = 1000; t.questiondown = 444; t.grave = 333; t.acute = 333; t.circumflex = 333; t.tilde = 333; t.macron = 333; t.breve = 333; t.dotaccent = 333; t.dieresis = 333; t.ring = 333; t.cedilla = 333; t.hungarumlaut = 333; t.ogonek = 333; t.caron = 333; t.emdash = 1000; t.AE = 889; t.ordfeminine = 276; t.Lslash = 611; t.Oslash = 722; t.OE = 889; t.ordmasculine = 310; t.ae = 667; t.dotlessi = 278; t.lslash = 278; t.oslash = 500; t.oe = 722; t.germandbls = 500; t.Idieresis = 333; t.eacute = 444; t.abreve = 444; t.uhungarumlaut = 500; t.ecaron = 444; t.Ydieresis = 722; t.divide = 564; t.Yacute = 722; t.Acircumflex = 722; t.aacute = 444; t.Ucircumflex = 722; t.yacute = 500; t.scommaaccent = 389; t.ecircumflex = 444; t.Uring = 722; t.Udieresis = 722; t.aogonek = 444; t.Uacute = 722; t.uogonek = 500; t.Edieresis = 611; t.Dcroat = 722; t.commaaccent = 250; t.copyright = 760; t.Emacron = 611; t.ccaron = 444; t.aring = 444; t.Ncommaaccent = 722; t.lacute = 278; t.agrave = 444; t.Tcommaaccent = 611; t.Cacute = 667; t.atilde = 444; t.Edotaccent = 611; t.scaron = 389; t.scedilla = 389; t.iacute = 278; t.lozenge = 471; t.Rcaron = 667; t.Gcommaaccent = 722; t.ucircumflex = 500; t.acircumflex = 444; t.Amacron = 722; t.rcaron = 333; t.ccedilla = 444; t.Zdotaccent = 611; t.Thorn = 556; t.Omacron = 722; t.Racute = 667; t.Sacute = 556; t.dcaron = 588; t.Umacron = 722; t.uring = 500; t.threesuperior = 300; t.Ograve = 722; t.Agrave = 722; t.Abreve = 722; t.multiply = 564; t.uacute = 500; t.Tcaron = 611; t.partialdiff = 476; t.ydieresis = 500; t.Nacute = 722; t.icircumflex = 278; t.Ecircumflex = 611; t.adieresis = 444; t.edieresis = 444; t.cacute = 444; t.nacute = 500; t.umacron = 500; t.Ncaron = 722; t.Iacute = 333; t.plusminus = 564; t.brokenbar = 200; t.registered = 760; t.Gbreve = 722; t.Idotaccent = 333; t.summation = 600; t.Egrave = 611; t.racute = 333; t.omacron = 500; t.Zacute = 611; t.Zcaron = 611; t.greaterequal = 549; t.Eth = 722; t.Ccedilla = 667; t.lcommaaccent = 278; t.tcaron = 326; t.eogonek = 444; t.Uogonek = 722; t.Aacute = 722; t.Adieresis = 722; t.egrave = 444; t.zacute = 444; t.iogonek = 278; t.Oacute = 722; t.oacute = 500; t.amacron = 444; t.sacute = 389; t.idieresis = 278; t.Ocircumflex = 722; t.Ugrave = 722; t.Delta = 612; t.thorn = 500; t.twosuperior = 300; t.Odieresis = 722; t.mu = 500; t.igrave = 278; t.ohungarumlaut = 500; t.Eogonek = 611; t.dcroat = 500; t.threequarters = 750; t.Scedilla = 556; t.lcaron = 344; t.Kcommaaccent = 722; t.Lacute = 611; t.trademark = 980; t.edotaccent = 444; t.Igrave = 333; t.Imacron = 333; t.Lcaron = 611; t.onehalf = 750; t.lessequal = 549; t.ocircumflex = 500; t.ntilde = 500; t.Uhungarumlaut = 722; t.Eacute = 611; t.emacron = 444; t.gbreve = 500; t.onequarter = 750; t.Scaron = 556; t.Scommaaccent = 556; t.Ohungarumlaut = 722; t.degree = 400; t.ograve = 500; t.Ccaron = 667; t.ugrave = 500; t.radical = 453; t.Dcaron = 722; t.rcommaaccent = 333; t.Ntilde = 722; t.otilde = 500; t.Rcommaaccent = 667; t.Lcommaaccent = 611; t.Atilde = 722; t.Aogonek = 722; t.Aring = 722; t.Otilde = 722; t.zdotaccent = 444; t.Ecaron = 611; t.Iogonek = 333; t.kcommaaccent = 500; t.minus = 564; t.Icircumflex = 333; t.ncaron = 500; t.tcommaaccent = 278; t.logicalnot = 564; t.odieresis = 500; t.udieresis = 500; t.notequal = 549; t.gcommaaccent = 500; t.eth = 500; t.zcaron = 444; t.ncommaaccent = 500; t.onesuperior = 300; t.imacron = 278; t.Euro = 500; }); t[&quot;Times-Bold&quot;] = (0, _core_utils.getLookupTableFactory)(function (t) { t.space = 250; t.exclam = 333; t.quotedbl = 555; t.numbersign = 500; t.dollar = 500; t.percent = 1000; t.ampersand = 833; t.quoteright = 333; t.parenleft = 333; t.parenright = 333; t.asterisk = 500; t.plus = 570; t.comma = 250; t.hyphen = 333; t.period = 250; t.slash = 278; t.zero = 500; t.one = 500; t.two = 500; t.three = 500; t.four = 500; t.five = 500; t.six = 500; t.seven = 500; t.eight = 500; t.nine = 500; t.colon = 333; t.semicolon = 333; t.less = 570; t.equal = 570; t.greater = 570; t.question = 500; t.at = 930; t.A = 722; t.B = 667; t.C = 722; t.D = 722; t.E = 667; t.F = 611; t.G = 778; t.H = 778; t.I = 389; t.J = 500; t.K = 778; t.L = 667; t.M = 944; t.N = 722; t.O = 778; t.P = 611; t.Q = 778; t.R = 722; t.S = 556; t.T = 667; t.U = 722; t.V = 722; t.W = 1000; t.X = 722; t.Y = 722; t.Z = 667; t.bracketleft = 333; t.backslash = 278; t.bracketright = 333; t.asciicircum = 581; t.underscore = 500; t.quoteleft = 333; t.a = 500; t.b = 556; t.c = 444; t.d = 556; t.e = 444; t.f = 333; t.g = 500; t.h = 556; t.i = 278; t.j = 333; t.k = 556; t.l = 278; t.m = 833; t.n = 556; t.o = 500; t.p = 556; t.q = 556; t.r = 444; t.s = 389; t.t = 333; t.u = 556; t.v = 500; t.w = 722; t.x = 500; t.y = 500; t.z = 444; t.braceleft = 394; t.bar = 220; t.braceright = 394; t.asciitilde = 520; t.exclamdown = 333; t.cent = 500; t.sterling = 500; t.fraction = 167; t.yen = 500; t.florin = 500; t.section = 500; t.currency = 500; t.quotesingle = 278; t.quotedblleft = 500; t.guillemotleft = 500; t.guilsinglleft = 333; t.guilsinglright = 333; t.fi = 556; t.fl = 556; t.endash = 500; t.dagger = 500; t.daggerdbl = 500; t.periodcentered = 250; t.paragraph = 540; t.bullet = 350; t.quotesinglbase = 333; t.quotedblbase = 500; t.quotedblright = 500; t.guillemotright = 500; t.ellipsis = 1000; t.perthousand = 1000; t.questiondown = 500; t.grave = 333; t.acute = 333; t.circumflex = 333; t.tilde = 333; t.macron = 333; t.breve = 333; t.dotaccent = 333; t.dieresis = 333; t.ring = 333; t.cedilla = 333; t.hungarumlaut = 333; t.ogonek = 333; t.caron = 333; t.emdash = 1000; t.AE = 1000; t.ordfeminine = 300; t.Lslash = 667; t.Oslash = 778; t.OE = 1000; t.ordmasculine = 330; t.ae = 722; t.dotlessi = 278; t.lslash = 278; t.oslash = 500; t.oe = 722; t.germandbls = 556; t.Idieresis = 389; t.eacute = 444; t.abreve = 500; t.uhungarumlaut = 556; t.ecaron = 444; t.Ydieresis = 722; t.divide = 570; t.Yacute = 722; t.Acircumflex = 722; t.aacute = 500; t.Ucircumflex = 722; t.yacute = 500; t.scommaaccent = 389; t.ecircumflex = 444; t.Uring = 722; t.Udieresis = 722; t.aogonek = 500; t.Uacute = 722; t.uogonek = 556; t.Edieresis = 667; t.Dcroat = 722; t.commaaccent = 250; t.copyright = 747; t.Emacron = 667; t.ccaron = 444; t.aring = 500; t.Ncommaaccent = 722; t.lacute = 278; t.agrave = 500; t.Tcommaaccent = 667; t.Cacute = 722; t.atilde = 500; t.Edotaccent = 667; t.scaron = 389; t.scedilla = 389; t.iacute = 278; t.lozenge = 494; t.Rcaron = 722; t.Gcommaaccent = 778; t.ucircumflex = 556; t.acircumflex = 500; t.Amacron = 722; t.rcaron = 444; t.ccedilla = 444; t.Zdotaccent = 667; t.Thorn = 611; t.Omacron = 778; t.Racute = 722; t.Sacute = 556; t.dcaron = 672; t.Umacron = 722; t.uring = 556; t.threesuperior = 300; t.Ograve = 778; t.Agrave = 722; t.Abreve = 722; t.multiply = 570; t.uacute = 556; t.Tcaron = 667; t.partialdiff = 494; t.ydieresis = 500; t.Nacute = 722; t.icircumflex = 278; t.Ecircumflex = 667; t.adieresis = 500; t.edieresis = 444; t.cacute = 444; t.nacute = 556; t.umacron = 556; t.Ncaron = 722; t.Iacute = 389; t.plusminus = 570; t.brokenbar = 220; t.registered = 747; t.Gbreve = 778; t.Idotaccent = 389; t.summation = 600; t.Egrave = 667; t.racute = 444; t.omacron = 500; t.Zacute = 667; t.Zcaron = 667; t.greaterequal = 549; t.Eth = 722; t.Ccedilla = 722; t.lcommaaccent = 278; t.tcaron = 416; t.eogonek = 444; t.Uogonek = 722; t.Aacute = 722; t.Adieresis = 722; t.egrave = 444; t.zacute = 444; t.iogonek = 278; t.Oacute = 778; t.oacute = 500; t.amacron = 500; t.sacute = 389; t.idieresis = 278; t.Ocircumflex = 778; t.Ugrave = 722; t.Delta = 612; t.thorn = 556; t.twosuperior = 300; t.Odieresis = 778; t.mu = 556; t.igrave = 278; t.ohungarumlaut = 500; t.Eogonek = 667; t.dcroat = 556; t.threequarters = 750; t.Scedilla = 556; t.lcaron = 394; t.Kcommaaccent = 778; t.Lacute = 667; t.trademark = 1000; t.edotaccent = 444; t.Igrave = 389; t.Imacron = 389; t.Lcaron = 667; t.onehalf = 750; t.lessequal = 549; t.ocircumflex = 500; t.ntilde = 556; t.Uhungarumlaut = 722; t.Eacute = 667; t.emacron = 444; t.gbreve = 500; t.onequarter = 750; t.Scaron = 556; t.Scommaaccent = 556; t.Ohungarumlaut = 778; t.degree = 400; t.ograve = 500; t.Ccaron = 722; t.ugrave = 556; t.radical = 549; t.Dcaron = 722; t.rcommaaccent = 444; t.Ntilde = 722; t.otilde = 500; t.Rcommaaccent = 722; t.Lcommaaccent = 667; t.Atilde = 722; t.Aogonek = 722; t.Aring = 722; t.Otilde = 778; t.zdotaccent = 444; t.Ecaron = 667; t.Iogonek = 389; t.kcommaaccent = 556; t.minus = 570; t.Icircumflex = 389; t.ncaron = 556; t.tcommaaccent = 333; t.logicalnot = 570; t.odieresis = 500; t.udieresis = 556; t.notequal = 549; t.gcommaaccent = 500; t.eth = 500; t.zcaron = 444; t.ncommaaccent = 556; t.onesuperior = 300; t.imacron = 278; t.Euro = 500; }); t[&quot;Times-BoldItalic&quot;] = (0, _core_utils.getLookupTableFactory)(function (t) { t.space = 250; t.exclam = 389; t.quotedbl = 555; t.numbersign = 500; t.dollar = 500; t.percent = 833; t.ampersand = 778; t.quoteright = 333; t.parenleft = 333; t.parenright = 333; t.asterisk = 500; t.plus = 570; t.comma = 250; t.hyphen = 333; t.period = 250; t.slash = 278; t.zero = 500; t.one = 500; t.two = 500; t.three = 500; t.four = 500; t.five = 500; t.six = 500; t.seven = 500; t.eight = 500; t.nine = 500; t.colon = 333; t.semicolon = 333; t.less = 570; t.equal = 570; t.greater = 570; t.question = 500; t.at = 832; t.A = 667; t.B = 667; t.C = 667; t.D = 722; t.E = 667; t.F = 667; t.G = 722; t.H = 778; t.I = 389; t.J = 500; t.K = 667; t.L = 611; t.M = 889; t.N = 722; t.O = 722; t.P = 611; t.Q = 722; t.R = 667; t.S = 556; t.T = 611; t.U = 722; t.V = 667; t.W = 889; t.X = 667; t.Y = 611; t.Z = 611; t.bracketleft = 333; t.backslash = 278; t.bracketright = 333; t.asciicircum = 570; t.underscore = 500; t.quoteleft = 333; t.a = 500; t.b = 500; t.c = 444; t.d = 500; t.e = 444; t.f = 333; t.g = 500; t.h = 556; t.i = 278; t.j = 278; t.k = 500; t.l = 278; t.m = 778; t.n = 556; t.o = 500; t.p = 500; t.q = 500; t.r = 389; t.s = 389; t.t = 278; t.u = 556; t.v = 444; t.w = 667; t.x = 500; t.y = 444; t.z = 389; t.braceleft = 348; t.bar = 220; t.braceright = 348; t.asciitilde = 570; t.exclamdown = 389; t.cent = 500; t.sterling = 500; t.fraction = 167; t.yen = 500; t.florin = 500; t.section = 500; t.currency = 500; t.quotesingle = 278; t.quotedblleft = 500; t.guillemotleft = 500; t.guilsinglleft = 333; t.guilsinglright = 333; t.fi = 556; t.fl = 556; t.endash = 500; t.dagger = 500; t.daggerdbl = 500; t.periodcentered = 250; t.paragraph = 500; t.bullet = 350; t.quotesinglbase = 333; t.quotedblbase = 500; t.quotedblright = 500; t.guillemotright = 500; t.ellipsis = 1000; t.perthousand = 1000; t.questiondown = 500; t.grave = 333; t.acute = 333; t.circumflex = 333; t.tilde = 333; t.macron = 333; t.breve = 333; t.dotaccent = 333; t.dieresis = 333; t.ring = 333; t.cedilla = 333; t.hungarumlaut = 333; t.ogonek = 333; t.caron = 333; t.emdash = 1000; t.AE = 944; t.ordfeminine = 266; t.Lslash = 611; t.Oslash = 722; t.OE = 944; t.ordmasculine = 300; t.ae = 722; t.dotlessi = 278; t.lslash = 278; t.oslash = 500; t.oe = 722; t.germandbls = 500; t.Idieresis = 389; t.eacute = 444; t.abreve = 500; t.uhungarumlaut = 556; t.ecaron = 444; t.Ydieresis = 611; t.divide = 570; t.Yacute = 611; t.Acircumflex = 667; t.aacute = 500; t.Ucircumflex = 722; t.yacute = 444; t.scommaaccent = 389; t.ecircumflex = 444; t.Uring = 722; t.Udieresis = 722; t.aogonek = 500; t.Uacute = 722; t.uogonek = 556; t.Edieresis = 667; t.Dcroat = 722; t.commaaccent = 250; t.copyright = 747; t.Emacron = 667; t.ccaron = 444; t.aring = 500; t.Ncommaaccent = 722; t.lacute = 278; t.agrave = 500; t.Tcommaaccent = 611; t.Cacute = 667; t.atilde = 500; t.Edotaccent = 667; t.scaron = 389; t.scedilla = 389; t.iacute = 278; t.lozenge = 494; t.Rcaron = 667; t.Gcommaaccent = 722; t.ucircumflex = 556; t.acircumflex = 500; t.Amacron = 667; t.rcaron = 389; t.ccedilla = 444; t.Zdotaccent = 611; t.Thorn = 611; t.Omacron = 722; t.Racute = 667; t.Sacute = 556; t.dcaron = 608; t.Umacron = 722; t.uring = 556; t.threesuperior = 300; t.Ograve = 722; t.Agrave = 667; t.Abreve = 667; t.multiply = 570; t.uacute = 556; t.Tcaron = 611; t.partialdiff = 494; t.ydieresis = 444; t.Nacute = 722; t.icircumflex = 278; t.Ecircumflex = 667; t.adieresis = 500; t.edieresis = 444; t.cacute = 444; t.nacute = 556; t.umacron = 556; t.Ncaron = 722; t.Iacute = 389; t.plusminus = 570; t.brokenbar = 220; t.registered = 747; t.Gbreve = 722; t.Idotaccent = 389; t.summation = 600; t.Egrave = 667; t.racute = 389; t.omacron = 500; t.Zacute = 611; t.Zcaron = 611; t.greaterequal = 549; t.Eth = 722; t.Ccedilla = 667; t.lcommaaccent = 278; t.tcaron = 366; t.eogonek = 444; t.Uogonek = 722; t.Aacute = 667; t.Adieresis = 667; t.egrave = 444; t.zacute = 389; t.iogonek = 278; t.Oacute = 722; t.oacute = 500; t.amacron = 500; t.sacute = 389; t.idieresis = 278; t.Ocircumflex = 722; t.Ugrave = 722; t.Delta = 612; t.thorn = 500; t.twosuperior = 300; t.Odieresis = 722; t.mu = 576; t.igrave = 278; t.ohungarumlaut = 500; t.Eogonek = 667; t.dcroat = 500; t.threequarters = 750; t.Scedilla = 556; t.lcaron = 382; t.Kcommaaccent = 667; t.Lacute = 611; t.trademark = 1000; t.edotaccent = 444; t.Igrave = 389; t.Imacron = 389; t.Lcaron = 611; t.onehalf = 750; t.lessequal = 549; t.ocircumflex = 500; t.ntilde = 556; t.Uhungarumlaut = 722; t.Eacute = 667; t.emacron = 444; t.gbreve = 500; t.onequarter = 750; t.Scaron = 556; t.Scommaaccent = 556; t.Ohungarumlaut = 722; t.degree = 400; t.ograve = 500; t.Ccaron = 667; t.ugrave = 556; t.radical = 549; t.Dcaron = 722; t.rcommaaccent = 389; t.Ntilde = 722; t.otilde = 500; t.Rcommaaccent = 667; t.Lcommaaccent = 611; t.Atilde = 667; t.Aogonek = 667; t.Aring = 667; t.Otilde = 722; t.zdotaccent = 389; t.Ecaron = 667; t.Iogonek = 389; t.kcommaaccent = 500; t.minus = 606; t.Icircumflex = 389; t.ncaron = 556; t.tcommaaccent = 278; t.logicalnot = 606; t.odieresis = 500; t.udieresis = 556; t.notequal = 549; t.gcommaaccent = 500; t.eth = 500; t.zcaron = 389; t.ncommaaccent = 556; t.onesuperior = 300; t.imacron = 278; t.Euro = 500; }); t[&quot;Times-Italic&quot;] = (0, _core_utils.getLookupTableFactory)(function (t) { t.space = 250; t.exclam = 333; t.quotedbl = 420; t.numbersign = 500; t.dollar = 500; t.percent = 833; t.ampersand = 778; t.quoteright = 333; t.parenleft = 333; t.parenright = 333; t.asterisk = 500; t.plus = 675; t.comma = 250; t.hyphen = 333; t.period = 250; t.slash = 278; t.zero = 500; t.one = 500; t.two = 500; t.three = 500; t.four = 500; t.five = 500; t.six = 500; t.seven = 500; t.eight = 500; t.nine = 500; t.colon = 333; t.semicolon = 333; t.less = 675; t.equal = 675; t.greater = 675; t.question = 500; t.at = 920; t.A = 611; t.B = 611; t.C = 667; t.D = 722; t.E = 611; t.F = 611; t.G = 722; t.H = 722; t.I = 333; t.J = 444; t.K = 667; t.L = 556; t.M = 833; t.N = 667; t.O = 722; t.P = 611; t.Q = 722; t.R = 611; t.S = 500; t.T = 556; t.U = 722; t.V = 611; t.W = 833; t.X = 611; t.Y = 556; t.Z = 556; t.bracketleft = 389; t.backslash = 278; t.bracketright = 389; t.asciicircum = 422; t.underscore = 500; t.quoteleft = 333; t.a = 500; t.b = 500; t.c = 444; t.d = 500; t.e = 444; t.f = 278; t.g = 500; t.h = 500; t.i = 278; t.j = 278; t.k = 444; t.l = 278; t.m = 722; t.n = 500; t.o = 500; t.p = 500; t.q = 500; t.r = 389; t.s = 389; t.t = 278; t.u = 500; t.v = 444; t.w = 667; t.x = 444; t.y = 444; t.z = 389; t.braceleft = 400; t.bar = 275; t.braceright = 400; t.asciitilde = 541; t.exclamdown = 389; t.cent = 500; t.sterling = 500; t.fraction = 167; t.yen = 500; t.florin = 500; t.section = 500; t.currency = 500; t.quotesingle = 214; t.quotedblleft = 556; t.guillemotleft = 500; t.guilsinglleft = 333; t.guilsinglright = 333; t.fi = 500; t.fl = 500; t.endash = 500; t.dagger = 500; t.daggerdbl = 500; t.periodcentered = 250; t.paragraph = 523; t.bullet = 350; t.quotesinglbase = 333; t.quotedblbase = 556; t.quotedblright = 556; t.guillemotright = 500; t.ellipsis = 889; t.perthousand = 1000; t.questiondown = 500; t.grave = 333; t.acute = 333; t.circumflex = 333; t.tilde = 333; t.macron = 333; t.breve = 333; t.dotaccent = 333; t.dieresis = 333; t.ring = 333; t.cedilla = 333; t.hungarumlaut = 333; t.ogonek = 333; t.caron = 333; t.emdash = 889; t.AE = 889; t.ordfeminine = 276; t.Lslash = 556; t.Oslash = 722; t.OE = 944; t.ordmasculine = 310; t.ae = 667; t.dotlessi = 278; t.lslash = 278; t.oslash = 500; t.oe = 667; t.germandbls = 500; t.Idieresis = 333; t.eacute = 444; t.abreve = 500; t.uhungarumlaut = 500; t.ecaron = 444; t.Ydieresis = 556; t.divide = 675; t.Yacute = 556; t.Acircumflex = 611; t.aacute = 500; t.Ucircumflex = 722; t.yacute = 444; t.scommaaccent = 389; t.ecircumflex = 444; t.Uring = 722; t.Udieresis = 722; t.aogonek = 500; t.Uacute = 722; t.uogonek = 500; t.Edieresis = 611; t.Dcroat = 722; t.commaaccent = 250; t.copyright = 760; t.Emacron = 611; t.ccaron = 444; t.aring = 500; t.Ncommaaccent = 667; t.lacute = 278; t.agrave = 500; t.Tcommaaccent = 556; t.Cacute = 667; t.atilde = 500; t.Edotaccent = 611; t.scaron = 389; t.scedilla = 389; t.iacute = 278; t.lozenge = 471; t.Rcaron = 611; t.Gcommaaccent = 722; t.ucircumflex = 500; t.acircumflex = 500; t.Amacron = 611; t.rcaron = 389; t.ccedilla = 444; t.Zdotaccent = 556; t.Thorn = 611; t.Omacron = 722; t.Racute = 611; t.Sacute = 500; t.dcaron = 544; t.Umacron = 722; t.uring = 500; t.threesuperior = 300; t.Ograve = 722; t.Agrave = 611; t.Abreve = 611; t.multiply = 675; t.uacute = 500; t.Tcaron = 556; t.partialdiff = 476; t.ydieresis = 444; t.Nacute = 667; t.icircumflex = 278; t.Ecircumflex = 611; t.adieresis = 500; t.edieresis = 444; t.cacute = 444; t.nacute = 500; t.umacron = 500; t.Ncaron = 667; t.Iacute = 333; t.plusminus = 675; t.brokenbar = 275; t.registered = 760; t.Gbreve = 722; t.Idotaccent = 333; t.summation = 600; t.Egrave = 611; t.racute = 389; t.omacron = 500; t.Zacute = 556; t.Zcaron = 556; t.greaterequal = 549; t.Eth = 722; t.Ccedilla = 667; t.lcommaaccent = 278; t.tcaron = 300; t.eogonek = 444; t.Uogonek = 722; t.Aacute = 611; t.Adieresis = 611; t.egrave = 444; t.zacute = 389; t.iogonek = 278; t.Oacute = 722; t.oacute = 500; t.amacron = 500; t.sacute = 389; t.idieresis = 278; t.Ocircumflex = 722; t.Ugrave = 722; t.Delta = 612; t.thorn = 500; t.twosuperior = 300; t.Odieresis = 722; t.mu = 500; t.igrave = 278; t.ohungarumlaut = 500; t.Eogonek = 611; t.dcroat = 500; t.threequarters = 750; t.Scedilla = 500; t.lcaron = 300; t.Kcommaaccent = 667; t.Lacute = 556; t.trademark = 980; t.edotaccent = 444; t.Igrave = 333; t.Imacron = 333; t.Lcaron = 611; t.onehalf = 750; t.lessequal = 549; t.ocircumflex = 500; t.ntilde = 500; t.Uhungarumlaut = 722; t.Eacute = 611; t.emacron = 444; t.gbreve = 500; t.onequarter = 750; t.Scaron = 500; t.Scommaaccent = 500; t.Ohungarumlaut = 722; t.degree = 400; t.ograve = 500; t.Ccaron = 667; t.ugrave = 500; t.radical = 453; t.Dcaron = 722; t.rcommaaccent = 389; t.Ntilde = 667; t.otilde = 500; t.Rcommaaccent = 611; t.Lcommaaccent = 556; t.Atilde = 611; t.Aogonek = 611; t.Aring = 611; t.Otilde = 722; t.zdotaccent = 389; t.Ecaron = 611; t.Iogonek = 333; t.kcommaaccent = 444; t.minus = 675; t.Icircumflex = 333; t.ncaron = 500; t.tcommaaccent = 278; t.logicalnot = 675; t.odieresis = 500; t.udieresis = 500; t.notequal = 549; t.gcommaaccent = 500; t.eth = 500; t.zcaron = 389; t.ncommaaccent = 500; t.onesuperior = 300; t.imacron = 278; t.Euro = 500; }); t.ZapfDingbats = (0, _core_utils.getLookupTableFactory)(function (t) { t.space = 278; t.a1 = 974; t.a2 = 961; t.a202 = 974; t.a3 = 980; t.a4 = 719; t.a5 = 789; t.a119 = 790; t.a118 = 791; t.a117 = 690; t.a11 = 960; t.a12 = 939; t.a13 = 549; t.a14 = 855; t.a15 = 911; t.a16 = 933; t.a105 = 911; t.a17 = 945; t.a18 = 974; t.a19 = 755; t.a20 = 846; t.a21 = 762; t.a22 = 761; t.a23 = 571; t.a24 = 677; t.a25 = 763; t.a26 = 760; t.a27 = 759; t.a28 = 754; t.a6 = 494; t.a7 = 552; t.a8 = 537; t.a9 = 577; t.a10 = 692; t.a29 = 786; t.a30 = 788; t.a31 = 788; t.a32 = 790; t.a33 = 793; t.a34 = 794; t.a35 = 816; t.a36 = 823; t.a37 = 789; t.a38 = 841; t.a39 = 823; t.a40 = 833; t.a41 = 816; t.a42 = 831; t.a43 = 923; t.a44 = 744; t.a45 = 723; t.a46 = 749; t.a47 = 790; t.a48 = 792; t.a49 = 695; t.a50 = 776; t.a51 = 768; t.a52 = 792; t.a53 = 759; t.a54 = 707; t.a55 = 708; t.a56 = 682; t.a57 = 701; t.a58 = 826; t.a59 = 815; t.a60 = 789; t.a61 = 789; t.a62 = 707; t.a63 = 687; t.a64 = 696; t.a65 = 689; t.a66 = 786; t.a67 = 787; t.a68 = 713; t.a69 = 791; t.a70 = 785; t.a71 = 791; t.a72 = 873; t.a73 = 761; t.a74 = 762; t.a203 = 762; t.a75 = 759; t.a204 = 759; t.a76 = 892; t.a77 = 892; t.a78 = 788; t.a79 = 784; t.a81 = 438; t.a82 = 138; t.a83 = 277; t.a84 = 415; t.a97 = 392; t.a98 = 392; t.a99 = 668; t.a100 = 668; t.a89 = 390; t.a90 = 390; t.a93 = 317; t.a94 = 317; t.a91 = 276; t.a92 = 276; t.a205 = 509; t.a85 = 509; t.a206 = 410; t.a86 = 410; t.a87 = 234; t.a88 = 234; t.a95 = 334; t.a96 = 334; t.a101 = 732; t.a102 = 544; t.a103 = 544; t.a104 = 910; t.a106 = 667; t.a107 = 760; t.a108 = 760; t.a112 = 776; t.a111 = 595; t.a110 = 694; t.a109 = 626; t.a120 = 788; t.a121 = 788; t.a122 = 788; t.a123 = 788; t.a124 = 788; t.a125 = 788; t.a126 = 788; t.a127 = 788; t.a128 = 788; t.a129 = 788; t.a130 = 788; t.a131 = 788; t.a132 = 788; t.a133 = 788; t.a134 = 788; t.a135 = 788; t.a136 = 788; t.a137 = 788; t.a138 = 788; t.a139 = 788; t.a140 = 788; t.a141 = 788; t.a142 = 788; t.a143 = 788; t.a144 = 788; t.a145 = 788; t.a146 = 788; t.a147 = 788; t.a148 = 788; t.a149 = 788; t.a150 = 788; t.a151 = 788; t.a152 = 788; t.a153 = 788; t.a154 = 788; t.a155 = 788; t.a156 = 788; t.a157 = 788; t.a158 = 788; t.a159 = 788; t.a160 = 894; t.a161 = 838; t.a163 = 1016; t.a164 = 458; t.a196 = 748; t.a165 = 924; t.a192 = 748; t.a166 = 918; t.a167 = 927; t.a168 = 928; t.a169 = 928; t.a170 = 834; t.a171 = 873; t.a172 = 828; t.a173 = 924; t.a162 = 924; t.a174 = 917; t.a175 = 930; t.a176 = 931; t.a177 = 463; t.a178 = 883; t.a179 = 836; t.a193 = 836; t.a180 = 867; t.a199 = 867; t.a181 = 696; t.a200 = 696; t.a182 = 874; t.a201 = 874; t.a183 = 760; t.a184 = 946; t.a197 = 771; t.a185 = 865; t.a194 = 771; t.a198 = 888; t.a186 = 967; t.a195 = 888; t.a187 = 831; t.a188 = 873; t.a189 = 927; t.a190 = 970; t.a191 = 918; }); }); exports.getMetrics = getMetrics; const getFontBasicMetrics = (0, _core_utils.getLookupTableFactory)(function (t) { t.Courier = { ascent: 629, descent: -157, capHeight: 562, xHeight: -426 }; t[&quot;Courier-Bold&quot;] = { ascent: 629, descent: -157, capHeight: 562, xHeight: 439 }; t[&quot;Courier-Oblique&quot;] = { ascent: 629, descent: -157, capHeight: 562, xHeight: 426 }; t[&quot;Courier-BoldOblique&quot;] = { ascent: 629, descent: -157, capHeight: 562, xHeight: 426 }; t.Helvetica = { ascent: 718, descent: -207, capHeight: 718, xHeight: 523 }; t[&quot;Helvetica-Bold&quot;] = { ascent: 718, descent: -207, capHeight: 718, xHeight: 532 }; t[&quot;Helvetica-Oblique&quot;] = { ascent: 718, descent: -207, capHeight: 718, xHeight: 523 }; t[&quot;Helvetica-BoldOblique&quot;] = { ascent: 718, descent: -207, capHeight: 718, xHeight: 532 }; t[&quot;Times-Roman&quot;] = { ascent: 683, descent: -217, capHeight: 662, xHeight: 450 }; t[&quot;Times-Bold&quot;] = { ascent: 683, descent: -217, capHeight: 676, xHeight: 461 }; t[&quot;Times-Italic&quot;] = { ascent: 683, descent: -217, capHeight: 653, xHeight: 441 }; t[&quot;Times-BoldItalic&quot;] = { ascent: 683, descent: -217, capHeight: 669, xHeight: 462 }; t.Symbol = { ascent: Math.NaN, descent: Math.NaN, capHeight: Math.NaN, xHeight: Math.NaN }; t.ZapfDingbats = { ascent: Math.NaN, descent: Math.NaN, capHeight: Math.NaN, xHeight: Math.NaN }; }); exports.getFontBasicMetrics = getFontBasicMetrics; /***/ }), /* 44 */ /***/ ((__unused_webpack_module, exports) =&gt; { Object.defineProperty(exports, &quot;__esModule&quot;, ({ value: true })); exports.GlyfTable = void 0; const ON_CURVE_POINT = 1 &lt;&lt; 0; const X_SHORT_VECTOR = 1 &lt;&lt; 1; const Y_SHORT_VECTOR = 1 &lt;&lt; 2; const REPEAT_FLAG = 1 &lt;&lt; 3; const X_IS_SAME_OR_POSITIVE_X_SHORT_VECTOR = 1 &lt;&lt; 4; const Y_IS_SAME_OR_POSITIVE_Y_SHORT_VECTOR = 1 &lt;&lt; 5; const OVERLAP_SIMPLE = 1 &lt;&lt; 6; const ARG_1_AND_2_ARE_WORDS = 1 &lt;&lt; 0; const ARGS_ARE_XY_VALUES = 1 &lt;&lt; 1; const WE_HAVE_A_SCALE = 1 &lt;&lt; 3; const MORE_COMPONENTS = 1 &lt;&lt; 5; const WE_HAVE_AN_X_AND_Y_SCALE = 1 &lt;&lt; 6; const WE_HAVE_A_TWO_BY_TWO = 1 &lt;&lt; 7; const WE_HAVE_INSTRUCTIONS = 1 &lt;&lt; 8; class GlyfTable { constructor({ glyfTable, isGlyphLocationsLong, locaTable, numGlyphs }) { this.glyphs = []; const loca = new DataView(locaTable.buffer, locaTable.byteOffset, locaTable.byteLength); const glyf = new DataView(glyfTable.buffer, glyfTable.byteOffset, glyfTable.byteLength); const offsetSize = isGlyphLocationsLong ? 4 : 2; let prev = isGlyphLocationsLong ? loca.getUint32(0) : 2 * loca.getUint16(0); let pos = 0; for (let i = 0; i &lt; numGlyphs; i++) { pos += offsetSize; const next = isGlyphLocationsLong ? loca.getUint32(pos) : 2 * loca.getUint16(pos); if (next === prev) { this.glyphs.push(new Glyph({})); continue; } const glyph = Glyph.parse(prev, glyf); this.glyphs.push(glyph); prev = next; } } getSize() { return this.glyphs.reduce((a, g) =&gt; { const size = g.getSize(); return a + (size + 3 &amp; ~3); }, 0); } write() { const totalSize = this.getSize(); const glyfTable = new DataView(new ArrayBuffer(totalSize)); const isLocationLong = totalSize &gt; 0x1fffe; const offsetSize = isLocationLong ? 4 : 2; const locaTable = new DataView(new ArrayBuffer((this.glyphs.length + 1) * offsetSize)); if (isLocationLong) { locaTable.setUint32(0, 0); } else { locaTable.setUint16(0, 0); } let pos = 0; let locaIndex = 0; for (const glyph of this.glyphs) { pos += glyph.write(pos, glyfTable); pos = pos + 3 &amp; ~3; locaIndex += offsetSize; if (isLocationLong) { locaTable.setUint32(locaIndex, pos); } else { locaTable.setUint16(locaIndex, pos &gt;&gt; 1); } } return { isLocationLong, loca: new Uint8Array(locaTable.buffer), glyf: new Uint8Array(glyfTable.buffer) }; } scale(factors) { for (let i = 0, ii = this.glyphs.length; i &lt; ii; i++) { this.glyphs[i].scale(factors[i]); } } } exports.GlyfTable = GlyfTable; class Glyph { constructor({ header = null, simple = null, composites = null }) { this.header = header; this.simple = simple; this.composites = composites; } static parse(pos, glyf) { const [read, header] = GlyphHeader.parse(pos, glyf); pos += read; if (header.numberOfContours &lt; 0) { const composites = []; while (true) { const [n, composite] = CompositeGlyph.parse(pos, glyf); pos += n; composites.push(composite); if (!(composite.flags &amp; MORE_COMPONENTS)) { break; } } return new Glyph({ header, composites }); } const simple = SimpleGlyph.parse(pos, glyf, header.numberOfContours); return new Glyph({ header, simple }); } getSize() { if (!this.header) { return 0; } const size = this.simple ? this.simple.getSize() : this.composites.reduce((a, c) =&gt; a + c.getSize(), 0); return this.header.getSize() + size; } write(pos, buf) { if (!this.header) { return 0; } const spos = pos; pos += this.header.write(pos, buf); if (this.simple) { pos += this.simple.write(pos, buf); } else { for (const composite of this.composites) { pos += composite.write(pos, buf); } } return pos - spos; } scale(factor) { if (!this.header) { return; } const xMiddle = (this.header.xMin + this.header.xMax) / 2; this.header.scale(xMiddle, factor); if (this.simple) { this.simple.scale(xMiddle, factor); } else { for (const composite of this.composites) { composite.scale(xMiddle, factor); } } } } class GlyphHeader { constructor({ numberOfContours, xMin, yMin, xMax, yMax }) { this.numberOfContours = numberOfContours; this.xMin = xMin; this.yMin = yMin; this.xMax = xMax; this.yMax = yMax; } static parse(pos, glyf) { return [10, new GlyphHeader({ numberOfContours: glyf.getInt16(pos), xMin: glyf.getInt16(pos + 2), yMin: glyf.getInt16(pos + 4), xMax: glyf.getInt16(pos + 6), yMax: glyf.getInt16(pos + 8) })]; } getSize() { return 10; } write(pos, buf) { buf.setInt16(pos, this.numberOfContours); buf.setInt16(pos + 2, this.xMin); buf.setInt16(pos + 4, this.yMin); buf.setInt16(pos + 6, this.xMax); buf.setInt16(pos + 8, this.yMax); return 10; } scale(x, factor) { this.xMin = Math.round(x + (this.xMin - x) * factor); this.xMax = Math.round(x + (this.xMax - x) * factor); } } class Contour { constructor({ flags, xCoordinates, yCoordinates }) { this.xCoordinates = xCoordinates; this.yCoordinates = yCoordinates; this.flags = flags; } } class SimpleGlyph { constructor({ contours, instructions }) { this.contours = contours; this.instructions = instructions; } static parse(pos, glyf, numberOfContours) { const endPtsOfContours = []; for (let i = 0; i &lt; numberOfContours; i++) { const endPt = glyf.getUint16(pos); pos += 2; endPtsOfContours.push(endPt); } const numberOfPt = endPtsOfContours[numberOfContours - 1] + 1; const instructionLength = glyf.getUint16(pos); pos += 2; const instructions = new Uint8Array(glyf).slice(pos, pos + instructionLength); pos += instructionLength; const flags = []; for (let i = 0; i &lt; numberOfPt; pos++, i++) { let flag = glyf.getUint8(pos); flags.push(flag); if (flag &amp; REPEAT_FLAG) { const count = glyf.getUint8(++pos); flag ^= REPEAT_FLAG; for (let m = 0; m &lt; count; m++) { flags.push(flag); } i += count; } } const allXCoordinates = []; let xCoordinates = []; let yCoordinates = []; let pointFlags = []; const contours = []; let endPtsOfContoursIndex = 0; let lastCoordinate = 0; for (let i = 0; i &lt; numberOfPt; i++) { const flag = flags[i]; if (flag &amp; X_SHORT_VECTOR) { const x = glyf.getUint8(pos++); lastCoordinate += flag &amp; X_IS_SAME_OR_POSITIVE_X_SHORT_VECTOR ? x : -x; xCoordinates.push(lastCoordinate); } else if (flag &amp; X_IS_SAME_OR_POSITIVE_X_SHORT_VECTOR) { xCoordinates.push(lastCoordinate); } else { lastCoordinate += glyf.getInt16(pos); pos += 2; xCoordinates.push(lastCoordinate); } if (endPtsOfContours[endPtsOfContoursIndex] === i) { endPtsOfContoursIndex++; allXCoordinates.push(xCoordinates); xCoordinates = []; } } lastCoordinate = 0; endPtsOfContoursIndex = 0; for (let i = 0; i &lt; numberOfPt; i++) { const flag = flags[i]; if (flag &amp; Y_SHORT_VECTOR) { const y = glyf.getUint8(pos++); lastCoordinate += flag &amp; Y_IS_SAME_OR_POSITIVE_Y_SHORT_VECTOR ? y : -y; yCoordinates.push(lastCoordinate); } else if (flag &amp; Y_IS_SAME_OR_POSITIVE_Y_SHORT_VECTOR) { yCoordinates.push(lastCoordinate); } else { lastCoordinate += glyf.getInt16(pos); pos += 2; yCoordinates.push(lastCoordinate); } pointFlags.push(flag &amp; ON_CURVE_POINT | flag &amp; OVERLAP_SIMPLE); if (endPtsOfContours[endPtsOfContoursIndex] === i) { xCoordinates = allXCoordinates[endPtsOfContoursIndex]; endPtsOfContoursIndex++; contours.push(new Contour({ flags: pointFlags, xCoordinates, yCoordinates })); yCoordinates = []; pointFlags = []; } } return new SimpleGlyph({ contours, instructions }); } getSize() { let size = this.contours.length * 2 + 2 + this.instructions.length; let lastX = 0; let lastY = 0; for (const contour of this.contours) { size += contour.flags.length; for (let i = 0, ii = contour.xCoordinates.length; i &lt; ii; i++) { const x = contour.xCoordinates[i]; const y = contour.yCoordinates[i]; let abs = Math.abs(x - lastX); if (abs &gt; 255) { size += 2; } else if (abs &gt; 0) { size += 1; } lastX = x; abs = Math.abs(y - lastY); if (abs &gt; 255) { size += 2; } else if (abs &gt; 0) { size += 1; } lastY = y; } } return size; } write(pos, buf) { const spos = pos; const xCoordinates = []; const yCoordinates = []; const flags = []; let lastX = 0; let lastY = 0; for (const contour of this.contours) { for (let i = 0, ii = contour.xCoordinates.length; i &lt; ii; i++) { let flag = contour.flags[i]; const x = contour.xCoordinates[i]; let delta = x - lastX; if (delta === 0) { flag |= X_IS_SAME_OR_POSITIVE_X_SHORT_VECTOR; xCoordinates.push(0); } else { const abs = Math.abs(delta); if (abs &lt;= 255) { flag |= delta &gt;= 0 ? X_SHORT_VECTOR | X_IS_SAME_OR_POSITIVE_X_SHORT_VECTOR : X_SHORT_VECTOR; xCoordinates.push(abs); } else { xCoordinates.push(delta); } } lastX = x; const y = contour.yCoordinates[i]; delta = y - lastY; if (delta === 0) { flag |= Y_IS_SAME_OR_POSITIVE_Y_SHORT_VECTOR; yCoordinates.push(0); } else { const abs = Math.abs(delta); if (abs &lt;= 255) { flag |= delta &gt;= 0 ? Y_SHORT_VECTOR | Y_IS_SAME_OR_POSITIVE_Y_SHORT_VECTOR : Y_SHORT_VECTOR; yCoordinates.push(abs); } else { yCoordinates.push(delta); } } lastY = y; flags.push(flag); } buf.setUint16(pos, xCoordinates.length - 1); pos += 2; } buf.setUint16(pos, this.instructions.length); pos += 2; if (this.instructions.length) { new Uint8Array(buf.buffer, 0, buf.buffer.byteLength).set(this.instructions, pos); pos += this.instructions.length; } for (const flag of flags) { buf.setUint8(pos++, flag); } for (let i = 0, ii = xCoordinates.length; i &lt; ii; i++) { const x = xCoordinates[i]; const flag = flags[i]; if (flag &amp; X_SHORT_VECTOR) { buf.setUint8(pos++, x); } else if (!(flag &amp; X_IS_SAME_OR_POSITIVE_X_SHORT_VECTOR)) { buf.setInt16(pos, x); pos += 2; } } for (let i = 0, ii = yCoordinates.length; i &lt; ii; i++) { const y = yCoordinates[i]; const flag = flags[i]; if (flag &amp; Y_SHORT_VECTOR) { buf.setUint8(pos++, y); } else if (!(flag &amp; Y_IS_SAME_OR_POSITIVE_Y_SHORT_VECTOR)) { buf.setInt16(pos, y); pos += 2; } } return pos - spos; } scale(x, factor) { for (const contour of this.contours) { if (contour.xCoordinates.length === 0) { continue; } for (let i = 0, ii = contour.xCoordinates.length; i &lt; ii; i++) { contour.xCoordinates[i] = Math.round(x + (contour.xCoordinates[i] - x) * factor); } } } } class CompositeGlyph { constructor({ flags, glyphIndex, argument1, argument2, transf, instructions }) { this.flags = flags; this.glyphIndex = glyphIndex; this.argument1 = argument1; this.argument2 = argument2; this.transf = transf; this.instructions = instructions; } static parse(pos, glyf) { const spos = pos; const transf = []; let flags = glyf.getUint16(pos); const glyphIndex = glyf.getUint16(pos + 2); pos += 4; let argument1, argument2; if (flags &amp; ARG_1_AND_2_ARE_WORDS) { if (flags &amp; ARGS_ARE_XY_VALUES) { argument1 = glyf.getInt16(pos); argument2 = glyf.getInt16(pos + 2); } else { argument1 = glyf.getUint16(pos); argument2 = glyf.getUint16(pos + 2); } pos += 4; flags ^= ARG_1_AND_2_ARE_WORDS; } else { if (flags &amp; ARGS_ARE_XY_VALUES) { argument1 = glyf.getInt8(pos); argument2 = glyf.getInt8(pos + 1); } else { argument1 = glyf.getUint8(pos); argument2 = glyf.getUint8(pos + 1); } pos += 2; } if (flags &amp; WE_HAVE_A_SCALE) { transf.push(glyf.getUint16(pos)); pos += 2; } else if (flags &amp; WE_HAVE_AN_X_AND_Y_SCALE) { transf.push(glyf.getUint16(pos), glyf.getUint16(pos + 2)); pos += 4; } else if (flags &amp; WE_HAVE_A_TWO_BY_TWO) { transf.push(glyf.getUint16(pos), glyf.getUint16(pos + 2), glyf.getUint16(pos + 4), glyf.getUint16(pos + 6)); pos += 8; } let instructions = null; if (flags &amp; WE_HAVE_INSTRUCTIONS) { const instructionLength = glyf.getUint16(pos); pos += 2; instructions = new Uint8Array(glyf).slice(pos, pos + instructionLength); pos += instructionLength; } return [pos - spos, new CompositeGlyph({ flags, glyphIndex, argument1, argument2, transf, instructions })]; } getSize() { let size = 2 + 2 + this.transf.length * 2; if (this.flags &amp; WE_HAVE_INSTRUCTIONS) { size += 2 + this.instructions.length; } size += 2; if (this.flags &amp; 2) { if (!(this.argument1 &gt;= -128 &amp;&amp; this.argument1 &lt;= 127 &amp;&amp; this.argument2 &gt;= -128 &amp;&amp; this.argument2 &lt;= 127)) { size += 2; } } else { if (!(this.argument1 &gt;= 0 &amp;&amp; this.argument1 &lt;= 255 &amp;&amp; this.argument2 &gt;= 0 &amp;&amp; this.argument2 &lt;= 255)) { size += 2; } } return size; } write(pos, buf) { const spos = pos; if (this.flags &amp; ARGS_ARE_XY_VALUES) { if (!(this.argument1 &gt;= -128 &amp;&amp; this.argument1 &lt;= 127 &amp;&amp; this.argument2 &gt;= -128 &amp;&amp; this.argument2 &lt;= 127)) { this.flags |= ARG_1_AND_2_ARE_WORDS; } } else { if (!(this.argument1 &gt;= 0 &amp;&amp; this.argument1 &lt;= 255 &amp;&amp; this.argument2 &gt;= 0 &amp;&amp; this.argument2 &lt;= 255)) { this.flags |= ARG_1_AND_2_ARE_WORDS; } } buf.setUint16(pos, this.flags); buf.setUint16(pos + 2, this.glyphIndex); pos += 4; if (this.flags &amp; ARG_1_AND_2_ARE_WORDS) { if (this.flags &amp; ARGS_ARE_XY_VALUES) { buf.setInt16(pos, this.argument1); buf.setInt16(pos + 2, this.argument2); } else { buf.setUint16(pos, this.argument1); buf.setUint16(pos + 2, this.argument2); } pos += 4; } else { buf.setUint8(pos, this.argument1); buf.setUint8(pos + 1, this.argument2); pos += 2; } if (this.flags &amp; WE_HAVE_INSTRUCTIONS) { buf.setUint16(pos, this.instructions.length); pos += 2; if (this.instructions.length) { new Uint8Array(buf.buffer, 0, buf.buffer.byteLength).set(this.instructions, pos); pos += this.instructions.length; } } return pos - spos; } scale(x, factor) {} } /***/ }), /* 45 */ /***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) =&gt; { Object.defineProperty(exports, &quot;__esModule&quot;, ({ value: true })); exports.OpenTypeFileBuilder = void 0; var _core_utils = __w_pdfjs_require__(4); var _util = __w_pdfjs_require__(2); function writeInt16(dest, offset, num) { dest[offset] = num &gt;&gt; 8 &amp; 0xff; dest[offset + 1] = num &amp; 0xff; } function writeInt32(dest, offset, num) { dest[offset] = num &gt;&gt; 24 &amp; 0xff; dest[offset + 1] = num &gt;&gt; 16 &amp; 0xff; dest[offset + 2] = num &gt;&gt; 8 &amp; 0xff; dest[offset + 3] = num &amp; 0xff; } function writeData(dest, offset, data) { if (data instanceof Uint8Array) { dest.set(data, offset); } else if (typeof data === &quot;string&quot;) { for (let i = 0, ii = data.length; i &lt; ii; i++) { dest[offset++] = data.charCodeAt(i) &amp; 0xff; } } else { for (const num of data) { dest[offset++] = num &amp; 0xff; } } } const OTF_HEADER_SIZE = 12; const OTF_TABLE_ENTRY_SIZE = 16; class OpenTypeFileBuilder { constructor(sfnt) { this.sfnt = sfnt; this.tables = Object.create(null); } static getSearchParams(entriesCount, entrySize) { let maxPower2 = 1, log2 = 0; while ((maxPower2 ^ entriesCount) &gt; maxPower2) { maxPower2 &lt;&lt;= 1; log2++; } const searchRange = maxPower2 * entrySize; return { range: searchRange, entry: log2, rangeShift: entrySize * entriesCount - searchRange }; } toArray() { let sfnt = this.sfnt; const tables = this.tables; const tablesNames = Object.keys(tables); tablesNames.sort(); const numTables = tablesNames.length; let i, j, jj, table, tableName; let offset = OTF_HEADER_SIZE + numTables * OTF_TABLE_ENTRY_SIZE; const tableOffsets = [offset]; for (i = 0; i &lt; numTables; i++) { table = tables[tablesNames[i]]; const paddedLength = (table.length + 3 &amp; ~3) &gt;&gt;&gt; 0; offset += paddedLength; tableOffsets.push(offset); } const file = new Uint8Array(offset); for (i = 0; i &lt; numTables; i++) { table = tables[tablesNames[i]]; writeData(file, tableOffsets[i], table); } if (sfnt === &quot;true&quot;) { sfnt = (0, _util.string32)(0x00010000); } file[0] = sfnt.charCodeAt(0) &amp; 0xff; file[1] = sfnt.charCodeAt(1) &amp; 0xff; file[2] = sfnt.charCodeAt(2) &amp; 0xff; file[3] = sfnt.charCodeAt(3) &amp; 0xff; writeInt16(file, 4, numTables); const searchParams = OpenTypeFileBuilder.getSearchParams(numTables, 16); writeInt16(file, 6, searchParams.range); writeInt16(file, 8, searchParams.entry); writeInt16(file, 10, searchParams.rangeShift); offset = OTF_HEADER_SIZE; for (i = 0; i &lt; numTables; i++) { tableName = tablesNames[i]; file[offset] = tableName.charCodeAt(0) &amp; 0xff; file[offset + 1] = tableName.charCodeAt(1) &amp; 0xff; file[offset + 2] = tableName.charCodeAt(2) &amp; 0xff; file[offset + 3] = tableName.charCodeAt(3) &amp; 0xff; let checksum = 0; for (j = tableOffsets[i], jj = tableOffsets[i + 1]; j &lt; jj; j += 4) { const quad = (0, _core_utils.readUint32)(file, j); checksum = checksum + quad &gt;&gt;&gt; 0; } writeInt32(file, offset + 4, checksum); writeInt32(file, offset + 8, tableOffsets[i]); writeInt32(file, offset + 12, tables[tableName].length); offset += OTF_TABLE_ENTRY_SIZE; } return file; } addTable(tag, data) { if (tag in this.tables) { throw new Error(&quot;Table &quot; + tag + &quot; already exists&quot;); } this.tables[tag] = data; } } exports.OpenTypeFileBuilder = OpenTypeFileBuilder; /***/ }), /* 46 */ /***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) =&gt; { Object.defineProperty(exports, &quot;__esModule&quot;, ({ value: true })); exports.Type1Font = void 0; var _cff_parser = __w_pdfjs_require__(33); var _util = __w_pdfjs_require__(2); var _fonts_utils = __w_pdfjs_require__(36); var _core_utils = __w_pdfjs_require__(4); var _stream = __w_pdfjs_require__(8); var _type1_parser = __w_pdfjs_require__(47); function findBlock(streamBytes, signature, startIndex) { const streamBytesLength = streamBytes.length; const signatureLength = signature.length; const scanLength = streamBytesLength - signatureLength; let i = startIndex, found = false; while (i &lt; scanLength) { let j = 0; while (j &lt; signatureLength &amp;&amp; streamBytes[i + j] === signature[j]) { j++; } if (j &gt;= signatureLength) { i += j; while (i &lt; streamBytesLength &amp;&amp; (0, _core_utils.isWhiteSpace)(streamBytes[i])) { i++; } found = true; break; } i++; } return { found, length: i }; } function getHeaderBlock(stream, suggestedLength) { const EEXEC_SIGNATURE = [0x65, 0x65, 0x78, 0x65, 0x63]; const streamStartPos = stream.pos; let headerBytes, headerBytesLength, block; try { headerBytes = stream.getBytes(suggestedLength); headerBytesLength = headerBytes.length; } catch (ex) {} if (headerBytesLength === suggestedLength) { block = findBlock(headerBytes, EEXEC_SIGNATURE, suggestedLength - 2 * EEXEC_SIGNATURE.length); if (block.found &amp;&amp; block.length === suggestedLength) { return { stream: new _stream.Stream(headerBytes), length: suggestedLength }; } } (0, _util.warn)(&apos;Invalid &quot;Length1&quot; property in Type1 font -- trying to recover.&apos;); stream.pos = streamStartPos; const SCAN_BLOCK_LENGTH = 2048; let actualLength; while (true) { const scanBytes = stream.peekBytes(SCAN_BLOCK_LENGTH); block = findBlock(scanBytes, EEXEC_SIGNATURE, 0); if (block.length === 0) { break; } stream.pos += block.length; if (block.found) { actualLength = stream.pos - streamStartPos; break; } } stream.pos = streamStartPos; if (actualLength) { return { stream: new _stream.Stream(stream.getBytes(actualLength)), length: actualLength }; } (0, _util.warn)(&apos;Unable to recover &quot;Length1&quot; property in Type1 font -- using as is.&apos;); return { stream: new _stream.Stream(stream.getBytes(suggestedLength)), length: suggestedLength }; } function getEexecBlock(stream, suggestedLength) { const eexecBytes = stream.getBytes(); if (eexecBytes.length === 0) { throw new _util.FormatError(&quot;getEexecBlock - no font program found.&quot;); } return { stream: new _stream.Stream(eexecBytes), length: eexecBytes.length }; } class Type1Font { constructor(name, file, properties) { const PFB_HEADER_SIZE = 6; let headerBlockLength = properties.length1; let eexecBlockLength = properties.length2; let pfbHeader = file.peekBytes(PFB_HEADER_SIZE); const pfbHeaderPresent = pfbHeader[0] === 0x80 &amp;&amp; pfbHeader[1] === 0x01; if (pfbHeaderPresent) { file.skip(PFB_HEADER_SIZE); headerBlockLength = pfbHeader[5] &lt;&lt; 24 | pfbHeader[4] &lt;&lt; 16 | pfbHeader[3] &lt;&lt; 8 | pfbHeader[2]; } const headerBlock = getHeaderBlock(file, headerBlockLength); const headerBlockParser = new _type1_parser.Type1Parser(headerBlock.stream, false, _fonts_utils.SEAC_ANALYSIS_ENABLED); headerBlockParser.extractFontHeader(properties); if (pfbHeaderPresent) { pfbHeader = file.getBytes(PFB_HEADER_SIZE); eexecBlockLength = pfbHeader[5] &lt;&lt; 24 | pfbHeader[4] &lt;&lt; 16 | pfbHeader[3] &lt;&lt; 8 | pfbHeader[2]; } const eexecBlock = getEexecBlock(file, eexecBlockLength); const eexecBlockParser = new _type1_parser.Type1Parser(eexecBlock.stream, true, _fonts_utils.SEAC_ANALYSIS_ENABLED); const data = eexecBlockParser.extractFontProgram(properties); for (const key in data.properties) { properties[key] = data.properties[key]; } const charstrings = data.charstrings; const type2Charstrings = this.getType2Charstrings(charstrings); const subrs = this.getType2Subrs(data.subrs); this.charstrings = charstrings; this.data = this.wrap(name, type2Charstrings, this.charstrings, subrs, properties); this.seacs = this.getSeacs(data.charstrings); } get numGlyphs() { return this.charstrings.length + 1; } getCharset() { const charset = [&quot;.notdef&quot;]; for (const { glyphName } of this.charstrings) { charset.push(glyphName); } return charset; } getGlyphMapping(properties) { const charstrings = this.charstrings; if (properties.composite) { const charCodeToGlyphId = Object.create(null); for (let glyphId = 0, charstringsLen = charstrings.length; glyphId &lt; charstringsLen; glyphId++) { const charCode = properties.cMap.charCodeOf(glyphId); charCodeToGlyphId[charCode] = glyphId + 1; } return charCodeToGlyphId; } const glyphNames = [&quot;.notdef&quot;]; let builtInEncoding, glyphId; for (glyphId = 0; glyphId &lt; charstrings.length; glyphId++) { glyphNames.push(charstrings[glyphId].glyphName); } const encoding = properties.builtInEncoding; if (encoding) { builtInEncoding = Object.create(null); for (const charCode in encoding) { glyphId = glyphNames.indexOf(encoding[charCode]); if (glyphId &gt;= 0) { builtInEncoding[charCode] = glyphId; } } } return (0, _fonts_utils.type1FontGlyphMapping)(properties, builtInEncoding, glyphNames); } hasGlyphId(id) { if (id &lt; 0 || id &gt;= this.numGlyphs) { return false; } if (id === 0) { return true; } const glyph = this.charstrings[id - 1]; return glyph.charstring.length &gt; 0; } getSeacs(charstrings) { const seacMap = []; for (let i = 0, ii = charstrings.length; i &lt; ii; i++) { const charstring = charstrings[i]; if (charstring.seac) { seacMap[i + 1] = charstring.seac; } } return seacMap; } getType2Charstrings(type1Charstrings) { const type2Charstrings = []; for (const type1Charstring of type1Charstrings) { type2Charstrings.push(type1Charstring.charstring); } return type2Charstrings; } getType2Subrs(type1Subrs) { let bias = 0; const count = type1Subrs.length; if (count &lt; 1133) { bias = 107; } else if (count &lt; 33769) { bias = 1131; } else { bias = 32768; } const type2Subrs = []; let i; for (i = 0; i &lt; bias; i++) { type2Subrs.push([0x0b]); } for (i = 0; i &lt; count; i++) { type2Subrs.push(type1Subrs[i]); } return type2Subrs; } wrap(name, glyphs, charstrings, subrs, properties) { const cff = new _cff_parser.CFF(); cff.header = new _cff_parser.CFFHeader(1, 0, 4, 4); cff.names = [name]; const topDict = new _cff_parser.CFFTopDict(); topDict.setByName(&quot;version&quot;, 391); topDict.setByName(&quot;Notice&quot;, 392); topDict.setByName(&quot;FullName&quot;, 393); topDict.setByName(&quot;FamilyName&quot;, 394); topDict.setByName(&quot;Weight&quot;, 395); topDict.setByName(&quot;Encoding&quot;, null); topDict.setByName(&quot;FontMatrix&quot;, properties.fontMatrix); topDict.setByName(&quot;FontBBox&quot;, properties.bbox); topDict.setByName(&quot;charset&quot;, null); topDict.setByName(&quot;CharStrings&quot;, null); topDict.setByName(&quot;Private&quot;, null); cff.topDict = topDict; const strings = new _cff_parser.CFFStrings(); strings.add(&quot;Version 0.11&quot;); strings.add(&quot;See original notice&quot;); strings.add(name); strings.add(name); strings.add(&quot;Medium&quot;); cff.strings = strings; cff.globalSubrIndex = new _cff_parser.CFFIndex(); const count = glyphs.length; const charsetArray = [&quot;.notdef&quot;]; let i, ii; for (i = 0; i &lt; count; i++) { const glyphName = charstrings[i].glyphName; const index = _cff_parser.CFFStandardStrings.indexOf(glyphName); if (index === -1) { strings.add(glyphName); } charsetArray.push(glyphName); } cff.charset = new _cff_parser.CFFCharset(false, 0, charsetArray); const charStringsIndex = new _cff_parser.CFFIndex(); charStringsIndex.add([0x8b, 0x0e]); for (i = 0; i &lt; count; i++) { charStringsIndex.add(glyphs[i]); } cff.charStrings = charStringsIndex; const privateDict = new _cff_parser.CFFPrivateDict(); privateDict.setByName(&quot;Subrs&quot;, null); const fields = [&quot;BlueValues&quot;, &quot;OtherBlues&quot;, &quot;FamilyBlues&quot;, &quot;FamilyOtherBlues&quot;, &quot;StemSnapH&quot;, &quot;StemSnapV&quot;, &quot;BlueShift&quot;, &quot;BlueFuzz&quot;, &quot;BlueScale&quot;, &quot;LanguageGroup&quot;, &quot;ExpansionFactor&quot;, &quot;ForceBold&quot;, &quot;StdHW&quot;, &quot;StdVW&quot;]; for (i = 0, ii = fields.length; i &lt; ii; i++) { const field = fields[i]; if (!(field in properties.privateData)) { continue; } const value = properties.privateData[field]; if (Array.isArray(value)) { for (let j = value.length - 1; j &gt; 0; j--) { value[j] -= value[j - 1]; } } privateDict.setByName(field, value); } cff.topDict.privateDict = privateDict; const subrIndex = new _cff_parser.CFFIndex(); for (i = 0, ii = subrs.length; i &lt; ii; i++) { subrIndex.add(subrs[i]); } privateDict.subrsIndex = subrIndex; const compiler = new _cff_parser.CFFCompiler(cff); return compiler.compile(); } } exports.Type1Font = Type1Font; /***/ }), /* 47 */ /***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) =&gt; { Object.defineProperty(exports, &quot;__esModule&quot;, ({ value: true })); exports.Type1Parser = void 0; var _encodings = __w_pdfjs_require__(35); var _core_utils = __w_pdfjs_require__(4); var _stream = __w_pdfjs_require__(8); var _util = __w_pdfjs_require__(2); const HINTING_ENABLED = false; const COMMAND_MAP = { hstem: [1], vstem: [3], vmoveto: [4], rlineto: [5], hlineto: [6], vlineto: [7], rrcurveto: [8], callsubr: [10], flex: [12, 35], drop: [12, 18], endchar: [14], rmoveto: [21], hmoveto: [22], vhcurveto: [30], hvcurveto: [31] }; class Type1CharString { constructor() { this.width = 0; this.lsb = 0; this.flexing = false; this.output = []; this.stack = []; } convert(encoded, subrs, seacAnalysisEnabled) { const count = encoded.length; let error = false; let wx, sbx, subrNumber; for (let i = 0; i &lt; count; i++) { let value = encoded[i]; if (value &lt; 32) { if (value === 12) { value = (value &lt;&lt; 8) + encoded[++i]; } switch (value) { case 1: if (!HINTING_ENABLED) { this.stack = []; break; } error = this.executeCommand(2, COMMAND_MAP.hstem); break; case 3: if (!HINTING_ENABLED) { this.stack = []; break; } error = this.executeCommand(2, COMMAND_MAP.vstem); break; case 4: if (this.flexing) { if (this.stack.length &lt; 1) { error = true; break; } const dy = this.stack.pop(); this.stack.push(0, dy); break; } error = this.executeCommand(1, COMMAND_MAP.vmoveto); break; case 5: error = this.executeCommand(2, COMMAND_MAP.rlineto); break; case 6: error = this.executeCommand(1, COMMAND_MAP.hlineto); break; case 7: error = this.executeCommand(1, COMMAND_MAP.vlineto); break; case 8: error = this.executeCommand(6, COMMAND_MAP.rrcurveto); break; case 9: this.stack = []; break; case 10: if (this.stack.length &lt; 1) { error = true; break; } subrNumber = this.stack.pop(); if (!subrs[subrNumber]) { error = true; break; } error = this.convert(subrs[subrNumber], subrs, seacAnalysisEnabled); break; case 11: return error; case 13: if (this.stack.length &lt; 2) { error = true; break; } wx = this.stack.pop(); sbx = this.stack.pop(); this.lsb = sbx; this.width = wx; this.stack.push(wx, sbx); error = this.executeCommand(2, COMMAND_MAP.hmoveto); break; case 14: this.output.push(COMMAND_MAP.endchar[0]); break; case 21: if (this.flexing) { break; } error = this.executeCommand(2, COMMAND_MAP.rmoveto); break; case 22: if (this.flexing) { this.stack.push(0); break; } error = this.executeCommand(1, COMMAND_MAP.hmoveto); break; case 30: error = this.executeCommand(4, COMMAND_MAP.vhcurveto); break; case 31: error = this.executeCommand(4, COMMAND_MAP.hvcurveto); break; case (12 &lt;&lt; 8) + 0: this.stack = []; break; case (12 &lt;&lt; 8) + 1: if (!HINTING_ENABLED) { this.stack = []; break; } error = this.executeCommand(2, COMMAND_MAP.vstem); break; case (12 &lt;&lt; 8) + 2: if (!HINTING_ENABLED) { this.stack = []; break; } error = this.executeCommand(2, COMMAND_MAP.hstem); break; case (12 &lt;&lt; 8) + 6: if (seacAnalysisEnabled) { const asb = this.stack.at(-5); this.seac = this.stack.splice(-4, 4); this.seac[0] += this.lsb - asb; error = this.executeCommand(0, COMMAND_MAP.endchar); } else { error = this.executeCommand(4, COMMAND_MAP.endchar); } break; case (12 &lt;&lt; 8) + 7: if (this.stack.length &lt; 4) { error = true; break; } this.stack.pop(); wx = this.stack.pop(); const sby = this.stack.pop(); sbx = this.stack.pop(); this.lsb = sbx; this.width = wx; this.stack.push(wx, sbx, sby); error = this.executeCommand(3, COMMAND_MAP.rmoveto); break; case (12 &lt;&lt; 8) + 12: if (this.stack.length &lt; 2) { error = true; break; } const num2 = this.stack.pop(); const num1 = this.stack.pop(); this.stack.push(num1 / num2); break; case (12 &lt;&lt; 8) + 16: if (this.stack.length &lt; 2) { error = true; break; } subrNumber = this.stack.pop(); const numArgs = this.stack.pop(); if (subrNumber === 0 &amp;&amp; numArgs === 3) { const flexArgs = this.stack.splice(this.stack.length - 17, 17); this.stack.push(flexArgs[2] + flexArgs[0], flexArgs[3] + flexArgs[1], flexArgs[4], flexArgs[5], flexArgs[6], flexArgs[7], flexArgs[8], flexArgs[9], flexArgs[10], flexArgs[11], flexArgs[12], flexArgs[13], flexArgs[14]); error = this.executeCommand(13, COMMAND_MAP.flex, true); this.flexing = false; this.stack.push(flexArgs[15], flexArgs[16]); } else if (subrNumber === 1 &amp;&amp; numArgs === 0) { this.flexing = true; } break; case (12 &lt;&lt; 8) + 17: break; case (12 &lt;&lt; 8) + 33: this.stack = []; break; default: (0, _util.warn)(&apos;Unknown type 1 charstring command of &quot;&apos; + value + &apos;&quot;&apos;); break; } if (error) { break; } continue; } else if (value &lt;= 246) { value -= 139; } else if (value &lt;= 250) { value = (value - 247) * 256 + encoded[++i] + 108; } else if (value &lt;= 254) { value = -((value - 251) * 256) - encoded[++i] - 108; } else { value = (encoded[++i] &amp; 0xff) &lt;&lt; 24 | (encoded[++i] &amp; 0xff) &lt;&lt; 16 | (encoded[++i] &amp; 0xff) &lt;&lt; 8 | (encoded[++i] &amp; 0xff) &lt;&lt; 0; } this.stack.push(value); } return error; } executeCommand(howManyArgs, command, keepStack) { const stackLength = this.stack.length; if (howManyArgs &gt; stackLength) { return true; } const start = stackLength - howManyArgs; for (let i = start; i &lt; stackLength; i++) { let value = this.stack[i]; if (Number.isInteger(value)) { this.output.push(28, value &gt;&gt; 8 &amp; 0xff, value &amp; 0xff); } else { value = 65536 * value | 0; this.output.push(255, value &gt;&gt; 24 &amp; 0xff, value &gt;&gt; 16 &amp; 0xff, value &gt;&gt; 8 &amp; 0xff, value &amp; 0xff); } } this.output.push(...command); if (keepStack) { this.stack.splice(start, howManyArgs); } else { this.stack.length = 0; } return false; } } const EEXEC_ENCRYPT_KEY = 55665; const CHAR_STRS_ENCRYPT_KEY = 4330; function isHexDigit(code) { return code &gt;= 48 &amp;&amp; code &lt;= 57 || code &gt;= 65 &amp;&amp; code &lt;= 70 || code &gt;= 97 &amp;&amp; code &lt;= 102; } function decrypt(data, key, discardNumber) { if (discardNumber &gt;= data.length) { return new Uint8Array(0); } const c1 = 52845, c2 = 22719; let r = key | 0, i, j; for (i = 0; i &lt; discardNumber; i++) { r = (data[i] + r) * c1 + c2 &amp; (1 &lt;&lt; 16) - 1; } const count = data.length - discardNumber; const decrypted = new Uint8Array(count); for (i = discardNumber, j = 0; j &lt; count; i++, j++) { const value = data[i]; decrypted[j] = value ^ r &gt;&gt; 8; r = (value + r) * c1 + c2 &amp; (1 &lt;&lt; 16) - 1; } return decrypted; } function decryptAscii(data, key, discardNumber) { const c1 = 52845, c2 = 22719; let r = key | 0; const count = data.length, maybeLength = count &gt;&gt;&gt; 1; const decrypted = new Uint8Array(maybeLength); let i, j; for (i = 0, j = 0; i &lt; count; i++) { const digit1 = data[i]; if (!isHexDigit(digit1)) { continue; } i++; let digit2; while (i &lt; count &amp;&amp; !isHexDigit(digit2 = data[i])) { i++; } if (i &lt; count) { const value = parseInt(String.fromCharCode(digit1, digit2), 16); decrypted[j++] = value ^ r &gt;&gt; 8; r = (value + r) * c1 + c2 &amp; (1 &lt;&lt; 16) - 1; } } return decrypted.slice(discardNumber, j); } function isSpecial(c) { return c === 0x2f || c === 0x5b || c === 0x5d || c === 0x7b || c === 0x7d || c === 0x28 || c === 0x29; } class Type1Parser { constructor(stream, encrypted, seacAnalysisEnabled) { if (encrypted) { const data = stream.getBytes(); const isBinary = !((isHexDigit(data[0]) || (0, _core_utils.isWhiteSpace)(data[0])) &amp;&amp; isHexDigit(data[1]) &amp;&amp; isHexDigit(data[2]) &amp;&amp; isHexDigit(data[3]) &amp;&amp; isHexDigit(data[4]) &amp;&amp; isHexDigit(data[5]) &amp;&amp; isHexDigit(data[6]) &amp;&amp; isHexDigit(data[7])); stream = new _stream.Stream(isBinary ? decrypt(data, EEXEC_ENCRYPT_KEY, 4) : decryptAscii(data, EEXEC_ENCRYPT_KEY, 4)); } this.seacAnalysisEnabled = !!seacAnalysisEnabled; this.stream = stream; this.nextChar(); } readNumberArray() { this.getToken(); const array = []; while (true) { const token = this.getToken(); if (token === null || token === &quot;]&quot; || token === &quot;}&quot;) { break; } array.push(parseFloat(token || 0)); } return array; } readNumber() { const token = this.getToken(); return parseFloat(token || 0); } readInt() { const token = this.getToken(); return parseInt(token || 0, 10) | 0; } readBoolean() { const token = this.getToken(); return token === &quot;true&quot; ? 1 : 0; } nextChar() { return this.currentChar = this.stream.getByte(); } prevChar() { this.stream.skip(-2); return this.currentChar = this.stream.getByte(); } getToken() { let comment = false; let ch = this.currentChar; while (true) { if (ch === -1) { return null; } if (comment) { if (ch === 0x0a || ch === 0x0d) { comment = false; } } else if (ch === 0x25) { comment = true; } else if (!(0, _core_utils.isWhiteSpace)(ch)) { break; } ch = this.nextChar(); } if (isSpecial(ch)) { this.nextChar(); return String.fromCharCode(ch); } let token = &quot;&quot;; do { token += String.fromCharCode(ch); ch = this.nextChar(); } while (ch &gt;= 0 &amp;&amp; !(0, _core_utils.isWhiteSpace)(ch) &amp;&amp; !isSpecial(ch)); return token; } readCharStrings(bytes, lenIV) { if (lenIV === -1) { return bytes; } return decrypt(bytes, CHAR_STRS_ENCRYPT_KEY, lenIV); } extractFontProgram(properties) { const stream = this.stream; const subrs = [], charstrings = []; const privateData = Object.create(null); privateData.lenIV = 4; const program = { subrs: [], charstrings: [], properties: { privateData } }; let token, length, data, lenIV; while ((token = this.getToken()) !== null) { if (token !== &quot;/&quot;) { continue; } token = this.getToken(); switch (token) { case &quot;CharStrings&quot;: this.getToken(); this.getToken(); this.getToken(); this.getToken(); while (true) { token = this.getToken(); if (token === null || token === &quot;end&quot;) { break; } if (token !== &quot;/&quot;) { continue; } const glyph = this.getToken(); length = this.readInt(); this.getToken(); data = length &gt; 0 ? stream.getBytes(length) : new Uint8Array(0); lenIV = program.properties.privateData.lenIV; const encoded = this.readCharStrings(data, lenIV); this.nextChar(); token = this.getToken(); if (token === &quot;noaccess&quot;) { this.getToken(); } else if (token === &quot;/&quot;) { this.prevChar(); } charstrings.push({ glyph, encoded }); } break; case &quot;Subrs&quot;: this.readInt(); this.getToken(); while (this.getToken() === &quot;dup&quot;) { const index = this.readInt(); length = this.readInt(); this.getToken(); data = length &gt; 0 ? stream.getBytes(length) : new Uint8Array(0); lenIV = program.properties.privateData.lenIV; const encoded = this.readCharStrings(data, lenIV); this.nextChar(); token = this.getToken(); if (token === &quot;noaccess&quot;) { this.getToken(); } subrs[index] = encoded; } break; case &quot;BlueValues&quot;: case &quot;OtherBlues&quot;: case &quot;FamilyBlues&quot;: case &quot;FamilyOtherBlues&quot;: const blueArray = this.readNumberArray(); if (blueArray.length &gt; 0 &amp;&amp; blueArray.length % 2 === 0 &amp;&amp; HINTING_ENABLED) { program.properties.privateData[token] = blueArray; } break; case &quot;StemSnapH&quot;: case &quot;StemSnapV&quot;: program.properties.privateData[token] = this.readNumberArray(); break; case &quot;StdHW&quot;: case &quot;StdVW&quot;: program.properties.privateData[token] = this.readNumberArray()[0]; break; case &quot;BlueShift&quot;: case &quot;lenIV&quot;: case &quot;BlueFuzz&quot;: case &quot;BlueScale&quot;: case &quot;LanguageGroup&quot;: case &quot;ExpansionFactor&quot;: program.properties.privateData[token] = this.readNumber(); break; case &quot;ForceBold&quot;: program.properties.privateData[token] = this.readBoolean(); break; } } for (const { encoded, glyph } of charstrings) { const charString = new Type1CharString(); const error = charString.convert(encoded, subrs, this.seacAnalysisEnabled); let output = charString.output; if (error) { output = [14]; } const charStringObject = { glyphName: glyph, charstring: output, width: charString.width, lsb: charString.lsb, seac: charString.seac }; if (glyph === &quot;.notdef&quot;) { program.charstrings.unshift(charStringObject); } else { program.charstrings.push(charStringObject); } if (properties.builtInEncoding) { const index = properties.builtInEncoding.indexOf(glyph); if (index &gt; -1 &amp;&amp; properties.widths[index] === undefined &amp;&amp; index &gt;= properties.firstChar &amp;&amp; index &lt;= properties.lastChar) { properties.widths[index] = charString.width; } } } return program; } extractFontHeader(properties) { let token; while ((token = this.getToken()) !== null) { if (token !== &quot;/&quot;) { continue; } token = this.getToken(); switch (token) { case &quot;FontMatrix&quot;: const matrix = this.readNumberArray(); properties.fontMatrix = matrix; break; case &quot;Encoding&quot;: const encodingArg = this.getToken(); let encoding; if (!/^\\d+$/.test(encodingArg)) { encoding = (0, _encodings.getEncoding)(encodingArg); } else { encoding = []; const size = parseInt(encodingArg, 10) | 0; this.getToken(); for (let j = 0; j &lt; size; j++) { token = this.getToken(); while (token !== &quot;dup&quot; &amp;&amp; token !== &quot;def&quot;) { token = this.getToken(); if (token === null) { return; } } if (token === &quot;def&quot;) { break; } const index = this.readInt(); this.getToken(); const glyph = this.getToken(); encoding[index] = glyph; this.getToken(); } } properties.builtInEncoding = encoding; break; case &quot;FontBBox&quot;: const fontBBox = this.readNumberArray(); properties.ascent = Math.max(fontBBox[3], fontBBox[1]); properties.descent = Math.min(fontBBox[1], fontBBox[3]); properties.ascentScaled = true; break; } } } } exports.Type1Parser = Type1Parser; /***/ }), /* 48 */ /***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) =&gt; { Object.defineProperty(exports, &quot;__esModule&quot;, ({ value: true })); exports.Pattern = void 0; exports.getTilingPatternIR = getTilingPatternIR; var _util = __w_pdfjs_require__(2); var _base_stream = __w_pdfjs_require__(5); var _colorspace = __w_pdfjs_require__(12); var _core_utils = __w_pdfjs_require__(4); const ShadingType = { FUNCTION_BASED: 1, AXIAL: 2, RADIAL: 3, FREE_FORM_MESH: 4, LATTICE_FORM_MESH: 5, COONS_PATCH_MESH: 6, TENSOR_PATCH_MESH: 7 }; class Pattern { constructor() { (0, _util.unreachable)(&quot;Cannot initialize Pattern.&quot;); } static parseShading(shading, xref, res, handler, pdfFunctionFactory, localColorSpaceCache) { const dict = shading instanceof _base_stream.BaseStream ? shading.dict : shading; const type = dict.get(&quot;ShadingType&quot;); try { switch (type) { case ShadingType.AXIAL: case ShadingType.RADIAL: return new RadialAxialShading(dict, xref, res, pdfFunctionFactory, localColorSpaceCache); case ShadingType.FREE_FORM_MESH: case ShadingType.LATTICE_FORM_MESH: case ShadingType.COONS_PATCH_MESH: case ShadingType.TENSOR_PATCH_MESH: return new MeshShading(shading, xref, res, pdfFunctionFactory, localColorSpaceCache); default: throw new _util.FormatError(&quot;Unsupported ShadingType: &quot; + type); } } catch (ex) { if (ex instanceof _core_utils.MissingDataException) { throw ex; } handler.send(&quot;UnsupportedFeature&quot;, { featureId: _util.UNSUPPORTED_FEATURES.shadingPattern }); (0, _util.warn)(ex); return new DummyShading(); } } } exports.Pattern = Pattern; class BaseShading { static get SMALL_NUMBER() { return (0, _util.shadow)(this, &quot;SMALL_NUMBER&quot;, 1e-6); } constructor() { if (this.constructor === BaseShading) { (0, _util.unreachable)(&quot;Cannot initialize BaseShading.&quot;); } } getIR() { (0, _util.unreachable)(&quot;Abstract method `getIR` called.&quot;); } } class RadialAxialShading extends BaseShading { constructor(dict, xref, resources, pdfFunctionFactory, localColorSpaceCache) { super(); this.coordsArr = dict.getArray(&quot;Coords&quot;); this.shadingType = dict.get(&quot;ShadingType&quot;); const cs = _colorspace.ColorSpace.parse({ cs: dict.getRaw(&quot;CS&quot;) || dict.getRaw(&quot;ColorSpace&quot;), xref, resources, pdfFunctionFactory, localColorSpaceCache }); const bbox = dict.getArray(&quot;BBox&quot;); if (Array.isArray(bbox) &amp;&amp; bbox.length === 4) { this.bbox = _util.Util.normalizeRect(bbox); } else { this.bbox = null; } let t0 = 0.0, t1 = 1.0; if (dict.has(&quot;Domain&quot;)) { const domainArr = dict.getArray(&quot;Domain&quot;); t0 = domainArr[0]; t1 = domainArr[1]; } let extendStart = false, extendEnd = false; if (dict.has(&quot;Extend&quot;)) { const extendArr = dict.getArray(&quot;Extend&quot;); extendStart = extendArr[0]; extendEnd = extendArr[1]; } if (this.shadingType === ShadingType.RADIAL &amp;&amp; (!extendStart || !extendEnd)) { const [x1, y1, r1, x2, y2, r2] = this.coordsArr; const distance = Math.hypot(x1 - x2, y1 - y2); if (r1 &lt;= r2 + distance &amp;&amp; r2 &lt;= r1 + distance) { (0, _util.warn)(&quot;Unsupported radial gradient.&quot;); } } this.extendStart = extendStart; this.extendEnd = extendEnd; const fnObj = dict.getRaw(&quot;Function&quot;); const fn = pdfFunctionFactory.createFromArray(fnObj); const NUMBER_OF_SAMPLES = 10; const step = (t1 - t0) / NUMBER_OF_SAMPLES; const colorStops = this.colorStops = []; if (t0 &gt;= t1 || step &lt;= 0) { (0, _util.info)(&quot;Bad shading domain.&quot;); return; } const color = new Float32Array(cs.numComps), ratio = new Float32Array(1); let rgbColor; for (let i = 0; i &lt;= NUMBER_OF_SAMPLES; i++) { ratio[0] = t0 + i * step; fn(ratio, 0, color, 0); rgbColor = cs.getRgb(color, 0); const cssColor = _util.Util.makeHexColor(rgbColor[0], rgbColor[1], rgbColor[2]); colorStops.push([i / NUMBER_OF_SAMPLES, cssColor]); } let background = &quot;transparent&quot;; if (dict.has(&quot;Background&quot;)) { rgbColor = cs.getRgb(dict.get(&quot;Background&quot;), 0); background = _util.Util.makeHexColor(rgbColor[0], rgbColor[1], rgbColor[2]); } if (!extendStart) { colorStops.unshift([0, background]); colorStops[1][0] += BaseShading.SMALL_NUMBER; } if (!extendEnd) { colorStops.at(-1)[0] -= BaseShading.SMALL_NUMBER; colorStops.push([1, background]); } this.colorStops = colorStops; } getIR() { const coordsArr = this.coordsArr; const shadingType = this.shadingType; let type, p0, p1, r0, r1; if (shadingType === ShadingType.AXIAL) { p0 = [coordsArr[0], coordsArr[1]]; p1 = [coordsArr[2], coordsArr[3]]; r0 = null; r1 = null; type = &quot;axial&quot;; } else if (shadingType === ShadingType.RADIAL) { p0 = [coordsArr[0], coordsArr[1]]; p1 = [coordsArr[3], coordsArr[4]]; r0 = coordsArr[2]; r1 = coordsArr[5]; type = &quot;radial&quot;; } else { (0, _util.unreachable)(`getPattern type unknown: ${shadingType}`); } return [&quot;RadialAxial&quot;, type, this.bbox, this.colorStops, p0, p1, r0, r1]; } } class MeshStreamReader { constructor(stream, context) { this.stream = stream; this.context = context; this.buffer = 0; this.bufferLength = 0; const numComps = context.numComps; this.tmpCompsBuf = new Float32Array(numComps); const csNumComps = context.colorSpace.numComps; this.tmpCsCompsBuf = context.colorFn ? new Float32Array(csNumComps) : this.tmpCompsBuf; } get hasData() { if (this.stream.end) { return this.stream.pos &lt; this.stream.end; } if (this.bufferLength &gt; 0) { return true; } const nextByte = this.stream.getByte(); if (nextByte &lt; 0) { return false; } this.buffer = nextByte; this.bufferLength = 8; return true; } readBits(n) { let buffer = this.buffer; let bufferLength = this.bufferLength; if (n === 32) { if (bufferLength === 0) { return (this.stream.getByte() &lt;&lt; 24 | this.stream.getByte() &lt;&lt; 16 | this.stream.getByte() &lt;&lt; 8 | this.stream.getByte()) &gt;&gt;&gt; 0; } buffer = buffer &lt;&lt; 24 | this.stream.getByte() &lt;&lt; 16 | this.stream.getByte() &lt;&lt; 8 | this.stream.getByte(); const nextByte = this.stream.getByte(); this.buffer = nextByte &amp; (1 &lt;&lt; bufferLength) - 1; return (buffer &lt;&lt; 8 - bufferLength | (nextByte &amp; 0xff) &gt;&gt; bufferLength) &gt;&gt;&gt; 0; } if (n === 8 &amp;&amp; bufferLength === 0) { return this.stream.getByte(); } while (bufferLength &lt; n) { buffer = buffer &lt;&lt; 8 | this.stream.getByte(); bufferLength += 8; } bufferLength -= n; this.bufferLength = bufferLength; this.buffer = buffer &amp; (1 &lt;&lt; bufferLength) - 1; return buffer &gt;&gt; bufferLength; } align() { this.buffer = 0; this.bufferLength = 0; } readFlag() { return this.readBits(this.context.bitsPerFlag); } readCoordinate() { const bitsPerCoordinate = this.context.bitsPerCoordinate; const xi = this.readBits(bitsPerCoordinate); const yi = this.readBits(bitsPerCoordinate); const decode = this.context.decode; const scale = bitsPerCoordinate &lt; 32 ? 1 / ((1 &lt;&lt; bitsPerCoordinate) - 1) : 2.3283064365386963e-10; return [xi * scale * (decode[1] - decode[0]) + decode[0], yi * scale * (decode[3] - decode[2]) + decode[2]]; } readComponents() { const numComps = this.context.numComps; const bitsPerComponent = this.context.bitsPerComponent; const scale = bitsPerComponent &lt; 32 ? 1 / ((1 &lt;&lt; bitsPerComponent) - 1) : 2.3283064365386963e-10; const decode = this.context.decode; const components = this.tmpCompsBuf; for (let i = 0, j = 4; i &lt; numComps; i++, j += 2) { const ci = this.readBits(bitsPerComponent); components[i] = ci * scale * (decode[j + 1] - decode[j]) + decode[j]; } const color = this.tmpCsCompsBuf; if (this.context.colorFn) { this.context.colorFn(components, 0, color, 0); } return this.context.colorSpace.getRgb(color, 0); } } const getB = function getBClosure() { function buildB(count) { const lut = []; for (let i = 0; i &lt;= count; i++) { const t = i / count, t_ = 1 - t; lut.push(new Float32Array([t_ * t_ * t_, 3 * t * t_ * t_, 3 * t * t * t_, t * t * t])); } return lut; } const cache = []; return function (count) { if (!cache[count]) { cache[count] = buildB(count); } return cache[count]; }; }(); class MeshShading extends BaseShading { static get MIN_SPLIT_PATCH_CHUNKS_AMOUNT() { return (0, _util.shadow)(this, &quot;MIN_SPLIT_PATCH_CHUNKS_AMOUNT&quot;, 3); } static get MAX_SPLIT_PATCH_CHUNKS_AMOUNT() { return (0, _util.shadow)(this, &quot;MAX_SPLIT_PATCH_CHUNKS_AMOUNT&quot;, 20); } static get TRIANGLE_DENSITY() { return (0, _util.shadow)(this, &quot;TRIANGLE_DENSITY&quot;, 20); } constructor(stream, xref, resources, pdfFunctionFactory, localColorSpaceCache) { super(); if (!(stream instanceof _base_stream.BaseStream)) { throw new _util.FormatError(&quot;Mesh data is not a stream&quot;); } const dict = stream.dict; this.shadingType = dict.get(&quot;ShadingType&quot;); const bbox = dict.getArray(&quot;BBox&quot;); if (Array.isArray(bbox) &amp;&amp; bbox.length === 4) { this.bbox = _util.Util.normalizeRect(bbox); } else { this.bbox = null; } const cs = _colorspace.ColorSpace.parse({ cs: dict.getRaw(&quot;CS&quot;) || dict.getRaw(&quot;ColorSpace&quot;), xref, resources, pdfFunctionFactory, localColorSpaceCache }); this.background = dict.has(&quot;Background&quot;) ? cs.getRgb(dict.get(&quot;Background&quot;), 0) : null; const fnObj = dict.getRaw(&quot;Function&quot;); const fn = fnObj ? pdfFunctionFactory.createFromArray(fnObj) : null; this.coords = []; this.colors = []; this.figures = []; const decodeContext = { bitsPerCoordinate: dict.get(&quot;BitsPerCoordinate&quot;), bitsPerComponent: dict.get(&quot;BitsPerComponent&quot;), bitsPerFlag: dict.get(&quot;BitsPerFlag&quot;), decode: dict.getArray(&quot;Decode&quot;), colorFn: fn, colorSpace: cs, numComps: fn ? 1 : cs.numComps }; const reader = new MeshStreamReader(stream, decodeContext); let patchMesh = false; switch (this.shadingType) { case ShadingType.FREE_FORM_MESH: this._decodeType4Shading(reader); break; case ShadingType.LATTICE_FORM_MESH: const verticesPerRow = dict.get(&quot;VerticesPerRow&quot;) | 0; if (verticesPerRow &lt; 2) { throw new _util.FormatError(&quot;Invalid VerticesPerRow&quot;); } this._decodeType5Shading(reader, verticesPerRow); break; case ShadingType.COONS_PATCH_MESH: this._decodeType6Shading(reader); patchMesh = true; break; case ShadingType.TENSOR_PATCH_MESH: this._decodeType7Shading(reader); patchMesh = true; break; default: (0, _util.unreachable)(&quot;Unsupported mesh type.&quot;); break; } if (patchMesh) { this._updateBounds(); for (let i = 0, ii = this.figures.length; i &lt; ii; i++) { this._buildFigureFromPatch(i); } } this._updateBounds(); this._packData(); } _decodeType4Shading(reader) { const coords = this.coords; const colors = this.colors; const operators = []; const ps = []; let verticesLeft = 0; while (reader.hasData) { const f = reader.readFlag(); const coord = reader.readCoordinate(); const color = reader.readComponents(); if (verticesLeft === 0) { if (!(0 &lt;= f &amp;&amp; f &lt;= 2)) { throw new _util.FormatError(&quot;Unknown type4 flag&quot;); } switch (f) { case 0: verticesLeft = 3; break; case 1: ps.push(ps.at(-2), ps.at(-1)); verticesLeft = 1; break; case 2: ps.push(ps.at(-3), ps.at(-1)); verticesLeft = 1; break; } operators.push(f); } ps.push(coords.length); coords.push(coord); colors.push(color); verticesLeft--; reader.align(); } this.figures.push({ type: &quot;triangles&quot;, coords: new Int32Array(ps), colors: new Int32Array(ps) }); } _decodeType5Shading(reader, verticesPerRow) { const coords = this.coords; const colors = this.colors; const ps = []; while (reader.hasData) { const coord = reader.readCoordinate(); const color = reader.readComponents(); ps.push(coords.length); coords.push(coord); colors.push(color); } this.figures.push({ type: &quot;lattice&quot;, coords: new Int32Array(ps), colors: new Int32Array(ps), verticesPerRow }); } _decodeType6Shading(reader) { const coords = this.coords; const colors = this.colors; const ps = new Int32Array(16); const cs = new Int32Array(4); while (reader.hasData) { const f = reader.readFlag(); if (!(0 &lt;= f &amp;&amp; f &lt;= 3)) { throw new _util.FormatError(&quot;Unknown type6 flag&quot;); } const pi = coords.length; for (let i = 0, ii = f !== 0 ? 8 : 12; i &lt; ii; i++) { coords.push(reader.readCoordinate()); } const ci = colors.length; for (let i = 0, ii = f !== 0 ? 2 : 4; i &lt; ii; i++) { colors.push(reader.readComponents()); } let tmp1, tmp2, tmp3, tmp4; switch (f) { case 0: ps[12] = pi + 3; ps[13] = pi + 4; ps[14] = pi + 5; ps[15] = pi + 6; ps[8] = pi + 2; ps[11] = pi + 7; ps[4] = pi + 1; ps[7] = pi + 8; ps[0] = pi; ps[1] = pi + 11; ps[2] = pi + 10; ps[3] = pi + 9; cs[2] = ci + 1; cs[3] = ci + 2; cs[0] = ci; cs[1] = ci + 3; break; case 1: tmp1 = ps[12]; tmp2 = ps[13]; tmp3 = ps[14]; tmp4 = ps[15]; ps[12] = tmp4; ps[13] = pi + 0; ps[14] = pi + 1; ps[15] = pi + 2; ps[8] = tmp3; ps[11] = pi + 3; ps[4] = tmp2; ps[7] = pi + 4; ps[0] = tmp1; ps[1] = pi + 7; ps[2] = pi + 6; ps[3] = pi + 5; tmp1 = cs[2]; tmp2 = cs[3]; cs[2] = tmp2; cs[3] = ci; cs[0] = tmp1; cs[1] = ci + 1; break; case 2: tmp1 = ps[15]; tmp2 = ps[11]; ps[12] = ps[3]; ps[13] = pi + 0; ps[14] = pi + 1; ps[15] = pi + 2; ps[8] = ps[7]; ps[11] = pi + 3; ps[4] = tmp2; ps[7] = pi + 4; ps[0] = tmp1; ps[1] = pi + 7; ps[2] = pi + 6; ps[3] = pi + 5; tmp1 = cs[3]; cs[2] = cs[1]; cs[3] = ci; cs[0] = tmp1; cs[1] = ci + 1; break; case 3: ps[12] = ps[0]; ps[13] = pi + 0; ps[14] = pi + 1; ps[15] = pi + 2; ps[8] = ps[1]; ps[11] = pi + 3; ps[4] = ps[2]; ps[7] = pi + 4; ps[0] = ps[3]; ps[1] = pi + 7; ps[2] = pi + 6; ps[3] = pi + 5; cs[2] = cs[0]; cs[3] = ci; cs[0] = cs[1]; cs[1] = ci + 1; break; } ps[5] = coords.length; coords.push([(-4 * coords[ps[0]][0] - coords[ps[15]][0] + 6 * (coords[ps[4]][0] + coords[ps[1]][0]) - 2 * (coords[ps[12]][0] + coords[ps[3]][0]) + 3 * (coords[ps[13]][0] + coords[ps[7]][0])) / 9, (-4 * coords[ps[0]][1] - coords[ps[15]][1] + 6 * (coords[ps[4]][1] + coords[ps[1]][1]) - 2 * (coords[ps[12]][1] + coords[ps[3]][1]) + 3 * (coords[ps[13]][1] + coords[ps[7]][1])) / 9]); ps[6] = coords.length; coords.push([(-4 * coords[ps[3]][0] - coords[ps[12]][0] + 6 * (coords[ps[2]][0] + coords[ps[7]][0]) - 2 * (coords[ps[0]][0] + coords[ps[15]][0]) + 3 * (coords[ps[4]][0] + coords[ps[14]][0])) / 9, (-4 * coords[ps[3]][1] - coords[ps[12]][1] + 6 * (coords[ps[2]][1] + coords[ps[7]][1]) - 2 * (coords[ps[0]][1] + coords[ps[15]][1]) + 3 * (coords[ps[4]][1] + coords[ps[14]][1])) / 9]); ps[9] = coords.length; coords.push([(-4 * coords[ps[12]][0] - coords[ps[3]][0] + 6 * (coords[ps[8]][0] + coords[ps[13]][0]) - 2 * (coords[ps[0]][0] + coords[ps[15]][0]) + 3 * (coords[ps[11]][0] + coords[ps[1]][0])) / 9, (-4 * coords[ps[12]][1] - coords[ps[3]][1] + 6 * (coords[ps[8]][1] + coords[ps[13]][1]) - 2 * (coords[ps[0]][1] + coords[ps[15]][1]) + 3 * (coords[ps[11]][1] + coords[ps[1]][1])) / 9]); ps[10] = coords.length; coords.push([(-4 * coords[ps[15]][0] - coords[ps[0]][0] + 6 * (coords[ps[11]][0] + coords[ps[14]][0]) - 2 * (coords[ps[12]][0] + coords[ps[3]][0]) + 3 * (coords[ps[2]][0] + coords[ps[8]][0])) / 9, (-4 * coords[ps[15]][1] - coords[ps[0]][1] + 6 * (coords[ps[11]][1] + coords[ps[14]][1]) - 2 * (coords[ps[12]][1] + coords[ps[3]][1]) + 3 * (coords[ps[2]][1] + coords[ps[8]][1])) / 9]); this.figures.push({ type: &quot;patch&quot;, coords: new Int32Array(ps), colors: new Int32Array(cs) }); } } _decodeType7Shading(reader) { const coords = this.coords; const colors = this.colors; const ps = new Int32Array(16); const cs = new Int32Array(4); while (reader.hasData) { const f = reader.readFlag(); if (!(0 &lt;= f &amp;&amp; f &lt;= 3)) { throw new _util.FormatError(&quot;Unknown type7 flag&quot;); } const pi = coords.length; for (let i = 0, ii = f !== 0 ? 12 : 16; i &lt; ii; i++) { coords.push(reader.readCoordinate()); } const ci = colors.length; for (let i = 0, ii = f !== 0 ? 2 : 4; i &lt; ii; i++) { colors.push(reader.readComponents()); } let tmp1, tmp2, tmp3, tmp4; switch (f) { case 0: ps[12] = pi + 3; ps[13] = pi + 4; ps[14] = pi + 5; ps[15] = pi + 6; ps[8] = pi + 2; ps[9] = pi + 13; ps[10] = pi + 14; ps[11] = pi + 7; ps[4] = pi + 1; ps[5] = pi + 12; ps[6] = pi + 15; ps[7] = pi + 8; ps[0] = pi; ps[1] = pi + 11; ps[2] = pi + 10; ps[3] = pi + 9; cs[2] = ci + 1; cs[3] = ci + 2; cs[0] = ci; cs[1] = ci + 3; break; case 1: tmp1 = ps[12]; tmp2 = ps[13]; tmp3 = ps[14]; tmp4 = ps[15]; ps[12] = tmp4; ps[13] = pi + 0; ps[14] = pi + 1; ps[15] = pi + 2; ps[8] = tmp3; ps[9] = pi + 9; ps[10] = pi + 10; ps[11] = pi + 3; ps[4] = tmp2; ps[5] = pi + 8; ps[6] = pi + 11; ps[7] = pi + 4; ps[0] = tmp1; ps[1] = pi + 7; ps[2] = pi + 6; ps[3] = pi + 5; tmp1 = cs[2]; tmp2 = cs[3]; cs[2] = tmp2; cs[3] = ci; cs[0] = tmp1; cs[1] = ci + 1; break; case 2: tmp1 = ps[15]; tmp2 = ps[11]; ps[12] = ps[3]; ps[13] = pi + 0; ps[14] = pi + 1; ps[15] = pi + 2; ps[8] = ps[7]; ps[9] = pi + 9; ps[10] = pi + 10; ps[11] = pi + 3; ps[4] = tmp2; ps[5] = pi + 8; ps[6] = pi + 11; ps[7] = pi + 4; ps[0] = tmp1; ps[1] = pi + 7; ps[2] = pi + 6; ps[3] = pi + 5; tmp1 = cs[3]; cs[2] = cs[1]; cs[3] = ci; cs[0] = tmp1; cs[1] = ci + 1; break; case 3: ps[12] = ps[0]; ps[13] = pi + 0; ps[14] = pi + 1; ps[15] = pi + 2; ps[8] = ps[1]; ps[9] = pi + 9; ps[10] = pi + 10; ps[11] = pi + 3; ps[4] = ps[2]; ps[5] = pi + 8; ps[6] = pi + 11; ps[7] = pi + 4; ps[0] = ps[3]; ps[1] = pi + 7; ps[2] = pi + 6; ps[3] = pi + 5; cs[2] = cs[0]; cs[3] = ci; cs[0] = cs[1]; cs[1] = ci + 1; break; } this.figures.push({ type: &quot;patch&quot;, coords: new Int32Array(ps), colors: new Int32Array(cs) }); } } _buildFigureFromPatch(index) { const figure = this.figures[index]; (0, _util.assert)(figure.type === &quot;patch&quot;, &quot;Unexpected patch mesh figure&quot;); const coords = this.coords, colors = this.colors; const pi = figure.coords; const ci = figure.colors; const figureMinX = Math.min(coords[pi[0]][0], coords[pi[3]][0], coords[pi[12]][0], coords[pi[15]][0]); const figureMinY = Math.min(coords[pi[0]][1], coords[pi[3]][1], coords[pi[12]][1], coords[pi[15]][1]); const figureMaxX = Math.max(coords[pi[0]][0], coords[pi[3]][0], coords[pi[12]][0], coords[pi[15]][0]); const figureMaxY = Math.max(coords[pi[0]][1], coords[pi[3]][1], coords[pi[12]][1], coords[pi[15]][1]); let splitXBy = Math.ceil((figureMaxX - figureMinX) * MeshShading.TRIANGLE_DENSITY / (this.bounds[2] - this.bounds[0])); splitXBy = Math.max(MeshShading.MIN_SPLIT_PATCH_CHUNKS_AMOUNT, Math.min(MeshShading.MAX_SPLIT_PATCH_CHUNKS_AMOUNT, splitXBy)); let splitYBy = Math.ceil((figureMaxY - figureMinY) * MeshShading.TRIANGLE_DENSITY / (this.bounds[3] - this.bounds[1])); splitYBy = Math.max(MeshShading.MIN_SPLIT_PATCH_CHUNKS_AMOUNT, Math.min(MeshShading.MAX_SPLIT_PATCH_CHUNKS_AMOUNT, splitYBy)); const verticesPerRow = splitXBy + 1; const figureCoords = new Int32Array((splitYBy + 1) * verticesPerRow); const figureColors = new Int32Array((splitYBy + 1) * verticesPerRow); let k = 0; const cl = new Uint8Array(3), cr = new Uint8Array(3); const c0 = colors[ci[0]], c1 = colors[ci[1]], c2 = colors[ci[2]], c3 = colors[ci[3]]; const bRow = getB(splitYBy), bCol = getB(splitXBy); for (let row = 0; row &lt;= splitYBy; row++) { cl[0] = (c0[0] * (splitYBy - row) + c2[0] * row) / splitYBy | 0; cl[1] = (c0[1] * (splitYBy - row) + c2[1] * row) / splitYBy | 0; cl[2] = (c0[2] * (splitYBy - row) + c2[2] * row) / splitYBy | 0; cr[0] = (c1[0] * (splitYBy - row) + c3[0] * row) / splitYBy | 0; cr[1] = (c1[1] * (splitYBy - row) + c3[1] * row) / splitYBy | 0; cr[2] = (c1[2] * (splitYBy - row) + c3[2] * row) / splitYBy | 0; for (let col = 0; col &lt;= splitXBy; col++, k++) { if ((row === 0 || row === splitYBy) &amp;&amp; (col === 0 || col === splitXBy)) { continue; } let x = 0, y = 0; let q = 0; for (let i = 0; i &lt;= 3; i++) { for (let j = 0; j &lt;= 3; j++, q++) { const m = bRow[row][i] * bCol[col][j]; x += coords[pi[q]][0] * m; y += coords[pi[q]][1] * m; } } figureCoords[k] = coords.length; coords.push([x, y]); figureColors[k] = colors.length; const newColor = new Uint8Array(3); newColor[0] = (cl[0] * (splitXBy - col) + cr[0] * col) / splitXBy | 0; newColor[1] = (cl[1] * (splitXBy - col) + cr[1] * col) / splitXBy | 0; newColor[2] = (cl[2] * (splitXBy - col) + cr[2] * col) / splitXBy | 0; colors.push(newColor); } } figureCoords[0] = pi[0]; figureColors[0] = ci[0]; figureCoords[splitXBy] = pi[3]; figureColors[splitXBy] = ci[1]; figureCoords[verticesPerRow * splitYBy] = pi[12]; figureColors[verticesPerRow * splitYBy] = ci[2]; figureCoords[verticesPerRow * splitYBy + splitXBy] = pi[15]; figureColors[verticesPerRow * splitYBy + splitXBy] = ci[3]; this.figures[index] = { type: &quot;lattice&quot;, coords: figureCoords, colors: figureColors, verticesPerRow }; } _updateBounds() { let minX = this.coords[0][0], minY = this.coords[0][1], maxX = minX, maxY = minY; for (let i = 1, ii = this.coords.length; i &lt; ii; i++) { const x = this.coords[i][0], y = this.coords[i][1]; minX = minX &gt; x ? x : minX; minY = minY &gt; y ? y : minY; maxX = maxX &lt; x ? x : maxX; maxY = maxY &lt; y ? y : maxY; } this.bounds = [minX, minY, maxX, maxY]; } _packData() { let i, ii, j, jj; const coords = this.coords; const coordsPacked = new Float32Array(coords.length * 2); for (i = 0, j = 0, ii = coords.length; i &lt; ii; i++) { const xy = coords[i]; coordsPacked[j++] = xy[0]; coordsPacked[j++] = xy[1]; } this.coords = coordsPacked; const colors = this.colors; const colorsPacked = new Uint8Array(colors.length * 3); for (i = 0, j = 0, ii = colors.length; i &lt; ii; i++) { const c = colors[i]; colorsPacked[j++] = c[0]; colorsPacked[j++] = c[1]; colorsPacked[j++] = c[2]; } this.colors = colorsPacked; const figures = this.figures; for (i = 0, ii = figures.length; i &lt; ii; i++) { const figure = figures[i], ps = figure.coords, cs = figure.colors; for (j = 0, jj = ps.length; j &lt; jj; j++) { ps[j] *= 2; cs[j] *= 3; } } } getIR() { return [&quot;Mesh&quot;, this.shadingType, this.coords, this.colors, this.figures, this.bounds, this.bbox, this.background]; } } class DummyShading extends BaseShading { getIR() { return [&quot;Dummy&quot;]; } } function getTilingPatternIR(operatorList, dict, color) { const matrix = dict.getArray(&quot;Matrix&quot;); const bbox = _util.Util.normalizeRect(dict.getArray(&quot;BBox&quot;)); const xstep = dict.get(&quot;XStep&quot;); const ystep = dict.get(&quot;YStep&quot;); const paintType = dict.get(&quot;PaintType&quot;); const tilingType = dict.get(&quot;TilingType&quot;); if (bbox[2] - bbox[0] === 0 || bbox[3] - bbox[1] === 0) { throw new _util.FormatError(`Invalid getTilingPatternIR /BBox array: [${bbox}].`); } return [&quot;TilingPattern&quot;, color, operatorList, matrix, bbox, xstep, ystep, paintType, tilingType]; } /***/ }), /* 49 */ /***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) =&gt; { Object.defineProperty(exports, &quot;__esModule&quot;, ({ value: true })); exports.getXfaFontDict = getXfaFontDict; exports.getXfaFontName = getXfaFontName; var _calibri_factors = __w_pdfjs_require__(50); var _primitives = __w_pdfjs_require__(3); var _helvetica_factors = __w_pdfjs_require__(51); var _liberationsans_widths = __w_pdfjs_require__(52); var _myriadpro_factors = __w_pdfjs_require__(53); var _segoeui_factors = __w_pdfjs_require__(54); var _core_utils = __w_pdfjs_require__(4); var _fonts_utils = __w_pdfjs_require__(36); const getXFAFontMap = (0, _core_utils.getLookupTableFactory)(function (t) { t[&quot;MyriadPro-Regular&quot;] = t[&quot;PdfJS-Fallback-Regular&quot;] = { name: &quot;LiberationSans-Regular&quot;, factors: _myriadpro_factors.MyriadProRegularFactors, baseWidths: _liberationsans_widths.LiberationSansRegularWidths, baseMapping: _liberationsans_widths.LiberationSansRegularMapping, metrics: _myriadpro_factors.MyriadProRegularMetrics }; t[&quot;MyriadPro-Bold&quot;] = t[&quot;PdfJS-Fallback-Bold&quot;] = { name: &quot;LiberationSans-Bold&quot;, factors: _myriadpro_factors.MyriadProBoldFactors, baseWidths: _liberationsans_widths.LiberationSansBoldWidths, baseMapping: _liberationsans_widths.LiberationSansBoldMapping, metrics: _myriadpro_factors.MyriadProBoldMetrics }; t[&quot;MyriadPro-It&quot;] = t[&quot;MyriadPro-Italic&quot;] = t[&quot;PdfJS-Fallback-Italic&quot;] = { name: &quot;LiberationSans-Italic&quot;, factors: _myriadpro_factors.MyriadProItalicFactors, baseWidths: _liberationsans_widths.LiberationSansItalicWidths, baseMapping: _liberationsans_widths.LiberationSansItalicMapping, metrics: _myriadpro_factors.MyriadProItalicMetrics }; t[&quot;MyriadPro-BoldIt&quot;] = t[&quot;MyriadPro-BoldItalic&quot;] = t[&quot;PdfJS-Fallback-BoldItalic&quot;] = { name: &quot;LiberationSans-BoldItalic&quot;, factors: _myriadpro_factors.MyriadProBoldItalicFactors, baseWidths: _liberationsans_widths.LiberationSansBoldItalicWidths, baseMapping: _liberationsans_widths.LiberationSansBoldItalicMapping, metrics: _myriadpro_factors.MyriadProBoldItalicMetrics }; t.ArialMT = t.Arial = t[&quot;Arial-Regular&quot;] = { name: &quot;LiberationSans-Regular&quot;, baseWidths: _liberationsans_widths.LiberationSansRegularWidths, baseMapping: _liberationsans_widths.LiberationSansRegularMapping }; t[&quot;Arial-BoldMT&quot;] = t[&quot;Arial-Bold&quot;] = { name: &quot;LiberationSans-Bold&quot;, baseWidths: _liberationsans_widths.LiberationSansBoldWidths, baseMapping: _liberationsans_widths.LiberationSansBoldMapping }; t[&quot;Arial-ItalicMT&quot;] = t[&quot;Arial-Italic&quot;] = { name: &quot;LiberationSans-Italic&quot;, baseWidths: _liberationsans_widths.LiberationSansItalicWidths, baseMapping: _liberationsans_widths.LiberationSansItalicMapping }; t[&quot;Arial-BoldItalicMT&quot;] = t[&quot;Arial-BoldItalic&quot;] = { name: &quot;LiberationSans-BoldItalic&quot;, baseWidths: _liberationsans_widths.LiberationSansBoldItalicWidths, baseMapping: _liberationsans_widths.LiberationSansBoldItalicMapping }; t[&quot;Calibri-Regular&quot;] = { name: &quot;LiberationSans-Regular&quot;, factors: _calibri_factors.CalibriRegularFactors, baseWidths: _liberationsans_widths.LiberationSansRegularWidths, baseMapping: _liberationsans_widths.LiberationSansRegularMapping, metrics: _calibri_factors.CalibriRegularMetrics }; t[&quot;Calibri-Bold&quot;] = { name: &quot;LiberationSans-Bold&quot;, factors: _calibri_factors.CalibriBoldFactors, baseWidths: _liberationsans_widths.LiberationSansBoldWidths, baseMapping: _liberationsans_widths.LiberationSansBoldMapping, metrics: _calibri_factors.CalibriBoldMetrics }; t[&quot;Calibri-Italic&quot;] = { name: &quot;LiberationSans-Italic&quot;, factors: _calibri_factors.CalibriItalicFactors, baseWidths: _liberationsans_widths.LiberationSansItalicWidths, baseMapping: _liberationsans_widths.LiberationSansItalicMapping, metrics: _calibri_factors.CalibriItalicMetrics }; t[&quot;Calibri-BoldItalic&quot;] = { name: &quot;LiberationSans-BoldItalic&quot;, factors: _calibri_factors.CalibriBoldItalicFactors, baseWidths: _liberationsans_widths.LiberationSansBoldItalicWidths, baseMapping: _liberationsans_widths.LiberationSansBoldItalicMapping, metrics: _calibri_factors.CalibriBoldItalicMetrics }; t[&quot;Segoeui-Regular&quot;] = { name: &quot;LiberationSans-Regular&quot;, factors: _segoeui_factors.SegoeuiRegularFactors, baseWidths: _liberationsans_widths.LiberationSansRegularWidths, baseMapping: _liberationsans_widths.LiberationSansRegularMapping, metrics: _segoeui_factors.SegoeuiRegularMetrics }; t[&quot;Segoeui-Bold&quot;] = { name: &quot;LiberationSans-Bold&quot;, factors: _segoeui_factors.SegoeuiBoldFactors, baseWidths: _liberationsans_widths.LiberationSansBoldWidths, baseMapping: _liberationsans_widths.LiberationSansBoldMapping, metrics: _segoeui_factors.SegoeuiBoldMetrics }; t[&quot;Segoeui-Italic&quot;] = { name: &quot;LiberationSans-Italic&quot;, factors: _segoeui_factors.SegoeuiItalicFactors, baseWidths: _liberationsans_widths.LiberationSansItalicWidths, baseMapping: _liberationsans_widths.LiberationSansItalicMapping, metrics: _segoeui_factors.SegoeuiItalicMetrics }; t[&quot;Segoeui-BoldItalic&quot;] = { name: &quot;LiberationSans-BoldItalic&quot;, factors: _segoeui_factors.SegoeuiBoldItalicFactors, baseWidths: _liberationsans_widths.LiberationSansBoldItalicWidths, baseMapping: _liberationsans_widths.LiberationSansBoldItalicMapping, metrics: _segoeui_factors.SegoeuiBoldItalicMetrics }; t[&quot;Helvetica-Regular&quot;] = t.Helvetica = { name: &quot;LiberationSans-Regular&quot;, factors: _helvetica_factors.HelveticaRegularFactors, baseWidths: _liberationsans_widths.LiberationSansRegularWidths, baseMapping: _liberationsans_widths.LiberationSansRegularMapping, metrics: _helvetica_factors.HelveticaRegularMetrics }; t[&quot;Helvetica-Bold&quot;] = { name: &quot;LiberationSans-Bold&quot;, factors: _helvetica_factors.HelveticaBoldFactors, baseWidths: _liberationsans_widths.LiberationSansBoldWidths, baseMapping: _liberationsans_widths.LiberationSansBoldMapping, metrics: _helvetica_factors.HelveticaBoldMetrics }; t[&quot;Helvetica-Italic&quot;] = { name: &quot;LiberationSans-Italic&quot;, factors: _helvetica_factors.HelveticaItalicFactors, baseWidths: _liberationsans_widths.LiberationSansItalicWidths, baseMapping: _liberationsans_widths.LiberationSansItalicMapping, metrics: _helvetica_factors.HelveticaItalicMetrics }; t[&quot;Helvetica-BoldItalic&quot;] = { name: &quot;LiberationSans-BoldItalic&quot;, factors: _helvetica_factors.HelveticaBoldItalicFactors, baseWidths: _liberationsans_widths.LiberationSansBoldItalicWidths, baseMapping: _liberationsans_widths.LiberationSansBoldItalicMapping, metrics: _helvetica_factors.HelveticaBoldItalicMetrics }; }); function getXfaFontName(name) { const fontName = (0, _fonts_utils.normalizeFontName)(name); const fontMap = getXFAFontMap(); return fontMap[fontName]; } function getXfaFontWidths(name) { const info = getXfaFontName(name); if (!info) { return null; } const { baseWidths, baseMapping, factors } = info; let rescaledBaseWidths; if (!factors) { rescaledBaseWidths = baseWidths; } else { rescaledBaseWidths = baseWidths.map((w, i) =&gt; w * factors[i]); } let currentCode = -2; let currentArray; const newWidths = []; for (const [unicode, glyphIndex] of baseMapping.map((charUnicode, index) =&gt; [charUnicode, index]).sort(([unicode1], [unicode2]) =&gt; unicode1 - unicode2)) { if (unicode === -1) { continue; } if (unicode === currentCode + 1) { currentArray.push(rescaledBaseWidths[glyphIndex]); currentCode += 1; } else { currentCode = unicode; currentArray = [rescaledBaseWidths[glyphIndex]]; newWidths.push(unicode, currentArray); } } return newWidths; } function getXfaFontDict(name) { const widths = getXfaFontWidths(name); const dict = new _primitives.Dict(null); dict.set(&quot;BaseFont&quot;, _primitives.Name.get(name)); dict.set(&quot;Type&quot;, _primitives.Name.get(&quot;Font&quot;)); dict.set(&quot;Subtype&quot;, _primitives.Name.get(&quot;CIDFontType2&quot;)); dict.set(&quot;Encoding&quot;, _primitives.Name.get(&quot;Identity-H&quot;)); dict.set(&quot;CIDToGIDMap&quot;, _primitives.Name.get(&quot;Identity&quot;)); dict.set(&quot;W&quot;, widths); dict.set(&quot;FirstChar&quot;, widths[0]); dict.set(&quot;LastChar&quot;, widths.at(-2) + widths.at(-1).length - 1); const descriptor = new _primitives.Dict(null); dict.set(&quot;FontDescriptor&quot;, descriptor); const systemInfo = new _primitives.Dict(null); systemInfo.set(&quot;Ordering&quot;, &quot;Identity&quot;); systemInfo.set(&quot;Registry&quot;, &quot;Adobe&quot;); systemInfo.set(&quot;Supplement&quot;, 0); dict.set(&quot;CIDSystemInfo&quot;, systemInfo); return dict; } /***/ }), /* 50 */ /***/ ((__unused_webpack_module, exports) =&gt; { Object.defineProperty(exports, &quot;__esModule&quot;, ({ value: true })); exports.CalibriRegularMetrics = exports.CalibriRegularFactors = exports.CalibriItalicMetrics = exports.CalibriItalicFactors = exports.CalibriBoldMetrics = exports.CalibriBoldItalicMetrics = exports.CalibriBoldItalicFactors = exports.CalibriBoldFactors = void 0; const CalibriBoldFactors = [1.3877, 1, 1, 1, 0.97801, 0.92482, 0.89552, 0.91133, 0.81988, 0.97566, 0.98152, 0.93548, 0.93548, 1.2798, 0.85284, 0.92794, 1, 0.96134, 1.54657, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.82845, 0.82845, 0.85284, 0.85284, 0.85284, 0.75859, 0.92138, 0.83908, 0.7762, 0.73293, 0.87289, 0.73133, 0.7514, 0.81921, 0.87356, 0.95958, 0.59526, 0.75727, 0.69225, 1.04924, 0.9121, 0.86943, 0.79795, 0.88198, 0.77958, 0.70864, 0.81055, 0.90399, 0.88653, 0.96017, 0.82577, 0.77892, 0.78257, 0.97507, 1.54657, 0.97507, 0.85284, 0.89552, 0.90176, 0.88762, 0.8785, 0.75241, 0.8785, 0.90518, 0.95015, 0.77618, 0.8785, 0.88401, 0.91916, 0.86304, 0.88401, 0.91488, 0.8785, 0.8801, 0.8785, 0.8785, 0.91343, 0.7173, 1.04106, 0.8785, 0.85075, 0.95794, 0.82616, 0.85162, 0.79492, 0.88331, 1.69808, 0.88331, 0.85284, 0.97801, 0.89552, 0.91133, 0.89552, 0.91133, 1.7801, 0.89552, 1.24487, 1.13254, 1.12401, 0.96839, 0.85284, 0.68787, 0.70645, 0.85592, 0.90747, 1.01466, 1.0088, 0.90323, 1, 1.07463, 1, 0.91056, 0.75806, 1.19118, 0.96839, 0.78864, 0.82845, 0.84133, 0.75859, 0.83908, 0.83908, 0.83908, 0.83908, 0.83908, 0.83908, 0.77539, 0.73293, 0.73133, 0.73133, 0.73133, 0.73133, 0.95958, 0.95958, 0.95958, 0.95958, 0.88506, 0.9121, 0.86943, 0.86943, 0.86943, 0.86943, 0.86943, 0.85284, 0.87508, 0.90399, 0.90399, 0.90399, 0.90399, 0.77892, 0.79795, 0.90807, 0.88762, 0.88762, 0.88762, 0.88762, 0.88762, 0.88762, 0.8715, 0.75241, 0.90518, 0.90518, 0.90518, 0.90518, 0.88401, 0.88401, 0.88401, 0.88401, 0.8785, 0.8785, 0.8801, 0.8801, 0.8801, 0.8801, 0.8801, 0.90747, 0.89049, 0.8785, 0.8785, 0.8785, 0.8785, 0.85162, 0.8785, 0.85162, 0.83908, 0.88762, 0.83908, 0.88762, 0.83908, 0.88762, 0.73293, 0.75241, 0.73293, 0.75241, 0.73293, 0.75241, 0.73293, 0.75241, 0.87289, 0.83016, 0.88506, 0.93125, 0.73133, 0.90518, 0.73133, 0.90518, 0.73133, 0.90518, 0.73133, 0.90518, 0.73133, 0.90518, 0.81921, 0.77618, 0.81921, 0.77618, 0.81921, 0.77618, 1, 1, 0.87356, 0.8785, 0.91075, 0.89608, 0.95958, 0.88401, 0.95958, 0.88401, 0.95958, 0.88401, 0.95958, 0.88401, 0.95958, 0.88401, 0.76229, 0.90167, 0.59526, 0.91916, 1, 1, 0.86304, 0.69225, 0.88401, 1, 1, 0.70424, 0.79468, 0.91926, 0.88175, 0.70823, 0.94903, 0.9121, 0.8785, 1, 1, 0.9121, 0.8785, 0.87802, 0.88656, 0.8785, 0.86943, 0.8801, 0.86943, 0.8801, 0.86943, 0.8801, 0.87402, 0.89291, 0.77958, 0.91343, 1, 1, 0.77958, 0.91343, 0.70864, 0.7173, 0.70864, 0.7173, 0.70864, 0.7173, 0.70864, 0.7173, 1, 1, 0.81055, 0.75841, 0.81055, 1.06452, 0.90399, 0.8785, 0.90399, 0.8785, 0.90399, 0.8785, 0.90399, 0.8785, 0.90399, 0.8785, 0.90399, 0.8785, 0.96017, 0.95794, 0.77892, 0.85162, 0.77892, 0.78257, 0.79492, 0.78257, 0.79492, 0.78257, 0.79492, 0.9297, 0.56892, 0.83908, 0.88762, 0.77539, 0.8715, 0.87508, 0.89049, 1, 1, 0.81055, 1.04106, 1.20528, 1.20528, 1, 1.15543, 0.70674, 0.98387, 0.94721, 1.33431, 1.45894, 0.95161, 1.06303, 0.83908, 0.80352, 0.57184, 0.6965, 0.56289, 0.82001, 0.56029, 0.81235, 1.02988, 0.83908, 0.7762, 0.68156, 0.80367, 0.73133, 0.78257, 0.87356, 0.86943, 0.95958, 0.75727, 0.89019, 1.04924, 0.9121, 0.7648, 0.86943, 0.87356, 0.79795, 0.78275, 0.81055, 0.77892, 0.9762, 0.82577, 0.99819, 0.84896, 0.95958, 0.77892, 0.96108, 1.01407, 0.89049, 1.02988, 0.94211, 0.96108, 0.8936, 0.84021, 0.87842, 0.96399, 0.79109, 0.89049, 1.00813, 1.02988, 0.86077, 0.87445, 0.92099, 0.84723, 0.86513, 0.8801, 0.75638, 0.85714, 0.78216, 0.79586, 0.87965, 0.94211, 0.97747, 0.78287, 0.97926, 0.84971, 1.02988, 0.94211, 0.8801, 0.94211, 0.84971, 0.73133, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.90264, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.90518, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.90548, 1, 1, 1, 1, 1, 1, 0.96017, 0.95794, 0.96017, 0.95794, 0.96017, 0.95794, 0.77892, 0.85162, 1, 1, 0.89552, 0.90527, 1, 0.90363, 0.92794, 0.92794, 0.92794, 0.92794, 0.87012, 0.87012, 0.87012, 0.89552, 0.89552, 1.42259, 0.71143, 1.06152, 1, 1, 1.03372, 1.03372, 0.97171, 1.4956, 2.2807, 0.93835, 0.83406, 0.91133, 0.84107, 0.91133, 1, 1, 1, 0.72021, 1, 1.23108, 0.83489, 0.88525, 0.88525, 0.81499, 0.90527, 1.81055, 0.90527, 1.81055, 1.31006, 1.53711, 0.94434, 1.08696, 1, 0.95018, 0.77192, 0.85284, 0.90747, 1.17534, 0.69825, 0.9716, 1.37077, 0.90747, 0.90747, 0.85356, 0.90747, 0.90747, 1.44947, 0.85284, 0.8941, 0.8941, 0.70572, 0.8, 0.70572, 0.70572, 0.70572, 0.70572, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.99862, 0.99862, 1, 1, 1, 1, 1, 1.08004, 0.91027, 1, 1, 1, 0.99862, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.90727, 0.90727, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]; exports.CalibriBoldFactors = CalibriBoldFactors; const CalibriBoldMetrics = { lineHeight: 1.2207, lineGap: 0.2207 }; exports.CalibriBoldMetrics = CalibriBoldMetrics; const CalibriBoldItalicFactors = [1.3877, 1, 1, 1, 0.97801, 0.92482, 0.89552, 0.91133, 0.81988, 0.97566, 0.98152, 0.93548, 0.93548, 1.2798, 0.85284, 0.92794, 1, 0.96134, 1.56239, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.82845, 0.82845, 0.85284, 0.85284, 0.85284, 0.75859, 0.92138, 0.83908, 0.7762, 0.71805, 0.87289, 0.73133, 0.7514, 0.81921, 0.87356, 0.95958, 0.59526, 0.75727, 0.69225, 1.04924, 0.90872, 0.85938, 0.79795, 0.87068, 0.77958, 0.69766, 0.81055, 0.90399, 0.88653, 0.96068, 0.82577, 0.77892, 0.78257, 0.97507, 1.529, 0.97507, 0.85284, 0.89552, 0.90176, 0.94908, 0.86411, 0.74012, 0.86411, 0.88323, 0.95015, 0.86411, 0.86331, 0.88401, 0.91916, 0.86304, 0.88401, 0.9039, 0.86331, 0.86331, 0.86411, 0.86411, 0.90464, 0.70852, 1.04106, 0.86331, 0.84372, 0.95794, 0.82616, 0.84548, 0.79492, 0.88331, 1.69808, 0.88331, 0.85284, 0.97801, 0.89552, 0.91133, 0.89552, 0.91133, 1.7801, 0.89552, 1.24487, 1.13254, 1.19129, 0.96839, 0.85284, 0.68787, 0.70645, 0.85592, 0.90747, 1.01466, 1.0088, 0.90323, 1, 1.07463, 1, 0.91056, 0.75806, 1.19118, 0.96839, 0.78864, 0.82845, 0.84133, 0.75859, 0.83908, 0.83908, 0.83908, 0.83908, 0.83908, 0.83908, 0.77539, 0.71805, 0.73133, 0.73133, 0.73133, 0.73133, 0.95958, 0.95958, 0.95958, 0.95958, 0.88506, 0.90872, 0.85938, 0.85938, 0.85938, 0.85938, 0.85938, 0.85284, 0.87068, 0.90399, 0.90399, 0.90399, 0.90399, 0.77892, 0.79795, 0.90807, 0.94908, 0.94908, 0.94908, 0.94908, 0.94908, 0.94908, 0.85887, 0.74012, 0.88323, 0.88323, 0.88323, 0.88323, 0.88401, 0.88401, 0.88401, 0.88401, 0.8785, 0.86331, 0.86331, 0.86331, 0.86331, 0.86331, 0.86331, 0.90747, 0.89049, 0.86331, 0.86331, 0.86331, 0.86331, 0.84548, 0.86411, 0.84548, 0.83908, 0.94908, 0.83908, 0.94908, 0.83908, 0.94908, 0.71805, 0.74012, 0.71805, 0.74012, 0.71805, 0.74012, 0.71805, 0.74012, 0.87289, 0.79538, 0.88506, 0.92726, 0.73133, 0.88323, 0.73133, 0.88323, 0.73133, 0.88323, 0.73133, 0.88323, 0.73133, 0.88323, 0.81921, 0.86411, 0.81921, 0.86411, 0.81921, 0.86411, 1, 1, 0.87356, 0.86331, 0.91075, 0.8777, 0.95958, 0.88401, 0.95958, 0.88401, 0.95958, 0.88401, 0.95958, 0.88401, 0.95958, 0.88401, 0.76467, 0.90167, 0.59526, 0.91916, 1, 1, 0.86304, 0.69225, 0.88401, 1, 1, 0.70424, 0.77312, 0.91926, 0.88175, 0.70823, 0.94903, 0.90872, 0.86331, 1, 1, 0.90872, 0.86331, 0.86906, 0.88116, 0.86331, 0.85938, 0.86331, 0.85938, 0.86331, 0.85938, 0.86331, 0.87402, 0.86549, 0.77958, 0.90464, 1, 1, 0.77958, 0.90464, 0.69766, 0.70852, 0.69766, 0.70852, 0.69766, 0.70852, 0.69766, 0.70852, 1, 1, 0.81055, 0.75841, 0.81055, 1.06452, 0.90399, 0.86331, 0.90399, 0.86331, 0.90399, 0.86331, 0.90399, 0.86331, 0.90399, 0.86331, 0.90399, 0.86331, 0.96068, 0.95794, 0.77892, 0.84548, 0.77892, 0.78257, 0.79492, 0.78257, 0.79492, 0.78257, 0.79492, 0.9297, 0.56892, 0.83908, 0.94908, 0.77539, 0.85887, 0.87068, 0.89049, 1, 1, 0.81055, 1.04106, 1.20528, 1.20528, 1, 1.15543, 0.70088, 0.98387, 0.94721, 1.33431, 1.45894, 0.95161, 1.48387, 0.83908, 0.80352, 0.57118, 0.6965, 0.56347, 0.79179, 0.55853, 0.80346, 1.02988, 0.83908, 0.7762, 0.67174, 0.86036, 0.73133, 0.78257, 0.87356, 0.86441, 0.95958, 0.75727, 0.89019, 1.04924, 0.90872, 0.74889, 0.85938, 0.87891, 0.79795, 0.7957, 0.81055, 0.77892, 0.97447, 0.82577, 0.97466, 0.87179, 0.95958, 0.77892, 0.94252, 0.95612, 0.8753, 1.02988, 0.92733, 0.94252, 0.87411, 0.84021, 0.8728, 0.95612, 0.74081, 0.8753, 1.02189, 1.02988, 0.84814, 0.87445, 0.91822, 0.84723, 0.85668, 0.86331, 0.81344, 0.87581, 0.76422, 0.82046, 0.96057, 0.92733, 0.99375, 0.78022, 0.95452, 0.86015, 1.02988, 0.92733, 0.86331, 0.92733, 0.86015, 0.73133, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.90631, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.88323, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.85174, 1, 1, 1, 1, 1, 1, 0.96068, 0.95794, 0.96068, 0.95794, 0.96068, 0.95794, 0.77892, 0.84548, 1, 1, 0.89552, 0.90527, 1, 0.90363, 0.92794, 0.92794, 0.92794, 0.89807, 0.87012, 0.87012, 0.87012, 0.89552, 0.89552, 1.42259, 0.71094, 1.06152, 1, 1, 1.03372, 1.03372, 0.97171, 1.4956, 2.2807, 0.92972, 0.83406, 0.91133, 0.83326, 0.91133, 1, 1, 1, 0.72021, 1, 1.23108, 0.83489, 0.88525, 0.88525, 0.81499, 0.90616, 1.81055, 0.90527, 1.81055, 1.3107, 1.53711, 0.94434, 1.08696, 1, 0.95018, 0.77192, 0.85284, 0.90747, 1.17534, 0.69825, 0.9716, 1.37077, 0.90747, 0.90747, 0.85356, 0.90747, 0.90747, 1.44947, 0.85284, 0.8941, 0.8941, 0.70572, 0.8, 0.70572, 0.70572, 0.70572, 0.70572, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.99862, 0.99862, 1, 1, 1, 1, 1, 1.08004, 0.91027, 1, 1, 1, 0.99862, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.90727, 0.90727, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]; exports.CalibriBoldItalicFactors = CalibriBoldItalicFactors; const CalibriBoldItalicMetrics = { lineHeight: 1.2207, lineGap: 0.2207 }; exports.CalibriBoldItalicMetrics = CalibriBoldItalicMetrics; const CalibriItalicFactors = [1.3877, 1, 1, 1, 1.17223, 1.1293, 0.89552, 0.91133, 0.80395, 1.02269, 1.15601, 0.91056, 0.91056, 1.2798, 0.85284, 0.89807, 1, 0.90861, 1.39543, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.96309, 0.96309, 0.85284, 0.85284, 0.85284, 0.83319, 0.88071, 0.8675, 0.81552, 0.72346, 0.85193, 0.73206, 0.7522, 0.81105, 0.86275, 0.90685, 0.6377, 0.77892, 0.75593, 1.02638, 0.89249, 0.84118, 0.77452, 0.85374, 0.75186, 0.67789, 0.79776, 0.88844, 0.85066, 0.94309, 0.77818, 0.7306, 0.76659, 1.10369, 1.38313, 1.10369, 1.06139, 0.89552, 0.8739, 0.9245, 0.9245, 0.83203, 0.9245, 0.85865, 1.09842, 0.9245, 0.9245, 1.03297, 1.07692, 0.90918, 1.03297, 0.94959, 0.9245, 0.92274, 0.9245, 0.9245, 1.02933, 0.77832, 1.20562, 0.9245, 0.8916, 0.98986, 0.86621, 0.89453, 0.79004, 0.94152, 1.77256, 0.94152, 0.85284, 0.97801, 0.89552, 0.91133, 0.89552, 0.91133, 1.91729, 0.89552, 1.17889, 1.13254, 1.16359, 0.92098, 0.85284, 0.68787, 0.71353, 0.84737, 0.90747, 1.0088, 1.0044, 0.87683, 1, 1.09091, 1, 0.92229, 0.739, 1.15642, 0.92098, 0.76288, 0.80504, 0.80972, 0.75859, 0.8675, 0.8675, 0.8675, 0.8675, 0.8675, 0.8675, 0.76318, 0.72346, 0.73206, 0.73206, 0.73206, 0.73206, 0.90685, 0.90685, 0.90685, 0.90685, 0.86477, 0.89249, 0.84118, 0.84118, 0.84118, 0.84118, 0.84118, 0.85284, 0.84557, 0.88844, 0.88844, 0.88844, 0.88844, 0.7306, 0.77452, 0.86331, 0.9245, 0.9245, 0.9245, 0.9245, 0.9245, 0.9245, 0.84843, 0.83203, 0.85865, 0.85865, 0.85865, 0.85865, 0.82601, 0.82601, 0.82601, 0.82601, 0.94469, 0.9245, 0.92274, 0.92274, 0.92274, 0.92274, 0.92274, 0.90747, 0.86651, 0.9245, 0.9245, 0.9245, 0.9245, 0.89453, 0.9245, 0.89453, 0.8675, 0.9245, 0.8675, 0.9245, 0.8675, 0.9245, 0.72346, 0.83203, 0.72346, 0.83203, 0.72346, 0.83203, 0.72346, 0.83203, 0.85193, 0.8875, 0.86477, 0.99034, 0.73206, 0.85865, 0.73206, 0.85865, 0.73206, 0.85865, 0.73206, 0.85865, 0.73206, 0.85865, 0.81105, 0.9245, 0.81105, 0.9245, 0.81105, 0.9245, 1, 1, 0.86275, 0.9245, 0.90872, 0.93591, 0.90685, 0.82601, 0.90685, 0.82601, 0.90685, 0.82601, 0.90685, 1.03297, 0.90685, 0.82601, 0.77896, 1.05611, 0.6377, 1.07692, 1, 1, 0.90918, 0.75593, 1.03297, 1, 1, 0.76032, 0.9375, 0.98156, 0.93407, 0.77261, 1.11429, 0.89249, 0.9245, 1, 1, 0.89249, 0.9245, 0.92534, 0.86698, 0.9245, 0.84118, 0.92274, 0.84118, 0.92274, 0.84118, 0.92274, 0.8667, 0.86291, 0.75186, 1.02933, 1, 1, 0.75186, 1.02933, 0.67789, 0.77832, 0.67789, 0.77832, 0.67789, 0.77832, 0.67789, 0.77832, 1, 1, 0.79776, 0.97655, 0.79776, 1.23023, 0.88844, 0.9245, 0.88844, 0.9245, 0.88844, 0.9245, 0.88844, 0.9245, 0.88844, 0.9245, 0.88844, 0.9245, 0.94309, 0.98986, 0.7306, 0.89453, 0.7306, 0.76659, 0.79004, 0.76659, 0.79004, 0.76659, 0.79004, 1.09231, 0.54873, 0.8675, 0.9245, 0.76318, 0.84843, 0.84557, 0.86651, 1, 1, 0.79776, 1.20562, 1.18622, 1.18622, 1, 1.1437, 0.67009, 0.96334, 0.93695, 1.35191, 1.40909, 0.95161, 1.48387, 0.8675, 0.90861, 0.6192, 0.7363, 0.64824, 0.82411, 0.56321, 0.85696, 1.23516, 0.8675, 0.81552, 0.7286, 0.84134, 0.73206, 0.76659, 0.86275, 0.84369, 0.90685, 0.77892, 0.85871, 1.02638, 0.89249, 0.75828, 0.84118, 0.85984, 0.77452, 0.76466, 0.79776, 0.7306, 0.90782, 0.77818, 0.903, 0.87291, 0.90685, 0.7306, 0.99058, 1.03667, 0.94635, 1.23516, 0.9849, 0.99058, 0.92393, 0.8916, 0.942, 1.03667, 0.75026, 0.94635, 1.0297, 1.23516, 0.90918, 0.94048, 0.98217, 0.89746, 0.84153, 0.92274, 0.82507, 0.88832, 0.84438, 0.88178, 1.03525, 0.9849, 1.00225, 0.78086, 0.97248, 0.89404, 1.23516, 0.9849, 0.92274, 0.9849, 0.89404, 0.73206, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.89693, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.85865, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.90933, 1, 1, 1, 1, 1, 1, 0.94309, 0.98986, 0.94309, 0.98986, 0.94309, 0.98986, 0.7306, 0.89453, 1, 1, 0.89552, 0.90527, 1, 0.90186, 1.12308, 1.12308, 1.12308, 1.12308, 1.2566, 1.2566, 1.2566, 0.89552, 0.89552, 1.42259, 0.68994, 1.03809, 1, 1, 1.0176, 1.0176, 1.11523, 1.4956, 2.01462, 0.97858, 0.82616, 0.91133, 0.83437, 0.91133, 1, 1, 1, 0.70508, 1, 1.23108, 0.79801, 0.84426, 0.84426, 0.774, 0.90572, 1.81055, 0.90749, 1.81055, 1.28809, 1.55469, 0.94434, 1.07806, 1, 0.97094, 0.7589, 0.85284, 0.90747, 1.19658, 0.69825, 0.97622, 1.33512, 0.90747, 0.90747, 0.85284, 0.90747, 0.90747, 1.44947, 0.85284, 0.8941, 0.8941, 0.70572, 0.8, 0.70572, 0.70572, 0.70572, 0.70572, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.99862, 0.99862, 1, 1, 1, 1, 1, 1.0336, 0.91027, 1, 1, 1, 0.99862, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.05859, 1.05859, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]; exports.CalibriItalicFactors = CalibriItalicFactors; const CalibriItalicMetrics = { lineHeight: 1.2207, lineGap: 0.2207 }; exports.CalibriItalicMetrics = CalibriItalicMetrics; const CalibriRegularFactors = [1.3877, 1, 1, 1, 1.17223, 1.1293, 0.89552, 0.91133, 0.80395, 1.02269, 1.15601, 0.91056, 0.91056, 1.2798, 0.85284, 0.89807, 1, 0.90861, 1.39016, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.96309, 0.96309, 0.85284, 0.85284, 0.85284, 0.83319, 0.88071, 0.8675, 0.81552, 0.73834, 0.85193, 0.73206, 0.7522, 0.81105, 0.86275, 0.90685, 0.6377, 0.77892, 0.75593, 1.02638, 0.89385, 0.85122, 0.77452, 0.86503, 0.75186, 0.68887, 0.79776, 0.88844, 0.85066, 0.94258, 0.77818, 0.7306, 0.76659, 1.10369, 1.39016, 1.10369, 1.06139, 0.89552, 0.8739, 0.86128, 0.94469, 0.8457, 0.94469, 0.89464, 1.09842, 0.84636, 0.94469, 1.03297, 1.07692, 0.90918, 1.03297, 0.95897, 0.94469, 0.9482, 0.94469, 0.94469, 1.04692, 0.78223, 1.20562, 0.94469, 0.90332, 0.98986, 0.86621, 0.90527, 0.79004, 0.94152, 1.77256, 0.94152, 0.85284, 0.97801, 0.89552, 0.91133, 0.89552, 0.91133, 1.91729, 0.89552, 1.17889, 1.13254, 1.08707, 0.92098, 0.85284, 0.68787, 0.71353, 0.84737, 0.90747, 1.0088, 1.0044, 0.87683, 1, 1.09091, 1, 0.92229, 0.739, 1.15642, 0.92098, 0.76288, 0.80504, 0.80972, 0.75859, 0.8675, 0.8675, 0.8675, 0.8675, 0.8675, 0.8675, 0.76318, 0.73834, 0.73206, 0.73206, 0.73206, 0.73206, 0.90685, 0.90685, 0.90685, 0.90685, 0.86477, 0.89385, 0.85122, 0.85122, 0.85122, 0.85122, 0.85122, 0.85284, 0.85311, 0.88844, 0.88844, 0.88844, 0.88844, 0.7306, 0.77452, 0.86331, 0.86128, 0.86128, 0.86128, 0.86128, 0.86128, 0.86128, 0.8693, 0.8457, 0.89464, 0.89464, 0.89464, 0.89464, 0.82601, 0.82601, 0.82601, 0.82601, 0.94469, 0.94469, 0.9482, 0.9482, 0.9482, 0.9482, 0.9482, 0.90747, 0.86651, 0.94469, 0.94469, 0.94469, 0.94469, 0.90527, 0.94469, 0.90527, 0.8675, 0.86128, 0.8675, 0.86128, 0.8675, 0.86128, 0.73834, 0.8457, 0.73834, 0.8457, 0.73834, 0.8457, 0.73834, 0.8457, 0.85193, 0.92454, 0.86477, 0.9921, 0.73206, 0.89464, 0.73206, 0.89464, 0.73206, 0.89464, 0.73206, 0.89464, 0.73206, 0.89464, 0.81105, 0.84636, 0.81105, 0.84636, 0.81105, 0.84636, 1, 1, 0.86275, 0.94469, 0.90872, 0.95786, 0.90685, 0.82601, 0.90685, 0.82601, 0.90685, 0.82601, 0.90685, 1.03297, 0.90685, 0.82601, 0.77741, 1.05611, 0.6377, 1.07692, 1, 1, 0.90918, 0.75593, 1.03297, 1, 1, 0.76032, 0.90452, 0.98156, 1.11842, 0.77261, 1.11429, 0.89385, 0.94469, 1, 1, 0.89385, 0.94469, 0.95877, 0.86901, 0.94469, 0.85122, 0.9482, 0.85122, 0.9482, 0.85122, 0.9482, 0.8667, 0.90016, 0.75186, 1.04692, 1, 1, 0.75186, 1.04692, 0.68887, 0.78223, 0.68887, 0.78223, 0.68887, 0.78223, 0.68887, 0.78223, 1, 1, 0.79776, 0.92188, 0.79776, 1.23023, 0.88844, 0.94469, 0.88844, 0.94469, 0.88844, 0.94469, 0.88844, 0.94469, 0.88844, 0.94469, 0.88844, 0.94469, 0.94258, 0.98986, 0.7306, 0.90527, 0.7306, 0.76659, 0.79004, 0.76659, 0.79004, 0.76659, 0.79004, 1.09231, 0.54873, 0.8675, 0.86128, 0.76318, 0.8693, 0.85311, 0.86651, 1, 1, 0.79776, 1.20562, 1.18622, 1.18622, 1, 1.1437, 0.67742, 0.96334, 0.93695, 1.35191, 1.40909, 0.95161, 1.48387, 0.86686, 0.90861, 0.62267, 0.74359, 0.65649, 0.85498, 0.56963, 0.88254, 1.23516, 0.8675, 0.81552, 0.75443, 0.84503, 0.73206, 0.76659, 0.86275, 0.85122, 0.90685, 0.77892, 0.85746, 1.02638, 0.89385, 0.75657, 0.85122, 0.86275, 0.77452, 0.74171, 0.79776, 0.7306, 0.95165, 0.77818, 0.89772, 0.88831, 0.90685, 0.7306, 0.98142, 1.02191, 0.96576, 1.23516, 0.99018, 0.98142, 0.9236, 0.89258, 0.94035, 1.02191, 0.78848, 0.96576, 0.9561, 1.23516, 0.90918, 0.92578, 0.95424, 0.89746, 0.83969, 0.9482, 0.80113, 0.89442, 0.85208, 0.86155, 0.98022, 0.99018, 1.00452, 0.81209, 0.99247, 0.89181, 1.23516, 0.99018, 0.9482, 0.99018, 0.89181, 0.73206, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.88844, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.89464, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.96766, 1, 1, 1, 1, 1, 1, 0.94258, 0.98986, 0.94258, 0.98986, 0.94258, 0.98986, 0.7306, 0.90527, 1, 1, 0.89552, 0.90527, 1, 0.90186, 1.12308, 1.12308, 1.12308, 1.12308, 1.2566, 1.2566, 1.2566, 0.89552, 0.89552, 1.42259, 0.69043, 1.03809, 1, 1, 1.0176, 1.0176, 1.11523, 1.4956, 2.01462, 0.99331, 0.82616, 0.91133, 0.84286, 0.91133, 1, 1, 1, 0.70508, 1, 1.23108, 0.79801, 0.84426, 0.84426, 0.774, 0.90527, 1.81055, 0.90527, 1.81055, 1.28809, 1.55469, 0.94434, 1.07806, 1, 0.97094, 0.7589, 0.85284, 0.90747, 1.19658, 0.69825, 0.97622, 1.33512, 0.90747, 0.90747, 0.85356, 0.90747, 0.90747, 1.44947, 0.85284, 0.8941, 0.8941, 0.70572, 0.8, 0.70572, 0.70572, 0.70572, 0.70572, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.99862, 0.99862, 1, 1, 1, 1, 1, 1.0336, 0.91027, 1, 1, 1, 0.99862, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.05859, 1.05859, 1, 1, 1, 1.07185, 0.99413, 0.96334, 1.08065, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]; exports.CalibriRegularFactors = CalibriRegularFactors; const CalibriRegularMetrics = { lineHeight: 1.2207, lineGap: 0.2207 }; exports.CalibriRegularMetrics = CalibriRegularMetrics; /***/ }), /* 51 */ /***/ ((__unused_webpack_module, exports) =&gt; { Object.defineProperty(exports, &quot;__esModule&quot;, ({ value: true })); exports.HelveticaRegularMetrics = exports.HelveticaRegularFactors = exports.HelveticaItalicMetrics = exports.HelveticaItalicFactors = exports.HelveticaBoldMetrics = exports.HelveticaBoldItalicMetrics = exports.HelveticaBoldItalicFactors = exports.HelveticaBoldFactors = void 0; const HelveticaBoldFactors = [0.76116, 1, 1, 1.0006, 0.99998, 0.99974, 0.99973, 0.99973, 0.99982, 0.99977, 1.00087, 0.99998, 0.99998, 0.99959, 1.00003, 1.0006, 0.99998, 1.0006, 1.0006, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99998, 1, 1.00003, 1.00003, 1.00003, 1.00026, 0.9999, 0.99977, 0.99977, 0.99977, 0.99977, 1.00001, 1.00026, 1.00022, 0.99977, 1.0006, 0.99973, 0.99977, 1.00026, 0.99999, 0.99977, 1.00022, 1.00001, 1.00022, 0.99977, 1.00001, 1.00026, 0.99977, 1.00001, 1.00016, 1.00001, 1.00001, 1.00026, 0.99998, 1.0006, 0.99998, 1.00003, 0.99973, 0.99998, 0.99973, 1.00026, 0.99973, 1.00026, 0.99973, 0.99998, 1.00026, 1.00026, 1.0006, 1.0006, 0.99973, 1.0006, 0.99982, 1.00026, 1.00026, 1.00026, 1.00026, 0.99959, 0.99973, 0.99998, 1.00026, 0.99973, 1.00022, 0.99973, 0.99973, 1, 0.99959, 1.00077, 0.99959, 1.00003, 0.99998, 0.99973, 0.99973, 0.99973, 0.99973, 1.00077, 0.99973, 0.99998, 1.00025, 0.99968, 0.99973, 1.00003, 1.00025, 0.60299, 1.00024, 1.06409, 1, 1, 0.99998, 1, 0.99973, 1.0006, 0.99998, 1, 0.99936, 0.99973, 1.00002, 1.00002, 1.00002, 1.00026, 0.99977, 0.99977, 0.99977, 0.99977, 0.99977, 0.99977, 1, 0.99977, 1.00001, 1.00001, 1.00001, 1.00001, 1.0006, 1.0006, 1.0006, 1.0006, 0.99977, 0.99977, 1.00022, 1.00022, 1.00022, 1.00022, 1.00022, 1.00003, 1.00022, 0.99977, 0.99977, 0.99977, 0.99977, 1.00001, 1.00001, 1.00026, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99982, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 1.0006, 1.0006, 1.0006, 1.0006, 1.00026, 1.00026, 1.00026, 1.00026, 1.00026, 1.00026, 1.00026, 1.06409, 1.00026, 1.00026, 1.00026, 1.00026, 1.00026, 0.99973, 1.00026, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 1.03374, 0.99977, 1.00026, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00022, 1.00026, 1.00022, 1.00026, 1.00022, 1.00026, 1.00022, 1.00026, 0.99977, 1.00026, 0.99977, 1.00026, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.00042, 0.99973, 0.99973, 1.0006, 0.99977, 0.99973, 0.99973, 1.00026, 1.0006, 1.00026, 1.0006, 1.00026, 1.03828, 1.00026, 0.99999, 1.00026, 1.0006, 0.99977, 1.00026, 0.99977, 1.00026, 0.99977, 1.00026, 0.9993, 0.9998, 1.00026, 1.00022, 1.00026, 1.00022, 1.00026, 1.00022, 1.00026, 1, 1.00016, 0.99977, 0.99959, 0.99977, 0.99959, 0.99977, 0.99959, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00026, 0.99998, 1.00026, 0.8121, 1.00026, 0.99998, 0.99977, 1.00026, 0.99977, 1.00026, 0.99977, 1.00026, 0.99977, 1.00026, 0.99977, 1.00026, 0.99977, 1.00026, 1.00016, 1.00022, 1.00001, 0.99973, 1.00001, 1.00026, 1, 1.00026, 1, 1.00026, 1, 1.0006, 0.99973, 0.99977, 0.99973, 1, 0.99982, 1.00022, 1.00026, 1.00001, 0.99973, 1.00026, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 1.00034, 0.99977, 1, 0.99997, 1.00026, 1.00078, 1.00036, 0.99973, 1.00013, 1.0006, 0.99977, 0.99977, 0.99988, 0.85148, 1.00001, 1.00026, 0.99977, 1.00022, 1.0006, 0.99977, 1.00001, 0.99999, 0.99977, 1.00069, 1.00022, 0.99977, 1.00001, 0.99984, 1.00026, 1.00001, 1.00024, 1.00001, 0.9999, 1, 1.0006, 1.00001, 1.00041, 0.99962, 1.00026, 1.0006, 0.99995, 1.00041, 0.99942, 0.99973, 0.99927, 1.00082, 0.99902, 1.00026, 1.00087, 1.0006, 1.00069, 0.99973, 0.99867, 0.99973, 0.9993, 1.00026, 1.00049, 1.00056, 1, 0.99988, 0.99935, 0.99995, 0.99954, 1.00055, 0.99945, 1.00032, 1.0006, 0.99995, 1.00026, 0.99995, 1.00032, 1.00001, 1.00008, 0.99971, 1.00019, 0.9994, 1.00001, 1.0006, 1.00044, 0.99973, 1.00023, 1.00047, 1, 0.99942, 0.99561, 0.99989, 1.00035, 0.99977, 1.00035, 0.99977, 1.00019, 0.99944, 1.00001, 1.00021, 0.99926, 1.00035, 1.00035, 0.99942, 1.00048, 0.99999, 0.99977, 1.00022, 1.00035, 1.00001, 0.99977, 1.00026, 0.99989, 1.00057, 1.00001, 0.99936, 1.00052, 1.00012, 0.99996, 1.00043, 1, 1.00035, 0.9994, 0.99976, 1.00035, 0.99973, 1.00052, 1.00041, 1.00119, 1.00037, 0.99973, 1.00002, 0.99986, 1.00041, 1.00041, 0.99902, 0.9996, 1.00034, 0.99999, 1.00026, 0.99999, 1.00026, 0.99973, 1.00052, 0.99973, 1, 0.99973, 1.00041, 1.00075, 0.9994, 1.0003, 0.99999, 1, 1.00041, 0.99955, 1, 0.99915, 0.99973, 0.99973, 1.00026, 1.00119, 0.99955, 0.99973, 1.0006, 0.99911, 1.0006, 1.00026, 0.99972, 1.00026, 0.99902, 1.00041, 0.99973, 0.99999, 1, 1, 1.00038, 1.0005, 1.00016, 1.00022, 1.00016, 1.00022, 1.00016, 1.00022, 1.00001, 0.99973, 1, 1, 0.99973, 1, 1, 0.99955, 1.0006, 1.0006, 1.0006, 1.0006, 1, 1, 1, 0.99973, 0.99973, 0.99972, 1, 1, 1.00106, 0.99999, 0.99998, 0.99998, 0.99999, 0.99998, 1.66475, 1, 0.99973, 0.99973, 1.00023, 0.99973, 0.99971, 1.00047, 1.00023, 1, 0.99991, 0.99984, 1.00002, 1.00002, 1.00002, 1.00002, 1, 1, 1, 1, 1, 1, 1, 0.99972, 1, 1.20985, 1.39713, 1.00003, 1.00031, 1.00015, 1, 0.99561, 1.00027, 1.00031, 1.00031, 0.99915, 1.00031, 1.00031, 0.99999, 1.00003, 0.99999, 0.99999, 1.41144, 1.6, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.40579, 1.40579, 1.36625, 0.99999, 1, 0.99861, 0.99861, 1, 1.00026, 1.00026, 1.00026, 1.00026, 0.99972, 0.99999, 0.99999, 0.99999, 0.99999, 1.40483, 1, 0.99977, 1.00054, 1, 1, 0.99953, 0.99962, 1.00042, 0.9995, 1, 1, 1, 1, 1, 1, 1, 1, 0.99998, 0.99998, 0.99998, 0.99998, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]; exports.HelveticaBoldFactors = HelveticaBoldFactors; const HelveticaBoldMetrics = { lineHeight: 1.2, lineGap: 0.2 }; exports.HelveticaBoldMetrics = HelveticaBoldMetrics; const HelveticaBoldItalicFactors = [0.76116, 1, 1, 1.0006, 0.99998, 0.99974, 0.99973, 0.99973, 0.99982, 0.99977, 1.00087, 0.99998, 0.99998, 0.99959, 1.00003, 1.0006, 0.99998, 1.0006, 1.0006, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99998, 1, 1.00003, 1.00003, 1.00003, 1.00026, 0.9999, 0.99977, 0.99977, 0.99977, 0.99977, 1.00001, 1.00026, 1.00022, 0.99977, 1.0006, 0.99973, 0.99977, 1.00026, 0.99999, 0.99977, 1.00022, 1.00001, 1.00022, 0.99977, 1.00001, 1.00026, 0.99977, 1.00001, 1.00016, 1.00001, 1.00001, 1.00026, 0.99998, 1.0006, 0.99998, 1.00003, 0.99973, 0.99998, 0.99973, 1.00026, 0.99973, 1.00026, 0.99973, 0.99998, 1.00026, 1.00026, 1.0006, 1.0006, 0.99973, 1.0006, 0.99982, 1.00026, 1.00026, 1.00026, 1.00026, 0.99959, 0.99973, 0.99998, 1.00026, 0.99973, 1.00022, 0.99973, 0.99973, 1, 0.99959, 1.00077, 0.99959, 1.00003, 0.99998, 0.99973, 0.99973, 0.99973, 0.99973, 1.00077, 0.99973, 0.99998, 1.00025, 0.99968, 0.99973, 1.00003, 1.00025, 0.60299, 1.00024, 1.06409, 1, 1, 0.99998, 1, 0.99973, 1.0006, 0.99998, 1, 0.99936, 0.99973, 1.00002, 1.00002, 1.00002, 1.00026, 0.99977, 0.99977, 0.99977, 0.99977, 0.99977, 0.99977, 1, 0.99977, 1.00001, 1.00001, 1.00001, 1.00001, 1.0006, 1.0006, 1.0006, 1.0006, 0.99977, 0.99977, 1.00022, 1.00022, 1.00022, 1.00022, 1.00022, 1.00003, 1.00022, 0.99977, 0.99977, 0.99977, 0.99977, 1.00001, 1.00001, 1.00026, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99982, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 1.0006, 1.0006, 1.0006, 1.0006, 1.00026, 1.00026, 1.00026, 1.00026, 1.00026, 1.00026, 1.00026, 1.06409, 1.00026, 1.00026, 1.00026, 1.00026, 1.00026, 0.99973, 1.00026, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 1.0044, 0.99977, 1.00026, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00022, 1.00026, 1.00022, 1.00026, 1.00022, 1.00026, 1.00022, 1.00026, 0.99977, 1.00026, 0.99977, 1.00026, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 0.99971, 0.99973, 0.99973, 1.0006, 0.99977, 0.99973, 0.99973, 1.00026, 1.0006, 1.00026, 1.0006, 1.00026, 1.01011, 1.00026, 0.99999, 1.00026, 1.0006, 0.99977, 1.00026, 0.99977, 1.00026, 0.99977, 1.00026, 0.9993, 0.9998, 1.00026, 1.00022, 1.00026, 1.00022, 1.00026, 1.00022, 1.00026, 1, 1.00016, 0.99977, 0.99959, 0.99977, 0.99959, 0.99977, 0.99959, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00026, 0.99998, 1.00026, 0.8121, 1.00026, 0.99998, 0.99977, 1.00026, 0.99977, 1.00026, 0.99977, 1.00026, 0.99977, 1.00026, 0.99977, 1.00026, 0.99977, 1.00026, 1.00016, 1.00022, 1.00001, 0.99973, 1.00001, 1.00026, 1, 1.00026, 1, 1.00026, 1, 1.0006, 0.99973, 0.99977, 0.99973, 1, 0.99982, 1.00022, 1.00026, 1.00001, 0.99973, 1.00026, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99977, 1, 1, 1.00026, 0.99969, 0.99972, 0.99981, 0.9998, 1.0006, 0.99977, 0.99977, 1.00022, 0.91155, 1.00001, 1.00026, 0.99977, 1.00022, 1.0006, 0.99977, 1.00001, 0.99999, 0.99977, 0.99966, 1.00022, 1.00032, 1.00001, 0.99944, 1.00026, 1.00001, 0.99968, 1.00001, 1.00047, 1, 1.0006, 1.00001, 0.99981, 1.00101, 1.00026, 1.0006, 0.99948, 0.99981, 1.00064, 0.99973, 0.99942, 1.00101, 1.00061, 1.00026, 1.00069, 1.0006, 1.00014, 0.99973, 1.01322, 0.99973, 1.00065, 1.00026, 1.00012, 0.99923, 1, 1.00064, 1.00076, 0.99948, 1.00055, 1.00063, 1.00007, 0.99943, 1.0006, 0.99948, 1.00026, 0.99948, 0.99943, 1.00001, 1.00001, 1.00029, 1.00038, 1.00035, 1.00001, 1.0006, 1.0006, 0.99973, 0.99978, 1.00001, 1.00057, 0.99989, 0.99967, 0.99964, 0.99967, 0.99977, 0.99999, 0.99977, 1.00038, 0.99977, 1.00001, 0.99973, 1.00066, 0.99967, 0.99967, 1.00041, 0.99998, 0.99999, 0.99977, 1.00022, 0.99967, 1.00001, 0.99977, 1.00026, 0.99964, 1.00031, 1.00001, 0.99999, 0.99999, 1, 1.00023, 1, 1, 0.99999, 1.00035, 1.00001, 0.99999, 0.99973, 0.99977, 0.99999, 1.00058, 0.99973, 0.99973, 0.99955, 0.9995, 1.00026, 1.00026, 1.00032, 0.99989, 1.00034, 0.99999, 1.00026, 1.00026, 1.00026, 0.99973, 0.45998, 0.99973, 1.00026, 0.99973, 1.00001, 0.99999, 0.99982, 0.99994, 0.99996, 1, 1.00042, 1.00044, 1.00029, 1.00023, 0.99973, 0.99973, 1.00026, 0.99949, 1.00002, 0.99973, 1.0006, 1.0006, 1.0006, 0.99975, 1.00026, 1.00026, 1.00032, 0.98685, 0.99973, 1.00026, 1, 1, 0.99966, 1.00044, 1.00016, 1.00022, 1.00016, 1.00022, 1.00016, 1.00022, 1.00001, 0.99973, 1, 1, 0.99973, 1, 1, 0.99955, 1.0006, 1.0006, 1.0006, 1.0006, 1, 1, 1, 0.99973, 0.99973, 0.99972, 1, 1, 1.00106, 0.99999, 0.99998, 0.99998, 0.99999, 0.99998, 1.66475, 1, 0.99973, 0.99973, 1, 0.99973, 0.99971, 0.99978, 1, 1, 0.99991, 0.99984, 1.00002, 1.00002, 1.00002, 1.00002, 1.00098, 1, 1, 1, 1.00049, 1, 1, 0.99972, 1, 1.20985, 1.39713, 1.00003, 1.00031, 1.00015, 1, 0.99561, 1.00027, 1.00031, 1.00031, 0.99915, 1.00031, 1.00031, 0.99999, 1.00003, 0.99999, 0.99999, 1.41144, 1.6, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.40579, 1.40579, 1.36625, 0.99999, 1, 0.99861, 0.99861, 1, 1.00026, 1.00026, 1.00026, 1.00026, 0.99972, 0.99999, 0.99999, 0.99999, 0.99999, 1.40483, 1, 0.99977, 1.00054, 1, 1, 0.99953, 0.99962, 1.00042, 0.9995, 1, 1, 1, 1, 1, 1, 1, 1, 0.99998, 0.99998, 0.99998, 0.99998, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]; exports.HelveticaBoldItalicFactors = HelveticaBoldItalicFactors; const HelveticaBoldItalicMetrics = { lineHeight: 1.35, lineGap: 0.2 }; exports.HelveticaBoldItalicMetrics = HelveticaBoldItalicMetrics; const HelveticaItalicFactors = [0.76116, 1, 1, 1.0006, 1.0006, 1.00006, 0.99973, 0.99973, 0.99982, 1.00001, 1.00043, 0.99998, 0.99998, 0.99959, 1.00003, 1.0006, 0.99998, 1.0006, 1.0006, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 1.0006, 1, 1.00003, 1.00003, 1.00003, 0.99973, 0.99987, 1.00001, 1.00001, 0.99977, 0.99977, 1.00001, 1.00026, 1.00022, 0.99977, 1.0006, 1, 1.00001, 0.99973, 0.99999, 0.99977, 1.00022, 1.00001, 1.00022, 0.99977, 1.00001, 1.00026, 0.99977, 1.00001, 1.00016, 1.00001, 1.00001, 1.00026, 1.0006, 1.0006, 1.0006, 0.99949, 0.99973, 0.99998, 0.99973, 0.99973, 1, 0.99973, 0.99973, 1.0006, 0.99973, 0.99973, 0.99924, 0.99924, 1, 0.99924, 0.99999, 0.99973, 0.99973, 0.99973, 0.99973, 0.99998, 1, 1.0006, 0.99973, 1, 0.99977, 1, 1, 1, 1.00005, 1.0009, 1.00005, 1.00003, 0.99998, 0.99973, 0.99973, 0.99973, 0.99973, 1.0009, 0.99973, 0.99998, 1.00025, 0.99968, 0.99973, 1.00003, 1.00025, 0.60299, 1.00024, 1.06409, 1, 1, 0.99998, 1, 0.9998, 1.0006, 0.99998, 1, 0.99936, 0.99973, 1.00002, 1.00002, 1.00002, 1.00026, 1.00001, 1.00001, 1.00001, 1.00001, 1.00001, 1.00001, 1, 0.99977, 1.00001, 1.00001, 1.00001, 1.00001, 1.0006, 1.0006, 1.0006, 1.0006, 0.99977, 0.99977, 1.00022, 1.00022, 1.00022, 1.00022, 1.00022, 1.00003, 1.00022, 0.99977, 0.99977, 0.99977, 0.99977, 1.00001, 1.00001, 1.00026, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99982, 1, 0.99973, 0.99973, 0.99973, 0.99973, 1.0006, 1.0006, 1.0006, 1.0006, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 1.06409, 1.00026, 0.99973, 0.99973, 0.99973, 0.99973, 1, 0.99973, 1, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 0.99977, 1, 0.99977, 1, 0.99977, 1, 0.99977, 1, 0.99977, 1.0288, 0.99977, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00022, 0.99973, 1.00022, 0.99973, 1.00022, 0.99973, 1.00022, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 0.99924, 1.0006, 1.0006, 0.99946, 1.00034, 1, 0.99924, 1.00001, 1, 1, 0.99973, 0.99924, 0.99973, 0.99924, 0.99973, 1.06311, 0.99973, 1.00024, 0.99973, 0.99924, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 1.00041, 0.9998, 0.99973, 1.00022, 0.99973, 1.00022, 0.99973, 1.00022, 0.99973, 1, 1.00016, 0.99977, 0.99998, 0.99977, 0.99998, 0.99977, 0.99998, 1.00001, 1, 1.00001, 1, 1.00001, 1, 1.00001, 1, 1.00026, 1.0006, 1.00026, 0.89547, 1.00026, 1.0006, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 1.00016, 0.99977, 1.00001, 1, 1.00001, 1.00026, 1, 1.00026, 1, 1.00026, 1, 0.99924, 0.99973, 1.00001, 0.99973, 1, 0.99982, 1.00022, 1.00026, 1.00001, 1, 1.00026, 1.0006, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 1.00001, 1, 1.00054, 0.99977, 1.00084, 1.00007, 0.99973, 1.00013, 0.99924, 1.00001, 1.00001, 0.99945, 0.91221, 1.00001, 1.00026, 0.99977, 1.00022, 1.0006, 1.00001, 1.00001, 0.99999, 0.99977, 0.99933, 1.00022, 1.00054, 1.00001, 1.00065, 1.00026, 1.00001, 1.0001, 1.00001, 1.00052, 1, 1.0006, 1.00001, 0.99945, 0.99897, 0.99968, 0.99924, 1.00036, 0.99945, 0.99949, 1, 1.0006, 0.99897, 0.99918, 0.99968, 0.99911, 0.99924, 1, 0.99962, 1.01487, 1, 1.0005, 0.99973, 1.00012, 1.00043, 1, 0.99995, 0.99994, 1.00036, 0.99947, 1.00019, 1.00063, 1.00025, 0.99924, 1.00036, 0.99973, 1.00036, 1.00025, 1.00001, 1.00001, 1.00027, 1.0001, 1.00068, 1.00001, 1.0006, 1.0006, 1, 1.00008, 0.99957, 0.99972, 0.9994, 0.99954, 0.99975, 1.00051, 1.00001, 1.00019, 1.00001, 1.0001, 0.99986, 1.00001, 1.00001, 1.00038, 0.99954, 0.99954, 0.9994, 1.00066, 0.99999, 0.99977, 1.00022, 1.00054, 1.00001, 0.99977, 1.00026, 0.99975, 1.0001, 1.00001, 0.99993, 0.9995, 0.99955, 1.00016, 0.99978, 0.99974, 1.00019, 1.00022, 0.99955, 1.00053, 0.99973, 1.00089, 1.00005, 0.99967, 1.00048, 0.99973, 1.00002, 1.00034, 0.99973, 0.99973, 0.99964, 1.00006, 1.00066, 0.99947, 0.99973, 0.98894, 0.99973, 1, 0.44898, 1, 0.99946, 1, 1.00039, 1.00082, 0.99991, 0.99991, 0.99985, 1.00022, 1.00023, 1.00061, 1.00006, 0.99966, 0.99973, 0.99973, 0.99973, 1.00019, 1.0008, 1, 0.99924, 0.99924, 0.99924, 0.99983, 1.00044, 0.99973, 0.99964, 0.98332, 1, 0.99973, 1, 1, 0.99962, 0.99895, 1.00016, 0.99977, 1.00016, 0.99977, 1.00016, 0.99977, 1.00001, 1, 1, 1, 0.99973, 1, 1, 0.99955, 0.99924, 0.99924, 0.99924, 0.99924, 0.99998, 0.99998, 0.99998, 0.99973, 0.99973, 0.99972, 1, 1, 1.00267, 0.99999, 0.99998, 0.99998, 1, 0.99998, 1.66475, 1, 0.99973, 0.99973, 1.00023, 0.99973, 1.00423, 0.99925, 0.99999, 1, 0.99991, 0.99984, 1.00002, 1.00002, 1.00002, 1.00002, 1.00049, 1, 1.00245, 1, 1, 1, 1, 0.96329, 1, 1.20985, 1.39713, 1.00003, 0.8254, 1.00015, 1, 1.00035, 1.00027, 1.00031, 1.00031, 1.00003, 1.00031, 1.00031, 0.99999, 1.00003, 0.99999, 0.99999, 1.41144, 1.6, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.40579, 1.40579, 1.36625, 0.99999, 1, 0.99861, 0.99861, 1, 1.00026, 1.00026, 1.00026, 1.00026, 0.95317, 0.99999, 0.99999, 0.99999, 0.99999, 1.40483, 1, 0.99977, 1.00054, 1, 1, 0.99953, 0.99962, 1.00042, 0.9995, 1, 1, 1, 1, 1, 1, 1, 1, 0.99998, 0.99998, 0.99998, 0.99998, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]; exports.HelveticaItalicFactors = HelveticaItalicFactors; const HelveticaItalicMetrics = { lineHeight: 1.35, lineGap: 0.2 }; exports.HelveticaItalicMetrics = HelveticaItalicMetrics; const HelveticaRegularFactors = [0.76116, 1, 1, 1.0006, 1.0006, 1.00006, 0.99973, 0.99973, 0.99982, 1.00001, 1.00043, 0.99998, 0.99998, 0.99959, 1.00003, 1.0006, 0.99998, 1.0006, 1.0006, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 1.0006, 1, 1.00003, 1.00003, 1.00003, 0.99973, 0.99987, 1.00001, 1.00001, 0.99977, 0.99977, 1.00001, 1.00026, 1.00022, 0.99977, 1.0006, 1, 1.00001, 0.99973, 0.99999, 0.99977, 1.00022, 1.00001, 1.00022, 0.99977, 1.00001, 1.00026, 0.99977, 1.00001, 1.00016, 1.00001, 1.00001, 1.00026, 1.0006, 1.0006, 1.0006, 0.99949, 0.99973, 0.99998, 0.99973, 0.99973, 1, 0.99973, 0.99973, 1.0006, 0.99973, 0.99973, 0.99924, 0.99924, 1, 0.99924, 0.99999, 0.99973, 0.99973, 0.99973, 0.99973, 0.99998, 1, 1.0006, 0.99973, 1, 0.99977, 1, 1, 1, 1.00005, 1.0009, 1.00005, 1.00003, 0.99998, 0.99973, 0.99973, 0.99973, 0.99973, 1.0009, 0.99973, 0.99998, 1.00025, 0.99968, 0.99973, 1.00003, 1.00025, 0.60299, 1.00024, 1.06409, 1, 1, 0.99998, 1, 0.9998, 1.0006, 0.99998, 1, 0.99936, 0.99973, 1.00002, 1.00002, 1.00002, 1.00026, 1.00001, 1.00001, 1.00001, 1.00001, 1.00001, 1.00001, 1, 0.99977, 1.00001, 1.00001, 1.00001, 1.00001, 1.0006, 1.0006, 1.0006, 1.0006, 0.99977, 0.99977, 1.00022, 1.00022, 1.00022, 1.00022, 1.00022, 1.00003, 1.00022, 0.99977, 0.99977, 0.99977, 0.99977, 1.00001, 1.00001, 1.00026, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99982, 1, 0.99973, 0.99973, 0.99973, 0.99973, 1.0006, 1.0006, 1.0006, 1.0006, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 1.06409, 1.00026, 0.99973, 0.99973, 0.99973, 0.99973, 1, 0.99973, 1, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 0.99977, 1, 0.99977, 1, 0.99977, 1, 0.99977, 1, 0.99977, 1.04596, 0.99977, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00022, 0.99973, 1.00022, 0.99973, 1.00022, 0.99973, 1.00022, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 0.99924, 1.0006, 1.0006, 1.00019, 1.00034, 1, 0.99924, 1.00001, 1, 1, 0.99973, 0.99924, 0.99973, 0.99924, 0.99973, 1.02572, 0.99973, 1.00005, 0.99973, 0.99924, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99999, 0.9998, 0.99973, 1.00022, 0.99973, 1.00022, 0.99973, 1.00022, 0.99973, 1, 1.00016, 0.99977, 0.99998, 0.99977, 0.99998, 0.99977, 0.99998, 1.00001, 1, 1.00001, 1, 1.00001, 1, 1.00001, 1, 1.00026, 1.0006, 1.00026, 0.84533, 1.00026, 1.0006, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 1.00016, 0.99977, 1.00001, 1, 1.00001, 1.00026, 1, 1.00026, 1, 1.00026, 1, 0.99924, 0.99973, 1.00001, 0.99973, 1, 0.99982, 1.00022, 1.00026, 1.00001, 1, 1.00026, 1.0006, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99928, 1, 0.99977, 1.00013, 1.00055, 0.99947, 0.99945, 0.99941, 0.99924, 1.00001, 1.00001, 1.0004, 0.91621, 1.00001, 1.00026, 0.99977, 1.00022, 1.0006, 1.00001, 1.00005, 0.99999, 0.99977, 1.00015, 1.00022, 0.99977, 1.00001, 0.99973, 1.00026, 1.00001, 1.00019, 1.00001, 0.99946, 1, 1.0006, 1.00001, 0.99978, 1.00045, 0.99973, 0.99924, 1.00023, 0.99978, 0.99966, 1, 1.00065, 1.00045, 1.00019, 0.99973, 0.99973, 0.99924, 1, 1, 0.96499, 1, 1.00055, 0.99973, 1.00008, 1.00027, 1, 0.9997, 0.99995, 1.00023, 0.99933, 1.00019, 1.00015, 1.00031, 0.99924, 1.00023, 0.99973, 1.00023, 1.00031, 1.00001, 0.99928, 1.00029, 1.00092, 1.00035, 1.00001, 1.0006, 1.0006, 1, 0.99988, 0.99975, 1, 1.00082, 0.99561, 0.9996, 1.00035, 1.00001, 0.99962, 1.00001, 1.00092, 0.99964, 1.00001, 0.99963, 0.99999, 1.00035, 1.00035, 1.00082, 0.99962, 0.99999, 0.99977, 1.00022, 1.00035, 1.00001, 0.99977, 1.00026, 0.9996, 0.99967, 1.00001, 1.00034, 1.00074, 1.00054, 1.00053, 1.00063, 0.99971, 0.99962, 1.00035, 0.99975, 0.99977, 0.99973, 1.00043, 0.99953, 1.0007, 0.99915, 0.99973, 1.00008, 0.99892, 1.00073, 1.00073, 1.00114, 0.99915, 1.00073, 0.99955, 0.99973, 1.00092, 0.99973, 1, 0.99998, 1, 1.0003, 1, 1.00043, 1.00001, 0.99969, 1.0003, 1, 1.00035, 1.00001, 0.9995, 1, 1.00092, 0.99973, 0.99973, 0.99973, 1.0007, 0.9995, 1, 0.99924, 1.0006, 0.99924, 0.99972, 1.00062, 0.99973, 1.00114, 1.00073, 1, 0.99955, 1, 1, 1.00047, 0.99968, 1.00016, 0.99977, 1.00016, 0.99977, 1.00016, 0.99977, 1.00001, 1, 1, 1, 0.99973, 1, 1, 0.99955, 0.99924, 0.99924, 0.99924, 0.99924, 0.99998, 0.99998, 0.99998, 0.99973, 0.99973, 0.99972, 1, 1, 1.00267, 0.99999, 0.99998, 0.99998, 1, 0.99998, 1.66475, 1, 0.99973, 0.99973, 1.00023, 0.99973, 0.99971, 0.99925, 1.00023, 1, 0.99991, 0.99984, 1.00002, 1.00002, 1.00002, 1.00002, 1, 1, 1, 1, 1, 1, 1, 0.96329, 1, 1.20985, 1.39713, 1.00003, 0.8254, 1.00015, 1, 1.00035, 1.00027, 1.00031, 1.00031, 0.99915, 1.00031, 1.00031, 0.99999, 1.00003, 0.99999, 0.99999, 1.41144, 1.6, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.40579, 1.40579, 1.36625, 0.99999, 1, 0.99861, 0.99861, 1, 1.00026, 1.00026, 1.00026, 1.00026, 0.95317, 0.99999, 0.99999, 0.99999, 0.99999, 1.40483, 1, 0.99977, 1.00054, 1, 1, 0.99953, 0.99962, 1.00042, 0.9995, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]; exports.HelveticaRegularFactors = HelveticaRegularFactors; const HelveticaRegularMetrics = { lineHeight: 1.2, lineGap: 0.2 }; exports.HelveticaRegularMetrics = HelveticaRegularMetrics; /***/ }), /* 52 */ /***/ ((__unused_webpack_module, exports) =&gt; { Object.defineProperty(exports, &quot;__esModule&quot;, ({ value: true })); exports.LiberationSansRegularWidths = exports.LiberationSansRegularMapping = exports.LiberationSansItalicWidths = exports.LiberationSansItalicMapping = exports.LiberationSansBoldWidths = exports.LiberationSansBoldMapping = exports.LiberationSansBoldItalicWidths = exports.LiberationSansBoldItalicMapping = void 0; const LiberationSansBoldWidths = [365, 0, 333, 278, 333, 474, 556, 556, 889, 722, 238, 333, 333, 389, 584, 278, 333, 278, 278, 556, 556, 556, 556, 556, 556, 556, 556, 556, 556, 333, 333, 584, 584, 584, 611, 975, 722, 722, 722, 722, 667, 611, 778, 722, 278, 556, 722, 611, 833, 722, 778, 667, 778, 722, 667, 611, 722, 667, 944, 667, 667, 611, 333, 278, 333, 584, 556, 333, 556, 611, 556, 611, 556, 333, 611, 611, 278, 278, 556, 278, 889, 611, 611, 611, 611, 389, 556, 333, 611, 556, 778, 556, 556, 500, 389, 280, 389, 584, 333, 556, 556, 556, 556, 280, 556, 333, 737, 370, 556, 584, 737, 552, 400, 549, 333, 333, 333, 576, 556, 278, 333, 333, 365, 556, 834, 834, 834, 611, 722, 722, 722, 722, 722, 722, 1000, 722, 667, 667, 667, 667, 278, 278, 278, 278, 722, 722, 778, 778, 778, 778, 778, 584, 778, 722, 722, 722, 722, 667, 667, 611, 556, 556, 556, 556, 556, 556, 889, 556, 556, 556, 556, 556, 278, 278, 278, 278, 611, 611, 611, 611, 611, 611, 611, 549, 611, 611, 611, 611, 611, 556, 611, 556, 722, 556, 722, 556, 722, 556, 722, 556, 722, 556, 722, 556, 722, 556, 722, 719, 722, 611, 667, 556, 667, 556, 667, 556, 667, 556, 667, 556, 778, 611, 778, 611, 778, 611, 778, 611, 722, 611, 722, 611, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 785, 556, 556, 278, 722, 556, 556, 611, 278, 611, 278, 611, 385, 611, 479, 611, 278, 722, 611, 722, 611, 722, 611, 708, 723, 611, 778, 611, 778, 611, 778, 611, 1000, 944, 722, 389, 722, 389, 722, 389, 667, 556, 667, 556, 667, 556, 667, 556, 611, 333, 611, 479, 611, 333, 722, 611, 722, 611, 722, 611, 722, 611, 722, 611, 722, 611, 944, 778, 667, 556, 667, 611, 500, 611, 500, 611, 500, 278, 556, 722, 556, 1000, 889, 778, 611, 667, 556, 611, 333, 333, 333, 333, 333, 333, 333, 333, 333, 333, 333, 465, 722, 333, 853, 906, 474, 825, 927, 838, 278, 722, 722, 601, 719, 667, 611, 722, 778, 278, 722, 667, 833, 722, 644, 778, 722, 667, 600, 611, 667, 821, 667, 809, 802, 278, 667, 615, 451, 611, 278, 582, 615, 610, 556, 606, 475, 460, 611, 541, 278, 558, 556, 612, 556, 445, 611, 766, 619, 520, 684, 446, 582, 715, 576, 753, 845, 278, 582, 611, 582, 845, 667, 669, 885, 567, 711, 667, 278, 276, 556, 1094, 1062, 875, 610, 722, 622, 719, 722, 719, 722, 567, 712, 667, 904, 626, 719, 719, 610, 702, 833, 722, 778, 719, 667, 722, 611, 622, 854, 667, 730, 703, 1005, 1019, 870, 979, 719, 711, 1031, 719, 556, 618, 615, 417, 635, 556, 709, 497, 615, 615, 500, 635, 740, 604, 611, 604, 611, 556, 490, 556, 875, 556, 615, 581, 833, 844, 729, 854, 615, 552, 854, 583, 556, 556, 611, 417, 552, 556, 278, 281, 278, 969, 906, 611, 500, 615, 556, 604, 778, 611, 487, 447, 944, 778, 944, 778, 944, 778, 667, 556, 333, 333, 556, 1000, 1000, 552, 278, 278, 278, 278, 500, 500, 500, 556, 556, 350, 1000, 1000, 240, 479, 333, 333, 604, 333, 167, 396, 556, 556, 1094, 556, 885, 489, 1115, 1000, 768, 600, 834, 834, 834, 834, 1000, 500, 1000, 500, 1000, 500, 500, 494, 612, 823, 713, 584, 549, 713, 979, 722, 274, 549, 549, 583, 549, 549, 604, 584, 604, 604, 708, 625, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 729, 604, 604, 354, 354, 1000, 990, 990, 990, 990, 494, 604, 604, 604, 604, 354, 1021, 1052, 917, 750, 750, 531, 656, 594, 510, 500, 750, 750, 611, 611, 333, 333, 333, 333, 333, 333, 333, 333, 222, 222, 333, 333, 333, 333, 333, 333, 333, 333]; exports.LiberationSansBoldWidths = LiberationSansBoldWidths; const LiberationSansBoldMapping = [-1, -1, -1, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 368, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 402, 506, 507, 508, 509, 510, 511, 536, 537, 538, 539, 710, 711, 713, 728, 729, 730, 731, 732, 733, 900, 901, 902, 903, 904, 905, 906, 908, 910, 911, 912, 913, 914, 915, 916, 917, 918, 919, 920, 921, 922, 923, 924, 925, 926, 927, 928, 929, 931, 932, 933, 934, 935, 936, 937, 938, 939, 940, 941, 942, 943, 944, 945, 946, 947, 948, 949, 950, 951, 952, 953, 954, 955, 956, 957, 958, 959, 960, 961, 962, 963, 964, 965, 966, 967, 968, 969, 970, 971, 972, 973, 974, 1024, 1025, 1026, 1027, 1028, 1029, 1030, 1031, 1032, 1033, 1034, 1035, 1036, 1037, 1038, 1039, 1040, 1041, 1042, 1043, 1044, 1045, 1046, 1047, 1048, 1049, 1050, 1051, 1052, 1053, 1054, 1055, 1056, 1057, 1058, 1059, 1060, 1061, 1062, 1063, 1064, 1065, 1066, 1067, 1068, 1069, 1070, 1071, 1072, 1073, 1074, 1075, 1076, 1077, 1078, 1079, 1080, 1081, 1082, 1083, 1084, 1085, 1086, 1087, 1088, 1089, 1090, 1091, 1092, 1093, 1094, 1095, 1096, 1097, 1098, 1099, 1100, 1101, 1102, 1103, 1104, 1105, 1106, 1107, 1108, 1109, 1110, 1111, 1112, 1113, 1114, 1115, 1116, 1117, 1118, 1119, 1138, 1139, 1168, 1169, 7808, 7809, 7810, 7811, 7812, 7813, 7922, 7923, 8208, 8209, 8211, 8212, 8213, 8215, 8216, 8217, 8218, 8219, 8220, 8221, 8222, 8224, 8225, 8226, 8230, 8240, 8242, 8243, 8249, 8250, 8252, 8254, 8260, 8319, 8355, 8356, 8359, 8364, 8453, 8467, 8470, 8482, 8486, 8494, 8539, 8540, 8541, 8542, 8592, 8593, 8594, 8595, 8596, 8597, 8616, 8706, 8710, 8719, 8721, 8722, 8730, 8734, 8735, 8745, 8747, 8776, 8800, 8801, 8804, 8805, 8962, 8976, 8992, 8993, 9472, 9474, 9484, 9488, 9492, 9496, 9500, 9508, 9516, 9524, 9532, 9552, 9553, 9554, 9555, 9556, 9557, 9558, 9559, 9560, 9561, 9562, 9563, 9564, 9565, 9566, 9567, 9568, 9569, 9570, 9571, 9572, 9573, 9574, 9575, 9576, 9577, 9578, 9579, 9580, 9600, 9604, 9608, 9612, 9616, 9617, 9618, 9619, 9632, 9633, 9642, 9643, 9644, 9650, 9658, 9660, 9668, 9674, 9675, 9679, 9688, 9689, 9702, 9786, 9787, 9788, 9792, 9794, 9824, 9827, 9829, 9830, 9834, 9835, 9836, 61441, 61442, 61445, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1]; exports.LiberationSansBoldMapping = LiberationSansBoldMapping; const LiberationSansBoldItalicWidths = [365, 0, 333, 278, 333, 474, 556, 556, 889, 722, 238, 333, 333, 389, 584, 278, 333, 278, 278, 556, 556, 556, 556, 556, 556, 556, 556, 556, 556, 333, 333, 584, 584, 584, 611, 975, 722, 722, 722, 722, 667, 611, 778, 722, 278, 556, 722, 611, 833, 722, 778, 667, 778, 722, 667, 611, 722, 667, 944, 667, 667, 611, 333, 278, 333, 584, 556, 333, 556, 611, 556, 611, 556, 333, 611, 611, 278, 278, 556, 278, 889, 611, 611, 611, 611, 389, 556, 333, 611, 556, 778, 556, 556, 500, 389, 280, 389, 584, 333, 556, 556, 556, 556, 280, 556, 333, 737, 370, 556, 584, 737, 552, 400, 549, 333, 333, 333, 576, 556, 278, 333, 333, 365, 556, 834, 834, 834, 611, 722, 722, 722, 722, 722, 722, 1000, 722, 667, 667, 667, 667, 278, 278, 278, 278, 722, 722, 778, 778, 778, 778, 778, 584, 778, 722, 722, 722, 722, 667, 667, 611, 556, 556, 556, 556, 556, 556, 889, 556, 556, 556, 556, 556, 278, 278, 278, 278, 611, 611, 611, 611, 611, 611, 611, 549, 611, 611, 611, 611, 611, 556, 611, 556, 722, 556, 722, 556, 722, 556, 722, 556, 722, 556, 722, 556, 722, 556, 722, 740, 722, 611, 667, 556, 667, 556, 667, 556, 667, 556, 667, 556, 778, 611, 778, 611, 778, 611, 778, 611, 722, 611, 722, 611, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 782, 556, 556, 278, 722, 556, 556, 611, 278, 611, 278, 611, 396, 611, 479, 611, 278, 722, 611, 722, 611, 722, 611, 708, 723, 611, 778, 611, 778, 611, 778, 611, 1000, 944, 722, 389, 722, 389, 722, 389, 667, 556, 667, 556, 667, 556, 667, 556, 611, 333, 611, 479, 611, 333, 722, 611, 722, 611, 722, 611, 722, 611, 722, 611, 722, 611, 944, 778, 667, 556, 667, 611, 500, 611, 500, 611, 500, 278, 556, 722, 556, 1000, 889, 778, 611, 667, 556, 611, 333, 333, 333, 333, 333, 333, 333, 333, 333, 333, 333, 333, 722, 333, 854, 906, 473, 844, 930, 847, 278, 722, 722, 610, 671, 667, 611, 722, 778, 278, 722, 667, 833, 722, 657, 778, 718, 667, 590, 611, 667, 822, 667, 829, 781, 278, 667, 620, 479, 611, 278, 591, 620, 621, 556, 610, 479, 492, 611, 558, 278, 566, 556, 603, 556, 450, 611, 712, 605, 532, 664, 409, 591, 704, 578, 773, 834, 278, 591, 611, 591, 834, 667, 667, 886, 614, 719, 667, 278, 278, 556, 1094, 1042, 854, 622, 719, 677, 719, 722, 708, 722, 614, 722, 667, 927, 643, 719, 719, 615, 687, 833, 722, 778, 719, 667, 722, 611, 677, 781, 667, 729, 708, 979, 989, 854, 1000, 708, 719, 1042, 729, 556, 619, 604, 534, 618, 556, 736, 510, 611, 611, 507, 622, 740, 604, 611, 611, 611, 556, 889, 556, 885, 556, 646, 583, 889, 935, 707, 854, 594, 552, 865, 589, 556, 556, 611, 469, 563, 556, 278, 278, 278, 969, 906, 611, 507, 619, 556, 611, 778, 611, 575, 467, 944, 778, 944, 778, 944, 778, 667, 556, 333, 333, 556, 1000, 1000, 552, 278, 278, 278, 278, 500, 500, 500, 556, 556, 350, 1000, 1000, 240, 479, 333, 333, 604, 333, 167, 396, 556, 556, 1104, 556, 885, 516, 1146, 1000, 768, 600, 834, 834, 834, 834, 999, 500, 1000, 500, 1000, 500, 500, 494, 612, 823, 713, 584, 549, 713, 979, 722, 274, 549, 549, 583, 549, 549, 604, 584, 604, 604, 708, 625, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 729, 604, 604, 354, 354, 1000, 990, 990, 990, 990, 494, 604, 604, 604, 604, 354, 1021, 1052, 917, 750, 750, 531, 656, 594, 510, 500, 750, 750, 611, 611, 333, 333, 333, 333, 333, 333, 333, 333, 222, 222, 333, 333, 333, 333, 333, 333, 333, 333]; exports.LiberationSansBoldItalicWidths = LiberationSansBoldItalicWidths; const LiberationSansBoldItalicMapping = [-1, -1, -1, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 368, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 402, 506, 507, 508, 509, 510, 511, 536, 537, 538, 539, 710, 711, 713, 728, 729, 730, 731, 732, 733, 900, 901, 902, 903, 904, 905, 906, 908, 910, 911, 912, 913, 914, 915, 916, 917, 918, 919, 920, 921, 922, 923, 924, 925, 926, 927, 928, 929, 931, 932, 933, 934, 935, 936, 937, 938, 939, 940, 941, 942, 943, 944, 945, 946, 947, 948, 949, 950, 951, 952, 953, 954, 955, 956, 957, 958, 959, 960, 961, 962, 963, 964, 965, 966, 967, 968, 969, 970, 971, 972, 973, 974, 1024, 1025, 1026, 1027, 1028, 1029, 1030, 1031, 1032, 1033, 1034, 1035, 1036, 1037, 1038, 1039, 1040, 1041, 1042, 1043, 1044, 1045, 1046, 1047, 1048, 1049, 1050, 1051, 1052, 1053, 1054, 1055, 1056, 1057, 1058, 1059, 1060, 1061, 1062, 1063, 1064, 1065, 1066, 1067, 1068, 1069, 1070, 1071, 1072, 1073, 1074, 1075, 1076, 1077, 1078, 1079, 1080, 1081, 1082, 1083, 1084, 1085, 1086, 1087, 1088, 1089, 1090, 1091, 1092, 1093, 1094, 1095, 1096, 1097, 1098, 1099, 1100, 1101, 1102, 1103, 1104, 1105, 1106, 1107, 1108, 1109, 1110, 1111, 1112, 1113, 1114, 1115, 1116, 1117, 1118, 1119, 1138, 1139, 1168, 1169, 7808, 7809, 7810, 7811, 7812, 7813, 7922, 7923, 8208, 8209, 8211, 8212, 8213, 8215, 8216, 8217, 8218, 8219, 8220, 8221, 8222, 8224, 8225, 8226, 8230, 8240, 8242, 8243, 8249, 8250, 8252, 8254, 8260, 8319, 8355, 8356, 8359, 8364, 8453, 8467, 8470, 8482, 8486, 8494, 8539, 8540, 8541, 8542, 8592, 8593, 8594, 8595, 8596, 8597, 8616, 8706, 8710, 8719, 8721, 8722, 8730, 8734, 8735, 8745, 8747, 8776, 8800, 8801, 8804, 8805, 8962, 8976, 8992, 8993, 9472, 9474, 9484, 9488, 9492, 9496, 9500, 9508, 9516, 9524, 9532, 9552, 9553, 9554, 9555, 9556, 9557, 9558, 9559, 9560, 9561, 9562, 9563, 9564, 9565, 9566, 9567, 9568, 9569, 9570, 9571, 9572, 9573, 9574, 9575, 9576, 9577, 9578, 9579, 9580, 9600, 9604, 9608, 9612, 9616, 9617, 9618, 9619, 9632, 9633, 9642, 9643, 9644, 9650, 9658, 9660, 9668, 9674, 9675, 9679, 9688, 9689, 9702, 9786, 9787, 9788, 9792, 9794, 9824, 9827, 9829, 9830, 9834, 9835, 9836, 61441, 61442, 61445, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1]; exports.LiberationSansBoldItalicMapping = LiberationSansBoldItalicMapping; const LiberationSansItalicWidths = [365, 0, 333, 278, 278, 355, 556, 556, 889, 667, 191, 333, 333, 389, 584, 278, 333, 278, 278, 556, 556, 556, 556, 556, 556, 556, 556, 556, 556, 278, 278, 584, 584, 584, 556, 1015, 667, 667, 722, 722, 667, 611, 778, 722, 278, 500, 667, 556, 833, 722, 778, 667, 778, 722, 667, 611, 722, 667, 944, 667, 667, 611, 278, 278, 278, 469, 556, 333, 556, 556, 500, 556, 556, 278, 556, 556, 222, 222, 500, 222, 833, 556, 556, 556, 556, 333, 500, 278, 556, 500, 722, 500, 500, 500, 334, 260, 334, 584, 333, 556, 556, 556, 556, 260, 556, 333, 737, 370, 556, 584, 737, 552, 400, 549, 333, 333, 333, 576, 537, 278, 333, 333, 365, 556, 834, 834, 834, 611, 667, 667, 667, 667, 667, 667, 1000, 722, 667, 667, 667, 667, 278, 278, 278, 278, 722, 722, 778, 778, 778, 778, 778, 584, 778, 722, 722, 722, 722, 667, 667, 611, 556, 556, 556, 556, 556, 556, 889, 500, 556, 556, 556, 556, 278, 278, 278, 278, 556, 556, 556, 556, 556, 556, 556, 549, 611, 556, 556, 556, 556, 500, 556, 500, 667, 556, 667, 556, 667, 556, 722, 500, 722, 500, 722, 500, 722, 500, 722, 625, 722, 556, 667, 556, 667, 556, 667, 556, 667, 556, 667, 556, 778, 556, 778, 556, 778, 556, 778, 556, 722, 556, 722, 556, 278, 278, 278, 278, 278, 278, 278, 222, 278, 278, 733, 444, 500, 222, 667, 500, 500, 556, 222, 556, 222, 556, 281, 556, 400, 556, 222, 722, 556, 722, 556, 722, 556, 615, 723, 556, 778, 556, 778, 556, 778, 556, 1000, 944, 722, 333, 722, 333, 722, 333, 667, 500, 667, 500, 667, 500, 667, 500, 611, 278, 611, 354, 611, 278, 722, 556, 722, 556, 722, 556, 722, 556, 722, 556, 722, 556, 944, 722, 667, 500, 667, 611, 500, 611, 500, 611, 500, 222, 556, 667, 556, 1000, 889, 778, 611, 667, 500, 611, 278, 333, 333, 333, 333, 333, 333, 333, 333, 333, 333, 333, 667, 278, 789, 846, 389, 794, 865, 775, 222, 667, 667, 570, 671, 667, 611, 722, 778, 278, 667, 667, 833, 722, 648, 778, 725, 667, 600, 611, 667, 837, 667, 831, 761, 278, 667, 570, 439, 555, 222, 550, 570, 571, 500, 556, 439, 463, 555, 542, 222, 500, 492, 548, 500, 447, 556, 670, 573, 486, 603, 374, 550, 652, 546, 728, 779, 222, 550, 556, 550, 779, 667, 667, 843, 544, 708, 667, 278, 278, 500, 1066, 982, 844, 589, 715, 639, 724, 667, 651, 667, 544, 704, 667, 917, 614, 715, 715, 589, 686, 833, 722, 778, 725, 667, 722, 611, 639, 795, 667, 727, 673, 920, 923, 805, 886, 651, 694, 1022, 682, 556, 562, 522, 493, 553, 556, 688, 465, 556, 556, 472, 564, 686, 550, 556, 556, 556, 500, 833, 500, 835, 500, 572, 518, 830, 851, 621, 736, 526, 492, 752, 534, 556, 556, 556, 378, 496, 500, 222, 222, 222, 910, 828, 556, 472, 565, 500, 556, 778, 556, 492, 339, 944, 722, 944, 722, 944, 722, 667, 500, 333, 333, 556, 1000, 1000, 552, 222, 222, 222, 222, 333, 333, 333, 556, 556, 350, 1000, 1000, 188, 354, 333, 333, 500, 333, 167, 365, 556, 556, 1094, 556, 885, 323, 1083, 1000, 768, 600, 834, 834, 834, 834, 1000, 500, 998, 500, 1000, 500, 500, 494, 612, 823, 713, 584, 549, 713, 979, 719, 274, 549, 549, 584, 549, 549, 604, 584, 604, 604, 708, 625, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 729, 604, 604, 354, 354, 1000, 990, 990, 990, 990, 494, 604, 604, 604, 604, 354, 1021, 1052, 917, 750, 750, 531, 656, 594, 510, 500, 750, 750, 500, 500, 333, 333, 333, 333, 333, 333, 333, 333, 222, 222, 294, 294, 324, 324, 316, 328, 398, 285]; exports.LiberationSansItalicWidths = LiberationSansItalicWidths; const LiberationSansItalicMapping = [-1, -1, -1, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 368, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 402, 506, 507, 508, 509, 510, 511, 536, 537, 538, 539, 710, 711, 713, 728, 729, 730, 731, 732, 733, 900, 901, 902, 903, 904, 905, 906, 908, 910, 911, 912, 913, 914, 915, 916, 917, 918, 919, 920, 921, 922, 923, 924, 925, 926, 927, 928, 929, 931, 932, 933, 934, 935, 936, 937, 938, 939, 940, 941, 942, 943, 944, 945, 946, 947, 948, 949, 950, 951, 952, 953, 954, 955, 956, 957, 958, 959, 960, 961, 962, 963, 964, 965, 966, 967, 968, 969, 970, 971, 972, 973, 974, 1024, 1025, 1026, 1027, 1028, 1029, 1030, 1031, 1032, 1033, 1034, 1035, 1036, 1037, 1038, 1039, 1040, 1041, 1042, 1043, 1044, 1045, 1046, 1047, 1048, 1049, 1050, 1051, 1052, 1053, 1054, 1055, 1056, 1057, 1058, 1059, 1060, 1061, 1062, 1063, 1064, 1065, 1066, 1067, 1068, 1069, 1070, 1071, 1072, 1073, 1074, 1075, 1076, 1077, 1078, 1079, 1080, 1081, 1082, 1083, 1084, 1085, 1086, 1087, 1088, 1089, 1090, 1091, 1092, 1093, 1094, 1095, 1096, 1097, 1098, 1099, 1100, 1101, 1102, 1103, 1104, 1105, 1106, 1107, 1108, 1109, 1110, 1111, 1112, 1113, 1114, 1115, 1116, 1117, 1118, 1119, 1138, 1139, 1168, 1169, 7808, 7809, 7810, 7811, 7812, 7813, 7922, 7923, 8208, 8209, 8211, 8212, 8213, 8215, 8216, 8217, 8218, 8219, 8220, 8221, 8222, 8224, 8225, 8226, 8230, 8240, 8242, 8243, 8249, 8250, 8252, 8254, 8260, 8319, 8355, 8356, 8359, 8364, 8453, 8467, 8470, 8482, 8486, 8494, 8539, 8540, 8541, 8542, 8592, 8593, 8594, 8595, 8596, 8597, 8616, 8706, 8710, 8719, 8721, 8722, 8730, 8734, 8735, 8745, 8747, 8776, 8800, 8801, 8804, 8805, 8962, 8976, 8992, 8993, 9472, 9474, 9484, 9488, 9492, 9496, 9500, 9508, 9516, 9524, 9532, 9552, 9553, 9554, 9555, 9556, 9557, 9558, 9559, 9560, 9561, 9562, 9563, 9564, 9565, 9566, 9567, 9568, 9569, 9570, 9571, 9572, 9573, 9574, 9575, 9576, 9577, 9578, 9579, 9580, 9600, 9604, 9608, 9612, 9616, 9617, 9618, 9619, 9632, 9633, 9642, 9643, 9644, 9650, 9658, 9660, 9668, 9674, 9675, 9679, 9688, 9689, 9702, 9786, 9787, 9788, 9792, 9794, 9824, 9827, 9829, 9830, 9834, 9835, 9836, 61441, 61442, 61445, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1]; exports.LiberationSansItalicMapping = LiberationSansItalicMapping; const LiberationSansRegularWidths = [365, 0, 333, 278, 278, 355, 556, 556, 889, 667, 191, 333, 333, 389, 584, 278, 333, 278, 278, 556, 556, 556, 556, 556, 556, 556, 556, 556, 556, 278, 278, 584, 584, 584, 556, 1015, 667, 667, 722, 722, 667, 611, 778, 722, 278, 500, 667, 556, 833, 722, 778, 667, 778, 722, 667, 611, 722, 667, 944, 667, 667, 611, 278, 278, 278, 469, 556, 333, 556, 556, 500, 556, 556, 278, 556, 556, 222, 222, 500, 222, 833, 556, 556, 556, 556, 333, 500, 278, 556, 500, 722, 500, 500, 500, 334, 260, 334, 584, 333, 556, 556, 556, 556, 260, 556, 333, 737, 370, 556, 584, 737, 552, 400, 549, 333, 333, 333, 576, 537, 278, 333, 333, 365, 556, 834, 834, 834, 611, 667, 667, 667, 667, 667, 667, 1000, 722, 667, 667, 667, 667, 278, 278, 278, 278, 722, 722, 778, 778, 778, 778, 778, 584, 778, 722, 722, 722, 722, 667, 667, 611, 556, 556, 556, 556, 556, 556, 889, 500, 556, 556, 556, 556, 278, 278, 278, 278, 556, 556, 556, 556, 556, 556, 556, 549, 611, 556, 556, 556, 556, 500, 556, 500, 667, 556, 667, 556, 667, 556, 722, 500, 722, 500, 722, 500, 722, 500, 722, 615, 722, 556, 667, 556, 667, 556, 667, 556, 667, 556, 667, 556, 778, 556, 778, 556, 778, 556, 778, 556, 722, 556, 722, 556, 278, 278, 278, 278, 278, 278, 278, 222, 278, 278, 735, 444, 500, 222, 667, 500, 500, 556, 222, 556, 222, 556, 292, 556, 334, 556, 222, 722, 556, 722, 556, 722, 556, 604, 723, 556, 778, 556, 778, 556, 778, 556, 1000, 944, 722, 333, 722, 333, 722, 333, 667, 500, 667, 500, 667, 500, 667, 500, 611, 278, 611, 375, 611, 278, 722, 556, 722, 556, 722, 556, 722, 556, 722, 556, 722, 556, 944, 722, 667, 500, 667, 611, 500, 611, 500, 611, 500, 222, 556, 667, 556, 1000, 889, 778, 611, 667, 500, 611, 278, 333, 333, 333, 333, 333, 333, 333, 333, 333, 333, 333, 667, 278, 784, 838, 384, 774, 855, 752, 222, 667, 667, 551, 668, 667, 611, 722, 778, 278, 667, 668, 833, 722, 650, 778, 722, 667, 618, 611, 667, 798, 667, 835, 748, 278, 667, 578, 446, 556, 222, 547, 578, 575, 500, 557, 446, 441, 556, 556, 222, 500, 500, 576, 500, 448, 556, 690, 569, 482, 617, 395, 547, 648, 525, 713, 781, 222, 547, 556, 547, 781, 667, 667, 865, 542, 719, 667, 278, 278, 500, 1057, 1010, 854, 583, 722, 635, 719, 667, 656, 667, 542, 677, 667, 923, 604, 719, 719, 583, 656, 833, 722, 778, 719, 667, 722, 611, 635, 760, 667, 740, 667, 917, 938, 792, 885, 656, 719, 1010, 722, 556, 573, 531, 365, 583, 556, 669, 458, 559, 559, 438, 583, 688, 552, 556, 542, 556, 500, 458, 500, 823, 500, 573, 521, 802, 823, 625, 719, 521, 510, 750, 542, 556, 556, 556, 365, 510, 500, 222, 278, 222, 906, 812, 556, 438, 559, 500, 552, 778, 556, 489, 411, 944, 722, 944, 722, 944, 722, 667, 500, 333, 333, 556, 1000, 1000, 552, 222, 222, 222, 222, 333, 333, 333, 556, 556, 350, 1000, 1000, 188, 354, 333, 333, 500, 333, 167, 365, 556, 556, 1094, 556, 885, 323, 1073, 1000, 768, 600, 834, 834, 834, 834, 1000, 500, 1000, 500, 1000, 500, 500, 494, 612, 823, 713, 584, 549, 713, 979, 719, 274, 549, 549, 583, 549, 549, 604, 584, 604, 604, 708, 625, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 729, 604, 604, 354, 354, 1000, 990, 990, 990, 990, 494, 604, 604, 604, 604, 354, 1021, 1052, 917, 750, 750, 531, 656, 594, 510, 500, 750, 750, 500, 500, 333, 333, 333, 333, 333, 333, 333, 333, 222, 222, 294, 294, 324, 324, 316, 328, 398, 285]; exports.LiberationSansRegularWidths = LiberationSansRegularWidths; const LiberationSansRegularMapping = [-1, -1, -1, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 368, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 402, 506, 507, 508, 509, 510, 511, 536, 537, 538, 539, 710, 711, 713, 728, 729, 730, 731, 732, 733, 900, 901, 902, 903, 904, 905, 906, 908, 910, 911, 912, 913, 914, 915, 916, 917, 918, 919, 920, 921, 922, 923, 924, 925, 926, 927, 928, 929, 931, 932, 933, 934, 935, 936, 937, 938, 939, 940, 941, 942, 943, 944, 945, 946, 947, 948, 949, 950, 951, 952, 953, 954, 955, 956, 957, 958, 959, 960, 961, 962, 963, 964, 965, 966, 967, 968, 969, 970, 971, 972, 973, 974, 1024, 1025, 1026, 1027, 1028, 1029, 1030, 1031, 1032, 1033, 1034, 1035, 1036, 1037, 1038, 1039, 1040, 1041, 1042, 1043, 1044, 1045, 1046, 1047, 1048, 1049, 1050, 1051, 1052, 1053, 1054, 1055, 1056, 1057, 1058, 1059, 1060, 1061, 1062, 1063, 1064, 1065, 1066, 1067, 1068, 1069, 1070, 1071, 1072, 1073, 1074, 1075, 1076, 1077, 1078, 1079, 1080, 1081, 1082, 1083, 1084, 1085, 1086, 1087, 1088, 1089, 1090, 1091, 1092, 1093, 1094, 1095, 1096, 1097, 1098, 1099, 1100, 1101, 1102, 1103, 1104, 1105, 1106, 1107, 1108, 1109, 1110, 1111, 1112, 1113, 1114, 1115, 1116, 1117, 1118, 1119, 1138, 1139, 1168, 1169, 7808, 7809, 7810, 7811, 7812, 7813, 7922, 7923, 8208, 8209, 8211, 8212, 8213, 8215, 8216, 8217, 8218, 8219, 8220, 8221, 8222, 8224, 8225, 8226, 8230, 8240, 8242, 8243, 8249, 8250, 8252, 8254, 8260, 8319, 8355, 8356, 8359, 8364, 8453, 8467, 8470, 8482, 8486, 8494, 8539, 8540, 8541, 8542, 8592, 8593, 8594, 8595, 8596, 8597, 8616, 8706, 8710, 8719, 8721, 8722, 8730, 8734, 8735, 8745, 8747, 8776, 8800, 8801, 8804, 8805, 8962, 8976, 8992, 8993, 9472, 9474, 9484, 9488, 9492, 9496, 9500, 9508, 9516, 9524, 9532, 9552, 9553, 9554, 9555, 9556, 9557, 9558, 9559, 9560, 9561, 9562, 9563, 9564, 9565, 9566, 9567, 9568, 9569, 9570, 9571, 9572, 9573, 9574, 9575, 9576, 9577, 9578, 9579, 9580, 9600, 9604, 9608, 9612, 9616, 9617, 9618, 9619, 9632, 9633, 9642, 9643, 9644, 9650, 9658, 9660, 9668, 9674, 9675, 9679, 9688, 9689, 9702, 9786, 9787, 9788, 9792, 9794, 9824, 9827, 9829, 9830, 9834, 9835, 9836, 61441, 61442, 61445, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1]; exports.LiberationSansRegularMapping = LiberationSansRegularMapping; /***/ }), /* 53 */ /***/ ((__unused_webpack_module, exports) =&gt; { Object.defineProperty(exports, &quot;__esModule&quot;, ({ value: true })); exports.MyriadProRegularMetrics = exports.MyriadProRegularFactors = exports.MyriadProItalicMetrics = exports.MyriadProItalicFactors = exports.MyriadProBoldMetrics = exports.MyriadProBoldItalicMetrics = exports.MyriadProBoldItalicFactors = exports.MyriadProBoldFactors = void 0; const MyriadProBoldFactors = [1.36898, 1, 1, 0.72706, 0.80479, 0.83734, 0.98894, 0.99793, 0.9897, 0.93884, 0.86209, 0.94292, 0.94292, 1.16661, 1.02058, 0.93582, 0.96694, 0.93582, 1.19137, 0.99793, 0.99793, 0.99793, 0.99793, 0.99793, 0.99793, 0.99793, 0.99793, 0.99793, 0.99793, 0.78076, 0.78076, 1.02058, 1.02058, 1.02058, 0.72851, 0.78966, 0.90838, 0.83637, 0.82391, 0.96376, 0.80061, 0.86275, 0.8768, 0.95407, 1.0258, 0.73901, 0.85022, 0.83655, 1.0156, 0.95546, 0.92179, 0.87107, 0.92179, 0.82114, 0.8096, 0.89713, 0.94438, 0.95353, 0.94083, 0.91905, 0.90406, 0.9446, 0.94292, 1.18777, 0.94292, 1.02058, 0.89903, 0.90088, 0.94938, 0.97898, 0.81093, 0.97571, 0.94938, 1.024, 0.9577, 0.95933, 0.98621, 1.0474, 0.97455, 0.98981, 0.9672, 0.95933, 0.9446, 0.97898, 0.97407, 0.97646, 0.78036, 1.10208, 0.95442, 0.95298, 0.97579, 0.9332, 0.94039, 0.938, 0.80687, 1.01149, 0.80687, 1.02058, 0.80479, 0.99793, 0.99793, 0.99793, 0.99793, 1.01149, 1.00872, 0.90088, 0.91882, 1.0213, 0.8361, 1.02058, 0.62295, 0.54324, 0.89022, 1.08595, 1, 1, 0.90088, 1, 0.97455, 0.93582, 0.90088, 1, 1.05686, 0.8361, 0.99642, 0.99642, 0.99642, 0.72851, 0.90838, 0.90838, 0.90838, 0.90838, 0.90838, 0.90838, 0.868, 0.82391, 0.80061, 0.80061, 0.80061, 0.80061, 1.0258, 1.0258, 1.0258, 1.0258, 0.97484, 0.95546, 0.92179, 0.92179, 0.92179, 0.92179, 0.92179, 1.02058, 0.92179, 0.94438, 0.94438, 0.94438, 0.94438, 0.90406, 0.86958, 0.98225, 0.94938, 0.94938, 0.94938, 0.94938, 0.94938, 0.94938, 0.9031, 0.81093, 0.94938, 0.94938, 0.94938, 0.94938, 0.98621, 0.98621, 0.98621, 0.98621, 0.93969, 0.95933, 0.9446, 0.9446, 0.9446, 0.9446, 0.9446, 1.08595, 0.9446, 0.95442, 0.95442, 0.95442, 0.95442, 0.94039, 0.97898, 0.94039, 0.90838, 0.94938, 0.90838, 0.94938, 0.90838, 0.94938, 0.82391, 0.81093, 0.82391, 0.81093, 0.82391, 0.81093, 0.82391, 0.81093, 0.96376, 0.84313, 0.97484, 0.97571, 0.80061, 0.94938, 0.80061, 0.94938, 0.80061, 0.94938, 0.80061, 0.94938, 0.80061, 0.94938, 0.8768, 0.9577, 0.8768, 0.9577, 0.8768, 0.9577, 1, 1, 0.95407, 0.95933, 0.97069, 0.95933, 1.0258, 0.98621, 1.0258, 0.98621, 1.0258, 0.98621, 1.0258, 0.98621, 1.0258, 0.98621, 0.887, 1.01591, 0.73901, 1.0474, 1, 1, 0.97455, 0.83655, 0.98981, 1, 1, 0.83655, 0.73977, 0.83655, 0.73903, 0.84638, 1.033, 0.95546, 0.95933, 1, 1, 0.95546, 0.95933, 0.8271, 0.95417, 0.95933, 0.92179, 0.9446, 0.92179, 0.9446, 0.92179, 0.9446, 0.936, 0.91964, 0.82114, 0.97646, 1, 1, 0.82114, 0.97646, 0.8096, 0.78036, 0.8096, 0.78036, 1, 1, 0.8096, 0.78036, 1, 1, 0.89713, 0.77452, 0.89713, 1.10208, 0.94438, 0.95442, 0.94438, 0.95442, 0.94438, 0.95442, 0.94438, 0.95442, 0.94438, 0.95442, 0.94438, 0.95442, 0.94083, 0.97579, 0.90406, 0.94039, 0.90406, 0.9446, 0.938, 0.9446, 0.938, 0.9446, 0.938, 1, 0.99793, 0.90838, 0.94938, 0.868, 0.9031, 0.92179, 0.9446, 1, 1, 0.89713, 1.10208, 0.90088, 0.90088, 0.90088, 0.90088, 0.90088, 0.90088, 0.90088, 0.90088, 0.90088, 0.90989, 0.9358, 0.91945, 0.83181, 0.75261, 0.87992, 0.82976, 0.96034, 0.83689, 0.97268, 1.0078, 0.90838, 0.83637, 0.8019, 0.90157, 0.80061, 0.9446, 0.95407, 0.92436, 1.0258, 0.85022, 0.97153, 1.0156, 0.95546, 0.89192, 0.92179, 0.92361, 0.87107, 0.96318, 0.89713, 0.93704, 0.95638, 0.91905, 0.91709, 0.92796, 1.0258, 0.93704, 0.94836, 1.0373, 0.95933, 1.0078, 0.95871, 0.94836, 0.96174, 0.92601, 0.9498, 0.98607, 0.95776, 0.95933, 1.05453, 1.0078, 0.98275, 0.9314, 0.95617, 0.91701, 1.05993, 0.9446, 0.78367, 0.9553, 1, 0.86832, 1.0128, 0.95871, 0.99394, 0.87548, 0.96361, 0.86774, 1.0078, 0.95871, 0.9446, 0.95871, 0.86774, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.94083, 0.97579, 0.94083, 0.97579, 0.94083, 0.97579, 0.90406, 0.94039, 0.96694, 1, 0.89903, 1, 1, 1, 0.93582, 0.93582, 0.93582, 1, 0.908, 0.908, 0.918, 0.94219, 0.94219, 0.96544, 1, 1.285, 1, 1, 0.81079, 0.81079, 1, 1, 0.74854, 1, 1, 1, 1, 0.99793, 1, 1, 1, 0.65, 1, 1.36145, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.17173, 1, 0.80535, 0.76169, 1.02058, 1.0732, 1.05486, 1, 1, 1.30692, 1.08595, 1.08595, 1, 1.08595, 1.08595, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.16161, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]; exports.MyriadProBoldFactors = MyriadProBoldFactors; const MyriadProBoldMetrics = { lineHeight: 1.2, lineGap: 0.2 }; exports.MyriadProBoldMetrics = MyriadProBoldMetrics; const MyriadProBoldItalicFactors = [1.36898, 1, 1, 0.66227, 0.80779, 0.81625, 0.97276, 0.97276, 0.97733, 0.92222, 0.83266, 0.94292, 0.94292, 1.16148, 1.02058, 0.93582, 0.96694, 0.93582, 1.17337, 0.97276, 0.97276, 0.97276, 0.97276, 0.97276, 0.97276, 0.97276, 0.97276, 0.97276, 0.97276, 0.78076, 0.78076, 1.02058, 1.02058, 1.02058, 0.71541, 0.76813, 0.85576, 0.80591, 0.80729, 0.94299, 0.77512, 0.83655, 0.86523, 0.92222, 0.98621, 0.71743, 0.81698, 0.79726, 0.98558, 0.92222, 0.90637, 0.83809, 0.90637, 0.80729, 0.76463, 0.86275, 0.90699, 0.91605, 0.9154, 0.85308, 0.85458, 0.90531, 0.94292, 1.21296, 0.94292, 1.02058, 0.89903, 1.18616, 0.99613, 0.91677, 0.78216, 0.91677, 0.90083, 0.98796, 0.9135, 0.92168, 0.95381, 0.98981, 0.95298, 0.95381, 0.93459, 0.92168, 0.91513, 0.92004, 0.91677, 0.95077, 0.748, 1.04502, 0.91677, 0.92061, 0.94236, 0.89544, 0.89364, 0.9, 0.80687, 0.8578, 0.80687, 1.02058, 0.80779, 0.97276, 0.97276, 0.97276, 0.97276, 0.8578, 0.99973, 1.18616, 0.91339, 1.08074, 0.82891, 1.02058, 0.55509, 0.71526, 0.89022, 1.08595, 1, 1, 1.18616, 1, 0.96736, 0.93582, 1.18616, 1, 1.04864, 0.82711, 0.99043, 0.99043, 0.99043, 0.71541, 0.85576, 0.85576, 0.85576, 0.85576, 0.85576, 0.85576, 0.845, 0.80729, 0.77512, 0.77512, 0.77512, 0.77512, 0.98621, 0.98621, 0.98621, 0.98621, 0.95961, 0.92222, 0.90637, 0.90637, 0.90637, 0.90637, 0.90637, 1.02058, 0.90251, 0.90699, 0.90699, 0.90699, 0.90699, 0.85458, 0.83659, 0.94951, 0.99613, 0.99613, 0.99613, 0.99613, 0.99613, 0.99613, 0.85811, 0.78216, 0.90083, 0.90083, 0.90083, 0.90083, 0.95381, 0.95381, 0.95381, 0.95381, 0.9135, 0.92168, 0.91513, 0.91513, 0.91513, 0.91513, 0.91513, 1.08595, 0.91677, 0.91677, 0.91677, 0.91677, 0.91677, 0.89364, 0.92332, 0.89364, 0.85576, 0.99613, 0.85576, 0.99613, 0.85576, 0.99613, 0.80729, 0.78216, 0.80729, 0.78216, 0.80729, 0.78216, 0.80729, 0.78216, 0.94299, 0.76783, 0.95961, 0.91677, 0.77512, 0.90083, 0.77512, 0.90083, 0.77512, 0.90083, 0.77512, 0.90083, 0.77512, 0.90083, 0.86523, 0.9135, 0.86523, 0.9135, 0.86523, 0.9135, 1, 1, 0.92222, 0.92168, 0.92222, 0.92168, 0.98621, 0.95381, 0.98621, 0.95381, 0.98621, 0.95381, 0.98621, 0.95381, 0.98621, 0.95381, 0.86036, 0.97096, 0.71743, 0.98981, 1, 1, 0.95298, 0.79726, 0.95381, 1, 1, 0.79726, 0.6894, 0.79726, 0.74321, 0.81691, 1.0006, 0.92222, 0.92168, 1, 1, 0.92222, 0.92168, 0.79464, 0.92098, 0.92168, 0.90637, 0.91513, 0.90637, 0.91513, 0.90637, 0.91513, 0.909, 0.87514, 0.80729, 0.95077, 1, 1, 0.80729, 0.95077, 0.76463, 0.748, 0.76463, 0.748, 1, 1, 0.76463, 0.748, 1, 1, 0.86275, 0.72651, 0.86275, 1.04502, 0.90699, 0.91677, 0.90699, 0.91677, 0.90699, 0.91677, 0.90699, 0.91677, 0.90699, 0.91677, 0.90699, 0.91677, 0.9154, 0.94236, 0.85458, 0.89364, 0.85458, 0.90531, 0.9, 0.90531, 0.9, 0.90531, 0.9, 1, 0.97276, 0.85576, 0.99613, 0.845, 0.85811, 0.90251, 0.91677, 1, 1, 0.86275, 1.04502, 1.18616, 1.18616, 1.18616, 1.18616, 1.18616, 1.18616, 1.18616, 1.18616, 1.18616, 1.00899, 1.30628, 0.85576, 0.80178, 0.66862, 0.7927, 0.69323, 0.88127, 0.72459, 0.89711, 0.95381, 0.85576, 0.80591, 0.7805, 0.94729, 0.77512, 0.90531, 0.92222, 0.90637, 0.98621, 0.81698, 0.92655, 0.98558, 0.92222, 0.85359, 0.90637, 0.90976, 0.83809, 0.94523, 0.86275, 0.83509, 0.93157, 0.85308, 0.83392, 0.92346, 0.98621, 0.83509, 0.92886, 0.91324, 0.92168, 0.95381, 0.90646, 0.92886, 0.90557, 0.86847, 0.90276, 0.91324, 0.86842, 0.92168, 0.99531, 0.95381, 0.9224, 0.85408, 0.92699, 0.86847, 1.0051, 0.91513, 0.80487, 0.93481, 1, 0.88159, 1.05214, 0.90646, 0.97355, 0.81539, 0.89398, 0.85923, 0.95381, 0.90646, 0.91513, 0.90646, 0.85923, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.9154, 0.94236, 0.9154, 0.94236, 0.9154, 0.94236, 0.85458, 0.89364, 0.96694, 1, 0.89903, 1, 1, 1, 0.91782, 0.91782, 0.91782, 1, 0.896, 0.896, 0.896, 0.9332, 0.9332, 0.95973, 1, 1.26, 1, 1, 0.80479, 0.80178, 1, 1, 0.85633, 1, 1, 1, 1, 0.97276, 1, 1, 1, 0.698, 1, 1.36145, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.14542, 1, 0.79199, 0.78694, 1.02058, 1.03493, 1.05486, 1, 1, 1.23026, 1.08595, 1.08595, 1, 1.08595, 1.08595, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.20006, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]; exports.MyriadProBoldItalicFactors = MyriadProBoldItalicFactors; const MyriadProBoldItalicMetrics = { lineHeight: 1.2, lineGap: 0.2 }; exports.MyriadProBoldItalicMetrics = MyriadProBoldItalicMetrics; const MyriadProItalicFactors = [1.36898, 1, 1, 0.65507, 0.84943, 0.85639, 0.88465, 0.88465, 0.86936, 0.88307, 0.86948, 0.85283, 0.85283, 1.06383, 1.02058, 0.75945, 0.9219, 0.75945, 1.17337, 0.88465, 0.88465, 0.88465, 0.88465, 0.88465, 0.88465, 0.88465, 0.88465, 0.88465, 0.88465, 0.75945, 0.75945, 1.02058, 1.02058, 1.02058, 0.69046, 0.70926, 0.85158, 0.77812, 0.76852, 0.89591, 0.70466, 0.76125, 0.80094, 0.86822, 0.83864, 0.728, 0.77212, 0.79475, 0.93637, 0.87514, 0.8588, 0.76013, 0.8588, 0.72421, 0.69866, 0.77598, 0.85991, 0.80811, 0.87832, 0.78112, 0.77512, 0.8562, 1.0222, 1.18417, 1.0222, 1.27014, 0.89903, 1.15012, 0.93859, 0.94399, 0.846, 0.94399, 0.81453, 1.0186, 0.94219, 0.96017, 1.03075, 1.02175, 0.912, 1.03075, 0.96998, 0.96017, 0.93859, 0.94399, 0.94399, 0.95493, 0.746, 1.12658, 0.94578, 0.91, 0.979, 0.882, 0.882, 0.83, 0.85034, 0.83537, 0.85034, 1.02058, 0.70869, 0.88465, 0.88465, 0.88465, 0.88465, 0.83537, 0.90083, 1.15012, 0.9161, 0.94565, 0.73541, 1.02058, 0.53609, 0.69353, 0.79519, 1.08595, 1, 1, 1.15012, 1, 0.91974, 0.75945, 1.15012, 1, 0.9446, 0.73361, 0.9005, 0.9005, 0.9005, 0.62864, 0.85158, 0.85158, 0.85158, 0.85158, 0.85158, 0.85158, 0.773, 0.76852, 0.70466, 0.70466, 0.70466, 0.70466, 0.83864, 0.83864, 0.83864, 0.83864, 0.90561, 0.87514, 0.8588, 0.8588, 0.8588, 0.8588, 0.8588, 1.02058, 0.85751, 0.85991, 0.85991, 0.85991, 0.85991, 0.77512, 0.76013, 0.88075, 0.93859, 0.93859, 0.93859, 0.93859, 0.93859, 0.93859, 0.8075, 0.846, 0.81453, 0.81453, 0.81453, 0.81453, 0.82424, 0.82424, 0.82424, 0.82424, 0.9278, 0.96017, 0.93859, 0.93859, 0.93859, 0.93859, 0.93859, 1.08595, 0.8562, 0.94578, 0.94578, 0.94578, 0.94578, 0.882, 0.94578, 0.882, 0.85158, 0.93859, 0.85158, 0.93859, 0.85158, 0.93859, 0.76852, 0.846, 0.76852, 0.846, 0.76852, 0.846, 0.76852, 0.846, 0.89591, 0.8544, 0.90561, 0.94399, 0.70466, 0.81453, 0.70466, 0.81453, 0.70466, 0.81453, 0.70466, 0.81453, 0.70466, 0.81453, 0.80094, 0.94219, 0.80094, 0.94219, 0.80094, 0.94219, 1, 1, 0.86822, 0.96017, 0.86822, 0.96017, 0.83864, 0.82424, 0.83864, 0.82424, 0.83864, 0.82424, 0.83864, 1.03075, 0.83864, 0.82424, 0.81402, 1.02738, 0.728, 1.02175, 1, 1, 0.912, 0.79475, 1.03075, 1, 1, 0.79475, 0.83911, 0.79475, 0.66266, 0.80553, 1.06676, 0.87514, 0.96017, 1, 1, 0.87514, 0.96017, 0.86865, 0.87396, 0.96017, 0.8588, 0.93859, 0.8588, 0.93859, 0.8588, 0.93859, 0.867, 0.84759, 0.72421, 0.95493, 1, 1, 0.72421, 0.95493, 0.69866, 0.746, 0.69866, 0.746, 1, 1, 0.69866, 0.746, 1, 1, 0.77598, 0.88417, 0.77598, 1.12658, 0.85991, 0.94578, 0.85991, 0.94578, 0.85991, 0.94578, 0.85991, 0.94578, 0.85991, 0.94578, 0.85991, 0.94578, 0.87832, 0.979, 0.77512, 0.882, 0.77512, 0.8562, 0.83, 0.8562, 0.83, 0.8562, 0.83, 1, 0.88465, 0.85158, 0.93859, 0.773, 0.8075, 0.85751, 0.8562, 1, 1, 0.77598, 1.12658, 1.15012, 1.15012, 1.15012, 1.15012, 1.15012, 1.15313, 1.15012, 1.15012, 1.15012, 1.08106, 1.03901, 0.85158, 0.77025, 0.62264, 0.7646, 0.65351, 0.86026, 0.69461, 0.89947, 1.03075, 0.85158, 0.77812, 0.76449, 0.88836, 0.70466, 0.8562, 0.86822, 0.8588, 0.83864, 0.77212, 0.85308, 0.93637, 0.87514, 0.82352, 0.8588, 0.85701, 0.76013, 0.89058, 0.77598, 0.8156, 0.82565, 0.78112, 0.77899, 0.89386, 0.83864, 0.8156, 0.9486, 0.92388, 0.96186, 1.03075, 0.91123, 0.9486, 0.93298, 0.878, 0.93942, 0.92388, 0.84596, 0.96186, 0.95119, 1.03075, 0.922, 0.88787, 0.95829, 0.88, 0.93559, 0.93859, 0.78815, 0.93758, 1, 0.89217, 1.03737, 0.91123, 0.93969, 0.77487, 0.85769, 0.86799, 1.03075, 0.91123, 0.93859, 0.91123, 0.86799, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.87832, 0.979, 0.87832, 0.979, 0.87832, 0.979, 0.77512, 0.882, 0.9219, 1, 0.89903, 1, 1, 1, 0.87321, 0.87321, 0.87321, 1, 1.027, 1.027, 1.027, 0.86847, 0.86847, 0.79121, 1, 1.124, 1, 1, 0.73572, 0.73572, 1, 1, 0.85034, 1, 1, 1, 1, 0.88465, 1, 1, 1, 0.669, 1, 1.36145, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.04828, 1, 0.74948, 0.75187, 1.02058, 0.98391, 1.02119, 1, 1, 1.06233, 1.08595, 1.08595, 1, 1.08595, 1.08595, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.05233, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]; exports.MyriadProItalicFactors = MyriadProItalicFactors; const MyriadProItalicMetrics = { lineHeight: 1.2, lineGap: 0.2 }; exports.MyriadProItalicMetrics = MyriadProItalicMetrics; const MyriadProRegularFactors = [1.36898, 1, 1, 0.76305, 0.82784, 0.94935, 0.89364, 0.92241, 0.89073, 0.90706, 0.98472, 0.85283, 0.85283, 1.0664, 1.02058, 0.74505, 0.9219, 0.74505, 1.23456, 0.92241, 0.92241, 0.92241, 0.92241, 0.92241, 0.92241, 0.92241, 0.92241, 0.92241, 0.92241, 0.74505, 0.74505, 1.02058, 1.02058, 1.02058, 0.73002, 0.72601, 0.91755, 0.8126, 0.80314, 0.92222, 0.73764, 0.79726, 0.83051, 0.90284, 0.86023, 0.74, 0.8126, 0.84869, 0.96518, 0.91115, 0.8858, 0.79761, 0.8858, 0.74498, 0.73914, 0.81363, 0.89591, 0.83659, 0.89633, 0.85608, 0.8111, 0.90531, 1.0222, 1.22736, 1.0222, 1.27014, 0.89903, 0.90088, 0.86667, 1.0231, 0.896, 1.01411, 0.90083, 1.05099, 1.00512, 0.99793, 1.05326, 1.09377, 0.938, 1.06226, 1.00119, 0.99793, 0.98714, 1.0231, 1.01231, 0.98196, 0.792, 1.19137, 0.99074, 0.962, 1.01915, 0.926, 0.942, 0.856, 0.85034, 0.92006, 0.85034, 1.02058, 0.69067, 0.92241, 0.92241, 0.92241, 0.92241, 0.92006, 0.9332, 0.90088, 0.91882, 0.93484, 0.75339, 1.02058, 0.56866, 0.54324, 0.79519, 1.08595, 1, 1, 0.90088, 1, 0.95325, 0.74505, 0.90088, 1, 0.97198, 0.75339, 0.91009, 0.91009, 0.91009, 0.66466, 0.91755, 0.91755, 0.91755, 0.91755, 0.91755, 0.91755, 0.788, 0.80314, 0.73764, 0.73764, 0.73764, 0.73764, 0.86023, 0.86023, 0.86023, 0.86023, 0.92915, 0.91115, 0.8858, 0.8858, 0.8858, 0.8858, 0.8858, 1.02058, 0.8858, 0.89591, 0.89591, 0.89591, 0.89591, 0.8111, 0.79611, 0.89713, 0.86667, 0.86667, 0.86667, 0.86667, 0.86667, 0.86667, 0.86936, 0.896, 0.90083, 0.90083, 0.90083, 0.90083, 0.84224, 0.84224, 0.84224, 0.84224, 0.97276, 0.99793, 0.98714, 0.98714, 0.98714, 0.98714, 0.98714, 1.08595, 0.89876, 0.99074, 0.99074, 0.99074, 0.99074, 0.942, 1.0231, 0.942, 0.91755, 0.86667, 0.91755, 0.86667, 0.91755, 0.86667, 0.80314, 0.896, 0.80314, 0.896, 0.80314, 0.896, 0.80314, 0.896, 0.92222, 0.93372, 0.92915, 1.01411, 0.73764, 0.90083, 0.73764, 0.90083, 0.73764, 0.90083, 0.73764, 0.90083, 0.73764, 0.90083, 0.83051, 1.00512, 0.83051, 1.00512, 0.83051, 1.00512, 1, 1, 0.90284, 0.99793, 0.90976, 0.99793, 0.86023, 0.84224, 0.86023, 0.84224, 0.86023, 0.84224, 0.86023, 1.05326, 0.86023, 0.84224, 0.82873, 1.07469, 0.74, 1.09377, 1, 1, 0.938, 0.84869, 1.06226, 1, 1, 0.84869, 0.83704, 0.84869, 0.81441, 0.85588, 1.08927, 0.91115, 0.99793, 1, 1, 0.91115, 0.99793, 0.91887, 0.90991, 0.99793, 0.8858, 0.98714, 0.8858, 0.98714, 0.8858, 0.98714, 0.894, 0.91434, 0.74498, 0.98196, 1, 1, 0.74498, 0.98196, 0.73914, 0.792, 0.73914, 0.792, 1, 1, 0.73914, 0.792, 1, 1, 0.81363, 0.904, 0.81363, 1.19137, 0.89591, 0.99074, 0.89591, 0.99074, 0.89591, 0.99074, 0.89591, 0.99074, 0.89591, 0.99074, 0.89591, 0.99074, 0.89633, 1.01915, 0.8111, 0.942, 0.8111, 0.90531, 0.856, 0.90531, 0.856, 0.90531, 0.856, 1, 0.92241, 0.91755, 0.86667, 0.788, 0.86936, 0.8858, 0.89876, 1, 1, 0.81363, 1.19137, 0.90088, 0.90088, 0.90088, 0.90088, 0.90088, 0.90088, 0.90088, 0.90088, 0.90088, 0.90388, 1.03901, 0.92138, 0.78105, 0.7154, 0.86169, 0.80513, 0.94007, 0.82528, 0.98612, 1.06226, 0.91755, 0.8126, 0.81884, 0.92819, 0.73764, 0.90531, 0.90284, 0.8858, 0.86023, 0.8126, 0.91172, 0.96518, 0.91115, 0.83089, 0.8858, 0.87791, 0.79761, 0.89297, 0.81363, 0.88157, 0.89992, 0.85608, 0.81992, 0.94307, 0.86023, 0.88157, 0.95308, 0.98699, 0.99793, 1.06226, 0.95817, 0.95308, 0.97358, 0.928, 0.98088, 0.98699, 0.92761, 0.99793, 0.96017, 1.06226, 0.986, 0.944, 0.95978, 0.938, 0.96705, 0.98714, 0.80442, 0.98972, 1, 0.89762, 1.04552, 0.95817, 0.99007, 0.87064, 0.91879, 0.88888, 1.06226, 0.95817, 0.98714, 0.95817, 0.88888, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.89633, 1.01915, 0.89633, 1.01915, 0.89633, 1.01915, 0.8111, 0.942, 0.9219, 1, 0.89903, 1, 1, 1, 0.93173, 0.93173, 0.93173, 1, 1.06304, 1.06304, 1.06904, 0.89903, 0.89903, 0.80549, 1, 1.156, 1, 1, 0.76575, 0.76575, 1, 1, 0.72458, 1, 1, 1, 1, 0.92241, 1, 1, 1, 0.619, 1, 1.36145, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.07257, 1, 0.74705, 0.71119, 1.02058, 1.024, 1.02119, 1, 1, 1.1536, 1.08595, 1.08595, 1, 1.08595, 1.08595, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.05638, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]; exports.MyriadProRegularFactors = MyriadProRegularFactors; const MyriadProRegularMetrics = { lineHeight: 1.2, lineGap: 0.2 }; exports.MyriadProRegularMetrics = MyriadProRegularMetrics; /***/ }), /* 54 */ /***/ ((__unused_webpack_module, exports) =&gt; { Object.defineProperty(exports, &quot;__esModule&quot;, ({ value: true })); exports.SegoeuiRegularMetrics = exports.SegoeuiRegularFactors = exports.SegoeuiItalicMetrics = exports.SegoeuiItalicFactors = exports.SegoeuiBoldMetrics = exports.SegoeuiBoldItalicMetrics = exports.SegoeuiBoldItalicFactors = exports.SegoeuiBoldFactors = void 0; const SegoeuiBoldFactors = [1.76738, 1, 1, 0.99297, 0.9824, 1.04016, 1.06497, 1.03424, 0.97529, 1.17647, 1.23203, 1.1085, 1.1085, 1.16939, 1.2107, 0.9754, 1.21408, 0.9754, 1.59578, 1.03424, 1.03424, 1.03424, 1.03424, 1.03424, 1.03424, 1.03424, 1.03424, 1.03424, 1.03424, 0.81378, 0.81378, 1.2107, 1.2107, 1.2107, 0.71703, 0.97847, 0.97363, 0.88776, 0.8641, 1.02096, 0.79795, 0.85132, 0.914, 1.06085, 1.1406, 0.8007, 0.89858, 0.83693, 1.14889, 1.09398, 0.97489, 0.92094, 0.97489, 0.90399, 0.84041, 0.95923, 1.00135, 1, 1.06467, 0.98243, 0.90996, 0.99361, 1.1085, 1.56942, 1.1085, 1.2107, 0.74627, 0.94282, 0.96752, 1.01519, 0.86304, 1.01359, 0.97278, 1.15103, 1.01359, 0.98561, 1.02285, 1.02285, 1.00527, 1.02285, 1.0302, 0.99041, 1.0008, 1.01519, 1.01359, 1.02258, 0.79104, 1.16862, 0.99041, 0.97454, 1.02511, 0.99298, 0.96752, 0.95801, 0.94856, 1.16579, 0.94856, 1.2107, 0.9824, 1.03424, 1.03424, 1, 1.03424, 1.16579, 0.8727, 1.3871, 1.18622, 1.10818, 1.04478, 1.2107, 1.18622, 0.75155, 0.94994, 1.28826, 1.21408, 1.21408, 0.91056, 1, 0.91572, 0.9754, 0.64663, 1.18328, 1.24866, 1.04478, 1.14169, 1.15749, 1.17389, 0.71703, 0.97363, 0.97363, 0.97363, 0.97363, 0.97363, 0.97363, 0.93506, 0.8641, 0.79795, 0.79795, 0.79795, 0.79795, 1.1406, 1.1406, 1.1406, 1.1406, 1.02096, 1.09398, 0.97426, 0.97426, 0.97426, 0.97426, 0.97426, 1.2107, 0.97489, 1.00135, 1.00135, 1.00135, 1.00135, 0.90996, 0.92094, 1.02798, 0.96752, 0.96752, 0.96752, 0.96752, 0.96752, 0.96752, 0.93136, 0.86304, 0.97278, 0.97278, 0.97278, 0.97278, 1.02285, 1.02285, 1.02285, 1.02285, 0.97122, 0.99041, 1, 1, 1, 1, 1, 1.28826, 1.0008, 0.99041, 0.99041, 0.99041, 0.99041, 0.96752, 1.01519, 0.96752, 0.97363, 0.96752, 0.97363, 0.96752, 0.97363, 0.96752, 0.8641, 0.86304, 0.8641, 0.86304, 0.8641, 0.86304, 0.8641, 0.86304, 1.02096, 1.03057, 1.02096, 1.03517, 0.79795, 0.97278, 0.79795, 0.97278, 0.79795, 0.97278, 0.79795, 0.97278, 0.79795, 0.97278, 0.914, 1.01359, 0.914, 1.01359, 0.914, 1.01359, 1, 1, 1.06085, 0.98561, 1.06085, 1.00879, 1.1406, 1.02285, 1.1406, 1.02285, 1.1406, 1.02285, 1.1406, 1.02285, 1.1406, 1.02285, 0.97138, 1.08692, 0.8007, 1.02285, 1, 1, 1.00527, 0.83693, 1.02285, 1, 1, 0.83693, 0.9455, 0.83693, 0.90418, 0.83693, 1.13005, 1.09398, 0.99041, 1, 1, 1.09398, 0.99041, 0.96692, 1.09251, 0.99041, 0.97489, 1.0008, 0.97489, 1.0008, 0.97489, 1.0008, 0.93994, 0.97931, 0.90399, 1.02258, 1, 1, 0.90399, 1.02258, 0.84041, 0.79104, 0.84041, 0.79104, 0.84041, 0.79104, 0.84041, 0.79104, 1, 1, 0.95923, 1.07034, 0.95923, 1.16862, 1.00135, 0.99041, 1.00135, 0.99041, 1.00135, 0.99041, 1.00135, 0.99041, 1.00135, 0.99041, 1.00135, 0.99041, 1.06467, 1.02511, 0.90996, 0.96752, 0.90996, 0.99361, 0.95801, 0.99361, 0.95801, 0.99361, 0.95801, 1.07733, 1.03424, 0.97363, 0.96752, 0.93506, 0.93136, 0.97489, 1.0008, 1, 1, 0.95923, 1.16862, 1.15103, 1.15103, 1.01173, 1.03959, 0.75953, 0.81378, 0.79912, 1.15103, 1.21994, 0.95161, 0.87815, 1.01149, 0.81525, 0.7676, 0.98167, 1.01134, 1.02546, 0.84097, 1.03089, 1.18102, 0.97363, 0.88776, 0.85134, 0.97826, 0.79795, 0.99361, 1.06085, 0.97489, 1.1406, 0.89858, 1.0388, 1.14889, 1.09398, 0.86039, 0.97489, 1.0595, 0.92094, 0.94793, 0.95923, 0.90996, 0.99346, 0.98243, 1.02112, 0.95493, 1.1406, 0.90996, 1.03574, 1.02597, 1.0008, 1.18102, 1.06628, 1.03574, 1.0192, 1.01932, 1.00886, 0.97531, 1.0106, 1.0008, 1.13189, 1.18102, 1.02277, 0.98683, 1.0016, 0.99561, 1.07237, 1.0008, 0.90434, 0.99921, 0.93803, 0.8965, 1.23085, 1.06628, 1.04983, 0.96268, 1.0499, 0.98439, 1.18102, 1.06628, 1.0008, 1.06628, 0.98439, 0.79795, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.09466, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.97278, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.02065, 1, 1, 1, 1, 1, 1, 1.06467, 1.02511, 1.06467, 1.02511, 1.06467, 1.02511, 0.90996, 0.96752, 1, 1.21408, 0.89903, 1, 1, 0.75155, 1.04394, 1.04394, 1.04394, 1.04394, 0.98633, 0.98633, 0.98633, 0.73047, 0.73047, 1.20642, 0.91211, 1.25635, 1.222, 1.02956, 1.03372, 1.03372, 0.96039, 1.24633, 1, 1.12454, 0.93503, 1.03424, 1.19687, 1.03424, 1, 1, 1, 0.771, 1, 1, 1.15749, 1.15749, 1.15749, 1.10948, 0.86279, 0.94434, 0.86279, 0.94434, 0.86182, 1, 1, 1.16897, 1, 0.96085, 0.90137, 1.2107, 1.18416, 1.13973, 0.69825, 0.9716, 2.10339, 1.29004, 1.29004, 1.21172, 1.29004, 1.29004, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.42603, 1, 0.99862, 0.99862, 1, 0.87025, 0.87025, 0.87025, 0.87025, 1.18874, 1.42603, 1, 1.42603, 1.42603, 0.99862, 1, 1, 1, 1, 1, 1.2886, 1.04315, 1.15296, 1.34163, 1, 1, 1, 1.09193, 1.09193, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]; exports.SegoeuiBoldFactors = SegoeuiBoldFactors; const SegoeuiBoldMetrics = { lineHeight: 1.33008, lineGap: 0 }; exports.SegoeuiBoldMetrics = SegoeuiBoldMetrics; const SegoeuiBoldItalicFactors = [1.76738, 1, 1, 0.98946, 1.03959, 1.04016, 1.02809, 1.036, 0.97639, 1.10953, 1.23203, 1.11144, 1.11144, 1.16939, 1.21237, 0.9754, 1.21261, 0.9754, 1.59754, 1.036, 1.036, 1.036, 1.036, 1.036, 1.036, 1.036, 1.036, 1.036, 1.036, 0.81378, 0.81378, 1.21237, 1.21237, 1.21237, 0.73541, 0.97847, 0.97363, 0.89723, 0.87897, 1.0426, 0.79429, 0.85292, 0.91149, 1.05815, 1.1406, 0.79631, 0.90128, 0.83853, 1.04396, 1.10615, 0.97552, 0.94436, 0.97552, 0.88641, 0.80527, 0.96083, 1.00135, 1, 1.06777, 0.9817, 0.91142, 0.99361, 1.11144, 1.57293, 1.11144, 1.21237, 0.74627, 1.31818, 1.06585, 0.97042, 0.83055, 0.97042, 0.93503, 1.1261, 0.97042, 0.97922, 1.14236, 0.94552, 1.01054, 1.14236, 1.02471, 0.97922, 0.94165, 0.97042, 0.97042, 1.0276, 0.78929, 1.1261, 0.97922, 0.95874, 1.02197, 0.98507, 0.96752, 0.97168, 0.95107, 1.16579, 0.95107, 1.21237, 1.03959, 1.036, 1.036, 1, 1.036, 1.16579, 0.87357, 1.31818, 1.18754, 1.26781, 1.05356, 1.21237, 1.18622, 0.79487, 0.94994, 1.29004, 1.24047, 1.24047, 1.31818, 1, 0.91484, 0.9754, 1.31818, 1.1349, 1.24866, 1.05356, 1.13934, 1.15574, 1.17389, 0.73541, 0.97363, 0.97363, 0.97363, 0.97363, 0.97363, 0.97363, 0.94385, 0.87897, 0.79429, 0.79429, 0.79429, 0.79429, 1.1406, 1.1406, 1.1406, 1.1406, 1.0426, 1.10615, 0.97552, 0.97552, 0.97552, 0.97552, 0.97552, 1.21237, 0.97552, 1.00135, 1.00135, 1.00135, 1.00135, 0.91142, 0.94436, 0.98721, 1.06585, 1.06585, 1.06585, 1.06585, 1.06585, 1.06585, 0.96705, 0.83055, 0.93503, 0.93503, 0.93503, 0.93503, 1.14236, 1.14236, 1.14236, 1.14236, 0.93125, 0.97922, 0.94165, 0.94165, 0.94165, 0.94165, 0.94165, 1.29004, 0.94165, 0.97922, 0.97922, 0.97922, 0.97922, 0.96752, 0.97042, 0.96752, 0.97363, 1.06585, 0.97363, 1.06585, 0.97363, 1.06585, 0.87897, 0.83055, 0.87897, 0.83055, 0.87897, 0.83055, 0.87897, 0.83055, 1.0426, 1.0033, 1.0426, 0.97042, 0.79429, 0.93503, 0.79429, 0.93503, 0.79429, 0.93503, 0.79429, 0.93503, 0.79429, 0.93503, 0.91149, 0.97042, 0.91149, 0.97042, 0.91149, 0.97042, 1, 1, 1.05815, 0.97922, 1.05815, 0.97922, 1.1406, 1.14236, 1.1406, 1.14236, 1.1406, 1.14236, 1.1406, 1.14236, 1.1406, 1.14236, 0.97441, 1.04302, 0.79631, 1.01582, 1, 1, 1.01054, 0.83853, 1.14236, 1, 1, 0.83853, 1.09125, 0.83853, 0.90418, 0.83853, 1.19508, 1.10615, 0.97922, 1, 1, 1.10615, 0.97922, 1.01034, 1.10466, 0.97922, 0.97552, 0.94165, 0.97552, 0.94165, 0.97552, 0.94165, 0.91602, 0.91981, 0.88641, 1.0276, 1, 1, 0.88641, 1.0276, 0.80527, 0.78929, 0.80527, 0.78929, 0.80527, 0.78929, 0.80527, 0.78929, 1, 1, 0.96083, 1.05403, 0.95923, 1.16862, 1.00135, 0.97922, 1.00135, 0.97922, 1.00135, 0.97922, 1.00135, 0.97922, 1.00135, 0.97922, 1.00135, 0.97922, 1.06777, 1.02197, 0.91142, 0.96752, 0.91142, 0.99361, 0.97168, 0.99361, 0.97168, 0.99361, 0.97168, 1.23199, 1.036, 0.97363, 1.06585, 0.94385, 0.96705, 0.97552, 0.94165, 1, 1, 0.96083, 1.1261, 1.31818, 1.31818, 1.31818, 1.31818, 1.31818, 1.31818, 1.31818, 1.31818, 1.31818, 0.95161, 1.27126, 1.00811, 0.83284, 0.77702, 0.99137, 0.95253, 1.0347, 0.86142, 1.07205, 1.14236, 0.97363, 0.89723, 0.86869, 1.09818, 0.79429, 0.99361, 1.05815, 0.97552, 1.1406, 0.90128, 1.06662, 1.04396, 1.10615, 0.84918, 0.97552, 1.04694, 0.94436, 0.98015, 0.96083, 0.91142, 1.00356, 0.9817, 1.01945, 0.98999, 1.1406, 0.91142, 1.04961, 0.9898, 1.00639, 1.14236, 1.07514, 1.04961, 0.99607, 1.02897, 1.008, 0.9898, 0.95134, 1.00639, 1.11121, 1.14236, 1.00518, 0.97981, 1.02186, 1, 1.08578, 0.94165, 0.99314, 0.98387, 0.93028, 0.93377, 1.35125, 1.07514, 1.10687, 0.93491, 1.04232, 1.00351, 1.14236, 1.07514, 0.94165, 1.07514, 1.00351, 0.79429, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.09097, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.93503, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.96609, 1, 1, 1, 1, 1, 1, 1.06777, 1.02197, 1.06777, 1.02197, 1.06777, 1.02197, 0.91142, 0.96752, 1, 1.21261, 0.89903, 1, 1, 0.75155, 1.04745, 1.04745, 1.04745, 1.04394, 0.98633, 0.98633, 0.98633, 0.72959, 0.72959, 1.20502, 0.91406, 1.26514, 1.222, 1.02956, 1.03372, 1.03372, 0.96039, 1.24633, 1, 1.09125, 0.93327, 1.03336, 1.16541, 1.036, 1, 1, 1, 0.771, 1, 1, 1.15574, 1.15574, 1.15574, 1.15574, 0.86364, 0.94434, 0.86279, 0.94434, 0.86224, 1, 1, 1.16798, 1, 0.96085, 0.90068, 1.21237, 1.18416, 1.13904, 0.69825, 0.9716, 2.10339, 1.29004, 1.29004, 1.21339, 1.29004, 1.29004, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.42603, 1, 0.99862, 0.99862, 1, 0.87025, 0.87025, 0.87025, 0.87025, 1.18775, 1.42603, 1, 1.42603, 1.42603, 0.99862, 1, 1, 1, 1, 1, 1.2886, 1.04315, 1.15296, 1.34163, 1, 1, 1, 1.13269, 1.13269, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]; exports.SegoeuiBoldItalicFactors = SegoeuiBoldItalicFactors; const SegoeuiBoldItalicMetrics = { lineHeight: 1.33008, lineGap: 0 }; exports.SegoeuiBoldItalicMetrics = SegoeuiBoldItalicMetrics; const SegoeuiItalicFactors = [1.76738, 1, 1, 0.98946, 1.14763, 1.05365, 1.06234, 0.96927, 0.92586, 1.15373, 1.18414, 0.91349, 0.91349, 1.07403, 1.17308, 0.78383, 1.20088, 0.78383, 1.42531, 0.96927, 0.96927, 0.96927, 0.96927, 0.96927, 0.96927, 0.96927, 0.96927, 0.96927, 0.96927, 0.78383, 0.78383, 1.17308, 1.17308, 1.17308, 0.77349, 0.94565, 0.94729, 0.85944, 0.88506, 0.9858, 0.74817, 0.80016, 0.88449, 0.98039, 0.95782, 0.69238, 0.89898, 0.83231, 0.98183, 1.03989, 0.96924, 0.86237, 0.96924, 0.80595, 0.74524, 0.86091, 0.95402, 0.94143, 0.98448, 0.8858, 0.83089, 0.93285, 1.0949, 1.39016, 1.0949, 1.45994, 0.74627, 1.04839, 0.97454, 0.97454, 0.87207, 0.97454, 0.87533, 1.06151, 0.97454, 1.00176, 1.16484, 1.08132, 0.98047, 1.16484, 1.02989, 1.01054, 0.96225, 0.97454, 0.97454, 1.06598, 0.79004, 1.16344, 1.00351, 0.94629, 0.9973, 0.91016, 0.96777, 0.9043, 0.91082, 0.92481, 0.91082, 1.17308, 0.95748, 0.96927, 0.96927, 1, 0.96927, 0.92481, 0.80597, 1.04839, 1.23393, 1.1781, 0.9245, 1.17308, 1.20808, 0.63218, 0.94261, 1.24822, 1.09971, 1.09971, 1.04839, 1, 0.85273, 0.78032, 1.04839, 1.09971, 1.22326, 0.9245, 1.09836, 1.13525, 1.15222, 0.70424, 0.94729, 0.94729, 0.94729, 0.94729, 0.94729, 0.94729, 0.85498, 0.88506, 0.74817, 0.74817, 0.74817, 0.74817, 0.95782, 0.95782, 0.95782, 0.95782, 0.9858, 1.03989, 0.96924, 0.96924, 0.96924, 0.96924, 0.96924, 1.17308, 0.96924, 0.95402, 0.95402, 0.95402, 0.95402, 0.83089, 0.86237, 0.88409, 0.97454, 0.97454, 0.97454, 0.97454, 0.97454, 0.97454, 0.92916, 0.87207, 0.87533, 0.87533, 0.87533, 0.87533, 0.93146, 0.93146, 0.93146, 0.93146, 0.93854, 1.01054, 0.96225, 0.96225, 0.96225, 0.96225, 0.96225, 1.24822, 0.8761, 1.00351, 1.00351, 1.00351, 1.00351, 0.96777, 0.97454, 0.96777, 0.94729, 0.97454, 0.94729, 0.97454, 0.94729, 0.97454, 0.88506, 0.87207, 0.88506, 0.87207, 0.88506, 0.87207, 0.88506, 0.87207, 0.9858, 0.95391, 0.9858, 0.97454, 0.74817, 0.87533, 0.74817, 0.87533, 0.74817, 0.87533, 0.74817, 0.87533, 0.74817, 0.87533, 0.88449, 0.97454, 0.88449, 0.97454, 0.88449, 0.97454, 1, 1, 0.98039, 1.00176, 0.98039, 1.00176, 0.95782, 0.93146, 0.95782, 0.93146, 0.95782, 0.93146, 0.95782, 1.16484, 0.95782, 0.93146, 0.84421, 1.12761, 0.69238, 1.08132, 1, 1, 0.98047, 0.83231, 1.16484, 1, 1, 0.84723, 1.04861, 0.84723, 0.78755, 0.83231, 1.23736, 1.03989, 1.01054, 1, 1, 1.03989, 1.01054, 0.9857, 1.03849, 1.01054, 0.96924, 0.96225, 0.96924, 0.96225, 0.96924, 0.96225, 0.92383, 0.90171, 0.80595, 1.06598, 1, 1, 0.80595, 1.06598, 0.74524, 0.79004, 0.74524, 0.79004, 0.74524, 0.79004, 0.74524, 0.79004, 1, 1, 0.86091, 1.02759, 0.85771, 1.16344, 0.95402, 1.00351, 0.95402, 1.00351, 0.95402, 1.00351, 0.95402, 1.00351, 0.95402, 1.00351, 0.95402, 1.00351, 0.98448, 0.9973, 0.83089, 0.96777, 0.83089, 0.93285, 0.9043, 0.93285, 0.9043, 0.93285, 0.9043, 1.31868, 0.96927, 0.94729, 0.97454, 0.85498, 0.92916, 0.96924, 0.8761, 1, 1, 0.86091, 1.16344, 1.04839, 1.04839, 1.04839, 1.04839, 1.04839, 1.04839, 1.04839, 1.04839, 1.04839, 0.81965, 0.81965, 0.94729, 0.78032, 0.71022, 0.90883, 0.84171, 0.99877, 0.77596, 1.05734, 1.2, 0.94729, 0.85944, 0.82791, 0.9607, 0.74817, 0.93285, 0.98039, 0.96924, 0.95782, 0.89898, 0.98316, 0.98183, 1.03989, 0.78614, 0.96924, 0.97642, 0.86237, 0.86075, 0.86091, 0.83089, 0.90082, 0.8858, 0.97296, 1.01284, 0.95782, 0.83089, 1.0976, 1.04, 1.03342, 1.2, 1.0675, 1.0976, 0.98205, 1.03809, 1.05097, 1.04, 0.95364, 1.03342, 1.05401, 1.2, 1.02148, 1.0119, 1.04724, 1.0127, 1.02732, 0.96225, 0.8965, 0.97783, 0.93574, 0.94818, 1.30679, 1.0675, 1.11826, 0.99821, 1.0557, 1.0326, 1.2, 1.0675, 0.96225, 1.0675, 1.0326, 0.74817, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.03754, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.87533, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.98705, 1, 1, 1, 1, 1, 1, 0.98448, 0.9973, 0.98448, 0.9973, 0.98448, 0.9973, 0.83089, 0.96777, 1, 1.20088, 0.89903, 1, 1, 0.75155, 0.94945, 0.94945, 0.94945, 0.94945, 1.12317, 1.12317, 1.12317, 0.67603, 0.67603, 1.15621, 0.73584, 1.21191, 1.22135, 1.06483, 0.94868, 0.94868, 0.95996, 1.24633, 1, 1.07497, 0.87709, 0.96927, 1.01473, 0.96927, 1, 1, 1, 0.77295, 1, 1, 1.09836, 1.09836, 1.09836, 1.01522, 0.86321, 0.94434, 0.8649, 0.94434, 0.86182, 1, 1, 1.083, 1, 0.91578, 0.86438, 1.17308, 1.18416, 1.14589, 0.69825, 0.97622, 1.96791, 1.24822, 1.24822, 1.17308, 1.24822, 1.24822, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.42603, 1, 0.99862, 0.99862, 1, 0.87025, 0.87025, 0.87025, 0.87025, 1.17984, 1.42603, 1, 1.42603, 1.42603, 0.99862, 1, 1, 1, 1, 1, 1.2886, 1.04315, 1.15296, 1.34163, 1, 1, 1, 1.10742, 1.10742, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]; exports.SegoeuiItalicFactors = SegoeuiItalicFactors; const SegoeuiItalicMetrics = { lineHeight: 1.33008, lineGap: 0 }; exports.SegoeuiItalicMetrics = SegoeuiItalicMetrics; const SegoeuiRegularFactors = [1.76738, 1, 1, 0.98594, 1.02285, 1.10454, 1.06234, 0.96927, 0.92037, 1.19985, 1.2046, 0.90616, 0.90616, 1.07152, 1.1714, 0.78032, 1.20088, 0.78032, 1.40246, 0.96927, 0.96927, 0.96927, 0.96927, 0.96927, 0.96927, 0.96927, 0.96927, 0.96927, 0.96927, 0.78032, 0.78032, 1.1714, 1.1714, 1.1714, 0.80597, 0.94084, 0.96706, 0.85944, 0.85734, 0.97093, 0.75842, 0.79936, 0.88198, 0.9831, 0.95782, 0.71387, 0.86969, 0.84636, 1.07796, 1.03584, 0.96924, 0.83968, 0.96924, 0.82826, 0.79649, 0.85771, 0.95132, 0.93119, 0.98965, 0.88433, 0.8287, 0.93365, 1.08612, 1.3638, 1.08612, 1.45786, 0.74627, 0.80499, 0.91484, 1.05707, 0.92383, 1.05882, 0.9403, 1.12654, 1.05882, 1.01756, 1.09011, 1.09011, 0.99414, 1.09011, 1.034, 1.01756, 1.05356, 1.05707, 1.05882, 1.04399, 0.84863, 1.21968, 1.01756, 0.95801, 1.00068, 0.91797, 0.96777, 0.9043, 0.90351, 0.92105, 0.90351, 1.1714, 0.85337, 0.96927, 0.96927, 0.99912, 0.96927, 0.92105, 0.80597, 1.2434, 1.20808, 1.05937, 0.90957, 1.1714, 1.20808, 0.75155, 0.94261, 1.24644, 1.09971, 1.09971, 0.84751, 1, 0.85273, 0.78032, 0.61584, 1.05425, 1.17914, 0.90957, 1.08665, 1.11593, 1.14169, 0.73381, 0.96706, 0.96706, 0.96706, 0.96706, 0.96706, 0.96706, 0.86035, 0.85734, 0.75842, 0.75842, 0.75842, 0.75842, 0.95782, 0.95782, 0.95782, 0.95782, 0.97093, 1.03584, 0.96924, 0.96924, 0.96924, 0.96924, 0.96924, 1.1714, 0.96924, 0.95132, 0.95132, 0.95132, 0.95132, 0.8287, 0.83968, 0.89049, 0.91484, 0.91484, 0.91484, 0.91484, 0.91484, 0.91484, 0.93575, 0.92383, 0.9403, 0.9403, 0.9403, 0.9403, 0.8717, 0.8717, 0.8717, 0.8717, 1.00527, 1.01756, 1.05356, 1.05356, 1.05356, 1.05356, 1.05356, 1.24644, 0.95923, 1.01756, 1.01756, 1.01756, 1.01756, 0.96777, 1.05707, 0.96777, 0.96706, 0.91484, 0.96706, 0.91484, 0.96706, 0.91484, 0.85734, 0.92383, 0.85734, 0.92383, 0.85734, 0.92383, 0.85734, 0.92383, 0.97093, 1.0969, 0.97093, 1.05882, 0.75842, 0.9403, 0.75842, 0.9403, 0.75842, 0.9403, 0.75842, 0.9403, 0.75842, 0.9403, 0.88198, 1.05882, 0.88198, 1.05882, 0.88198, 1.05882, 1, 1, 0.9831, 1.01756, 0.9831, 1.01756, 0.95782, 0.8717, 0.95782, 0.8717, 0.95782, 0.8717, 0.95782, 1.09011, 0.95782, 0.8717, 0.84784, 1.11551, 0.71387, 1.09011, 1, 1, 0.99414, 0.84636, 1.09011, 1, 1, 0.84636, 1.0536, 0.84636, 0.94298, 0.84636, 1.23297, 1.03584, 1.01756, 1, 1, 1.03584, 1.01756, 1.00323, 1.03444, 1.01756, 0.96924, 1.05356, 0.96924, 1.05356, 0.96924, 1.05356, 0.93066, 0.98293, 0.82826, 1.04399, 1, 1, 0.82826, 1.04399, 0.79649, 0.84863, 0.79649, 0.84863, 0.79649, 0.84863, 0.79649, 0.84863, 1, 1, 0.85771, 1.17318, 0.85771, 1.21968, 0.95132, 1.01756, 0.95132, 1.01756, 0.95132, 1.01756, 0.95132, 1.01756, 0.95132, 1.01756, 0.95132, 1.01756, 0.98965, 1.00068, 0.8287, 0.96777, 0.8287, 0.93365, 0.9043, 0.93365, 0.9043, 0.93365, 0.9043, 1.08571, 0.96927, 0.96706, 0.91484, 0.86035, 0.93575, 0.96924, 0.95923, 1, 1, 0.85771, 1.21968, 1.11437, 1.11437, 0.93109, 0.91202, 0.60411, 0.84164, 0.55572, 1.01173, 0.97361, 0.81818, 0.81818, 0.96635, 0.78032, 0.72727, 0.92366, 0.98601, 1.03405, 0.77968, 1.09799, 1.2, 0.96706, 0.85944, 0.85638, 0.96491, 0.75842, 0.93365, 0.9831, 0.96924, 0.95782, 0.86969, 0.94152, 1.07796, 1.03584, 0.78437, 0.96924, 0.98715, 0.83968, 0.83491, 0.85771, 0.8287, 0.94492, 0.88433, 0.9287, 1.0098, 0.95782, 0.8287, 1.0625, 0.98248, 1.03424, 1.2, 1.01071, 1.0625, 0.95246, 1.03809, 1.04912, 0.98248, 1.00221, 1.03424, 1.05443, 1.2, 1.04785, 0.99609, 1.00169, 1.05176, 0.99346, 1.05356, 0.9087, 1.03004, 0.95542, 0.93117, 1.23362, 1.01071, 1.07831, 1.02512, 1.05205, 1.03502, 1.2, 1.01071, 1.05356, 1.01071, 1.03502, 0.75842, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.03719, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.9403, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.04021, 1, 1, 1, 1, 1, 1, 0.98965, 1.00068, 0.98965, 1.00068, 0.98965, 1.00068, 0.8287, 0.96777, 1, 1.20088, 0.89903, 1, 1, 0.75155, 1.03077, 1.03077, 1.03077, 1.03077, 1.13196, 1.13196, 1.13196, 0.67428, 0.67428, 1.16039, 0.73291, 1.20996, 1.22135, 1.06483, 0.94868, 0.94868, 0.95996, 1.24633, 1, 1.07497, 0.87796, 0.96927, 1.01518, 0.96927, 1, 1, 1, 0.77295, 1, 1, 1.10539, 1.10539, 1.11358, 1.06967, 0.86279, 0.94434, 0.86279, 0.94434, 0.86182, 1, 1, 1.083, 1, 0.91578, 0.86507, 1.1714, 1.18416, 1.14589, 0.69825, 0.97622, 1.9697, 1.24822, 1.24822, 1.17238, 1.24822, 1.24822, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.42603, 1, 0.99862, 0.99862, 1, 0.87025, 0.87025, 0.87025, 0.87025, 1.18083, 1.42603, 1, 1.42603, 1.42603, 0.99862, 1, 1, 1, 1, 1, 1.2886, 1.04315, 1.15296, 1.34163, 1, 1, 1, 1.10938, 1.10938, 1, 1, 1, 1.05425, 1.09971, 1.09971, 1.09971, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]; exports.SegoeuiRegularFactors = SegoeuiRegularFactors; const SegoeuiRegularMetrics = { lineHeight: 1.33008, lineGap: 0 }; exports.SegoeuiRegularMetrics = SegoeuiRegularMetrics; /***/ }), /* 55 */ /***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) =&gt; { Object.defineProperty(exports, &quot;__esModule&quot;, ({ value: true })); exports.PostScriptEvaluator = exports.PostScriptCompiler = exports.PDFFunctionFactory = void 0; exports.isPDFFunction = isPDFFunction; var _primitives = __w_pdfjs_require__(3); var _util = __w_pdfjs_require__(2); var _ps_parser = __w_pdfjs_require__(56); var _base_stream = __w_pdfjs_require__(5); var _image_utils = __w_pdfjs_require__(57); class PDFFunctionFactory { constructor({ xref, isEvalSupported = true }) { this.xref = xref; this.isEvalSupported = isEvalSupported !== false; } create(fn) { const cachedFunction = this.getCached(fn); if (cachedFunction) { return cachedFunction; } const parsedFunction = PDFFunction.parse({ xref: this.xref, isEvalSupported: this.isEvalSupported, fn: fn instanceof _primitives.Ref ? this.xref.fetch(fn) : fn }); this._cache(fn, parsedFunction); return parsedFunction; } createFromArray(fnObj) { const cachedFunction = this.getCached(fnObj); if (cachedFunction) { return cachedFunction; } const parsedFunction = PDFFunction.parseArray({ xref: this.xref, isEvalSupported: this.isEvalSupported, fnObj: fnObj instanceof _primitives.Ref ? this.xref.fetch(fnObj) : fnObj }); this._cache(fnObj, parsedFunction); return parsedFunction; } getCached(cacheKey) { let fnRef; if (cacheKey instanceof _primitives.Ref) { fnRef = cacheKey; } else if (cacheKey instanceof _primitives.Dict) { fnRef = cacheKey.objId; } else if (cacheKey instanceof _base_stream.BaseStream) { fnRef = cacheKey.dict &amp;&amp; cacheKey.dict.objId; } if (fnRef) { const localFunction = this._localFunctionCache.getByRef(fnRef); if (localFunction) { return localFunction; } } return null; } _cache(cacheKey, parsedFunction) { if (!parsedFunction) { throw new Error(&apos;PDFFunctionFactory._cache - expected &quot;parsedFunction&quot; argument.&apos;); } let fnRef; if (cacheKey instanceof _primitives.Ref) { fnRef = cacheKey; } else if (cacheKey instanceof _primitives.Dict) { fnRef = cacheKey.objId; } else if (cacheKey instanceof _base_stream.BaseStream) { fnRef = cacheKey.dict &amp;&amp; cacheKey.dict.objId; } if (fnRef) { this._localFunctionCache.set(null, fnRef, parsedFunction); } } get _localFunctionCache() { return (0, _util.shadow)(this, &quot;_localFunctionCache&quot;, new _image_utils.LocalFunctionCache()); } } exports.PDFFunctionFactory = PDFFunctionFactory; function toNumberArray(arr) { if (!Array.isArray(arr)) { return null; } const length = arr.length; for (let i = 0; i &lt; length; i++) { if (typeof arr[i] !== &quot;number&quot;) { const result = new Array(length); for (let j = 0; j &lt; length; j++) { result[j] = +arr[j]; } return result; } } return arr; } class PDFFunction { static getSampleArray(size, outputSize, bps, stream) { let i, ii; let length = 1; for (i = 0, ii = size.length; i &lt; ii; i++) { length *= size[i]; } length *= outputSize; const array = new Array(length); let codeSize = 0; let codeBuf = 0; const sampleMul = 1.0 / (2.0 ** bps - 1); const strBytes = stream.getBytes((length * bps + 7) / 8); let strIdx = 0; for (i = 0; i &lt; length; i++) { while (codeSize &lt; bps) { codeBuf &lt;&lt;= 8; codeBuf |= strBytes[strIdx++]; codeSize += 8; } codeSize -= bps; array[i] = (codeBuf &gt;&gt; codeSize) * sampleMul; codeBuf &amp;= (1 &lt;&lt; codeSize) - 1; } return array; } static parse({ xref, isEvalSupported, fn }) { const dict = fn.dict || fn; const typeNum = dict.get(&quot;FunctionType&quot;); switch (typeNum) { case 0: return this.constructSampled({ xref, isEvalSupported, fn, dict }); case 1: break; case 2: return this.constructInterpolated({ xref, isEvalSupported, dict }); case 3: return this.constructStiched({ xref, isEvalSupported, dict }); case 4: return this.constructPostScript({ xref, isEvalSupported, fn, dict }); } throw new _util.FormatError(&quot;Unknown type of function&quot;); } static parseArray({ xref, isEvalSupported, fnObj }) { if (!Array.isArray(fnObj)) { return this.parse({ xref, isEvalSupported, fn: fnObj }); } const fnArray = []; for (const fn of fnObj) { fnArray.push(this.parse({ xref, isEvalSupported, fn: xref.fetchIfRef(fn) })); } return function (src, srcOffset, dest, destOffset) { for (let i = 0, ii = fnArray.length; i &lt; ii; i++) { fnArray[i](src, srcOffset, dest, destOffset + i); } }; } static constructSampled({ xref, isEvalSupported, fn, dict }) { function toMultiArray(arr) { const inputLength = arr.length; const out = []; let index = 0; for (let i = 0; i &lt; inputLength; i += 2) { out[index++] = [arr[i], arr[i + 1]]; } return out; } function interpolate(x, xmin, xmax, ymin, ymax) { return ymin + (x - xmin) * ((ymax - ymin) / (xmax - xmin)); } let domain = toNumberArray(dict.getArray(&quot;Domain&quot;)); let range = toNumberArray(dict.getArray(&quot;Range&quot;)); if (!domain || !range) { throw new _util.FormatError(&quot;No domain or range&quot;); } const inputSize = domain.length / 2; const outputSize = range.length / 2; domain = toMultiArray(domain); range = toMultiArray(range); const size = toNumberArray(dict.getArray(&quot;Size&quot;)); const bps = dict.get(&quot;BitsPerSample&quot;); const order = dict.get(&quot;Order&quot;) || 1; if (order !== 1) { (0, _util.info)(&quot;No support for cubic spline interpolation: &quot; + order); } let encode = toNumberArray(dict.getArray(&quot;Encode&quot;)); if (!encode) { encode = []; for (let i = 0; i &lt; inputSize; ++i) { encode.push([0, size[i] - 1]); } } else { encode = toMultiArray(encode); } let decode = toNumberArray(dict.getArray(&quot;Decode&quot;)); if (!decode) { decode = range; } else { decode = toMultiArray(decode); } const samples = this.getSampleArray(size, outputSize, bps, fn); return function constructSampledFn(src, srcOffset, dest, destOffset) { const cubeVertices = 1 &lt;&lt; inputSize; const cubeN = new Float64Array(cubeVertices); const cubeVertex = new Uint32Array(cubeVertices); let i, j; for (j = 0; j &lt; cubeVertices; j++) { cubeN[j] = 1; } let k = outputSize, pos = 1; for (i = 0; i &lt; inputSize; ++i) { const domain_2i = domain[i][0]; const domain_2i_1 = domain[i][1]; const xi = Math.min(Math.max(src[srcOffset + i], domain_2i), domain_2i_1); let e = interpolate(xi, domain_2i, domain_2i_1, encode[i][0], encode[i][1]); const size_i = size[i]; e = Math.min(Math.max(e, 0), size_i - 1); const e0 = e &lt; size_i - 1 ? Math.floor(e) : e - 1; const n0 = e0 + 1 - e; const n1 = e - e0; const offset0 = e0 * k; const offset1 = offset0 + k; for (j = 0; j &lt; cubeVertices; j++) { if (j &amp; pos) { cubeN[j] *= n1; cubeVertex[j] += offset1; } else { cubeN[j] *= n0; cubeVertex[j] += offset0; } } k *= size_i; pos &lt;&lt;= 1; } for (j = 0; j &lt; outputSize; ++j) { let rj = 0; for (i = 0; i &lt; cubeVertices; i++) { rj += samples[cubeVertex[i] + j] * cubeN[i]; } rj = interpolate(rj, 0, 1, decode[j][0], decode[j][1]); dest[destOffset + j] = Math.min(Math.max(rj, range[j][0]), range[j][1]); } }; } static constructInterpolated({ xref, isEvalSupported, dict }) { const c0 = toNumberArray(dict.getArray(&quot;C0&quot;)) || [0]; const c1 = toNumberArray(dict.getArray(&quot;C1&quot;)) || [1]; const n = dict.get(&quot;N&quot;); const diff = []; for (let i = 0, ii = c0.length; i &lt; ii; ++i) { diff.push(c1[i] - c0[i]); } const length = diff.length; return function constructInterpolatedFn(src, srcOffset, dest, destOffset) { const x = n === 1 ? src[srcOffset] : src[srcOffset] ** n; for (let j = 0; j &lt; length; ++j) { dest[destOffset + j] = c0[j] + x * diff[j]; } }; } static constructStiched({ xref, isEvalSupported, dict }) { const domain = toNumberArray(dict.getArray(&quot;Domain&quot;)); if (!domain) { throw new _util.FormatError(&quot;No domain&quot;); } const inputSize = domain.length / 2; if (inputSize !== 1) { throw new _util.FormatError(&quot;Bad domain for stiched function&quot;); } const fns = []; for (const fn of dict.get(&quot;Functions&quot;)) { fns.push(this.parse({ xref, isEvalSupported, fn: xref.fetchIfRef(fn) })); } const bounds = toNumberArray(dict.getArray(&quot;Bounds&quot;)); const encode = toNumberArray(dict.getArray(&quot;Encode&quot;)); const tmpBuf = new Float32Array(1); return function constructStichedFn(src, srcOffset, dest, destOffset) { const clip = function constructStichedFromIRClip(v, min, max) { if (v &gt; max) { v = max; } else if (v &lt; min) { v = min; } return v; }; const v = clip(src[srcOffset], domain[0], domain[1]); const length = bounds.length; let i; for (i = 0; i &lt; length; ++i) { if (v &lt; bounds[i]) { break; } } let dmin = domain[0]; if (i &gt; 0) { dmin = bounds[i - 1]; } let dmax = domain[1]; if (i &lt; bounds.length) { dmax = bounds[i]; } const rmin = encode[2 * i]; const rmax = encode[2 * i + 1]; tmpBuf[0] = dmin === dmax ? rmin : rmin + (v - dmin) * (rmax - rmin) / (dmax - dmin); fns[i](tmpBuf, 0, dest, destOffset); }; } static constructPostScript({ xref, isEvalSupported, fn, dict }) { const domain = toNumberArray(dict.getArray(&quot;Domain&quot;)); const range = toNumberArray(dict.getArray(&quot;Range&quot;)); if (!domain) { throw new _util.FormatError(&quot;No domain.&quot;); } if (!range) { throw new _util.FormatError(&quot;No range.&quot;); } const lexer = new _ps_parser.PostScriptLexer(fn); const parser = new _ps_parser.PostScriptParser(lexer); const code = parser.parse(); if (isEvalSupported &amp;&amp; _util.FeatureTest.isEvalSupported) { const compiled = new PostScriptCompiler().compile(code, domain, range); if (compiled) { return new Function(&quot;src&quot;, &quot;srcOffset&quot;, &quot;dest&quot;, &quot;destOffset&quot;, compiled); } } (0, _util.info)(&quot;Unable to compile PS function&quot;); const numOutputs = range.length &gt;&gt; 1; const numInputs = domain.length &gt;&gt; 1; const evaluator = new PostScriptEvaluator(code); const cache = Object.create(null); const MAX_CACHE_SIZE = 2048 * 4; let cache_available = MAX_CACHE_SIZE; const tmpBuf = new Float32Array(numInputs); return function constructPostScriptFn(src, srcOffset, dest, destOffset) { let i, value; let key = &quot;&quot;; const input = tmpBuf; for (i = 0; i &lt; numInputs; i++) { value = src[srcOffset + i]; input[i] = value; key += value + &quot;_&quot;; } const cachedValue = cache[key]; if (cachedValue !== undefined) { dest.set(cachedValue, destOffset); return; } const output = new Float32Array(numOutputs); const stack = evaluator.execute(input); const stackIndex = stack.length - numOutputs; for (i = 0; i &lt; numOutputs; i++) { value = stack[stackIndex + i]; let bound = range[i * 2]; if (value &lt; bound) { value = bound; } else { bound = range[i * 2 + 1]; if (value &gt; bound) { value = bound; } } output[i] = value; } if (cache_available &gt; 0) { cache_available--; cache[key] = output; } dest.set(output, destOffset); }; } } function isPDFFunction(v) { let fnDict; if (typeof v !== &quot;object&quot;) { return false; } else if (v instanceof _primitives.Dict) { fnDict = v; } else if (v instanceof _base_stream.BaseStream) { fnDict = v.dict; } else { return false; } return fnDict.has(&quot;FunctionType&quot;); } class PostScriptStack { static get MAX_STACK_SIZE() { return (0, _util.shadow)(this, &quot;MAX_STACK_SIZE&quot;, 100); } constructor(initialStack) { this.stack = initialStack ? Array.from(initialStack) : []; } push(value) { if (this.stack.length &gt;= PostScriptStack.MAX_STACK_SIZE) { throw new Error(&quot;PostScript function stack overflow.&quot;); } this.stack.push(value); } pop() { if (this.stack.length &lt;= 0) { throw new Error(&quot;PostScript function stack underflow.&quot;); } return this.stack.pop(); } copy(n) { if (this.stack.length + n &gt;= PostScriptStack.MAX_STACK_SIZE) { throw new Error(&quot;PostScript function stack overflow.&quot;); } const stack = this.stack; for (let i = stack.length - n, j = n - 1; j &gt;= 0; j--, i++) { stack.push(stack[i]); } } index(n) { this.push(this.stack[this.stack.length - n - 1]); } roll(n, p) { const stack = this.stack; const l = stack.length - n; const r = stack.length - 1; const c = l + (p - Math.floor(p / n) * n); for (let i = l, j = r; i &lt; j; i++, j--) { const t = stack[i]; stack[i] = stack[j]; stack[j] = t; } for (let i = l, j = c - 1; i &lt; j; i++, j--) { const t = stack[i]; stack[i] = stack[j]; stack[j] = t; } for (let i = c, j = r; i &lt; j; i++, j--) { const t = stack[i]; stack[i] = stack[j]; stack[j] = t; } } } class PostScriptEvaluator { constructor(operators) { this.operators = operators; } execute(initialStack) { const stack = new PostScriptStack(initialStack); let counter = 0; const operators = this.operators; const length = operators.length; let operator, a, b; while (counter &lt; length) { operator = operators[counter++]; if (typeof operator === &quot;number&quot;) { stack.push(operator); continue; } switch (operator) { case &quot;jz&quot;: b = stack.pop(); a = stack.pop(); if (!a) { counter = b; } break; case &quot;j&quot;: a = stack.pop(); counter = a; break; case &quot;abs&quot;: a = stack.pop(); stack.push(Math.abs(a)); break; case &quot;add&quot;: b = stack.pop(); a = stack.pop(); stack.push(a + b); break; case &quot;and&quot;: b = stack.pop(); a = stack.pop(); if (typeof a === &quot;boolean&quot; &amp;&amp; typeof b === &quot;boolean&quot;) { stack.push(a &amp;&amp; b); } else { stack.push(a &amp; b); } break; case &quot;atan&quot;: a = stack.pop(); stack.push(Math.atan(a)); break; case &quot;bitshift&quot;: b = stack.pop(); a = stack.pop(); if (a &gt; 0) { stack.push(a &lt;&lt; b); } else { stack.push(a &gt;&gt; b); } break; case &quot;ceiling&quot;: a = stack.pop(); stack.push(Math.ceil(a)); break; case &quot;copy&quot;: a = stack.pop(); stack.copy(a); break; case &quot;cos&quot;: a = stack.pop(); stack.push(Math.cos(a)); break; case &quot;cvi&quot;: a = stack.pop() | 0; stack.push(a); break; case &quot;cvr&quot;: break; case &quot;div&quot;: b = stack.pop(); a = stack.pop(); stack.push(a / b); break; case &quot;dup&quot;: stack.copy(1); break; case &quot;eq&quot;: b = stack.pop(); a = stack.pop(); stack.push(a === b); break; case &quot;exch&quot;: stack.roll(2, 1); break; case &quot;exp&quot;: b = stack.pop(); a = stack.pop(); stack.push(a ** b); break; case &quot;false&quot;: stack.push(false); break; case &quot;floor&quot;: a = stack.pop(); stack.push(Math.floor(a)); break; case &quot;ge&quot;: b = stack.pop(); a = stack.pop(); stack.push(a &gt;= b); break; case &quot;gt&quot;: b = stack.pop(); a = stack.pop(); stack.push(a &gt; b); break; case &quot;idiv&quot;: b = stack.pop(); a = stack.pop(); stack.push(a / b | 0); break; case &quot;index&quot;: a = stack.pop(); stack.index(a); break; case &quot;le&quot;: b = stack.pop(); a = stack.pop(); stack.push(a &lt;= b); break; case &quot;ln&quot;: a = stack.pop(); stack.push(Math.log(a)); break; case &quot;log&quot;: a = stack.pop(); stack.push(Math.log(a) / Math.LN10); break; case &quot;lt&quot;: b = stack.pop(); a = stack.pop(); stack.push(a &lt; b); break; case &quot;mod&quot;: b = stack.pop(); a = stack.pop(); stack.push(a % b); break; case &quot;mul&quot;: b = stack.pop(); a = stack.pop(); stack.push(a * b); break; case &quot;ne&quot;: b = stack.pop(); a = stack.pop(); stack.push(a !== b); break; case &quot;neg&quot;: a = stack.pop(); stack.push(-a); break; case &quot;not&quot;: a = stack.pop(); if (typeof a === &quot;boolean&quot;) { stack.push(!a); } else { stack.push(~a); } break; case &quot;or&quot;: b = stack.pop(); a = stack.pop(); if (typeof a === &quot;boolean&quot; &amp;&amp; typeof b === &quot;boolean&quot;) { stack.push(a || b); } else { stack.push(a | b); } break; case &quot;pop&quot;: stack.pop(); break; case &quot;roll&quot;: b = stack.pop(); a = stack.pop(); stack.roll(a, b); break; case &quot;round&quot;: a = stack.pop(); stack.push(Math.round(a)); break; case &quot;sin&quot;: a = stack.pop(); stack.push(Math.sin(a)); break; case &quot;sqrt&quot;: a = stack.pop(); stack.push(Math.sqrt(a)); break; case &quot;sub&quot;: b = stack.pop(); a = stack.pop(); stack.push(a - b); break; case &quot;true&quot;: stack.push(true); break; case &quot;truncate&quot;: a = stack.pop(); a = a &lt; 0 ? Math.ceil(a) : Math.floor(a); stack.push(a); break; case &quot;xor&quot;: b = stack.pop(); a = stack.pop(); if (typeof a === &quot;boolean&quot; &amp;&amp; typeof b === &quot;boolean&quot;) { stack.push(a !== b); } else { stack.push(a ^ b); } break; default: throw new _util.FormatError(`Unknown operator ${operator}`); } } return stack.stack; } } exports.PostScriptEvaluator = PostScriptEvaluator; class AstNode { constructor(type) { this.type = type; } visit(visitor) { (0, _util.unreachable)(&quot;abstract method&quot;); } } class AstArgument extends AstNode { constructor(index, min, max) { super(&quot;args&quot;); this.index = index; this.min = min; this.max = max; } visit(visitor) { visitor.visitArgument(this); } } class AstLiteral extends AstNode { constructor(number) { super(&quot;literal&quot;); this.number = number; this.min = number; this.max = number; } visit(visitor) { visitor.visitLiteral(this); } } class AstBinaryOperation extends AstNode { constructor(op, arg1, arg2, min, max) { super(&quot;binary&quot;); this.op = op; this.arg1 = arg1; this.arg2 = arg2; this.min = min; this.max = max; } visit(visitor) { visitor.visitBinaryOperation(this); } } class AstMin extends AstNode { constructor(arg, max) { super(&quot;max&quot;); this.arg = arg; this.min = arg.min; this.max = max; } visit(visitor) { visitor.visitMin(this); } } class AstVariable extends AstNode { constructor(index, min, max) { super(&quot;var&quot;); this.index = index; this.min = min; this.max = max; } visit(visitor) { visitor.visitVariable(this); } } class AstVariableDefinition extends AstNode { constructor(variable, arg) { super(&quot;definition&quot;); this.variable = variable; this.arg = arg; } visit(visitor) { visitor.visitVariableDefinition(this); } } class ExpressionBuilderVisitor { constructor() { this.parts = []; } visitArgument(arg) { this.parts.push(&quot;Math.max(&quot;, arg.min, &quot;, Math.min(&quot;, arg.max, &quot;, src[srcOffset + &quot;, arg.index, &quot;]))&quot;); } visitVariable(variable) { this.parts.push(&quot;v&quot;, variable.index); } visitLiteral(literal) { this.parts.push(literal.number); } visitBinaryOperation(operation) { this.parts.push(&quot;(&quot;); operation.arg1.visit(this); this.parts.push(&quot; &quot;, operation.op, &quot; &quot;); operation.arg2.visit(this); this.parts.push(&quot;)&quot;); } visitVariableDefinition(definition) { this.parts.push(&quot;var &quot;); definition.variable.visit(this); this.parts.push(&quot; = &quot;); definition.arg.visit(this); this.parts.push(&quot;;&quot;); } visitMin(max) { this.parts.push(&quot;Math.min(&quot;); max.arg.visit(this); this.parts.push(&quot;, &quot;, max.max, &quot;)&quot;); } toString() { return this.parts.join(&quot;&quot;); } } function buildAddOperation(num1, num2) { if (num2.type === &quot;literal&quot; &amp;&amp; num2.number === 0) { return num1; } if (num1.type === &quot;literal&quot; &amp;&amp; num1.number === 0) { return num2; } if (num2.type === &quot;literal&quot; &amp;&amp; num1.type === &quot;literal&quot;) { return new AstLiteral(num1.number + num2.number); } return new AstBinaryOperation(&quot;+&quot;, num1, num2, num1.min + num2.min, num1.max + num2.max); } function buildMulOperation(num1, num2) { if (num2.type === &quot;literal&quot;) { if (num2.number === 0) { return new AstLiteral(0); } else if (num2.number === 1) { return num1; } else if (num1.type === &quot;literal&quot;) { return new AstLiteral(num1.number * num2.number); } } if (num1.type === &quot;literal&quot;) { if (num1.number === 0) { return new AstLiteral(0); } else if (num1.number === 1) { return num2; } } const min = Math.min(num1.min * num2.min, num1.min * num2.max, num1.max * num2.min, num1.max * num2.max); const max = Math.max(num1.min * num2.min, num1.min * num2.max, num1.max * num2.min, num1.max * num2.max); return new AstBinaryOperation(&quot;*&quot;, num1, num2, min, max); } function buildSubOperation(num1, num2) { if (num2.type === &quot;literal&quot;) { if (num2.number === 0) { return num1; } else if (num1.type === &quot;literal&quot;) { return new AstLiteral(num1.number - num2.number); } } if (num2.type === &quot;binary&quot; &amp;&amp; num2.op === &quot;-&quot; &amp;&amp; num1.type === &quot;literal&quot; &amp;&amp; num1.number === 1 &amp;&amp; num2.arg1.type === &quot;literal&quot; &amp;&amp; num2.arg1.number === 1) { return num2.arg2; } return new AstBinaryOperation(&quot;-&quot;, num1, num2, num1.min - num2.max, num1.max - num2.min); } function buildMinOperation(num1, max) { if (num1.min &gt;= max) { return new AstLiteral(max); } else if (num1.max &lt;= max) { return num1; } return new AstMin(num1, max); } class PostScriptCompiler { compile(code, domain, range) { const stack = []; const instructions = []; const inputSize = domain.length &gt;&gt; 1, outputSize = range.length &gt;&gt; 1; let lastRegister = 0; let n, j; let num1, num2, ast1, ast2, tmpVar, item; for (let i = 0; i &lt; inputSize; i++) { stack.push(new AstArgument(i, domain[i * 2], domain[i * 2 + 1])); } for (let i = 0, ii = code.length; i &lt; ii; i++) { item = code[i]; if (typeof item === &quot;number&quot;) { stack.push(new AstLiteral(item)); continue; } switch (item) { case &quot;add&quot;: if (stack.length &lt; 2) { return null; } num2 = stack.pop(); num1 = stack.pop(); stack.push(buildAddOperation(num1, num2)); break; case &quot;cvr&quot;: if (stack.length &lt; 1) { return null; } break; case &quot;mul&quot;: if (stack.length &lt; 2) { return null; } num2 = stack.pop(); num1 = stack.pop(); stack.push(buildMulOperation(num1, num2)); break; case &quot;sub&quot;: if (stack.length &lt; 2) { return null; } num2 = stack.pop(); num1 = stack.pop(); stack.push(buildSubOperation(num1, num2)); break; case &quot;exch&quot;: if (stack.length &lt; 2) { return null; } ast1 = stack.pop(); ast2 = stack.pop(); stack.push(ast1, ast2); break; case &quot;pop&quot;: if (stack.length &lt; 1) { return null; } stack.pop(); break; case &quot;index&quot;: if (stack.length &lt; 1) { return null; } num1 = stack.pop(); if (num1.type !== &quot;literal&quot;) { return null; } n = num1.number; if (n &lt; 0 || !Number.isInteger(n) || stack.length &lt; n) { return null; } ast1 = stack[stack.length - n - 1]; if (ast1.type === &quot;literal&quot; || ast1.type === &quot;var&quot;) { stack.push(ast1); break; } tmpVar = new AstVariable(lastRegister++, ast1.min, ast1.max); stack[stack.length - n - 1] = tmpVar; stack.push(tmpVar); instructions.push(new AstVariableDefinition(tmpVar, ast1)); break; case &quot;dup&quot;: if (stack.length &lt; 1) { return null; } if (typeof code[i + 1] === &quot;number&quot; &amp;&amp; code[i + 2] === &quot;gt&quot; &amp;&amp; code[i + 3] === i + 7 &amp;&amp; code[i + 4] === &quot;jz&quot; &amp;&amp; code[i + 5] === &quot;pop&quot; &amp;&amp; code[i + 6] === code[i + 1]) { num1 = stack.pop(); stack.push(buildMinOperation(num1, code[i + 1])); i += 6; break; } ast1 = stack.at(-1); if (ast1.type === &quot;literal&quot; || ast1.type === &quot;var&quot;) { stack.push(ast1); break; } tmpVar = new AstVariable(lastRegister++, ast1.min, ast1.max); stack[stack.length - 1] = tmpVar; stack.push(tmpVar); instructions.push(new AstVariableDefinition(tmpVar, ast1)); break; case &quot;roll&quot;: if (stack.length &lt; 2) { return null; } num2 = stack.pop(); num1 = stack.pop(); if (num2.type !== &quot;literal&quot; || num1.type !== &quot;literal&quot;) { return null; } j = num2.number; n = num1.number; if (n &lt;= 0 || !Number.isInteger(n) || !Number.isInteger(j) || stack.length &lt; n) { return null; } j = (j % n + n) % n; if (j === 0) { break; } stack.push(...stack.splice(stack.length - n, n - j)); break; default: return null; } } if (stack.length !== outputSize) { return null; } const result = []; for (const instruction of instructions) { const statementBuilder = new ExpressionBuilderVisitor(); instruction.visit(statementBuilder); result.push(statementBuilder.toString()); } for (let i = 0, ii = stack.length; i &lt; ii; i++) { const expr = stack[i], statementBuilder = new ExpressionBuilderVisitor(); expr.visit(statementBuilder); const min = range[i * 2], max = range[i * 2 + 1]; const out = [statementBuilder.toString()]; if (min &gt; expr.min) { out.unshift(&quot;Math.max(&quot;, min, &quot;, &quot;); out.push(&quot;)&quot;); } if (max &lt; expr.max) { out.unshift(&quot;Math.min(&quot;, max, &quot;, &quot;); out.push(&quot;)&quot;); } out.unshift(&quot;dest[destOffset + &quot;, i, &quot;] = &quot;); out.push(&quot;;&quot;); result.push(out.join(&quot;&quot;)); } return result.join(&quot;\\n&quot;); } } exports.PostScriptCompiler = PostScriptCompiler; /***/ }), /* 56 */ /***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) =&gt; { Object.defineProperty(exports, &quot;__esModule&quot;, ({ value: true })); exports.PostScriptParser = exports.PostScriptLexer = void 0; var _util = __w_pdfjs_require__(2); var _primitives = __w_pdfjs_require__(3); var _core_utils = __w_pdfjs_require__(4); class PostScriptParser { constructor(lexer) { this.lexer = lexer; this.operators = []; this.token = null; this.prev = null; } nextToken() { this.prev = this.token; this.token = this.lexer.getToken(); } accept(type) { if (this.token.type === type) { this.nextToken(); return true; } return false; } expect(type) { if (this.accept(type)) { return true; } throw new _util.FormatError(`Unexpected symbol: found ${this.token.type} expected ${type}.`); } parse() { this.nextToken(); this.expect(PostScriptTokenTypes.LBRACE); this.parseBlock(); this.expect(PostScriptTokenTypes.RBRACE); return this.operators; } parseBlock() { while (true) { if (this.accept(PostScriptTokenTypes.NUMBER)) { this.operators.push(this.prev.value); } else if (this.accept(PostScriptTokenTypes.OPERATOR)) { this.operators.push(this.prev.value); } else if (this.accept(PostScriptTokenTypes.LBRACE)) { this.parseCondition(); } else { return; } } } parseCondition() { const conditionLocation = this.operators.length; this.operators.push(null, null); this.parseBlock(); this.expect(PostScriptTokenTypes.RBRACE); if (this.accept(PostScriptTokenTypes.IF)) { this.operators[conditionLocation] = this.operators.length; this.operators[conditionLocation + 1] = &quot;jz&quot;; } else if (this.accept(PostScriptTokenTypes.LBRACE)) { const jumpLocation = this.operators.length; this.operators.push(null, null); const endOfTrue = this.operators.length; this.parseBlock(); this.expect(PostScriptTokenTypes.RBRACE); this.expect(PostScriptTokenTypes.IFELSE); this.operators[jumpLocation] = this.operators.length; this.operators[jumpLocation + 1] = &quot;j&quot;; this.operators[conditionLocation] = endOfTrue; this.operators[conditionLocation + 1] = &quot;jz&quot;; } else { throw new _util.FormatError(&quot;PS Function: error parsing conditional.&quot;); } } } exports.PostScriptParser = PostScriptParser; const PostScriptTokenTypes = { LBRACE: 0, RBRACE: 1, NUMBER: 2, OPERATOR: 3, IF: 4, IFELSE: 5 }; class PostScriptToken { static get opCache() { return (0, _util.shadow)(this, &quot;opCache&quot;, Object.create(null)); } constructor(type, value) { this.type = type; this.value = value; } static getOperator(op) { const opValue = PostScriptToken.opCache[op]; if (opValue) { return opValue; } return PostScriptToken.opCache[op] = new PostScriptToken(PostScriptTokenTypes.OPERATOR, op); } static get LBRACE() { return (0, _util.shadow)(this, &quot;LBRACE&quot;, new PostScriptToken(PostScriptTokenTypes.LBRACE, &quot;{&quot;)); } static get RBRACE() { return (0, _util.shadow)(this, &quot;RBRACE&quot;, new PostScriptToken(PostScriptTokenTypes.RBRACE, &quot;}&quot;)); } static get IF() { return (0, _util.shadow)(this, &quot;IF&quot;, new PostScriptToken(PostScriptTokenTypes.IF, &quot;IF&quot;)); } static get IFELSE() { return (0, _util.shadow)(this, &quot;IFELSE&quot;, new PostScriptToken(PostScriptTokenTypes.IFELSE, &quot;IFELSE&quot;)); } } class PostScriptLexer { constructor(stream) { this.stream = stream; this.nextChar(); this.strBuf = []; } nextChar() { return this.currentChar = this.stream.getByte(); } getToken() { let comment = false; let ch = this.currentChar; while (true) { if (ch &lt; 0) { return _primitives.EOF; } if (comment) { if (ch === 0x0a || ch === 0x0d) { comment = false; } } else if (ch === 0x25) { comment = true; } else if (!(0, _core_utils.isWhiteSpace)(ch)) { break; } ch = this.nextChar(); } switch (ch | 0) { case 0x30: case 0x31: case 0x32: case 0x33: case 0x34: case 0x35: case 0x36: case 0x37: case 0x38: case 0x39: case 0x2b: case 0x2d: case 0x2e: return new PostScriptToken(PostScriptTokenTypes.NUMBER, this.getNumber()); case 0x7b: this.nextChar(); return PostScriptToken.LBRACE; case 0x7d: this.nextChar(); return PostScriptToken.RBRACE; } const strBuf = this.strBuf; strBuf.length = 0; strBuf[0] = String.fromCharCode(ch); while ((ch = this.nextChar()) &gt;= 0 &amp;&amp; (ch &gt;= 0x41 &amp;&amp; ch &lt;= 0x5a || ch &gt;= 0x61 &amp;&amp; ch &lt;= 0x7a)) { strBuf.push(String.fromCharCode(ch)); } const str = strBuf.join(&quot;&quot;); switch (str.toLowerCase()) { case &quot;if&quot;: return PostScriptToken.IF; case &quot;ifelse&quot;: return PostScriptToken.IFELSE; default: return PostScriptToken.getOperator(str); } } getNumber() { let ch = this.currentChar; const strBuf = this.strBuf; strBuf.length = 0; strBuf[0] = String.fromCharCode(ch); while ((ch = this.nextChar()) &gt;= 0) { if (ch &gt;= 0x30 &amp;&amp; ch &lt;= 0x39 || ch === 0x2d || ch === 0x2e) { strBuf.push(String.fromCharCode(ch)); } else { break; } } const value = parseFloat(strBuf.join(&quot;&quot;)); if (isNaN(value)) { throw new _util.FormatError(`Invalid floating point number: ${value}`); } return value; } } exports.PostScriptLexer = PostScriptLexer; /***/ }), /* 57 */ /***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) =&gt; { Object.defineProperty(exports, &quot;__esModule&quot;, ({ value: true })); exports.LocalTilingPatternCache = exports.LocalImageCache = exports.LocalGStateCache = exports.LocalFunctionCache = exports.LocalColorSpaceCache = exports.GlobalImageCache = void 0; var _util = __w_pdfjs_require__(2); var _primitives = __w_pdfjs_require__(3); class BaseLocalCache { constructor(options) { if (this.constructor === BaseLocalCache) { (0, _util.unreachable)(&quot;Cannot initialize BaseLocalCache.&quot;); } this._onlyRefs = (options &amp;&amp; options.onlyRefs) === true; if (!this._onlyRefs) { this._nameRefMap = new Map(); this._imageMap = new Map(); } this._imageCache = new _primitives.RefSetCache(); } getByName(name) { if (this._onlyRefs) { (0, _util.unreachable)(&quot;Should not call `getByName` method.&quot;); } const ref = this._nameRefMap.get(name); if (ref) { return this.getByRef(ref); } return this._imageMap.get(name) || null; } getByRef(ref) { return this._imageCache.get(ref) || null; } set(name, ref, data) { (0, _util.unreachable)(&quot;Abstract method `set` called.&quot;); } } class LocalImageCache extends BaseLocalCache { set(name, ref = null, data) { if (typeof name !== &quot;string&quot;) { throw new Error(&apos;LocalImageCache.set - expected &quot;name&quot; argument.&apos;); } if (ref) { if (this._imageCache.has(ref)) { return; } this._nameRefMap.set(name, ref); this._imageCache.put(ref, data); return; } if (this._imageMap.has(name)) { return; } this._imageMap.set(name, data); } } exports.LocalImageCache = LocalImageCache; class LocalColorSpaceCache extends BaseLocalCache { set(name = null, ref = null, data) { if (typeof name !== &quot;string&quot; &amp;&amp; !ref) { throw new Error(&apos;LocalColorSpaceCache.set - expected &quot;name&quot; and/or &quot;ref&quot; argument.&apos;); } if (ref) { if (this._imageCache.has(ref)) { return; } if (name !== null) { this._nameRefMap.set(name, ref); } this._imageCache.put(ref, data); return; } if (this._imageMap.has(name)) { return; } this._imageMap.set(name, data); } } exports.LocalColorSpaceCache = LocalColorSpaceCache; class LocalFunctionCache extends BaseLocalCache { constructor(options) { super({ onlyRefs: true }); } set(name = null, ref, data) { if (!ref) { throw new Error(&apos;LocalFunctionCache.set - expected &quot;ref&quot; argument.&apos;); } if (this._imageCache.has(ref)) { return; } this._imageCache.put(ref, data); } } exports.LocalFunctionCache = LocalFunctionCache; class LocalGStateCache extends BaseLocalCache { set(name, ref = null, data) { if (typeof name !== &quot;string&quot;) { throw new Error(&apos;LocalGStateCache.set - expected &quot;name&quot; argument.&apos;); } if (ref) { if (this._imageCache.has(ref)) { return; } this._nameRefMap.set(name, ref); this._imageCache.put(ref, data); return; } if (this._imageMap.has(name)) { return; } this._imageMap.set(name, data); } } exports.LocalGStateCache = LocalGStateCache; class LocalTilingPatternCache extends BaseLocalCache { constructor(options) { super({ onlyRefs: true }); } set(name = null, ref, data) { if (!ref) { throw new Error(&apos;LocalTilingPatternCache.set - expected &quot;ref&quot; argument.&apos;); } if (this._imageCache.has(ref)) { return; } this._imageCache.put(ref, data); } } exports.LocalTilingPatternCache = LocalTilingPatternCache; class GlobalImageCache { static get NUM_PAGES_THRESHOLD() { return (0, _util.shadow)(this, &quot;NUM_PAGES_THRESHOLD&quot;, 2); } static get MIN_IMAGES_TO_CACHE() { return (0, _util.shadow)(this, &quot;MIN_IMAGES_TO_CACHE&quot;, 10); } static get MAX_BYTE_SIZE() { return (0, _util.shadow)(this, &quot;MAX_BYTE_SIZE&quot;, 40e6); } constructor() { this._refCache = new _primitives.RefSetCache(); this._imageCache = new _primitives.RefSetCache(); } get _byteSize() { let byteSize = 0; for (const imageData of this._imageCache) { byteSize += imageData.byteSize; } return byteSize; } get _cacheLimitReached() { if (this._imageCache.size &lt; GlobalImageCache.MIN_IMAGES_TO_CACHE) { return false; } if (this._byteSize &lt; GlobalImageCache.MAX_BYTE_SIZE) { return false; } return true; } shouldCache(ref, pageIndex) { const pageIndexSet = this._refCache.get(ref); const numPages = pageIndexSet ? pageIndexSet.size + (pageIndexSet.has(pageIndex) ? 0 : 1) : 1; if (numPages &lt; GlobalImageCache.NUM_PAGES_THRESHOLD) { return false; } if (!this._imageCache.has(ref) &amp;&amp; this._cacheLimitReached) { return false; } return true; } addPageIndex(ref, pageIndex) { let pageIndexSet = this._refCache.get(ref); if (!pageIndexSet) { pageIndexSet = new Set(); this._refCache.put(ref, pageIndexSet); } pageIndexSet.add(pageIndex); } addByteSize(ref, byteSize) { const imageData = this._imageCache.get(ref); if (!imageData) { return; } if (imageData.byteSize) { return; } imageData.byteSize = byteSize; } getData(ref, pageIndex) { const pageIndexSet = this._refCache.get(ref); if (!pageIndexSet) { return null; } if (pageIndexSet.size &lt; GlobalImageCache.NUM_PAGES_THRESHOLD) { return null; } const imageData = this._imageCache.get(ref); if (!imageData) { return null; } pageIndexSet.add(pageIndex); return imageData; } setData(ref, data) { if (!this._refCache.has(ref)) { throw new Error(&apos;GlobalImageCache.setData - expected &quot;addPageIndex&quot; to have been called.&apos;); } if (this._imageCache.has(ref)) { return; } if (this._cacheLimitReached) { (0, _util.warn)(&quot;GlobalImageCache.setData - cache limit reached.&quot;); return; } this._imageCache.put(ref, data); } clear(onlyData = false) { if (!onlyData) { this._refCache.clear(); } this._imageCache.clear(); } } exports.GlobalImageCache = GlobalImageCache; /***/ }), /* 58 */ /***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) =&gt; { Object.defineProperty(exports, &quot;__esModule&quot;, ({ value: true })); exports.bidi = bidi; var _util = __w_pdfjs_require__(2); const baseTypes = [&quot;BN&quot;, &quot;BN&quot;, &quot;BN&quot;, &quot;BN&quot;, &quot;BN&quot;, &quot;BN&quot;, &quot;BN&quot;, &quot;BN&quot;, &quot;BN&quot;, &quot;S&quot;, &quot;B&quot;, &quot;S&quot;, &quot;WS&quot;, &quot;B&quot;, &quot;BN&quot;, &quot;BN&quot;, &quot;BN&quot;, &quot;BN&quot;, &quot;BN&quot;, &quot;BN&quot;, &quot;BN&quot;, &quot;BN&quot;, &quot;BN&quot;, &quot;BN&quot;, &quot;BN&quot;, &quot;BN&quot;, &quot;BN&quot;, &quot;BN&quot;, &quot;B&quot;, &quot;B&quot;, &quot;B&quot;, &quot;S&quot;, &quot;WS&quot;, &quot;ON&quot;, &quot;ON&quot;, &quot;ET&quot;, &quot;ET&quot;, &quot;ET&quot;, &quot;ON&quot;, &quot;ON&quot;, &quot;ON&quot;, &quot;ON&quot;, &quot;ON&quot;, &quot;ES&quot;, &quot;CS&quot;, &quot;ES&quot;, &quot;CS&quot;, &quot;CS&quot;, &quot;EN&quot;, &quot;EN&quot;, &quot;EN&quot;, &quot;EN&quot;, &quot;EN&quot;, &quot;EN&quot;, &quot;EN&quot;, &quot;EN&quot;, &quot;EN&quot;, &quot;EN&quot;, &quot;CS&quot;, &quot;ON&quot;, &quot;ON&quot;, &quot;ON&quot;, &quot;ON&quot;, &quot;ON&quot;, &quot;ON&quot;, &quot;L&quot;, &quot;L&quot;, &quot;L&quot;, &quot;L&quot;, &quot;L&quot;, &quot;L&quot;, &quot;L&quot;, &quot;L&quot;, &quot;L&quot;, &quot;L&quot;, &quot;L&quot;, &quot;L&quot;, &quot;L&quot;, &quot;L&quot;, &quot;L&quot;, &quot;L&quot;, &quot;L&quot;, &quot;L&quot;, &quot;L&quot;, &quot;L&quot;, &quot;L&quot;, &quot;L&quot;, &quot;L&quot;, &quot;L&quot;, &quot;L&quot;, &quot;L&quot;, &quot;ON&quot;, &quot;ON&quot;, &quot;ON&quot;, &quot;ON&quot;, &quot;ON&quot;, &quot;ON&quot;, &quot;L&quot;, &quot;L&quot;, &quot;L&quot;, &quot;L&quot;, &quot;L&quot;, &quot;L&quot;, &quot;L&quot;, &quot;L&quot;, &quot;L&quot;, &quot;L&quot;, &quot;L&quot;, &quot;L&quot;, &quot;L&quot;, &quot;L&quot;, &quot;L&quot;, &quot;L&quot;, &quot;L&quot;, &quot;L&quot;, &quot;L&quot;, &quot;L&quot;, &quot;L&quot;, &quot;L&quot;, &quot;L&quot;, &quot;L&quot;, &quot;L&quot;, &quot;L&quot;, &quot;ON&quot;, &quot;ON&quot;, &quot;ON&quot;, &quot;ON&quot;, &quot;BN&quot;, &quot;BN&quot;, &quot;BN&quot;, &quot;BN&quot;, &quot;BN&quot;, &quot;BN&quot;, &quot;B&quot;, &quot;BN&quot;, &quot;BN&quot;, &quot;BN&quot;, &quot;BN&quot;, &quot;BN&quot;, &quot;BN&quot;, &quot;BN&quot;, &quot;BN&quot;, &quot;BN&quot;, &quot;BN&quot;, &quot;BN&quot;, &quot;BN&quot;, &quot;BN&quot;, &quot;BN&quot;, &quot;BN&quot;, &quot;BN&quot;, &quot;BN&quot;, &quot;BN&quot;, &quot;BN&quot;, &quot;BN&quot;, &quot;BN&quot;, &quot;BN&quot;, &quot;BN&quot;, &quot;BN&quot;, &quot;BN&quot;, &quot;BN&quot;, &quot;CS&quot;, &quot;ON&quot;, &quot;ET&quot;, &quot;ET&quot;, &quot;ET&quot;, &quot;ET&quot;, &quot;ON&quot;, &quot;ON&quot;, &quot;ON&quot;, &quot;ON&quot;, &quot;L&quot;, &quot;ON&quot;, &quot;ON&quot;, &quot;BN&quot;, &quot;ON&quot;, &quot;ON&quot;, &quot;ET&quot;, &quot;ET&quot;, &quot;EN&quot;, &quot;EN&quot;, &quot;ON&quot;, &quot;L&quot;, &quot;ON&quot;, &quot;ON&quot;, &quot;ON&quot;, &quot;EN&quot;, &quot;L&quot;, &quot;ON&quot;, &quot;ON&quot;, &quot;ON&quot;, &quot;ON&quot;, &quot;ON&quot;, &quot;L&quot;, &quot;L&quot;, &quot;L&quot;, &quot;L&quot;, &quot;L&quot;, &quot;L&quot;, &quot;L&quot;, &quot;L&quot;, &quot;L&quot;, &quot;L&quot;, &quot;L&quot;, &quot;L&quot;, &quot;L&quot;, &quot;L&quot;, &quot;L&quot;, &quot;L&quot;, &quot;L&quot;, &quot;L&quot;, &quot;L&quot;, &quot;L&quot;, &quot;L&quot;, &quot;L&quot;, &quot;L&quot;, &quot;ON&quot;, &quot;L&quot;, &quot;L&quot;, &quot;L&quot;, &quot;L&quot;, &quot;L&quot;, &quot;L&quot;, &quot;L&quot;, &quot;L&quot;, &quot;L&quot;, &quot;L&quot;, &quot;L&quot;, &quot;L&quot;, &quot;L&quot;, &quot;L&quot;, &quot;L&quot;, &quot;L&quot;, &quot;L&quot;, &quot;L&quot;, &quot;L&quot;, &quot;L&quot;, &quot;L&quot;, &quot;L&quot;, &quot;L&quot;, &quot;L&quot;, &quot;L&quot;, &quot;L&quot;, &quot;L&quot;, &quot;L&quot;, &quot;L&quot;, &quot;L&quot;, &quot;L&quot;, &quot;ON&quot;, &quot;L&quot;, &quot;L&quot;, &quot;L&quot;, &quot;L&quot;, &quot;L&quot;, &quot;L&quot;, &quot;L&quot;, &quot;L&quot;]; const arabicTypes = [&quot;AN&quot;, &quot;AN&quot;, &quot;AN&quot;, &quot;AN&quot;, &quot;AN&quot;, &quot;AN&quot;, &quot;ON&quot;, &quot;ON&quot;, &quot;AL&quot;, &quot;ET&quot;, &quot;ET&quot;, &quot;AL&quot;, &quot;CS&quot;, &quot;AL&quot;, &quot;ON&quot;, &quot;ON&quot;, &quot;NSM&quot;, &quot;NSM&quot;, &quot;NSM&quot;, &quot;NSM&quot;, &quot;NSM&quot;, &quot;NSM&quot;, &quot;NSM&quot;, &quot;NSM&quot;, &quot;NSM&quot;, &quot;NSM&quot;, &quot;NSM&quot;, &quot;AL&quot;, &quot;AL&quot;, &quot;&quot;, &quot;AL&quot;, &quot;AL&quot;, &quot;AL&quot;, &quot;AL&quot;, &quot;AL&quot;, &quot;AL&quot;, &quot;AL&quot;, &quot;AL&quot;, &quot;AL&quot;, &quot;AL&quot;, &quot;AL&quot;, &quot;AL&quot;, &quot;AL&quot;, &quot;AL&quot;, &quot;AL&quot;, &quot;AL&quot;, &quot;AL&quot;, &quot;AL&quot;, &quot;AL&quot;, &quot;AL&quot;, &quot;AL&quot;, &quot;AL&quot;, &quot;AL&quot;, &quot;AL&quot;, &quot;AL&quot;, &quot;AL&quot;, &quot;AL&quot;, &quot;AL&quot;, &quot;AL&quot;, &quot;AL&quot;, &quot;AL&quot;, &quot;AL&quot;, &quot;AL&quot;, &quot;AL&quot;, &quot;AL&quot;, &quot;AL&quot;, &quot;AL&quot;, &quot;AL&quot;, &quot;AL&quot;, &quot;AL&quot;, &quot;AL&quot;, &quot;AL&quot;, &quot;AL&quot;, &quot;AL&quot;, &quot;AL&quot;, &quot;NSM&quot;, &quot;NSM&quot;, &quot;NSM&quot;, &quot;NSM&quot;, &quot;NSM&quot;, &quot;NSM&quot;, &quot;NSM&quot;, &quot;NSM&quot;, &quot;NSM&quot;, &quot;NSM&quot;, &quot;NSM&quot;, &quot;NSM&quot;, &quot;NSM&quot;, &quot;NSM&quot;, &quot;NSM&quot;, &quot;NSM&quot;, &quot;NSM&quot;, &quot;NSM&quot;, &quot;NSM&quot;, &quot;NSM&quot;, &quot;NSM&quot;, &quot;AN&quot;, &quot;AN&quot;, &quot;AN&quot;, &quot;AN&quot;, &quot;AN&quot;, &quot;AN&quot;, &quot;AN&quot;, &quot;AN&quot;, &quot;AN&quot;, &quot;AN&quot;, &quot;ET&quot;, &quot;AN&quot;, &quot;AN&quot;, &quot;AL&quot;, &quot;AL&quot;, &quot;AL&quot;, &quot;NSM&quot;, &quot;AL&quot;, &quot;AL&quot;, &quot;AL&quot;, &quot;AL&quot;, &quot;AL&quot;, &quot;AL&quot;, &quot;AL&quot;, &quot;AL&quot;, &quot;AL&quot;, &quot;AL&quot;, &quot;AL&quot;, &quot;AL&quot;, &quot;AL&quot;, &quot;AL&quot;, &quot;AL&quot;, &quot;AL&quot;, &quot;AL&quot;, &quot;AL&quot;, &quot;AL&quot;, &quot;AL&quot;, &quot;AL&quot;, &quot;AL&quot;, &quot;AL&quot;, &quot;AL&quot;, &quot;AL&quot;, &quot;AL&quot;, &quot;AL&quot;, &quot;AL&quot;, &quot;AL&quot;, &quot;AL&quot;, &quot;AL&quot;, &quot;AL&quot;, &quot;AL&quot;, &quot;AL&quot;, &quot;AL&quot;, &quot;AL&quot;, &quot;AL&quot;, &quot;AL&quot;, &quot;AL&quot;, &quot;AL&quot;, &quot;AL&quot;, &quot;AL&quot;, &quot;AL&quot;, &quot;AL&quot;, &quot;AL&quot;, &quot;AL&quot;, &quot;AL&quot;, &quot;AL&quot;, &quot;AL&quot;, &quot;AL&quot;, &quot;AL&quot;, &quot;AL&quot;, &quot;AL&quot;, &quot;AL&quot;, &quot;AL&quot;, &quot;AL&quot;, &quot;AL&quot;, &quot;AL&quot;, &quot;AL&quot;, &quot;AL&quot;, &quot;AL&quot;, &quot;AL&quot;, &quot;AL&quot;, &quot;AL&quot;, &quot;AL&quot;, &quot;AL&quot;, &quot;AL&quot;, &quot;AL&quot;, &quot;AL&quot;, &quot;AL&quot;, &quot;AL&quot;, &quot;AL&quot;, &quot;AL&quot;, &quot;AL&quot;, &quot;AL&quot;, &quot;AL&quot;, &quot;AL&quot;, &quot;AL&quot;, &quot;AL&quot;, &quot;AL&quot;, &quot;AL&quot;, &quot;AL&quot;, &quot;AL&quot;, &quot;AL&quot;, &quot;AL&quot;, &quot;AL&quot;, &quot;AL&quot;, &quot;AL&quot;, &quot;AL&quot;, &quot;AL&quot;, &quot;AL&quot;, &quot;AL&quot;, &quot;AL&quot;, &quot;AL&quot;, &quot;AL&quot;, &quot;AL&quot;, &quot;AL&quot;, &quot;AL&quot;, &quot;AL&quot;, &quot;AL&quot;, &quot;AL&quot;, &quot;NSM&quot;, &quot;NSM&quot;, &quot;NSM&quot;, &quot;NSM&quot;, &quot;NSM&quot;, &quot;NSM&quot;, &quot;NSM&quot;, &quot;AN&quot;, &quot;ON&quot;, &quot;NSM&quot;, &quot;NSM&quot;, &quot;NSM&quot;, &quot;NSM&quot;, &quot;NSM&quot;, &quot;NSM&quot;, &quot;AL&quot;, &quot;AL&quot;, &quot;NSM&quot;, &quot;NSM&quot;, &quot;ON&quot;, &quot;NSM&quot;, &quot;NSM&quot;, &quot;NSM&quot;, &quot;NSM&quot;, &quot;AL&quot;, &quot;AL&quot;, &quot;EN&quot;, &quot;EN&quot;, &quot;EN&quot;, &quot;EN&quot;, &quot;EN&quot;, &quot;EN&quot;, &quot;EN&quot;, &quot;EN&quot;, &quot;EN&quot;, &quot;EN&quot;, &quot;AL&quot;, &quot;AL&quot;, &quot;AL&quot;, &quot;AL&quot;, &quot;AL&quot;, &quot;AL&quot;]; function isOdd(i) { return (i &amp; 1) !== 0; } function isEven(i) { return (i &amp; 1) === 0; } function findUnequal(arr, start, value) { let j, jj; for (j = start, jj = arr.length; j &lt; jj; ++j) { if (arr[j] !== value) { return j; } } return j; } function setValues(arr, start, end, value) { for (let j = start; j &lt; end; ++j) { arr[j] = value; } } function reverseValues(arr, start, end) { for (let i = start, j = end - 1; i &lt; j; ++i, --j) { const temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; } } function createBidiText(str, isLTR, vertical = false) { let dir = &quot;ltr&quot;; if (vertical) { dir = &quot;ttb&quot;; } else if (!isLTR) { dir = &quot;rtl&quot;; } return { str, dir }; } const chars = []; const types = []; function bidi(str, startLevel = -1, vertical = false) { let isLTR = true; const strLength = str.length; if (strLength === 0 || vertical) { return createBidiText(str, isLTR, vertical); } chars.length = strLength; types.length = strLength; let numBidi = 0; let i, ii; for (i = 0; i &lt; strLength; ++i) { chars[i] = str.charAt(i); const charCode = str.charCodeAt(i); let charType = &quot;L&quot;; if (charCode &lt;= 0x00ff) { charType = baseTypes[charCode]; } else if (0x0590 &lt;= charCode &amp;&amp; charCode &lt;= 0x05f4) { charType = &quot;R&quot;; } else if (0x0600 &lt;= charCode &amp;&amp; charCode &lt;= 0x06ff) { charType = arabicTypes[charCode &amp; 0xff]; if (!charType) { (0, _util.warn)(&quot;Bidi: invalid Unicode character &quot; + charCode.toString(16)); } } else if (0x0700 &lt;= charCode &amp;&amp; charCode &lt;= 0x08ac) { charType = &quot;AL&quot;; } if (charType === &quot;R&quot; || charType === &quot;AL&quot; || charType === &quot;AN&quot;) { numBidi++; } types[i] = charType; } if (numBidi === 0) { isLTR = true; return createBidiText(str, isLTR); } if (startLevel === -1) { if (numBidi / strLength &lt; 0.3 &amp;&amp; strLength &gt; 4) { isLTR = true; startLevel = 0; } else { isLTR = false; startLevel = 1; } } const levels = []; for (i = 0; i &lt; strLength; ++i) { levels[i] = startLevel; } const e = isOdd(startLevel) ? &quot;R&quot; : &quot;L&quot;; const sor = e; const eor = sor; let lastType = sor; for (i = 0; i &lt; strLength; ++i) { if (types[i] === &quot;NSM&quot;) { types[i] = lastType; } else { lastType = types[i]; } } lastType = sor; let t; for (i = 0; i &lt; strLength; ++i) { t = types[i]; if (t === &quot;EN&quot;) { types[i] = lastType === &quot;AL&quot; ? &quot;AN&quot; : &quot;EN&quot;; } else if (t === &quot;R&quot; || t === &quot;L&quot; || t === &quot;AL&quot;) { lastType = t; } } for (i = 0; i &lt; strLength; ++i) { t = types[i]; if (t === &quot;AL&quot;) { types[i] = &quot;R&quot;; } } for (i = 1; i &lt; strLength - 1; ++i) { if (types[i] === &quot;ES&quot; &amp;&amp; types[i - 1] === &quot;EN&quot; &amp;&amp; types[i + 1] === &quot;EN&quot;) { types[i] = &quot;EN&quot;; } if (types[i] === &quot;CS&quot; &amp;&amp; (types[i - 1] === &quot;EN&quot; || types[i - 1] === &quot;AN&quot;) &amp;&amp; types[i + 1] === types[i - 1]) { types[i] = types[i - 1]; } } for (i = 0; i &lt; strLength; ++i) { if (types[i] === &quot;EN&quot;) { for (let j = i - 1; j &gt;= 0; --j) { if (types[j] !== &quot;ET&quot;) { break; } types[j] = &quot;EN&quot;; } for (let j = i + 1; j &lt; strLength; ++j) { if (types[j] !== &quot;ET&quot;) { break; } types[j] = &quot;EN&quot;; } } } for (i = 0; i &lt; strLength; ++i) { t = types[i]; if (t === &quot;WS&quot; || t === &quot;ES&quot; || t === &quot;ET&quot; || t === &quot;CS&quot;) { types[i] = &quot;ON&quot;; } } lastType = sor; for (i = 0; i &lt; strLength; ++i) { t = types[i]; if (t === &quot;EN&quot;) { types[i] = lastType === &quot;L&quot; ? &quot;L&quot; : &quot;EN&quot;; } else if (t === &quot;R&quot; || t === &quot;L&quot;) { lastType = t; } } for (i = 0; i &lt; strLength; ++i) { if (types[i] === &quot;ON&quot;) { const end = findUnequal(types, i + 1, &quot;ON&quot;); let before = sor; if (i &gt; 0) { before = types[i - 1]; } let after = eor; if (end + 1 &lt; strLength) { after = types[end + 1]; } if (before !== &quot;L&quot;) { before = &quot;R&quot;; } if (after !== &quot;L&quot;) { after = &quot;R&quot;; } if (before === after) { setValues(types, i, end, before); } i = end - 1; } } for (i = 0; i &lt; strLength; ++i) { if (types[i] === &quot;ON&quot;) { types[i] = e; } } for (i = 0; i &lt; strLength; ++i) { t = types[i]; if (isEven(levels[i])) { if (t === &quot;R&quot;) { levels[i] += 1; } else if (t === &quot;AN&quot; || t === &quot;EN&quot;) { levels[i] += 2; } } else { if (t === &quot;L&quot; || t === &quot;AN&quot; || t === &quot;EN&quot;) { levels[i] += 1; } } } let highestLevel = -1; let lowestOddLevel = 99; let level; for (i = 0, ii = levels.length; i &lt; ii; ++i) { level = levels[i]; if (highestLevel &lt; level) { highestLevel = level; } if (lowestOddLevel &gt; level &amp;&amp; isOdd(level)) { lowestOddLevel = level; } } for (level = highestLevel; level &gt;= lowestOddLevel; --level) { let start = -1; for (i = 0, ii = levels.length; i &lt; ii; ++i) { if (levels[i] &lt; level) { if (start &gt;= 0) { reverseValues(chars, start, i); start = -1; } } else if (start &lt; 0) { start = i; } } if (start &gt;= 0) { reverseValues(chars, start, levels.length); } } for (i = 0, ii = chars.length; i &lt; ii; ++i) { const ch = chars[i]; if (ch === &quot;&lt;&quot; || ch === &quot;&gt;&quot;) { chars[i] = &quot;&quot;; } } return createBidiText(chars.join(&quot;&quot;), isLTR); } /***/ }), /* 59 */ /***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) =&gt; { Object.defineProperty(exports, &quot;__esModule&quot;, ({ value: true })); exports.MurmurHash3_64 = void 0; var _util = __w_pdfjs_require__(2); const SEED = 0xc3d2e1f0; const MASK_HIGH = 0xffff0000; const MASK_LOW = 0xffff; class MurmurHash3_64 { constructor(seed) { this.h1 = seed ? seed &amp; 0xffffffff : SEED; this.h2 = seed ? seed &amp; 0xffffffff : SEED; } update(input) { let data, length; if (typeof input === &quot;string&quot;) { data = new Uint8Array(input.length * 2); length = 0; for (let i = 0, ii = input.length; i &lt; ii; i++) { const code = input.charCodeAt(i); if (code &lt;= 0xff) { data[length++] = code; } else { data[length++] = code &gt;&gt;&gt; 8; data[length++] = code &amp; 0xff; } } } else if ((0, _util.isArrayBuffer)(input)) { data = input.slice(); length = data.byteLength; } else { throw new Error(&quot;Wrong data format in MurmurHash3_64_update. &quot; + &quot;Input must be a string or array.&quot;); } const blockCounts = length &gt;&gt; 2; const tailLength = length - blockCounts * 4; const dataUint32 = new Uint32Array(data.buffer, 0, blockCounts); let k1 = 0, k2 = 0; let h1 = this.h1, h2 = this.h2; const C1 = 0xcc9e2d51, C2 = 0x1b873593; const C1_LOW = C1 &amp; MASK_LOW, C2_LOW = C2 &amp; MASK_LOW; for (let i = 0; i &lt; blockCounts; i++) { if (i &amp; 1) { k1 = dataUint32[i]; k1 = k1 * C1 &amp; MASK_HIGH | k1 * C1_LOW &amp; MASK_LOW; k1 = k1 &lt;&lt; 15 | k1 &gt;&gt;&gt; 17; k1 = k1 * C2 &amp; MASK_HIGH | k1 * C2_LOW &amp; MASK_LOW; h1 ^= k1; h1 = h1 &lt;&lt; 13 | h1 &gt;&gt;&gt; 19; h1 = h1 * 5 + 0xe6546b64; } else { k2 = dataUint32[i]; k2 = k2 * C1 &amp; MASK_HIGH | k2 * C1_LOW &amp; MASK_LOW; k2 = k2 &lt;&lt; 15 | k2 &gt;&gt;&gt; 17; k2 = k2 * C2 &amp; MASK_HIGH | k2 * C2_LOW &amp; MASK_LOW; h2 ^= k2; h2 = h2 &lt;&lt; 13 | h2 &gt;&gt;&gt; 19; h2 = h2 * 5 + 0xe6546b64; } } k1 = 0; switch (tailLength) { case 3: k1 ^= data[blockCounts * 4 + 2] &lt;&lt; 16; case 2: k1 ^= data[blockCounts * 4 + 1] &lt;&lt; 8; case 1: k1 ^= data[blockCounts * 4]; k1 = k1 * C1 &amp; MASK_HIGH | k1 * C1_LOW &amp; MASK_LOW; k1 = k1 &lt;&lt; 15 | k1 &gt;&gt;&gt; 17; k1 = k1 * C2 &amp; MASK_HIGH | k1 * C2_LOW &amp; MASK_LOW; if (blockCounts &amp; 1) { h1 ^= k1; } else { h2 ^= k1; } } this.h1 = h1; this.h2 = h2; } hexdigest() { let h1 = this.h1, h2 = this.h2; h1 ^= h2 &gt;&gt;&gt; 1; h1 = h1 * 0xed558ccd &amp; MASK_HIGH | h1 * 0x8ccd &amp; MASK_LOW; h2 = h2 * 0xff51afd7 &amp; MASK_HIGH | ((h2 &lt;&lt; 16 | h1 &gt;&gt;&gt; 16) * 0xafd7ed55 &amp; MASK_HIGH) &gt;&gt;&gt; 16; h1 ^= h2 &gt;&gt;&gt; 1; h1 = h1 * 0x1a85ec53 &amp; MASK_HIGH | h1 * 0xec53 &amp; MASK_LOW; h2 = h2 * 0xc4ceb9fe &amp; MASK_HIGH | ((h2 &lt;&lt; 16 | h1 &gt;&gt;&gt; 16) * 0xb9fe1a85 &amp; MASK_HIGH) &gt;&gt;&gt; 16; h1 ^= h2 &gt;&gt;&gt; 1; const hex1 = (h1 &gt;&gt;&gt; 0).toString(16), hex2 = (h2 &gt;&gt;&gt; 0).toString(16); return hex1.padStart(8, &quot;0&quot;) + hex2.padStart(8, &quot;0&quot;); } } exports.MurmurHash3_64 = MurmurHash3_64; /***/ }), /* 60 */ /***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) =&gt; { Object.defineProperty(exports, &quot;__esModule&quot;, ({ value: true })); exports.OperatorList = void 0; var _util = __w_pdfjs_require__(2); function addState(parentState, pattern, checkFn, iterateFn, processFn) { let state = parentState; for (let i = 0, ii = pattern.length - 1; i &lt; ii; i++) { const item = pattern[i]; state = state[item] || (state[item] = []); } state[pattern.at(-1)] = { checkFn, iterateFn, processFn }; } const InitialState = []; addState(InitialState, [_util.OPS.save, _util.OPS.transform, _util.OPS.paintInlineImageXObject, _util.OPS.restore], null, function iterateInlineImageGroup(context, i) { const fnArray = context.fnArray; const iFirstSave = context.iCurr - 3; const pos = (i - iFirstSave) % 4; switch (pos) { case 0: return fnArray[i] === _util.OPS.save; case 1: return fnArray[i] === _util.OPS.transform; case 2: return fnArray[i] === _util.OPS.paintInlineImageXObject; case 3: return fnArray[i] === _util.OPS.restore; } throw new Error(`iterateInlineImageGroup - invalid pos: ${pos}`); }, function foundInlineImageGroup(context, i) { const MIN_IMAGES_IN_INLINE_IMAGES_BLOCK = 10; const MAX_IMAGES_IN_INLINE_IMAGES_BLOCK = 200; const MAX_WIDTH = 1000; const IMAGE_PADDING = 1; const fnArray = context.fnArray, argsArray = context.argsArray; const curr = context.iCurr; const iFirstSave = curr - 3; const iFirstTransform = curr - 2; const iFirstPIIXO = curr - 1; const count = Math.min(Math.floor((i - iFirstSave) / 4), MAX_IMAGES_IN_INLINE_IMAGES_BLOCK); if (count &lt; MIN_IMAGES_IN_INLINE_IMAGES_BLOCK) { return i - (i - iFirstSave) % 4; } let maxX = 0; const map = []; let maxLineHeight = 0; let currentX = IMAGE_PADDING, currentY = IMAGE_PADDING; for (let q = 0; q &lt; count; q++) { const transform = argsArray[iFirstTransform + (q &lt;&lt; 2)]; const img = argsArray[iFirstPIIXO + (q &lt;&lt; 2)][0]; if (currentX + img.width &gt; MAX_WIDTH) { maxX = Math.max(maxX, currentX); currentY += maxLineHeight + 2 * IMAGE_PADDING; currentX = 0; maxLineHeight = 0; } map.push({ transform, x: currentX, y: currentY, w: img.width, h: img.height }); currentX += img.width + 2 * IMAGE_PADDING; maxLineHeight = Math.max(maxLineHeight, img.height); } const imgWidth = Math.max(maxX, currentX) + IMAGE_PADDING; const imgHeight = currentY + maxLineHeight + IMAGE_PADDING; const imgData = new Uint8Array(imgWidth * imgHeight * 4); const imgRowSize = imgWidth &lt;&lt; 2; for (let q = 0; q &lt; count; q++) { const data = argsArray[iFirstPIIXO + (q &lt;&lt; 2)][0].data; const rowSize = map[q].w &lt;&lt; 2; let dataOffset = 0; let offset = map[q].x + map[q].y * imgWidth &lt;&lt; 2; imgData.set(data.subarray(0, rowSize), offset - imgRowSize); for (let k = 0, kk = map[q].h; k &lt; kk; k++) { imgData.set(data.subarray(dataOffset, dataOffset + rowSize), offset); dataOffset += rowSize; offset += imgRowSize; } imgData.set(data.subarray(dataOffset - rowSize, dataOffset), offset); while (offset &gt;= 0) { data[offset - 4] = data[offset]; data[offset - 3] = data[offset + 1]; data[offset - 2] = data[offset + 2]; data[offset - 1] = data[offset + 3]; data[offset + rowSize] = data[offset + rowSize - 4]; data[offset + rowSize + 1] = data[offset + rowSize - 3]; data[offset + rowSize + 2] = data[offset + rowSize - 2]; data[offset + rowSize + 3] = data[offset + rowSize - 1]; offset -= imgRowSize; } } fnArray.splice(iFirstSave, count * 4, _util.OPS.paintInlineImageXObjectGroup); argsArray.splice(iFirstSave, count * 4, [{ width: imgWidth, height: imgHeight, kind: _util.ImageKind.RGBA_32BPP, data: imgData }, map]); return iFirstSave + 1; }); addState(InitialState, [_util.OPS.save, _util.OPS.transform, _util.OPS.paintImageMaskXObject, _util.OPS.restore], null, function iterateImageMaskGroup(context, i) { const fnArray = context.fnArray; const iFirstSave = context.iCurr - 3; const pos = (i - iFirstSave) % 4; switch (pos) { case 0: return fnArray[i] === _util.OPS.save; case 1: return fnArray[i] === _util.OPS.transform; case 2: return fnArray[i] === _util.OPS.paintImageMaskXObject; case 3: return fnArray[i] === _util.OPS.restore; } throw new Error(`iterateImageMaskGroup - invalid pos: ${pos}`); }, function foundImageMaskGroup(context, i) { const MIN_IMAGES_IN_MASKS_BLOCK = 10; const MAX_IMAGES_IN_MASKS_BLOCK = 100; const MAX_SAME_IMAGES_IN_MASKS_BLOCK = 1000; const fnArray = context.fnArray, argsArray = context.argsArray; const curr = context.iCurr; const iFirstSave = curr - 3; const iFirstTransform = curr - 2; const iFirstPIMXO = curr - 1; let count = Math.floor((i - iFirstSave) / 4); if (count &lt; MIN_IMAGES_IN_MASKS_BLOCK) { return i - (i - iFirstSave) % 4; } let isSameImage = false; let iTransform, transformArgs; const firstPIMXOArg0 = argsArray[iFirstPIMXO][0]; const firstTransformArg0 = argsArray[iFirstTransform][0], firstTransformArg1 = argsArray[iFirstTransform][1], firstTransformArg2 = argsArray[iFirstTransform][2], firstTransformArg3 = argsArray[iFirstTransform][3]; if (firstTransformArg1 === firstTransformArg2) { isSameImage = true; iTransform = iFirstTransform + 4; let iPIMXO = iFirstPIMXO + 4; for (let q = 1; q &lt; count; q++, iTransform += 4, iPIMXO += 4) { transformArgs = argsArray[iTransform]; if (argsArray[iPIMXO][0] !== firstPIMXOArg0 || transformArgs[0] !== firstTransformArg0 || transformArgs[1] !== firstTransformArg1 || transformArgs[2] !== firstTransformArg2 || transformArgs[3] !== firstTransformArg3) { if (q &lt; MIN_IMAGES_IN_MASKS_BLOCK) { isSameImage = false; } else { count = q; } break; } } } if (isSameImage) { count = Math.min(count, MAX_SAME_IMAGES_IN_MASKS_BLOCK); const positions = new Float32Array(count * 2); iTransform = iFirstTransform; for (let q = 0; q &lt; count; q++, iTransform += 4) { transformArgs = argsArray[iTransform]; positions[q &lt;&lt; 1] = transformArgs[4]; positions[(q &lt;&lt; 1) + 1] = transformArgs[5]; } fnArray.splice(iFirstSave, count * 4, _util.OPS.paintImageMaskXObjectRepeat); argsArray.splice(iFirstSave, count * 4, [firstPIMXOArg0, firstTransformArg0, firstTransformArg1, firstTransformArg2, firstTransformArg3, positions]); } else { count = Math.min(count, MAX_IMAGES_IN_MASKS_BLOCK); const images = []; for (let q = 0; q &lt; count; q++) { transformArgs = argsArray[iFirstTransform + (q &lt;&lt; 2)]; const maskParams = argsArray[iFirstPIMXO + (q &lt;&lt; 2)][0]; images.push({ data: maskParams.data, width: maskParams.width, height: maskParams.height, interpolate: maskParams.interpolate, count: maskParams.count, transform: transformArgs }); } fnArray.splice(iFirstSave, count * 4, _util.OPS.paintImageMaskXObjectGroup); argsArray.splice(iFirstSave, count * 4, [images]); } return iFirstSave + 1; }); addState(InitialState, [_util.OPS.save, _util.OPS.transform, _util.OPS.paintImageXObject, _util.OPS.restore], function (context) { const argsArray = context.argsArray; const iFirstTransform = context.iCurr - 2; return argsArray[iFirstTransform][1] === 0 &amp;&amp; argsArray[iFirstTransform][2] === 0; }, function iterateImageGroup(context, i) { const fnArray = context.fnArray, argsArray = context.argsArray; const iFirstSave = context.iCurr - 3; const pos = (i - iFirstSave) % 4; switch (pos) { case 0: return fnArray[i] === _util.OPS.save; case 1: if (fnArray[i] !== _util.OPS.transform) { return false; } const iFirstTransform = context.iCurr - 2; const firstTransformArg0 = argsArray[iFirstTransform][0]; const firstTransformArg3 = argsArray[iFirstTransform][3]; if (argsArray[i][0] !== firstTransformArg0 || argsArray[i][1] !== 0 || argsArray[i][2] !== 0 || argsArray[i][3] !== firstTransformArg3) { return false; } return true; case 2: if (fnArray[i] !== _util.OPS.paintImageXObject) { return false; } const iFirstPIXO = context.iCurr - 1; const firstPIXOArg0 = argsArray[iFirstPIXO][0]; if (argsArray[i][0] !== firstPIXOArg0) { return false; } return true; case 3: return fnArray[i] === _util.OPS.restore; } throw new Error(`iterateImageGroup - invalid pos: ${pos}`); }, function (context, i) { const MIN_IMAGES_IN_BLOCK = 3; const MAX_IMAGES_IN_BLOCK = 1000; const fnArray = context.fnArray, argsArray = context.argsArray; const curr = context.iCurr; const iFirstSave = curr - 3; const iFirstTransform = curr - 2; const iFirstPIXO = curr - 1; const firstPIXOArg0 = argsArray[iFirstPIXO][0]; const firstTransformArg0 = argsArray[iFirstTransform][0]; const firstTransformArg3 = argsArray[iFirstTransform][3]; const count = Math.min(Math.floor((i - iFirstSave) / 4), MAX_IMAGES_IN_BLOCK); if (count &lt; MIN_IMAGES_IN_BLOCK) { return i - (i - iFirstSave) % 4; } const positions = new Float32Array(count * 2); let iTransform = iFirstTransform; for (let q = 0; q &lt; count; q++, iTransform += 4) { const transformArgs = argsArray[iTransform]; positions[q &lt;&lt; 1] = transformArgs[4]; positions[(q &lt;&lt; 1) + 1] = transformArgs[5]; } const args = [firstPIXOArg0, firstTransformArg0, firstTransformArg3, positions]; fnArray.splice(iFirstSave, count * 4, _util.OPS.paintImageXObjectRepeat); argsArray.splice(iFirstSave, count * 4, args); return iFirstSave + 1; }); addState(InitialState, [_util.OPS.beginText, _util.OPS.setFont, _util.OPS.setTextMatrix, _util.OPS.showText, _util.OPS.endText], null, function iterateShowTextGroup(context, i) { const fnArray = context.fnArray, argsArray = context.argsArray; const iFirstSave = context.iCurr - 4; const pos = (i - iFirstSave) % 5; switch (pos) { case 0: return fnArray[i] === _util.OPS.beginText; case 1: return fnArray[i] === _util.OPS.setFont; case 2: return fnArray[i] === _util.OPS.setTextMatrix; case 3: if (fnArray[i] !== _util.OPS.showText) { return false; } const iFirstSetFont = context.iCurr - 3; const firstSetFontArg0 = argsArray[iFirstSetFont][0]; const firstSetFontArg1 = argsArray[iFirstSetFont][1]; if (argsArray[i][0] !== firstSetFontArg0 || argsArray[i][1] !== firstSetFontArg1) { return false; } return true; case 4: return fnArray[i] === _util.OPS.endText; } throw new Error(`iterateShowTextGroup - invalid pos: ${pos}`); }, function (context, i) { const MIN_CHARS_IN_BLOCK = 3; const MAX_CHARS_IN_BLOCK = 1000; const fnArray = context.fnArray, argsArray = context.argsArray; const curr = context.iCurr; const iFirstBeginText = curr - 4; const iFirstSetFont = curr - 3; const iFirstSetTextMatrix = curr - 2; const iFirstShowText = curr - 1; const iFirstEndText = curr; const firstSetFontArg0 = argsArray[iFirstSetFont][0]; const firstSetFontArg1 = argsArray[iFirstSetFont][1]; let count = Math.min(Math.floor((i - iFirstBeginText) / 5), MAX_CHARS_IN_BLOCK); if (count &lt; MIN_CHARS_IN_BLOCK) { return i - (i - iFirstBeginText) % 5; } let iFirst = iFirstBeginText; if (iFirstBeginText &gt;= 4 &amp;&amp; fnArray[iFirstBeginText - 4] === fnArray[iFirstSetFont] &amp;&amp; fnArray[iFirstBeginText - 3] === fnArray[iFirstSetTextMatrix] &amp;&amp; fnArray[iFirstBeginText - 2] === fnArray[iFirstShowText] &amp;&amp; fnArray[iFirstBeginText - 1] === fnArray[iFirstEndText] &amp;&amp; argsArray[iFirstBeginText - 4][0] === firstSetFontArg0 &amp;&amp; argsArray[iFirstBeginText - 4][1] === firstSetFontArg1) { count++; iFirst -= 5; } let iEndText = iFirst + 4; for (let q = 1; q &lt; count; q++) { fnArray.splice(iEndText, 3); argsArray.splice(iEndText, 3); iEndText += 2; } return iEndText + 1; }); class NullOptimizer { constructor(queue) { this.queue = queue; } _optimize() {} push(fn, args) { this.queue.fnArray.push(fn); this.queue.argsArray.push(args); this._optimize(); } flush() {} reset() {} } class QueueOptimizer extends NullOptimizer { constructor(queue) { super(queue); this.state = null; this.context = { iCurr: 0, fnArray: queue.fnArray, argsArray: queue.argsArray }; this.match = null; this.lastProcessed = 0; } _optimize() { const fnArray = this.queue.fnArray; let i = this.lastProcessed, ii = fnArray.length; let state = this.state; let match = this.match; if (!state &amp;&amp; !match &amp;&amp; i + 1 === ii &amp;&amp; !InitialState[fnArray[i]]) { this.lastProcessed = ii; return; } const context = this.context; while (i &lt; ii) { if (match) { const iterate = (0, match.iterateFn)(context, i); if (iterate) { i++; continue; } i = (0, match.processFn)(context, i + 1); ii = fnArray.length; match = null; state = null; if (i &gt;= ii) { break; } } state = (state || InitialState)[fnArray[i]]; if (!state || Array.isArray(state)) { i++; continue; } context.iCurr = i; i++; if (state.checkFn &amp;&amp; !(0, state.checkFn)(context)) { state = null; continue; } match = state; state = null; } this.state = state; this.match = match; this.lastProcessed = i; } flush() { while (this.match) { const length = this.queue.fnArray.length; this.lastProcessed = (0, this.match.processFn)(this.context, length); this.match = null; this.state = null; this._optimize(); } } reset() { this.state = null; this.match = null; this.lastProcessed = 0; } } class OperatorList { static get CHUNK_SIZE() { return (0, _util.shadow)(this, &quot;CHUNK_SIZE&quot;, 1000); } static get CHUNK_SIZE_ABOUT() { return (0, _util.shadow)(this, &quot;CHUNK_SIZE_ABOUT&quot;, this.CHUNK_SIZE - 5); } constructor(intent = 0, streamSink) { this._streamSink = streamSink; this.fnArray = []; this.argsArray = []; if (streamSink &amp;&amp; !(intent &amp; _util.RenderingIntentFlag.OPLIST)) { this.optimizer = new QueueOptimizer(this); } else { this.optimizer = new NullOptimizer(this); } this.dependencies = new Set(); this._totalLength = 0; this.weight = 0; this._resolved = streamSink ? null : Promise.resolve(); } get length() { return this.argsArray.length; } get ready() { return this._resolved || this._streamSink.ready; } get totalLength() { return this._totalLength + this.length; } addOp(fn, args) { this.optimizer.push(fn, args); this.weight++; if (this._streamSink) { if (this.weight &gt;= OperatorList.CHUNK_SIZE) { this.flush(); } else if (this.weight &gt;= OperatorList.CHUNK_SIZE_ABOUT &amp;&amp; (fn === _util.OPS.restore || fn === _util.OPS.endText)) { this.flush(); } } } addImageOps(fn, args, optionalContent) { if (optionalContent !== undefined) { this.addOp(_util.OPS.beginMarkedContentProps, [&quot;OC&quot;, optionalContent]); } this.addOp(fn, args); if (optionalContent !== undefined) { this.addOp(_util.OPS.endMarkedContent, []); } } addDependency(dependency) { if (this.dependencies.has(dependency)) { return; } this.dependencies.add(dependency); this.addOp(_util.OPS.dependency, [dependency]); } addDependencies(dependencies) { for (const dependency of dependencies) { this.addDependency(dependency); } } addOpList(opList) { if (!(opList instanceof OperatorList)) { (0, _util.warn)(&apos;addOpList - ignoring invalid &quot;opList&quot; parameter.&apos;); return; } for (const dependency of opList.dependencies) { this.dependencies.add(dependency); } for (let i = 0, ii = opList.length; i &lt; ii; i++) { this.addOp(opList.fnArray[i], opList.argsArray[i]); } } getIR() { return { fnArray: this.fnArray, argsArray: this.argsArray, length: this.length }; } get _transfers() { const transfers = []; const { fnArray, argsArray, length } = this; for (let i = 0; i &lt; length; i++) { switch (fnArray[i]) { case _util.OPS.paintInlineImageXObject: case _util.OPS.paintInlineImageXObjectGroup: case _util.OPS.paintImageMaskXObject: const arg = argsArray[i][0]; if (!arg.cached &amp;&amp; arg.data &amp;&amp; arg.data.buffer instanceof ArrayBuffer) { transfers.push(arg.data.buffer); } break; } } return transfers; } flush(lastChunk = false, separateAnnots = null) { this.optimizer.flush(); const length = this.length; this._totalLength += length; this._streamSink.enqueue({ fnArray: this.fnArray, argsArray: this.argsArray, lastChunk, separateAnnots, length }, 1, this._transfers); this.dependencies.clear(); this.fnArray.length = 0; this.argsArray.length = 0; this.weight = 0; this.optimizer.reset(); } } exports.OperatorList = OperatorList; /***/ }), /* 61 */ /***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) =&gt; { Object.defineProperty(exports, &quot;__esModule&quot;, ({ value: true })); exports.PDFImage = void 0; var _util = __w_pdfjs_require__(2); var _image_utils = __w_pdfjs_require__(62); var _base_stream = __w_pdfjs_require__(5); var _colorspace = __w_pdfjs_require__(12); var _decode_stream = __w_pdfjs_require__(17); var _jpeg_stream = __w_pdfjs_require__(25); var _jpx = __w_pdfjs_require__(28); var _primitives = __w_pdfjs_require__(3); function decodeAndClamp(value, addend, coefficient, max) { value = addend + value * coefficient; if (value &lt; 0) { value = 0; } else if (value &gt; max) { value = max; } return value; } function resizeImageMask(src, bpc, w1, h1, w2, h2) { const length = w2 * h2; let dest; if (bpc &lt;= 8) { dest = new Uint8Array(length); } else if (bpc &lt;= 16) { dest = new Uint16Array(length); } else { dest = new Uint32Array(length); } const xRatio = w1 / w2; const yRatio = h1 / h2; let i, j, py, newIndex = 0, oldIndex; const xScaled = new Uint16Array(w2); const w1Scanline = w1; for (i = 0; i &lt; w2; i++) { xScaled[i] = Math.floor(i * xRatio); } for (i = 0; i &lt; h2; i++) { py = Math.floor(i * yRatio) * w1Scanline; for (j = 0; j &lt; w2; j++) { oldIndex = py + xScaled[j]; dest[newIndex++] = src[oldIndex]; } } return dest; } class PDFImage { constructor({ xref, res, image, isInline = false, smask = null, mask = null, isMask = false, pdfFunctionFactory, localColorSpaceCache }) { this.image = image; const dict = image.dict; const filter = dict.get(&quot;F&quot;, &quot;Filter&quot;); let filterName; if (filter instanceof _primitives.Name) { filterName = filter.name; } else if (Array.isArray(filter)) { const filterZero = xref.fetchIfRef(filter[0]); if (filterZero instanceof _primitives.Name) { filterName = filterZero.name; } } switch (filterName) { case &quot;JPXDecode&quot;: const jpxImage = new _jpx.JpxImage(); jpxImage.parseImageProperties(image.stream); image.stream.reset(); image.width = jpxImage.width; image.height = jpxImage.height; image.bitsPerComponent = jpxImage.bitsPerComponent; image.numComps = jpxImage.componentsCount; break; case &quot;JBIG2Decode&quot;: image.bitsPerComponent = 1; image.numComps = 1; break; } let width = dict.get(&quot;W&quot;, &quot;Width&quot;); let height = dict.get(&quot;H&quot;, &quot;Height&quot;); if (Number.isInteger(image.width) &amp;&amp; image.width &gt; 0 &amp;&amp; Number.isInteger(image.height) &amp;&amp; image.height &gt; 0 &amp;&amp; (image.width !== width || image.height !== height)) { (0, _util.warn)(&quot;PDFImage - using the Width/Height of the image data, &quot; + &quot;rather than the image dictionary.&quot;); width = image.width; height = image.height; } if (width &lt; 1 || height &lt; 1) { throw new _util.FormatError(`Invalid image width: ${width} or height: ${height}`); } this.width = width; this.height = height; this.interpolate = dict.get(&quot;I&quot;, &quot;Interpolate&quot;); this.imageMask = dict.get(&quot;IM&quot;, &quot;ImageMask&quot;) || false; this.matte = dict.get(&quot;Matte&quot;) || false; let bitsPerComponent = image.bitsPerComponent; if (!bitsPerComponent) { bitsPerComponent = dict.get(&quot;BPC&quot;, &quot;BitsPerComponent&quot;); if (!bitsPerComponent) { if (this.imageMask) { bitsPerComponent = 1; } else { throw new _util.FormatError(`Bits per component missing in image: ${this.imageMask}`); } } } this.bpc = bitsPerComponent; if (!this.imageMask) { let colorSpace = dict.getRaw(&quot;CS&quot;) || dict.getRaw(&quot;ColorSpace&quot;); if (!colorSpace) { (0, _util.info)(&quot;JPX images (which do not require color spaces)&quot;); switch (image.numComps) { case 1: colorSpace = _primitives.Name.get(&quot;DeviceGray&quot;); break; case 3: colorSpace = _primitives.Name.get(&quot;DeviceRGB&quot;); break; case 4: colorSpace = _primitives.Name.get(&quot;DeviceCMYK&quot;); break; default: throw new Error(`JPX images with ${image.numComps} color components not supported.`); } } this.colorSpace = _colorspace.ColorSpace.parse({ cs: colorSpace, xref, resources: isInline ? res : null, pdfFunctionFactory, localColorSpaceCache }); this.numComps = this.colorSpace.numComps; } this.decode = dict.getArray(&quot;D&quot;, &quot;Decode&quot;); this.needsDecode = false; if (this.decode &amp;&amp; (this.colorSpace &amp;&amp; !this.colorSpace.isDefaultDecode(this.decode, bitsPerComponent) || isMask &amp;&amp; !_colorspace.ColorSpace.isDefaultDecode(this.decode, 1))) { this.needsDecode = true; const max = (1 &lt;&lt; bitsPerComponent) - 1; this.decodeCoefficients = []; this.decodeAddends = []; const isIndexed = this.colorSpace &amp;&amp; this.colorSpace.name === &quot;Indexed&quot;; for (let i = 0, j = 0; i &lt; this.decode.length; i += 2, ++j) { const dmin = this.decode[i]; const dmax = this.decode[i + 1]; this.decodeCoefficients[j] = isIndexed ? (dmax - dmin) / max : dmax - dmin; this.decodeAddends[j] = isIndexed ? dmin : max * dmin; } } if (smask) { this.smask = new PDFImage({ xref, res, image: smask, isInline, pdfFunctionFactory, localColorSpaceCache }); } else if (mask) { if (mask instanceof _base_stream.BaseStream) { const maskDict = mask.dict, imageMask = maskDict.get(&quot;IM&quot;, &quot;ImageMask&quot;); if (!imageMask) { (0, _util.warn)(&quot;Ignoring /Mask in image without /ImageMask.&quot;); } else { this.mask = new PDFImage({ xref, res, image: mask, isInline, isMask: true, pdfFunctionFactory, localColorSpaceCache }); } } else { this.mask = mask; } } } static async buildImage({ xref, res, image, isInline = false, pdfFunctionFactory, localColorSpaceCache }) { const imageData = image; let smaskData = null; let maskData = null; const smask = image.dict.get(&quot;SMask&quot;); const mask = image.dict.get(&quot;Mask&quot;); if (smask) { if (smask instanceof _base_stream.BaseStream) { smaskData = smask; } else { (0, _util.warn)(&quot;Unsupported /SMask format.&quot;); } } else if (mask) { if (mask instanceof _base_stream.BaseStream || Array.isArray(mask)) { maskData = mask; } else { (0, _util.warn)(&quot;Unsupported /Mask format.&quot;); } } return new PDFImage({ xref, res, image: imageData, isInline, smask: smaskData, mask: maskData, pdfFunctionFactory, localColorSpaceCache }); } static createRawMask({ imgArray, width, height, imageIsFromDecodeStream, inverseDecode, interpolate }) { const computedLength = (width + 7 &gt;&gt; 3) * height; const actualLength = imgArray.byteLength; const haveFullData = computedLength === actualLength; let data, i; if (imageIsFromDecodeStream &amp;&amp; (!inverseDecode || haveFullData)) { data = imgArray; } else if (!inverseDecode) { data = new Uint8Array(imgArray); } else { data = new Uint8Array(computedLength); data.set(imgArray); data.fill(0xff, actualLength); } if (inverseDecode) { for (i = 0; i &lt; actualLength; i++) { data[i] ^= 0xff; } } return { data, width, height, interpolate }; } static createMask({ imgArray, width, height, imageIsFromDecodeStream, inverseDecode, interpolate, isOffscreenCanvasSupported = true }) { const isSingleOpaquePixel = width === 1 &amp;&amp; height === 1 &amp;&amp; inverseDecode === (imgArray.length === 0 || !!(imgArray[0] &amp; 128)); if (isSingleOpaquePixel) { return { isSingleOpaquePixel }; } if (isOffscreenCanvasSupported &amp;&amp; _util.FeatureTest.isOffscreenCanvasSupported) { const canvas = new OffscreenCanvas(width, height); const ctx = canvas.getContext(&quot;2d&quot;); const imgData = ctx.createImageData(width, height); (0, _image_utils.applyMaskImageData)({ src: imgArray, dest: imgData.data, width, height, inverseDecode }); ctx.putImageData(imgData, 0, 0); const bitmap = canvas.transferToImageBitmap(); return { data: null, width, height, interpolate, bitmap }; } return this.createRawMask({ imgArray, width, height, inverseDecode, imageIsFromDecodeStream, interpolate }); } get drawWidth() { return Math.max(this.width, this.smask &amp;&amp; this.smask.width || 0, this.mask &amp;&amp; this.mask.width || 0); } get drawHeight() { return Math.max(this.height, this.smask &amp;&amp; this.smask.height || 0, this.mask &amp;&amp; this.mask.height || 0); } decodeBuffer(buffer) { const bpc = this.bpc; const numComps = this.numComps; const decodeAddends = this.decodeAddends; const decodeCoefficients = this.decodeCoefficients; const max = (1 &lt;&lt; bpc) - 1; let i, ii; if (bpc === 1) { for (i = 0, ii = buffer.length; i &lt; ii; i++) { buffer[i] = +!buffer[i]; } return; } let index = 0; for (i = 0, ii = this.width * this.height; i &lt; ii; i++) { for (let j = 0; j &lt; numComps; j++) { buffer[index] = decodeAndClamp(buffer[index], decodeAddends[j], decodeCoefficients[j], max); index++; } } } getComponents(buffer) { const bpc = this.bpc; if (bpc === 8) { return buffer; } const width = this.width; const height = this.height; const numComps = this.numComps; const length = width * height * numComps; let bufferPos = 0; let output; if (bpc &lt;= 8) { output = new Uint8Array(length); } else if (bpc &lt;= 16) { output = new Uint16Array(length); } else { output = new Uint32Array(length); } const rowComps = width * numComps; const max = (1 &lt;&lt; bpc) - 1; let i = 0, ii, buf; if (bpc === 1) { let mask, loop1End, loop2End; for (let j = 0; j &lt; height; j++) { loop1End = i + (rowComps &amp; ~7); loop2End = i + rowComps; while (i &lt; loop1End) { buf = buffer[bufferPos++]; output[i] = buf &gt;&gt; 7 &amp; 1; output[i + 1] = buf &gt;&gt; 6 &amp; 1; output[i + 2] = buf &gt;&gt; 5 &amp; 1; output[i + 3] = buf &gt;&gt; 4 &amp; 1; output[i + 4] = buf &gt;&gt; 3 &amp; 1; output[i + 5] = buf &gt;&gt; 2 &amp; 1; output[i + 6] = buf &gt;&gt; 1 &amp; 1; output[i + 7] = buf &amp; 1; i += 8; } if (i &lt; loop2End) { buf = buffer[bufferPos++]; mask = 128; while (i &lt; loop2End) { output[i++] = +!!(buf &amp; mask); mask &gt;&gt;= 1; } } } } else { let bits = 0; buf = 0; for (i = 0, ii = length; i &lt; ii; ++i) { if (i % rowComps === 0) { buf = 0; bits = 0; } while (bits &lt; bpc) { buf = buf &lt;&lt; 8 | buffer[bufferPos++]; bits += 8; } const remainingBits = bits - bpc; let value = buf &gt;&gt; remainingBits; if (value &lt; 0) { value = 0; } else if (value &gt; max) { value = max; } output[i] = value; buf &amp;= (1 &lt;&lt; remainingBits) - 1; bits = remainingBits; } } return output; } fillOpacity(rgbaBuf, width, height, actualHeight, image) { const smask = this.smask; const mask = this.mask; let alphaBuf, sw, sh, i, ii, j; if (smask) { sw = smask.width; sh = smask.height; alphaBuf = new Uint8ClampedArray(sw * sh); smask.fillGrayBuffer(alphaBuf); if (sw !== width || sh !== height) { alphaBuf = resizeImageMask(alphaBuf, smask.bpc, sw, sh, width, height); } } else if (mask) { if (mask instanceof PDFImage) { sw = mask.width; sh = mask.height; alphaBuf = new Uint8ClampedArray(sw * sh); mask.numComps = 1; mask.fillGrayBuffer(alphaBuf); for (i = 0, ii = sw * sh; i &lt; ii; ++i) { alphaBuf[i] = 255 - alphaBuf[i]; } if (sw !== width || sh !== height) { alphaBuf = resizeImageMask(alphaBuf, mask.bpc, sw, sh, width, height); } } else if (Array.isArray(mask)) { alphaBuf = new Uint8ClampedArray(width * height); const numComps = this.numComps; for (i = 0, ii = width * height; i &lt; ii; ++i) { let opacity = 0; const imageOffset = i * numComps; for (j = 0; j &lt; numComps; ++j) { const color = image[imageOffset + j]; const maskOffset = j * 2; if (color &lt; mask[maskOffset] || color &gt; mask[maskOffset + 1]) { opacity = 255; break; } } alphaBuf[i] = opacity; } } else { throw new _util.FormatError(&quot;Unknown mask format.&quot;); } } if (alphaBuf) { for (i = 0, j = 3, ii = width * actualHeight; i &lt; ii; ++i, j += 4) { rgbaBuf[j] = alphaBuf[i]; } } else { for (i = 0, j = 3, ii = width * actualHeight; i &lt; ii; ++i, j += 4) { rgbaBuf[j] = 255; } } } undoPreblend(buffer, width, height) { const matte = this.smask &amp;&amp; this.smask.matte; if (!matte) { return; } const matteRgb = this.colorSpace.getRgb(matte, 0); const matteR = matteRgb[0]; const matteG = matteRgb[1]; const matteB = matteRgb[2]; const length = width * height * 4; for (let i = 0; i &lt; length; i += 4) { const alpha = buffer[i + 3]; if (alpha === 0) { buffer[i] = 255; buffer[i + 1] = 255; buffer[i + 2] = 255; continue; } const k = 255 / alpha; buffer[i] = (buffer[i] - matteR) * k + matteR; buffer[i + 1] = (buffer[i + 1] - matteG) * k + matteG; buffer[i + 2] = (buffer[i + 2] - matteB) * k + matteB; } } createImageData(forceRGBA = false) { const drawWidth = this.drawWidth; const drawHeight = this.drawHeight; const imgData = { width: drawWidth, height: drawHeight, interpolate: this.interpolate, kind: 0, data: null }; const numComps = this.numComps; const originalWidth = this.width; const originalHeight = this.height; const bpc = this.bpc; const rowBytes = originalWidth * numComps * bpc + 7 &gt;&gt; 3; if (!forceRGBA) { let kind; if (this.colorSpace.name === &quot;DeviceGray&quot; &amp;&amp; bpc === 1) { kind = _util.ImageKind.GRAYSCALE_1BPP; } else if (this.colorSpace.name === &quot;DeviceRGB&quot; &amp;&amp; bpc === 8 &amp;&amp; !this.needsDecode) { kind = _util.ImageKind.RGB_24BPP; } if (kind &amp;&amp; !this.smask &amp;&amp; !this.mask &amp;&amp; drawWidth === originalWidth &amp;&amp; drawHeight === originalHeight) { imgData.kind = kind; imgData.data = this.getImageBytes(originalHeight * rowBytes, {}); if (this.needsDecode) { (0, _util.assert)(kind === _util.ImageKind.GRAYSCALE_1BPP, &quot;PDFImage.createImageData: The image must be grayscale.&quot;); const buffer = imgData.data; for (let i = 0, ii = buffer.length; i &lt; ii; i++) { buffer[i] ^= 0xff; } } return imgData; } if (this.image instanceof _jpeg_stream.JpegStream &amp;&amp; !this.smask &amp;&amp; !this.mask) { let imageLength = originalHeight * rowBytes; switch (this.colorSpace.name) { case &quot;DeviceGray&quot;: imageLength *= 3; case &quot;DeviceRGB&quot;: case &quot;DeviceCMYK&quot;: imgData.kind = _util.ImageKind.RGB_24BPP; imgData.data = this.getImageBytes(imageLength, { drawWidth, drawHeight, forceRGB: true }); return imgData; } } } const imgArray = this.getImageBytes(originalHeight * rowBytes, { internal: true }); const actualHeight = 0 | imgArray.length / rowBytes * drawHeight / originalHeight; const comps = this.getComponents(imgArray); let alpha01, maybeUndoPreblend; if (!forceRGBA &amp;&amp; !this.smask &amp;&amp; !this.mask) { imgData.kind = _util.ImageKind.RGB_24BPP; imgData.data = new Uint8ClampedArray(drawWidth * drawHeight * 3); alpha01 = 0; maybeUndoPreblend = false; } else { imgData.kind = _util.ImageKind.RGBA_32BPP; imgData.data = new Uint8ClampedArray(drawWidth * drawHeight * 4); alpha01 = 1; maybeUndoPreblend = true; this.fillOpacity(imgData.data, drawWidth, drawHeight, actualHeight, comps); } if (this.needsDecode) { this.decodeBuffer(comps); } this.colorSpace.fillRgb(imgData.data, originalWidth, originalHeight, drawWidth, drawHeight, actualHeight, bpc, comps, alpha01); if (maybeUndoPreblend) { this.undoPreblend(imgData.data, drawWidth, actualHeight); } return imgData; } fillGrayBuffer(buffer) { const numComps = this.numComps; if (numComps !== 1) { throw new _util.FormatError(`Reading gray scale from a color image: ${numComps}`); } const width = this.width; const height = this.height; const bpc = this.bpc; const rowBytes = width * numComps * bpc + 7 &gt;&gt; 3; const imgArray = this.getImageBytes(height * rowBytes, { internal: true }); const comps = this.getComponents(imgArray); let i, length; if (bpc === 1) { length = width * height; if (this.needsDecode) { for (i = 0; i &lt; length; ++i) { buffer[i] = comps[i] - 1 &amp; 255; } } else { for (i = 0; i &lt; length; ++i) { buffer[i] = -comps[i] &amp; 255; } } return; } if (this.needsDecode) { this.decodeBuffer(comps); } length = width * height; const scale = 255 / ((1 &lt;&lt; bpc) - 1); for (i = 0; i &lt; length; ++i) { buffer[i] = scale * comps[i]; } } getImageBytes(length, { drawWidth, drawHeight, forceRGB = false, internal = false }) { this.image.reset(); this.image.drawWidth = drawWidth || this.width; this.image.drawHeight = drawHeight || this.height; this.image.forceRGB = !!forceRGB; const imageBytes = this.image.getBytes(length); if (internal || this.image instanceof _decode_stream.DecodeStream) { return imageBytes; } (0, _util.assert)(imageBytes instanceof Uint8Array, &apos;PDFImage.getImageBytes: Unsupported &quot;imageBytes&quot; type.&apos;); return new Uint8Array(imageBytes); } } exports.PDFImage = PDFImage; /***/ }), /* 62 */ /***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) =&gt; { Object.defineProperty(exports, &quot;__esModule&quot;, ({ value: true })); exports.applyMaskImageData = applyMaskImageData; var _util = __w_pdfjs_require__(2); function applyMaskImageData({ src, srcPos = 0, dest, destPos = 0, width, height, inverseDecode = false }) { const opaque = _util.FeatureTest.isLittleEndian ? 0xff000000 : 0x000000ff; const [zeroMapping, oneMapping] = !inverseDecode ? [opaque, 0] : [0, opaque]; const widthInSource = width &gt;&gt; 3; const widthRemainder = width &amp; 7; const srcLength = src.length; dest = new Uint32Array(dest.buffer); for (let i = 0; i &lt; height; i++) { for (const max = srcPos + widthInSource; srcPos &lt; max; srcPos++) { const elem = srcPos &lt; srcLength ? src[srcPos] : 255; dest[destPos++] = elem &amp; 0b10000000 ? oneMapping : zeroMapping; dest[destPos++] = elem &amp; 0b1000000 ? oneMapping : zeroMapping; dest[destPos++] = elem &amp; 0b100000 ? oneMapping : zeroMapping; dest[destPos++] = elem &amp; 0b10000 ? oneMapping : zeroMapping; dest[destPos++] = elem &amp; 0b1000 ? oneMapping : zeroMapping; dest[destPos++] = elem &amp; 0b100 ? oneMapping : zeroMapping; dest[destPos++] = elem &amp; 0b10 ? oneMapping : zeroMapping; dest[destPos++] = elem &amp; 0b1 ? oneMapping : zeroMapping; } if (widthRemainder === 0) { continue; } const elem = srcPos &lt; srcLength ? src[srcPos++] : 255; for (let j = 0; j &lt; widthRemainder; j++) { dest[destPos++] = elem &amp; 1 &lt;&lt; 7 - j ? oneMapping : zeroMapping; } } return { srcPos, destPos }; } /***/ }), /* 63 */ /***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) =&gt; { Object.defineProperty(exports, &quot;__esModule&quot;, ({ value: true })); exports.incrementalUpdate = incrementalUpdate; exports.writeDict = writeDict; exports.writeObject = writeObject; var _util = __w_pdfjs_require__(2); var _primitives = __w_pdfjs_require__(3); var _core_utils = __w_pdfjs_require__(4); var _xml_parser = __w_pdfjs_require__(64); var _base_stream = __w_pdfjs_require__(5); var _crypto = __w_pdfjs_require__(65); function writeObject(ref, obj, buffer, transform) { buffer.push(`${ref.num} ${ref.gen} obj\\n`); if (obj instanceof _primitives.Dict) { writeDict(obj, buffer, transform); } else if (obj instanceof _base_stream.BaseStream) { writeStream(obj, buffer, transform); } buffer.push(&quot;\\nendobj\\n&quot;); } function writeDict(dict, buffer, transform) { buffer.push(&quot;&lt;&lt;&quot;); for (const key of dict.getKeys()) { buffer.push(` /${(0, _core_utils.escapePDFName)(key)} `); writeValue(dict.getRaw(key), buffer, transform); } buffer.push(&quot;&gt;&gt;&quot;); } function writeStream(stream, buffer, transform) { writeDict(stream.dict, buffer, transform); buffer.push(&quot; stream\\n&quot;); let string = stream.getString(); if (transform !== null) { string = transform.encryptString(string); } buffer.push(string, &quot;\\nendstream\\n&quot;); } function writeArray(array, buffer, transform) { buffer.push(&quot;[&quot;); let first = true; for (const val of array) { if (!first) { buffer.push(&quot; &quot;); } else { first = false; } writeValue(val, buffer, transform); } buffer.push(&quot;]&quot;); } function writeValue(value, buffer, transform) { if (value instanceof _primitives.Name) { buffer.push(`/${(0, _core_utils.escapePDFName)(value.name)}`); } else if (value instanceof _primitives.Ref) { buffer.push(`${value.num} ${value.gen} R`); } else if (Array.isArray(value)) { writeArray(value, buffer, transform); } else if (typeof value === &quot;string&quot;) { if (transform !== null) { value = transform.encryptString(value); } buffer.push(`(${(0, _util.escapeString)(value)})`); } else if (typeof value === &quot;number&quot;) { buffer.push((0, _core_utils.numberToString)(value)); } else if (typeof value === &quot;boolean&quot;) { buffer.push(value.toString()); } else if (value instanceof _primitives.Dict) { writeDict(value, buffer, transform); } else if (value instanceof _base_stream.BaseStream) { writeStream(value, buffer, transform); } else if (value === null) { buffer.push(&quot;null&quot;); } else { (0, _util.warn)(`Unhandled value in writer: ${typeof value}, please file a bug.`); } } function writeInt(number, size, offset, buffer) { for (let i = size + offset - 1; i &gt; offset - 1; i--) { buffer[i] = number &amp; 0xff; number &gt;&gt;= 8; } return offset + size; } function writeString(string, offset, buffer) { for (let i = 0, len = string.length; i &lt; len; i++) { buffer[offset + i] = string.charCodeAt(i) &amp; 0xff; } } function computeMD5(filesize, xrefInfo) { const time = Math.floor(Date.now() / 1000); const filename = xrefInfo.filename || &quot;&quot;; const md5Buffer = [time.toString(), filename, filesize.toString()]; let md5BufferLen = md5Buffer.reduce((a, str) =&gt; a + str.length, 0); for (const value of Object.values(xrefInfo.info)) { md5Buffer.push(value); md5BufferLen += value.length; } const array = new Uint8Array(md5BufferLen); let offset = 0; for (const str of md5Buffer) { writeString(str, offset, array); offset += str.length; } return (0, _util.bytesToString)((0, _crypto.calculateMD5)(array)); } function writeXFADataForAcroform(str, newRefs) { const xml = new _xml_parser.SimpleXMLParser({ hasAttributes: true }).parseFromString(str); for (const { xfa } of newRefs) { if (!xfa) { continue; } const { path, value } = xfa; if (!path) { continue; } const node = xml.documentElement.searchNode((0, _core_utils.parseXFAPath)(path), 0); if (node) { if (Array.isArray(value)) { node.childNodes = value.map(val =&gt; new _xml_parser.SimpleDOMNode(&quot;value&quot;, val)); } else { node.childNodes = [new _xml_parser.SimpleDOMNode(&quot;#text&quot;, value)]; } } else { (0, _util.warn)(`Node not found for path: ${path}`); } } const buffer = []; xml.documentElement.dump(buffer); return buffer.join(&quot;&quot;); } function updateXFA({ xfaData, xfaDatasetsRef, hasXfaDatasetsEntry, acroFormRef, acroForm, newRefs, xref, xrefInfo }) { if (xref === null) { return; } if (!hasXfaDatasetsEntry) { if (!acroFormRef) { (0, _util.warn)(&quot;XFA - Cannot save it&quot;); return; } const oldXfa = acroForm.get(&quot;XFA&quot;); const newXfa = oldXfa.slice(); newXfa.splice(2, 0, &quot;datasets&quot;); newXfa.splice(3, 0, xfaDatasetsRef); acroForm.set(&quot;XFA&quot;, newXfa); const encrypt = xref.encrypt; let transform = null; if (encrypt) { transform = encrypt.createCipherTransform(acroFormRef.num, acroFormRef.gen); } const buffer = [`${acroFormRef.num} ${acroFormRef.gen} obj\\n`]; writeDict(acroForm, buffer, transform); buffer.push(&quot;\\n&quot;); acroForm.set(&quot;XFA&quot;, oldXfa); newRefs.push({ ref: acroFormRef, data: buffer.join(&quot;&quot;) }); } if (xfaData === null) { const datasets = xref.fetchIfRef(xfaDatasetsRef); xfaData = writeXFADataForAcroform(datasets.getString(), newRefs); } const encrypt = xref.encrypt; if (encrypt) { const transform = encrypt.createCipherTransform(xfaDatasetsRef.num, xfaDatasetsRef.gen); xfaData = transform.encryptString(xfaData); } const data = `${xfaDatasetsRef.num} ${xfaDatasetsRef.gen} obj\\n` + `&lt;&lt; /Type /EmbeddedFile /Length ${xfaData.length}&gt;&gt;\\nstream\\n` + xfaData + &quot;\\nendstream\\nendobj\\n&quot;; newRefs.push({ ref: xfaDatasetsRef, data }); } function incrementalUpdate({ originalData, xrefInfo, newRefs, xref = null, hasXfa = false, xfaDatasetsRef = null, hasXfaDatasetsEntry = false, acroFormRef = null, acroForm = null, xfaData = null }) { if (hasXfa) { updateXFA({ xfaData, xfaDatasetsRef, hasXfaDatasetsEntry, acroFormRef, acroForm, newRefs, xref, xrefInfo }); } const newXref = new _primitives.Dict(null); const refForXrefTable = xrefInfo.newRef; let buffer, baseOffset; const lastByte = originalData.at(-1); if (lastByte === 0x0a || lastByte === 0x0d) { buffer = []; baseOffset = originalData.length; } else { buffer = [&quot;\\n&quot;]; baseOffset = originalData.length + 1; } newXref.set(&quot;Size&quot;, refForXrefTable.num + 1); newXref.set(&quot;Prev&quot;, xrefInfo.startXRef); newXref.set(&quot;Type&quot;, _primitives.Name.get(&quot;XRef&quot;)); if (xrefInfo.rootRef !== null) { newXref.set(&quot;Root&quot;, xrefInfo.rootRef); } if (xrefInfo.infoRef !== null) { newXref.set(&quot;Info&quot;, xrefInfo.infoRef); } if (xrefInfo.encryptRef !== null) { newXref.set(&quot;Encrypt&quot;, xrefInfo.encryptRef); } newRefs.push({ ref: refForXrefTable, data: &quot;&quot; }); newRefs = newRefs.sort((a, b) =&gt; { return a.ref.num - b.ref.num; }); const xrefTableData = [[0, 1, 0xffff]]; const indexes = [0, 1]; let maxOffset = 0; for (const { ref, data } of newRefs) { maxOffset = Math.max(maxOffset, baseOffset); xrefTableData.push([1, baseOffset, Math.min(ref.gen, 0xffff)]); baseOffset += data.length; indexes.push(ref.num, 1); buffer.push(data); } newXref.set(&quot;Index&quot;, indexes); if (Array.isArray(xrefInfo.fileIds) &amp;&amp; xrefInfo.fileIds.length &gt; 0) { const md5 = computeMD5(baseOffset, xrefInfo); newXref.set(&quot;ID&quot;, [xrefInfo.fileIds[0], md5]); } const offsetSize = Math.ceil(Math.log2(maxOffset) / 8); const sizes = [1, offsetSize, 2]; const structSize = sizes[0] + sizes[1] + sizes[2]; const tableLength = structSize * xrefTableData.length; newXref.set(&quot;W&quot;, sizes); newXref.set(&quot;Length&quot;, tableLength); buffer.push(`${refForXrefTable.num} ${refForXrefTable.gen} obj\\n`); writeDict(newXref, buffer, null); buffer.push(&quot; stream\\n&quot;); const bufferLen = buffer.reduce((a, str) =&gt; a + str.length, 0); const footer = `\\nendstream\\nendobj\\nstartxref\\n${baseOffset}\\n%%EOF\\n`; const array = new Uint8Array(originalData.length + bufferLen + tableLength + footer.length); array.set(originalData); let offset = originalData.length; for (const str of buffer) { writeString(str, offset, array); offset += str.length; } for (const [type, objOffset, gen] of xrefTableData) { offset = writeInt(type, sizes[0], offset, array); offset = writeInt(objOffset, sizes[1], offset, array); offset = writeInt(gen, sizes[2], offset, array); } writeString(footer, offset, array); return array; } /***/ }), /* 64 */ /***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) =&gt; { Object.defineProperty(exports, &quot;__esModule&quot;, ({ value: true })); exports.XMLParserErrorCode = exports.XMLParserBase = exports.SimpleXMLParser = exports.SimpleDOMNode = void 0; var _core_utils = __w_pdfjs_require__(4); const XMLParserErrorCode = { NoError: 0, EndOfDocument: -1, UnterminatedCdat: -2, UnterminatedXmlDeclaration: -3, UnterminatedDoctypeDeclaration: -4, UnterminatedComment: -5, MalformedElement: -6, OutOfMemory: -7, UnterminatedAttributeValue: -8, UnterminatedElement: -9, ElementNeverBegun: -10 }; exports.XMLParserErrorCode = XMLParserErrorCode; function isWhitespace(s, index) { const ch = s[index]; return ch === &quot; &quot; || ch === &quot;\\n&quot; || ch === &quot;\\r&quot; || ch === &quot;\\t&quot;; } function isWhitespaceString(s) { for (let i = 0, ii = s.length; i &lt; ii; i++) { if (!isWhitespace(s, i)) { return false; } } return true; } class XMLParserBase { _resolveEntities(s) { return s.replace(/&amp;([^;]+);/g, (all, entity) =&gt; { if (entity.substring(0, 2) === &quot;#x&quot;) { return String.fromCodePoint(parseInt(entity.substring(2), 16)); } else if (entity.substring(0, 1) === &quot;#&quot;) { return String.fromCodePoint(parseInt(entity.substring(1), 10)); } switch (entity) { case &quot;lt&quot;: return &quot;&lt;&quot;; case &quot;gt&quot;: return &quot;&gt;&quot;; case &quot;amp&quot;: return &quot;&amp;&quot;; case &quot;quot&quot;: return &apos;&quot;&apos;; case &quot;apos&quot;: return &quot;&apos;&quot;; } return this.onResolveEntity(entity); }); } _parseContent(s, start) { const attributes = []; let pos = start; function skipWs() { while (pos &lt; s.length &amp;&amp; isWhitespace(s, pos)) { ++pos; } } while (pos &lt; s.length &amp;&amp; !isWhitespace(s, pos) &amp;&amp; s[pos] !== &quot;&gt;&quot; &amp;&amp; s[pos] !== &quot;/&quot;) { ++pos; } const name = s.substring(start, pos); skipWs(); while (pos &lt; s.length &amp;&amp; s[pos] !== &quot;&gt;&quot; &amp;&amp; s[pos] !== &quot;/&quot; &amp;&amp; s[pos] !== &quot;?&quot;) { skipWs(); let attrName = &quot;&quot;, attrValue = &quot;&quot;; while (pos &lt; s.length &amp;&amp; !isWhitespace(s, pos) &amp;&amp; s[pos] !== &quot;=&quot;) { attrName += s[pos]; ++pos; } skipWs(); if (s[pos] !== &quot;=&quot;) { return null; } ++pos; skipWs(); const attrEndChar = s[pos]; if (attrEndChar !== &apos;&quot;&apos; &amp;&amp; attrEndChar !== &quot;&apos;&quot;) { return null; } const attrEndIndex = s.indexOf(attrEndChar, ++pos); if (attrEndIndex &lt; 0) { return null; } attrValue = s.substring(pos, attrEndIndex); attributes.push({ name: attrName, value: this._resolveEntities(attrValue) }); pos = attrEndIndex + 1; skipWs(); } return { name, attributes, parsed: pos - start }; } _parseProcessingInstruction(s, start) { let pos = start; function skipWs() { while (pos &lt; s.length &amp;&amp; isWhitespace(s, pos)) { ++pos; } } while (pos &lt; s.length &amp;&amp; !isWhitespace(s, pos) &amp;&amp; s[pos] !== &quot;&gt;&quot; &amp;&amp; s[pos] !== &quot;?&quot; &amp;&amp; s[pos] !== &quot;/&quot;) { ++pos; } const name = s.substring(start, pos); skipWs(); const attrStart = pos; while (pos &lt; s.length &amp;&amp; (s[pos] !== &quot;?&quot; || s[pos + 1] !== &quot;&gt;&quot;)) { ++pos; } const value = s.substring(attrStart, pos); return { name, value, parsed: pos - start }; } parseXml(s) { let i = 0; while (i &lt; s.length) { const ch = s[i]; let j = i; if (ch === &quot;&lt;&quot;) { ++j; const ch2 = s[j]; let q; switch (ch2) { case &quot;/&quot;: ++j; q = s.indexOf(&quot;&gt;&quot;, j); if (q &lt; 0) { this.onError(XMLParserErrorCode.UnterminatedElement); return; } this.onEndElement(s.substring(j, q)); j = q + 1; break; case &quot;?&quot;: ++j; const pi = this._parseProcessingInstruction(s, j); if (s.substring(j + pi.parsed, j + pi.parsed + 2) !== &quot;?&gt;&quot;) { this.onError(XMLParserErrorCode.UnterminatedXmlDeclaration); return; } this.onPi(pi.name, pi.value); j += pi.parsed + 2; break; case &quot;!&quot;: if (s.substring(j + 1, j + 3) === &quot;--&quot;) { q = s.indexOf(&quot;--&gt;&quot;, j + 3); if (q &lt; 0) { this.onError(XMLParserErrorCode.UnterminatedComment); return; } this.onComment(s.substring(j + 3, q)); j = q + 3; } else if (s.substring(j + 1, j + 8) === &quot;[CDATA[&quot;) { q = s.indexOf(&quot;]]&gt;&quot;, j + 8); if (q &lt; 0) { this.onError(XMLParserErrorCode.UnterminatedCdat); return; } this.onCdata(s.substring(j + 8, q)); j = q + 3; } else if (s.substring(j + 1, j + 8) === &quot;DOCTYPE&quot;) { const q2 = s.indexOf(&quot;[&quot;, j + 8); let complexDoctype = false; q = s.indexOf(&quot;&gt;&quot;, j + 8); if (q &lt; 0) { this.onError(XMLParserErrorCode.UnterminatedDoctypeDeclaration); return; } if (q2 &gt; 0 &amp;&amp; q &gt; q2) { q = s.indexOf(&quot;]&gt;&quot;, j + 8); if (q &lt; 0) { this.onError(XMLParserErrorCode.UnterminatedDoctypeDeclaration); return; } complexDoctype = true; } const doctypeContent = s.substring(j + 8, q + (complexDoctype ? 1 : 0)); this.onDoctype(doctypeContent); j = q + (complexDoctype ? 2 : 1); } else { this.onError(XMLParserErrorCode.MalformedElement); return; } break; default: const content = this._parseContent(s, j); if (content === null) { this.onError(XMLParserErrorCode.MalformedElement); return; } let isClosed = false; if (s.substring(j + content.parsed, j + content.parsed + 2) === &quot;/&gt;&quot;) { isClosed = true; } else if (s.substring(j + content.parsed, j + content.parsed + 1) !== &quot;&gt;&quot;) { this.onError(XMLParserErrorCode.UnterminatedElement); return; } this.onBeginElement(content.name, content.attributes, isClosed); j += content.parsed + (isClosed ? 2 : 1); break; } } else { while (j &lt; s.length &amp;&amp; s[j] !== &quot;&lt;&quot;) { j++; } const text = s.substring(i, j); this.onText(this._resolveEntities(text)); } i = j; } } onResolveEntity(name) { return `&amp;${name};`; } onPi(name, value) {} onComment(text) {} onCdata(text) {} onDoctype(doctypeContent) {} onText(text) {} onBeginElement(name, attributes, isEmpty) {} onEndElement(name) {} onError(code) {} } exports.XMLParserBase = XMLParserBase; class SimpleDOMNode { constructor(nodeName, nodeValue) { this.nodeName = nodeName; this.nodeValue = nodeValue; Object.defineProperty(this, &quot;parentNode&quot;, { value: null, writable: true }); } get firstChild() { return this.childNodes &amp;&amp; this.childNodes[0]; } get nextSibling() { const childNodes = this.parentNode.childNodes; if (!childNodes) { return undefined; } const index = childNodes.indexOf(this); if (index === -1) { return undefined; } return childNodes[index + 1]; } get textContent() { if (!this.childNodes) { return this.nodeValue || &quot;&quot;; } return this.childNodes.map(function (child) { return child.textContent; }).join(&quot;&quot;); } get children() { return this.childNodes || []; } hasChildNodes() { return this.childNodes &amp;&amp; this.childNodes.length &gt; 0; } searchNode(paths, pos) { if (pos &gt;= paths.length) { return this; } const component = paths[pos]; const stack = []; let node = this; while (true) { if (component.name === node.nodeName) { if (component.pos === 0) { const res = node.searchNode(paths, pos + 1); if (res !== null) { return res; } } else if (stack.length === 0) { return null; } else { const [parent] = stack.pop(); let siblingPos = 0; for (const child of parent.childNodes) { if (component.name === child.nodeName) { if (siblingPos === component.pos) { return child.searchNode(paths, pos + 1); } siblingPos++; } } return node.searchNode(paths, pos + 1); } } if (node.childNodes &amp;&amp; node.childNodes.length !== 0) { stack.push([node, 0]); node = node.childNodes[0]; } else if (stack.length === 0) { return null; } else { while (stack.length !== 0) { const [parent, currentPos] = stack.pop(); const newPos = currentPos + 1; if (newPos &lt; parent.childNodes.length) { stack.push([parent, newPos]); node = parent.childNodes[newPos]; break; } } if (stack.length === 0) { return null; } } } } dump(buffer) { if (this.nodeName === &quot;#text&quot;) { buffer.push((0, _core_utils.encodeToXmlString)(this.nodeValue)); return; } buffer.push(`&lt;${this.nodeName}`); if (this.attributes) { for (const attribute of this.attributes) { buffer.push(` ${attribute.name}=&quot;${(0, _core_utils.encodeToXmlString)(attribute.value)}&quot;`); } } if (this.hasChildNodes()) { buffer.push(&quot;&gt;&quot;); for (const child of this.childNodes) { child.dump(buffer); } buffer.push(``); } else if (this.nodeValue) { buffer.push(`&gt;${(0, _core_utils.encodeToXmlString)(this.nodeValue)}`); } else { buffer.push(&quot;/&gt;&quot;); } } } exports.SimpleDOMNode = SimpleDOMNode; class SimpleXMLParser extends XMLParserBase { constructor({ hasAttributes = false, lowerCaseName = false }) { super(); this._currentFragment = null; this._stack = null; this._errorCode = XMLParserErrorCode.NoError; this._hasAttributes = hasAttributes; this._lowerCaseName = lowerCaseName; } parseFromString(data) { this._currentFragment = []; this._stack = []; this._errorCode = XMLParserErrorCode.NoError; this.parseXml(data); if (this._errorCode !== XMLParserErrorCode.NoError) { return undefined; } const [documentElement] = this._currentFragment; if (!documentElement) { return undefined; } return { documentElement }; } onText(text) { if (isWhitespaceString(text)) { return; } const node = new SimpleDOMNode(&quot;#text&quot;, text); this._currentFragment.push(node); } onCdata(text) { const node = new SimpleDOMNode(&quot;#text&quot;, text); this._currentFragment.push(node); } onBeginElement(name, attributes, isEmpty) { if (this._lowerCaseName) { name = name.toLowerCase(); } const node = new SimpleDOMNode(name); node.childNodes = []; if (this._hasAttributes) { node.attributes = attributes; } this._currentFragment.push(node); if (isEmpty) { return; } this._stack.push(this._currentFragment); this._currentFragment = node.childNodes; } onEndElement(name) { this._currentFragment = this._stack.pop() || []; const lastElement = this._currentFragment.at(-1); if (!lastElement) { return null; } for (const childNode of lastElement.childNodes) { childNode.parentNode = lastElement; } return lastElement; } onError(code) { this._errorCode = code; } } exports.SimpleXMLParser = SimpleXMLParser; /***/ }), /* 65 */ /***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) =&gt; { Object.defineProperty(exports, &quot;__esModule&quot;, ({ value: true })); exports.calculateSHA256 = exports.calculateMD5 = exports.PDF20 = exports.PDF17 = exports.CipherTransformFactory = exports.ARCFourCipher = exports.AES256Cipher = exports.AES128Cipher = void 0; exports.calculateSHA384 = calculateSHA384; exports.calculateSHA512 = void 0; var _util = __w_pdfjs_require__(2); var _primitives = __w_pdfjs_require__(3); var _decrypt_stream = __w_pdfjs_require__(66); class ARCFourCipher { constructor(key) { this.a = 0; this.b = 0; const s = new Uint8Array(256); const keyLength = key.length; for (let i = 0; i &lt; 256; ++i) { s[i] = i; } for (let i = 0, j = 0; i &lt; 256; ++i) { const tmp = s[i]; j = j + tmp + key[i % keyLength] &amp; 0xff; s[i] = s[j]; s[j] = tmp; } this.s = s; } encryptBlock(data) { let a = this.a, b = this.b; const s = this.s; const n = data.length; const output = new Uint8Array(n); for (let i = 0; i &lt; n; ++i) { a = a + 1 &amp; 0xff; const tmp = s[a]; b = b + tmp &amp; 0xff; const tmp2 = s[b]; s[a] = tmp2; s[b] = tmp; output[i] = data[i] ^ s[tmp + tmp2 &amp; 0xff]; } this.a = a; this.b = b; return output; } decryptBlock(data) { return this.encryptBlock(data); } encrypt(data) { return this.encryptBlock(data); } } exports.ARCFourCipher = ARCFourCipher; const calculateMD5 = function calculateMD5Closure() { const r = new Uint8Array([7, 12, 17, 22, 7, 12, 17, 22, 7, 12, 17, 22, 7, 12, 17, 22, 5, 9, 14, 20, 5, 9, 14, 20, 5, 9, 14, 20, 5, 9, 14, 20, 4, 11, 16, 23, 4, 11, 16, 23, 4, 11, 16, 23, 4, 11, 16, 23, 6, 10, 15, 21, 6, 10, 15, 21, 6, 10, 15, 21, 6, 10, 15, 21]); const k = new Int32Array([-680876936, -389564586, 606105819, -1044525330, -176418897, 1200080426, -1473231341, -45705983, 1770035416, -1958414417, -42063, -1990404162, 1804603682, -40341101, -1502002290, 1236535329, -165796510, -1069501632, 643717713, -373897302, -701558691, 38016083, -660478335, -405537848, 568446438, -1019803690, -187363961, 1163531501, -1444681467, -51403784, 1735328473, -1926607734, -378558, -2022574463, 1839030562, -35309556, -1530992060, 1272893353, -155497632, -1094730640, 681279174, -358537222, -722521979, 76029189, -640364487, -421815835, 530742520, -995338651, -198630844, 1126891415, -1416354905, -57434055, 1700485571, -1894986606, -1051523, -2054922799, 1873313359, -30611744, -1560198380, 1309151649, -145523070, -1120210379, 718787259, -343485551]); function hash(data, offset, length) { let h0 = 1732584193, h1 = -271733879, h2 = -1732584194, h3 = 271733878; const paddedLength = length + 72 &amp; ~63; const padded = new Uint8Array(paddedLength); let i, j; for (i = 0; i &lt; length; ++i) { padded[i] = data[offset++]; } padded[i++] = 0x80; const n = paddedLength - 8; while (i &lt; n) { padded[i++] = 0; } padded[i++] = length &lt;&lt; 3 &amp; 0xff; padded[i++] = length &gt;&gt; 5 &amp; 0xff; padded[i++] = length &gt;&gt; 13 &amp; 0xff; padded[i++] = length &gt;&gt; 21 &amp; 0xff; padded[i++] = length &gt;&gt;&gt; 29 &amp; 0xff; padded[i++] = 0; padded[i++] = 0; padded[i++] = 0; const w = new Int32Array(16); for (i = 0; i &lt; paddedLength;) { for (j = 0; j &lt; 16; ++j, i += 4) { w[j] = padded[i] | padded[i + 1] &lt;&lt; 8 | padded[i + 2] &lt;&lt; 16 | padded[i + 3] &lt;&lt; 24; } let a = h0, b = h1, c = h2, d = h3, f, g; for (j = 0; j &lt; 64; ++j) { if (j &lt; 16) { f = b &amp; c | ~b &amp; d; g = j; } else if (j &lt; 32) { f = d &amp; b | ~d &amp; c; g = 5 * j + 1 &amp; 15; } else if (j &lt; 48) { f = b ^ c ^ d; g = 3 * j + 5 &amp; 15; } else { f = c ^ (b | ~d); g = 7 * j &amp; 15; } const tmp = d, rotateArg = a + f + k[j] + w[g] | 0, rotate = r[j]; d = c; c = b; b = b + (rotateArg &lt;&lt; rotate | rotateArg &gt;&gt;&gt; 32 - rotate) | 0; a = tmp; } h0 = h0 + a | 0; h1 = h1 + b | 0; h2 = h2 + c | 0; h3 = h3 + d | 0; } return new Uint8Array([h0 &amp; 0xFF, h0 &gt;&gt; 8 &amp; 0xFF, h0 &gt;&gt; 16 &amp; 0xFF, h0 &gt;&gt;&gt; 24 &amp; 0xFF, h1 &amp; 0xFF, h1 &gt;&gt; 8 &amp; 0xFF, h1 &gt;&gt; 16 &amp; 0xFF, h1 &gt;&gt;&gt; 24 &amp; 0xFF, h2 &amp; 0xFF, h2 &gt;&gt; 8 &amp; 0xFF, h2 &gt;&gt; 16 &amp; 0xFF, h2 &gt;&gt;&gt; 24 &amp; 0xFF, h3 &amp; 0xFF, h3 &gt;&gt; 8 &amp; 0xFF, h3 &gt;&gt; 16 &amp; 0xFF, h3 &gt;&gt;&gt; 24 &amp; 0xFF]); } return hash; }(); exports.calculateMD5 = calculateMD5; class Word64 { constructor(highInteger, lowInteger) { this.high = highInteger | 0; this.low = lowInteger | 0; } and(word) { this.high &amp;= word.high; this.low &amp;= word.low; } xor(word) { this.high ^= word.high; this.low ^= word.low; } or(word) { this.high |= word.high; this.low |= word.low; } shiftRight(places) { if (places &gt;= 32) { this.low = this.high &gt;&gt;&gt; places - 32 | 0; this.high = 0; } else { this.low = this.low &gt;&gt;&gt; places | this.high &lt;&lt; 32 - places; this.high = this.high &gt;&gt;&gt; places | 0; } } shiftLeft(places) { if (places &gt;= 32) { this.high = this.low &lt;&lt; places - 32; this.low = 0; } else { this.high = this.high &lt;&lt; places | this.low &gt;&gt;&gt; 32 - places; this.low &lt;&lt;= places; } } rotateRight(places) { let low, high; if (places &amp; 32) { high = this.low; low = this.high; } else { low = this.low; high = this.high; } places &amp;= 31; this.low = low &gt;&gt;&gt; places | high &lt;&lt; 32 - places; this.high = high &gt;&gt;&gt; places | low &lt;&lt; 32 - places; } not() { this.high = ~this.high; this.low = ~this.low; } add(word) { const lowAdd = (this.low &gt;&gt;&gt; 0) + (word.low &gt;&gt;&gt; 0); let highAdd = (this.high &gt;&gt;&gt; 0) + (word.high &gt;&gt;&gt; 0); if (lowAdd &gt; 0xffffffff) { highAdd += 1; } this.low = lowAdd | 0; this.high = highAdd | 0; } copyTo(bytes, offset) { bytes[offset] = this.high &gt;&gt;&gt; 24 &amp; 0xff; bytes[offset + 1] = this.high &gt;&gt; 16 &amp; 0xff; bytes[offset + 2] = this.high &gt;&gt; 8 &amp; 0xff; bytes[offset + 3] = this.high &amp; 0xff; bytes[offset + 4] = this.low &gt;&gt;&gt; 24 &amp; 0xff; bytes[offset + 5] = this.low &gt;&gt; 16 &amp; 0xff; bytes[offset + 6] = this.low &gt;&gt; 8 &amp; 0xff; bytes[offset + 7] = this.low &amp; 0xff; } assign(word) { this.high = word.high; this.low = word.low; } } const calculateSHA256 = function calculateSHA256Closure() { function rotr(x, n) { return x &gt;&gt;&gt; n | x &lt;&lt; 32 - n; } function ch(x, y, z) { return x &amp; y ^ ~x &amp; z; } function maj(x, y, z) { return x &amp; y ^ x &amp; z ^ y &amp; z; } function sigma(x) { return rotr(x, 2) ^ rotr(x, 13) ^ rotr(x, 22); } function sigmaPrime(x) { return rotr(x, 6) ^ rotr(x, 11) ^ rotr(x, 25); } function littleSigma(x) { return rotr(x, 7) ^ rotr(x, 18) ^ x &gt;&gt;&gt; 3; } function littleSigmaPrime(x) { return rotr(x, 17) ^ rotr(x, 19) ^ x &gt;&gt;&gt; 10; } const k = [0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5, 0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174, 0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da, 0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967, 0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85, 0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070, 0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3, 0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2]; function hash(data, offset, length) { let h0 = 0x6a09e667, h1 = 0xbb67ae85, h2 = 0x3c6ef372, h3 = 0xa54ff53a, h4 = 0x510e527f, h5 = 0x9b05688c, h6 = 0x1f83d9ab, h7 = 0x5be0cd19; const paddedLength = Math.ceil((length + 9) / 64) * 64; const padded = new Uint8Array(paddedLength); let i, j; for (i = 0; i &lt; length; ++i) { padded[i] = data[offset++]; } padded[i++] = 0x80; const n = paddedLength - 8; while (i &lt; n) { padded[i++] = 0; } padded[i++] = 0; padded[i++] = 0; padded[i++] = 0; padded[i++] = length &gt;&gt;&gt; 29 &amp; 0xff; padded[i++] = length &gt;&gt; 21 &amp; 0xff; padded[i++] = length &gt;&gt; 13 &amp; 0xff; padded[i++] = length &gt;&gt; 5 &amp; 0xff; padded[i++] = length &lt;&lt; 3 &amp; 0xff; const w = new Uint32Array(64); for (i = 0; i &lt; paddedLength;) { for (j = 0; j &lt; 16; ++j) { w[j] = padded[i] &lt;&lt; 24 | padded[i + 1] &lt;&lt; 16 | padded[i + 2] &lt;&lt; 8 | padded[i + 3]; i += 4; } for (j = 16; j &lt; 64; ++j) { w[j] = littleSigmaPrime(w[j - 2]) + w[j - 7] + littleSigma(w[j - 15]) + w[j - 16] | 0; } let a = h0, b = h1, c = h2, d = h3, e = h4, f = h5, g = h6, h = h7, t1, t2; for (j = 0; j &lt; 64; ++j) { t1 = h + sigmaPrime(e) + ch(e, f, g) + k[j] + w[j]; t2 = sigma(a) + maj(a, b, c); h = g; g = f; f = e; e = d + t1 | 0; d = c; c = b; b = a; a = t1 + t2 | 0; } h0 = h0 + a | 0; h1 = h1 + b | 0; h2 = h2 + c | 0; h3 = h3 + d | 0; h4 = h4 + e | 0; h5 = h5 + f | 0; h6 = h6 + g | 0; h7 = h7 + h | 0; } return new Uint8Array([h0 &gt;&gt; 24 &amp; 0xFF, h0 &gt;&gt; 16 &amp; 0xFF, h0 &gt;&gt; 8 &amp; 0xFF, h0 &amp; 0xFF, h1 &gt;&gt; 24 &amp; 0xFF, h1 &gt;&gt; 16 &amp; 0xFF, h1 &gt;&gt; 8 &amp; 0xFF, h1 &amp; 0xFF, h2 &gt;&gt; 24 &amp; 0xFF, h2 &gt;&gt; 16 &amp; 0xFF, h2 &gt;&gt; 8 &amp; 0xFF, h2 &amp; 0xFF, h3 &gt;&gt; 24 &amp; 0xFF, h3 &gt;&gt; 16 &amp; 0xFF, h3 &gt;&gt; 8 &amp; 0xFF, h3 &amp; 0xFF, h4 &gt;&gt; 24 &amp; 0xFF, h4 &gt;&gt; 16 &amp; 0xFF, h4 &gt;&gt; 8 &amp; 0xFF, h4 &amp; 0xFF, h5 &gt;&gt; 24 &amp; 0xFF, h5 &gt;&gt; 16 &amp; 0xFF, h5 &gt;&gt; 8 &amp; 0xFF, h5 &amp; 0xFF, h6 &gt;&gt; 24 &amp; 0xFF, h6 &gt;&gt; 16 &amp; 0xFF, h6 &gt;&gt; 8 &amp; 0xFF, h6 &amp; 0xFF, h7 &gt;&gt; 24 &amp; 0xFF, h7 &gt;&gt; 16 &amp; 0xFF, h7 &gt;&gt; 8 &amp; 0xFF, h7 &amp; 0xFF]); } return hash; }(); exports.calculateSHA256 = calculateSHA256; const calculateSHA512 = function calculateSHA512Closure() { function ch(result, x, y, z, tmp) { result.assign(x); result.and(y); tmp.assign(x); tmp.not(); tmp.and(z); result.xor(tmp); } function maj(result, x, y, z, tmp) { result.assign(x); result.and(y); tmp.assign(x); tmp.and(z); result.xor(tmp); tmp.assign(y); tmp.and(z); result.xor(tmp); } function sigma(result, x, tmp) { result.assign(x); result.rotateRight(28); tmp.assign(x); tmp.rotateRight(34); result.xor(tmp); tmp.assign(x); tmp.rotateRight(39); result.xor(tmp); } function sigmaPrime(result, x, tmp) { result.assign(x); result.rotateRight(14); tmp.assign(x); tmp.rotateRight(18); result.xor(tmp); tmp.assign(x); tmp.rotateRight(41); result.xor(tmp); } function littleSigma(result, x, tmp) { result.assign(x); result.rotateRight(1); tmp.assign(x); tmp.rotateRight(8); result.xor(tmp); tmp.assign(x); tmp.shiftRight(7); result.xor(tmp); } function littleSigmaPrime(result, x, tmp) { result.assign(x); result.rotateRight(19); tmp.assign(x); tmp.rotateRight(61); result.xor(tmp); tmp.assign(x); tmp.shiftRight(6); result.xor(tmp); } const k = [new Word64(0x428a2f98, 0xd728ae22), new Word64(0x71374491, 0x23ef65cd), new Word64(0xb5c0fbcf, 0xec4d3b2f), new Word64(0xe9b5dba5, 0x8189dbbc), new Word64(0x3956c25b, 0xf348b538), new Word64(0x59f111f1, 0xb605d019), new Word64(0x923f82a4, 0xaf194f9b), new Word64(0xab1c5ed5, 0xda6d8118), new Word64(0xd807aa98, 0xa3030242), new Word64(0x12835b01, 0x45706fbe), new Word64(0x243185be, 0x4ee4b28c), new Word64(0x550c7dc3, 0xd5ffb4e2), new Word64(0x72be5d74, 0xf27b896f), new Word64(0x80deb1fe, 0x3b1696b1), new Word64(0x9bdc06a7, 0x25c71235), new Word64(0xc19bf174, 0xcf692694), new Word64(0xe49b69c1, 0x9ef14ad2), new Word64(0xefbe4786, 0x384f25e3), new Word64(0x0fc19dc6, 0x8b8cd5b5), new Word64(0x240ca1cc, 0x77ac9c65), new Word64(0x2de92c6f, 0x592b0275), new Word64(0x4a7484aa, 0x6ea6e483), new Word64(0x5cb0a9dc, 0xbd41fbd4), new Word64(0x76f988da, 0x831153b5), new Word64(0x983e5152, 0xee66dfab), new Word64(0xa831c66d, 0x2db43210), new Word64(0xb00327c8, 0x98fb213f), new Word64(0xbf597fc7, 0xbeef0ee4), new Word64(0xc6e00bf3, 0x3da88fc2), new Word64(0xd5a79147, 0x930aa725), new Word64(0x06ca6351, 0xe003826f), new Word64(0x14292967, 0x0a0e6e70), new Word64(0x27b70a85, 0x46d22ffc), new Word64(0x2e1b2138, 0x5c26c926), new Word64(0x4d2c6dfc, 0x5ac42aed), new Word64(0x53380d13, 0x9d95b3df), new Word64(0x650a7354, 0x8baf63de), new Word64(0x766a0abb, 0x3c77b2a8), new Word64(0x81c2c92e, 0x47edaee6), new Word64(0x92722c85, 0x1482353b), new Word64(0xa2bfe8a1, 0x4cf10364), new Word64(0xa81a664b, 0xbc423001), new Word64(0xc24b8b70, 0xd0f89791), new Word64(0xc76c51a3, 0x0654be30), new Word64(0xd192e819, 0xd6ef5218), new Word64(0xd6990624, 0x5565a910), new Word64(0xf40e3585, 0x5771202a), new Word64(0x106aa070, 0x32bbd1b8), new Word64(0x19a4c116, 0xb8d2d0c8), new Word64(0x1e376c08, 0x5141ab53), new Word64(0x2748774c, 0xdf8eeb99), new Word64(0x34b0bcb5, 0xe19b48a8), new Word64(0x391c0cb3, 0xc5c95a63), new Word64(0x4ed8aa4a, 0xe3418acb), new Word64(0x5b9cca4f, 0x7763e373), new Word64(0x682e6ff3, 0xd6b2b8a3), new Word64(0x748f82ee, 0x5defb2fc), new Word64(0x78a5636f, 0x43172f60), new Word64(0x84c87814, 0xa1f0ab72), new Word64(0x8cc70208, 0x1a6439ec), new Word64(0x90befffa, 0x23631e28), new Word64(0xa4506ceb, 0xde82bde9), new Word64(0xbef9a3f7, 0xb2c67915), new Word64(0xc67178f2, 0xe372532b), new Word64(0xca273ece, 0xea26619c), new Word64(0xd186b8c7, 0x21c0c207), new Word64(0xeada7dd6, 0xcde0eb1e), new Word64(0xf57d4f7f, 0xee6ed178), new Word64(0x06f067aa, 0x72176fba), new Word64(0x0a637dc5, 0xa2c898a6), new Word64(0x113f9804, 0xbef90dae), new Word64(0x1b710b35, 0x131c471b), new Word64(0x28db77f5, 0x23047d84), new Word64(0x32caab7b, 0x40c72493), new Word64(0x3c9ebe0a, 0x15c9bebc), new Word64(0x431d67c4, 0x9c100d4c), new Word64(0x4cc5d4be, 0xcb3e42b6), new Word64(0x597f299c, 0xfc657e2a), new Word64(0x5fcb6fab, 0x3ad6faec), new Word64(0x6c44198c, 0x4a475817)]; function hash(data, offset, length, mode384 = false) { let h0, h1, h2, h3, h4, h5, h6, h7; if (!mode384) { h0 = new Word64(0x6a09e667, 0xf3bcc908); h1 = new Word64(0xbb67ae85, 0x84caa73b); h2 = new Word64(0x3c6ef372, 0xfe94f82b); h3 = new Word64(0xa54ff53a, 0x5f1d36f1); h4 = new Word64(0x510e527f, 0xade682d1); h5 = new Word64(0x9b05688c, 0x2b3e6c1f); h6 = new Word64(0x1f83d9ab, 0xfb41bd6b); h7 = new Word64(0x5be0cd19, 0x137e2179); } else { h0 = new Word64(0xcbbb9d5d, 0xc1059ed8); h1 = new Word64(0x629a292a, 0x367cd507); h2 = new Word64(0x9159015a, 0x3070dd17); h3 = new Word64(0x152fecd8, 0xf70e5939); h4 = new Word64(0x67332667, 0xffc00b31); h5 = new Word64(0x8eb44a87, 0x68581511); h6 = new Word64(0xdb0c2e0d, 0x64f98fa7); h7 = new Word64(0x47b5481d, 0xbefa4fa4); } const paddedLength = Math.ceil((length + 17) / 128) * 128; const padded = new Uint8Array(paddedLength); let i, j; for (i = 0; i &lt; length; ++i) { padded[i] = data[offset++]; } padded[i++] = 0x80; const n = paddedLength - 16; while (i &lt; n) { padded[i++] = 0; } padded[i++] = 0; padded[i++] = 0; padded[i++] = 0; padded[i++] = 0; padded[i++] = 0; padded[i++] = 0; padded[i++] = 0; padded[i++] = 0; padded[i++] = 0; padded[i++] = 0; padded[i++] = 0; padded[i++] = length &gt;&gt;&gt; 29 &amp; 0xff; padded[i++] = length &gt;&gt; 21 &amp; 0xff; padded[i++] = length &gt;&gt; 13 &amp; 0xff; padded[i++] = length &gt;&gt; 5 &amp; 0xff; padded[i++] = length &lt;&lt; 3 &amp; 0xff; const w = new Array(80); for (i = 0; i &lt; 80; i++) { w[i] = new Word64(0, 0); } let a = new Word64(0, 0), b = new Word64(0, 0), c = new Word64(0, 0); let d = new Word64(0, 0), e = new Word64(0, 0), f = new Word64(0, 0); let g = new Word64(0, 0), h = new Word64(0, 0); const t1 = new Word64(0, 0), t2 = new Word64(0, 0); const tmp1 = new Word64(0, 0), tmp2 = new Word64(0, 0); let tmp3; for (i = 0; i &lt; paddedLength;) { for (j = 0; j &lt; 16; ++j) { w[j].high = padded[i] &lt;&lt; 24 | padded[i + 1] &lt;&lt; 16 | padded[i + 2] &lt;&lt; 8 | padded[i + 3]; w[j].low = padded[i + 4] &lt;&lt; 24 | padded[i + 5] &lt;&lt; 16 | padded[i + 6] &lt;&lt; 8 | padded[i + 7]; i += 8; } for (j = 16; j &lt; 80; ++j) { tmp3 = w[j]; littleSigmaPrime(tmp3, w[j - 2], tmp2); tmp3.add(w[j - 7]); littleSigma(tmp1, w[j - 15], tmp2); tmp3.add(tmp1); tmp3.add(w[j - 16]); } a.assign(h0); b.assign(h1); c.assign(h2); d.assign(h3); e.assign(h4); f.assign(h5); g.assign(h6); h.assign(h7); for (j = 0; j &lt; 80; ++j) { t1.assign(h); sigmaPrime(tmp1, e, tmp2); t1.add(tmp1); ch(tmp1, e, f, g, tmp2); t1.add(tmp1); t1.add(k[j]); t1.add(w[j]); sigma(t2, a, tmp2); maj(tmp1, a, b, c, tmp2); t2.add(tmp1); tmp3 = h; h = g; g = f; f = e; d.add(t1); e = d; d = c; c = b; b = a; tmp3.assign(t1); tmp3.add(t2); a = tmp3; } h0.add(a); h1.add(b); h2.add(c); h3.add(d); h4.add(e); h5.add(f); h6.add(g); h7.add(h); } let result; if (!mode384) { result = new Uint8Array(64); h0.copyTo(result, 0); h1.copyTo(result, 8); h2.copyTo(result, 16); h3.copyTo(result, 24); h4.copyTo(result, 32); h5.copyTo(result, 40); h6.copyTo(result, 48); h7.copyTo(result, 56); } else { result = new Uint8Array(48); h0.copyTo(result, 0); h1.copyTo(result, 8); h2.copyTo(result, 16); h3.copyTo(result, 24); h4.copyTo(result, 32); h5.copyTo(result, 40); } return result; } return hash; }(); exports.calculateSHA512 = calculateSHA512; function calculateSHA384(data, offset, length) { return calculateSHA512(data, offset, length, true); } class NullCipher { decryptBlock(data) { return data; } encrypt(data) { return data; } } class AESBaseCipher { constructor() { if (this.constructor === AESBaseCipher) { (0, _util.unreachable)(&quot;Cannot initialize AESBaseCipher.&quot;); } this._s = new Uint8Array([0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5, 0x30, 0x01, 0x67, 0x2b, 0xfe, 0xd7, 0xab, 0x76, 0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0, 0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0, 0xb7, 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc, 0x34, 0xa5, 0xe5, 0xf1, 0x71, 0xd8, 0x31, 0x15, 0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05, 0x9a, 0x07, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75, 0x09, 0x83, 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0, 0x52, 0x3b, 0xd6, 0xb3, 0x29, 0xe3, 0x2f, 0x84, 0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b, 0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf, 0xd0, 0xef, 0xaa, 0xfb, 0x43, 0x4d, 0x33, 0x85, 0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c, 0x9f, 0xa8, 0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5, 0xbc, 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2, 0xcd, 0x0c, 0x13, 0xec, 0x5f, 0x97, 0x44, 0x17, 0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19, 0x73, 0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88, 0x46, 0xee, 0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb, 0xe0, 0x32, 0x3a, 0x0a, 0x49, 0x06, 0x24, 0x5c, 0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79, 0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9, 0x6c, 0x56, 0xf4, 0xea, 0x65, 0x7a, 0xae, 0x08, 0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6, 0xb4, 0xc6, 0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a, 0x70, 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e, 0x61, 0x35, 0x57, 0xb9, 0x86, 0xc1, 0x1d, 0x9e, 0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e, 0x94, 0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf, 0x8c, 0xa1, 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68, 0x41, 0x99, 0x2d, 0x0f, 0xb0, 0x54, 0xbb, 0x16]); this._inv_s = new Uint8Array([0x52, 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38, 0xbf, 0x40, 0xa3, 0x9e, 0x81, 0xf3, 0xd7, 0xfb, 0x7c, 0xe3, 0x39, 0x82, 0x9b, 0x2f, 0xff, 0x87, 0x34, 0x8e, 0x43, 0x44, 0xc4, 0xde, 0xe9, 0xcb, 0x54, 0x7b, 0x94, 0x32, 0xa6, 0xc2, 0x23, 0x3d, 0xee, 0x4c, 0x95, 0x0b, 0x42, 0xfa, 0xc3, 0x4e, 0x08, 0x2e, 0xa1, 0x66, 0x28, 0xd9, 0x24, 0xb2, 0x76, 0x5b, 0xa2, 0x49, 0x6d, 0x8b, 0xd1, 0x25, 0x72, 0xf8, 0xf6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xd4, 0xa4, 0x5c, 0xcc, 0x5d, 0x65, 0xb6, 0x92, 0x6c, 0x70, 0x48, 0x50, 0xfd, 0xed, 0xb9, 0xda, 0x5e, 0x15, 0x46, 0x57, 0xa7, 0x8d, 0x9d, 0x84, 0x90, 0xd8, 0xab, 0x00, 0x8c, 0xbc, 0xd3, 0x0a, 0xf7, 0xe4, 0x58, 0x05, 0xb8, 0xb3, 0x45, 0x06, 0xd0, 0x2c, 0x1e, 0x8f, 0xca, 0x3f, 0x0f, 0x02, 0xc1, 0xaf, 0xbd, 0x03, 0x01, 0x13, 0x8a, 0x6b, 0x3a, 0x91, 0x11, 0x41, 0x4f, 0x67, 0xdc, 0xea, 0x97, 0xf2, 0xcf, 0xce, 0xf0, 0xb4, 0xe6, 0x73, 0x96, 0xac, 0x74, 0x22, 0xe7, 0xad, 0x35, 0x85, 0xe2, 0xf9, 0x37, 0xe8, 0x1c, 0x75, 0xdf, 0x6e, 0x47, 0xf1, 0x1a, 0x71, 0x1d, 0x29, 0xc5, 0x89, 0x6f, 0xb7, 0x62, 0x0e, 0xaa, 0x18, 0xbe, 0x1b, 0xfc, 0x56, 0x3e, 0x4b, 0xc6, 0xd2, 0x79, 0x20, 0x9a, 0xdb, 0xc0, 0xfe, 0x78, 0xcd, 0x5a, 0xf4, 0x1f, 0xdd, 0xa8, 0x33, 0x88, 0x07, 0xc7, 0x31, 0xb1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xec, 0x5f, 0x60, 0x51, 0x7f, 0xa9, 0x19, 0xb5, 0x4a, 0x0d, 0x2d, 0xe5, 0x7a, 0x9f, 0x93, 0xc9, 0x9c, 0xef, 0xa0, 0xe0, 0x3b, 0x4d, 0xae, 0x2a, 0xf5, 0xb0, 0xc8, 0xeb, 0xbb, 0x3c, 0x83, 0x53, 0x99, 0x61, 0x17, 0x2b, 0x04, 0x7e, 0xba, 0x77, 0xd6, 0x26, 0xe1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0c, 0x7d]); this._mix = new Uint32Array([0x00000000, 0x0e090d0b, 0x1c121a16, 0x121b171d, 0x3824342c, 0x362d3927, 0x24362e3a, 0x2a3f2331, 0x70486858, 0x7e416553, 0x6c5a724e, 0x62537f45, 0x486c5c74, 0x4665517f, 0x547e4662, 0x5a774b69, 0xe090d0b0, 0xee99ddbb, 0xfc82caa6, 0xf28bc7ad, 0xd8b4e49c, 0xd6bde997, 0xc4a6fe8a, 0xcaaff381, 0x90d8b8e8, 0x9ed1b5e3, 0x8ccaa2fe, 0x82c3aff5, 0xa8fc8cc4, 0xa6f581cf, 0xb4ee96d2, 0xbae79bd9, 0xdb3bbb7b, 0xd532b670, 0xc729a16d, 0xc920ac66, 0xe31f8f57, 0xed16825c, 0xff0d9541, 0xf104984a, 0xab73d323, 0xa57ade28, 0xb761c935, 0xb968c43e, 0x9357e70f, 0x9d5eea04, 0x8f45fd19, 0x814cf012, 0x3bab6bcb, 0x35a266c0, 0x27b971dd, 0x29b07cd6, 0x038f5fe7, 0x0d8652ec, 0x1f9d45f1, 0x119448fa, 0x4be30393, 0x45ea0e98, 0x57f11985, 0x59f8148e, 0x73c737bf, 0x7dce3ab4, 0x6fd52da9, 0x61dc20a2, 0xad766df6, 0xa37f60fd, 0xb16477e0, 0xbf6d7aeb, 0x955259da, 0x9b5b54d1, 0x894043cc, 0x87494ec7, 0xdd3e05ae, 0xd33708a5, 0xc12c1fb8, 0xcf2512b3, 0xe51a3182, 0xeb133c89, 0xf9082b94, 0xf701269f, 0x4de6bd46, 0x43efb04d, 0x51f4a750, 0x5ffdaa5b, 0x75c2896a, 0x7bcb8461, 0x69d0937c, 0x67d99e77, 0x3daed51e, 0x33a7d815, 0x21bccf08, 0x2fb5c203, 0x058ae132, 0x0b83ec39, 0x1998fb24, 0x1791f62f, 0x764dd68d, 0x7844db86, 0x6a5fcc9b, 0x6456c190, 0x4e69e2a1, 0x4060efaa, 0x527bf8b7, 0x5c72f5bc, 0x0605bed5, 0x080cb3de, 0x1a17a4c3, 0x141ea9c8, 0x3e218af9, 0x302887f2, 0x223390ef, 0x2c3a9de4, 0x96dd063d, 0x98d40b36, 0x8acf1c2b, 0x84c61120, 0xaef93211, 0xa0f03f1a, 0xb2eb2807, 0xbce2250c, 0xe6956e65, 0xe89c636e, 0xfa877473, 0xf48e7978, 0xdeb15a49, 0xd0b85742, 0xc2a3405f, 0xccaa4d54, 0x41ecdaf7, 0x4fe5d7fc, 0x5dfec0e1, 0x53f7cdea, 0x79c8eedb, 0x77c1e3d0, 0x65daf4cd, 0x6bd3f9c6, 0x31a4b2af, 0x3fadbfa4, 0x2db6a8b9, 0x23bfa5b2, 0x09808683, 0x07898b88, 0x15929c95, 0x1b9b919e, 0xa17c0a47, 0xaf75074c, 0xbd6e1051, 0xb3671d5a, 0x99583e6b, 0x97513360, 0x854a247d, 0x8b432976, 0xd134621f, 0xdf3d6f14, 0xcd267809, 0xc32f7502, 0xe9105633, 0xe7195b38, 0xf5024c25, 0xfb0b412e, 0x9ad7618c, 0x94de6c87, 0x86c57b9a, 0x88cc7691, 0xa2f355a0, 0xacfa58ab, 0xbee14fb6, 0xb0e842bd, 0xea9f09d4, 0xe49604df, 0xf68d13c2, 0xf8841ec9, 0xd2bb3df8, 0xdcb230f3, 0xcea927ee, 0xc0a02ae5, 0x7a47b13c, 0x744ebc37, 0x6655ab2a, 0x685ca621, 0x42638510, 0x4c6a881b, 0x5e719f06, 0x5078920d, 0x0a0fd964, 0x0406d46f, 0x161dc372, 0x1814ce79, 0x322bed48, 0x3c22e043, 0x2e39f75e, 0x2030fa55, 0xec9ab701, 0xe293ba0a, 0xf088ad17, 0xfe81a01c, 0xd4be832d, 0xdab78e26, 0xc8ac993b, 0xc6a59430, 0x9cd2df59, 0x92dbd252, 0x80c0c54f, 0x8ec9c844, 0xa4f6eb75, 0xaaffe67e, 0xb8e4f163, 0xb6edfc68, 0x0c0a67b1, 0x02036aba, 0x10187da7, 0x1e1170ac, 0x342e539d, 0x3a275e96, 0x283c498b, 0x26354480, 0x7c420fe9, 0x724b02e2, 0x605015ff, 0x6e5918f4, 0x44663bc5, 0x4a6f36ce, 0x587421d3, 0x567d2cd8, 0x37a10c7a, 0x39a80171, 0x2bb3166c, 0x25ba1b67, 0x0f853856, 0x018c355d, 0x13972240, 0x1d9e2f4b, 0x47e96422, 0x49e06929, 0x5bfb7e34, 0x55f2733f, 0x7fcd500e, 0x71c45d05, 0x63df4a18, 0x6dd64713, 0xd731dcca, 0xd938d1c1, 0xcb23c6dc, 0xc52acbd7, 0xef15e8e6, 0xe11ce5ed, 0xf307f2f0, 0xfd0efffb, 0xa779b492, 0xa970b999, 0xbb6bae84, 0xb562a38f, 0x9f5d80be, 0x91548db5, 0x834f9aa8, 0x8d4697a3]); this._mixCol = new Uint8Array(256); for (let i = 0; i &lt; 256; i++) { if (i &lt; 128) { this._mixCol[i] = i &lt;&lt; 1; } else { this._mixCol[i] = i &lt;&lt; 1 ^ 0x1b; } } this.buffer = new Uint8Array(16); this.bufferPosition = 0; } _expandKey(cipherKey) { (0, _util.unreachable)(&quot;Cannot call `_expandKey` on the base class&quot;); } _decrypt(input, key) { let t, u, v; const state = new Uint8Array(16); state.set(input); for (let j = 0, k = this._keySize; j &lt; 16; ++j, ++k) { state[j] ^= key[k]; } for (let i = this._cyclesOfRepetition - 1; i &gt;= 1; --i) { t = state[13]; state[13] = state[9]; state[9] = state[5]; state[5] = state[1]; state[1] = t; t = state[14]; u = state[10]; state[14] = state[6]; state[10] = state[2]; state[6] = t; state[2] = u; t = state[15]; u = state[11]; v = state[7]; state[15] = state[3]; state[11] = t; state[7] = u; state[3] = v; for (let j = 0; j &lt; 16; ++j) { state[j] = this._inv_s[state[j]]; } for (let j = 0, k = i * 16; j &lt; 16; ++j, ++k) { state[j] ^= key[k]; } for (let j = 0; j &lt; 16; j += 4) { const s0 = this._mix[state[j]]; const s1 = this._mix[state[j + 1]]; const s2 = this._mix[state[j + 2]]; const s3 = this._mix[state[j + 3]]; t = s0 ^ s1 &gt;&gt;&gt; 8 ^ s1 &lt;&lt; 24 ^ s2 &gt;&gt;&gt; 16 ^ s2 &lt;&lt; 16 ^ s3 &gt;&gt;&gt; 24 ^ s3 &lt;&lt; 8; state[j] = t &gt;&gt;&gt; 24 &amp; 0xff; state[j + 1] = t &gt;&gt; 16 &amp; 0xff; state[j + 2] = t &gt;&gt; 8 &amp; 0xff; state[j + 3] = t &amp; 0xff; } } t = state[13]; state[13] = state[9]; state[9] = state[5]; state[5] = state[1]; state[1] = t; t = state[14]; u = state[10]; state[14] = state[6]; state[10] = state[2]; state[6] = t; state[2] = u; t = state[15]; u = state[11]; v = state[7]; state[15] = state[3]; state[11] = t; state[7] = u; state[3] = v; for (let j = 0; j &lt; 16; ++j) { state[j] = this._inv_s[state[j]]; state[j] ^= key[j]; } return state; } _encrypt(input, key) { const s = this._s; let t, u, v; const state = new Uint8Array(16); state.set(input); for (let j = 0; j &lt; 16; ++j) { state[j] ^= key[j]; } for (let i = 1; i &lt; this._cyclesOfRepetition; i++) { for (let j = 0; j &lt; 16; ++j) { state[j] = s[state[j]]; } v = state[1]; state[1] = state[5]; state[5] = state[9]; state[9] = state[13]; state[13] = v; v = state[2]; u = state[6]; state[2] = state[10]; state[6] = state[14]; state[10] = v; state[14] = u; v = state[3]; u = state[7]; t = state[11]; state[3] = state[15]; state[7] = v; state[11] = u; state[15] = t; for (let j = 0; j &lt; 16; j += 4) { const s0 = state[j + 0]; const s1 = state[j + 1]; const s2 = state[j + 2]; const s3 = state[j + 3]; t = s0 ^ s1 ^ s2 ^ s3; state[j + 0] ^= t ^ this._mixCol[s0 ^ s1]; state[j + 1] ^= t ^ this._mixCol[s1 ^ s2]; state[j + 2] ^= t ^ this._mixCol[s2 ^ s3]; state[j + 3] ^= t ^ this._mixCol[s3 ^ s0]; } for (let j = 0, k = i * 16; j &lt; 16; ++j, ++k) { state[j] ^= key[k]; } } for (let j = 0; j &lt; 16; ++j) { state[j] = s[state[j]]; } v = state[1]; state[1] = state[5]; state[5] = state[9]; state[9] = state[13]; state[13] = v; v = state[2]; u = state[6]; state[2] = state[10]; state[6] = state[14]; state[10] = v; state[14] = u; v = state[3]; u = state[7]; t = state[11]; state[3] = state[15]; state[7] = v; state[11] = u; state[15] = t; for (let j = 0, k = this._keySize; j &lt; 16; ++j, ++k) { state[j] ^= key[k]; } return state; } _decryptBlock2(data, finalize) { const sourceLength = data.length; let buffer = this.buffer, bufferLength = this.bufferPosition; const result = []; let iv = this.iv; for (let i = 0; i &lt; sourceLength; ++i) { buffer[bufferLength] = data[i]; ++bufferLength; if (bufferLength &lt; 16) { continue; } const plain = this._decrypt(buffer, this._key); for (let j = 0; j &lt; 16; ++j) { plain[j] ^= iv[j]; } iv = buffer; result.push(plain); buffer = new Uint8Array(16); bufferLength = 0; } this.buffer = buffer; this.bufferLength = bufferLength; this.iv = iv; if (result.length === 0) { return new Uint8Array(0); } let outputLength = 16 * result.length; if (finalize) { const lastBlock = result.at(-1); let psLen = lastBlock[15]; if (psLen &lt;= 16) { for (let i = 15, ii = 16 - psLen; i &gt;= ii; --i) { if (lastBlock[i] !== psLen) { psLen = 0; break; } } outputLength -= psLen; result[result.length - 1] = lastBlock.subarray(0, 16 - psLen); } } const output = new Uint8Array(outputLength); for (let i = 0, j = 0, ii = result.length; i &lt; ii; ++i, j += 16) { output.set(result[i], j); } return output; } decryptBlock(data, finalize, iv = null) { const sourceLength = data.length; const buffer = this.buffer; let bufferLength = this.bufferPosition; if (iv) { this.iv = iv; } else { for (let i = 0; bufferLength &lt; 16 &amp;&amp; i &lt; sourceLength; ++i, ++bufferLength) { buffer[bufferLength] = data[i]; } if (bufferLength &lt; 16) { this.bufferLength = bufferLength; return new Uint8Array(0); } this.iv = buffer; data = data.subarray(16); } this.buffer = new Uint8Array(16); this.bufferLength = 0; this.decryptBlock = this._decryptBlock2; return this.decryptBlock(data, finalize); } encrypt(data, iv) { const sourceLength = data.length; let buffer = this.buffer, bufferLength = this.bufferPosition; const result = []; if (!iv) { iv = new Uint8Array(16); } for (let i = 0; i &lt; sourceLength; ++i) { buffer[bufferLength] = data[i]; ++bufferLength; if (bufferLength &lt; 16) { continue; } for (let j = 0; j &lt; 16; ++j) { buffer[j] ^= iv[j]; } const cipher = this._encrypt(buffer, this._key); iv = cipher; result.push(cipher); buffer = new Uint8Array(16); bufferLength = 0; } this.buffer = buffer; this.bufferLength = bufferLength; this.iv = iv; if (result.length === 0) { return new Uint8Array(0); } const outputLength = 16 * result.length; const output = new Uint8Array(outputLength); for (let i = 0, j = 0, ii = result.length; i &lt; ii; ++i, j += 16) { output.set(result[i], j); } return output; } } class AES128Cipher extends AESBaseCipher { constructor(key) { super(); this._cyclesOfRepetition = 10; this._keySize = 160; this._rcon = new Uint8Array([0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8, 0xab, 0x4d, 0x9a, 0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3, 0x7d, 0xfa, 0xef, 0xc5, 0x91, 0x39, 0x72, 0xe4, 0xd3, 0xbd, 0x61, 0xc2, 0x9f, 0x25, 0x4a, 0x94, 0x33, 0x66, 0xcc, 0x83, 0x1d, 0x3a, 0x74, 0xe8, 0xcb, 0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8, 0xab, 0x4d, 0x9a, 0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3, 0x7d, 0xfa, 0xef, 0xc5, 0x91, 0x39, 0x72, 0xe4, 0xd3, 0xbd, 0x61, 0xc2, 0x9f, 0x25, 0x4a, 0x94, 0x33, 0x66, 0xcc, 0x83, 0x1d, 0x3a, 0x74, 0xe8, 0xcb, 0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8, 0xab, 0x4d, 0x9a, 0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3, 0x7d, 0xfa, 0xef, 0xc5, 0x91, 0x39, 0x72, 0xe4, 0xd3, 0xbd, 0x61, 0xc2, 0x9f, 0x25, 0x4a, 0x94, 0x33, 0x66, 0xcc, 0x83, 0x1d, 0x3a, 0x74, 0xe8, 0xcb, 0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8, 0xab, 0x4d, 0x9a, 0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3, 0x7d, 0xfa, 0xef, 0xc5, 0x91, 0x39, 0x72, 0xe4, 0xd3, 0xbd, 0x61, 0xc2, 0x9f, 0x25, 0x4a, 0x94, 0x33, 0x66, 0xcc, 0x83, 0x1d, 0x3a, 0x74, 0xe8, 0xcb, 0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8, 0xab, 0x4d, 0x9a, 0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3, 0x7d, 0xfa, 0xef, 0xc5, 0x91, 0x39, 0x72, 0xe4, 0xd3, 0xbd, 0x61, 0xc2, 0x9f, 0x25, 0x4a, 0x94, 0x33, 0x66, 0xcc, 0x83, 0x1d, 0x3a, 0x74, 0xe8, 0xcb, 0x8d]); this._key = this._expandKey(key); } _expandKey(cipherKey) { const b = 176; const s = this._s; const rcon = this._rcon; const result = new Uint8Array(b); result.set(cipherKey); for (let j = 16, i = 1; j &lt; b; ++i) { let t1 = result[j - 3]; let t2 = result[j - 2]; let t3 = result[j - 1]; let t4 = result[j - 4]; t1 = s[t1]; t2 = s[t2]; t3 = s[t3]; t4 = s[t4]; t1 ^= rcon[i]; for (let n = 0; n &lt; 4; ++n) { result[j] = t1 ^= result[j - 16]; j++; result[j] = t2 ^= result[j - 16]; j++; result[j] = t3 ^= result[j - 16]; j++; result[j] = t4 ^= result[j - 16]; j++; } } return result; } } exports.AES128Cipher = AES128Cipher; class AES256Cipher extends AESBaseCipher { constructor(key) { super(); this._cyclesOfRepetition = 14; this._keySize = 224; this._key = this._expandKey(key); } _expandKey(cipherKey) { const b = 240; const s = this._s; const result = new Uint8Array(b); result.set(cipherKey); let r = 1; let t1, t2, t3, t4; for (let j = 32, i = 1; j &lt; b; ++i) { if (j % 32 === 16) { t1 = s[t1]; t2 = s[t2]; t3 = s[t3]; t4 = s[t4]; } else if (j % 32 === 0) { t1 = result[j - 3]; t2 = result[j - 2]; t3 = result[j - 1]; t4 = result[j - 4]; t1 = s[t1]; t2 = s[t2]; t3 = s[t3]; t4 = s[t4]; t1 ^= r; if ((r &lt;&lt;= 1) &gt;= 256) { r = (r ^ 0x1b) &amp; 0xff; } } for (let n = 0; n &lt; 4; ++n) { result[j] = t1 ^= result[j - 32]; j++; result[j] = t2 ^= result[j - 32]; j++; result[j] = t3 ^= result[j - 32]; j++; result[j] = t4 ^= result[j - 32]; j++; } } return result; } } exports.AES256Cipher = AES256Cipher; class PDF17 { checkOwnerPassword(password, ownerValidationSalt, userBytes, ownerPassword) { const hashData = new Uint8Array(password.length + 56); hashData.set(password, 0); hashData.set(ownerValidationSalt, password.length); hashData.set(userBytes, password.length + ownerValidationSalt.length); const result = calculateSHA256(hashData, 0, hashData.length); return (0, _util.isArrayEqual)(result, ownerPassword); } checkUserPassword(password, userValidationSalt, userPassword) { const hashData = new Uint8Array(password.length + 8); hashData.set(password, 0); hashData.set(userValidationSalt, password.length); const result = calculateSHA256(hashData, 0, hashData.length); return (0, _util.isArrayEqual)(result, userPassword); } getOwnerKey(password, ownerKeySalt, userBytes, ownerEncryption) { const hashData = new Uint8Array(password.length + 56); hashData.set(password, 0); hashData.set(ownerKeySalt, password.length); hashData.set(userBytes, password.length + ownerKeySalt.length); const key = calculateSHA256(hashData, 0, hashData.length); const cipher = new AES256Cipher(key); return cipher.decryptBlock(ownerEncryption, false, new Uint8Array(16)); } getUserKey(password, userKeySalt, userEncryption) { const hashData = new Uint8Array(password.length + 8); hashData.set(password, 0); hashData.set(userKeySalt, password.length); const key = calculateSHA256(hashData, 0, hashData.length); const cipher = new AES256Cipher(key); return cipher.decryptBlock(userEncryption, false, new Uint8Array(16)); } } exports.PDF17 = PDF17; const PDF20 = function PDF20Closure() { function calculatePDF20Hash(password, input, userBytes) { let k = calculateSHA256(input, 0, input.length).subarray(0, 32); let e = [0]; let i = 0; while (i &lt; 64 || e.at(-1) &gt; i - 32) { const combinedLength = password.length + k.length + userBytes.length, combinedArray = new Uint8Array(combinedLength); let writeOffset = 0; combinedArray.set(password, writeOffset); writeOffset += password.length; combinedArray.set(k, writeOffset); writeOffset += k.length; combinedArray.set(userBytes, writeOffset); const k1 = new Uint8Array(combinedLength * 64); for (let j = 0, pos = 0; j &lt; 64; j++, pos += combinedLength) { k1.set(combinedArray, pos); } const cipher = new AES128Cipher(k.subarray(0, 16)); e = cipher.encrypt(k1, k.subarray(16, 32)); const remainder = e.slice(0, 16).reduce((a, b) =&gt; a + b, 0) % 3; if (remainder === 0) { k = calculateSHA256(e, 0, e.length); } else if (remainder === 1) { k = calculateSHA384(e, 0, e.length); } else if (remainder === 2) { k = calculateSHA512(e, 0, e.length); } i++; } return k.subarray(0, 32); } class PDF20 { hash(password, concatBytes, userBytes) { return calculatePDF20Hash(password, concatBytes, userBytes); } checkOwnerPassword(password, ownerValidationSalt, userBytes, ownerPassword) { const hashData = new Uint8Array(password.length + 56); hashData.set(password, 0); hashData.set(ownerValidationSalt, password.length); hashData.set(userBytes, password.length + ownerValidationSalt.length); const result = calculatePDF20Hash(password, hashData, userBytes); return (0, _util.isArrayEqual)(result, ownerPassword); } checkUserPassword(password, userValidationSalt, userPassword) { const hashData = new Uint8Array(password.length + 8); hashData.set(password, 0); hashData.set(userValidationSalt, password.length); const result = calculatePDF20Hash(password, hashData, []); return (0, _util.isArrayEqual)(result, userPassword); } getOwnerKey(password, ownerKeySalt, userBytes, ownerEncryption) { const hashData = new Uint8Array(password.length + 56); hashData.set(password, 0); hashData.set(ownerKeySalt, password.length); hashData.set(userBytes, password.length + ownerKeySalt.length); const key = calculatePDF20Hash(password, hashData, userBytes); const cipher = new AES256Cipher(key); return cipher.decryptBlock(ownerEncryption, false, new Uint8Array(16)); } getUserKey(password, userKeySalt, userEncryption) { const hashData = new Uint8Array(password.length + 8); hashData.set(password, 0); hashData.set(userKeySalt, password.length); const key = calculatePDF20Hash(password, hashData, []); const cipher = new AES256Cipher(key); return cipher.decryptBlock(userEncryption, false, new Uint8Array(16)); } } return PDF20; }(); exports.PDF20 = PDF20; class CipherTransform { constructor(stringCipherConstructor, streamCipherConstructor) { this.StringCipherConstructor = stringCipherConstructor; this.StreamCipherConstructor = streamCipherConstructor; } createStream(stream, length) { const cipher = new this.StreamCipherConstructor(); return new _decrypt_stream.DecryptStream(stream, length, function cipherTransformDecryptStream(data, finalize) { return cipher.decryptBlock(data, finalize); }); } decryptString(s) { const cipher = new this.StringCipherConstructor(); let data = (0, _util.stringToBytes)(s); data = cipher.decryptBlock(data, true); return (0, _util.bytesToString)(data); } encryptString(s) { const cipher = new this.StringCipherConstructor(); if (cipher instanceof AESBaseCipher) { const strLen = s.length; const pad = 16 - strLen % 16; s += String.fromCharCode(pad).repeat(pad); const iv = new Uint8Array(16); if (typeof crypto !== &quot;undefined&quot;) { crypto.getRandomValues(iv); } else { for (let i = 0; i &lt; 16; i++) { iv[i] = Math.floor(256 * Math.random()); } } let data = (0, _util.stringToBytes)(s); data = cipher.encrypt(data, iv); const buf = new Uint8Array(16 + data.length); buf.set(iv); buf.set(data, 16); return (0, _util.bytesToString)(buf); } let data = (0, _util.stringToBytes)(s); data = cipher.encrypt(data); return (0, _util.bytesToString)(data); } } const CipherTransformFactory = function CipherTransformFactoryClosure() { const defaultPasswordBytes = new Uint8Array([0x28, 0xbf, 0x4e, 0x5e, 0x4e, 0x75, 0x8a, 0x41, 0x64, 0x00, 0x4e, 0x56, 0xff, 0xfa, 0x01, 0x08, 0x2e, 0x2e, 0x00, 0xb6, 0xd0, 0x68, 0x3e, 0x80, 0x2f, 0x0c, 0xa9, 0xfe, 0x64, 0x53, 0x69, 0x7a]); function createEncryptionKey20(revision, password, ownerPassword, ownerValidationSalt, ownerKeySalt, uBytes, userPassword, userValidationSalt, userKeySalt, ownerEncryption, userEncryption, perms) { if (password) { const passwordLength = Math.min(127, password.length); password = password.subarray(0, passwordLength); } else { password = []; } let pdfAlgorithm; if (revision === 6) { pdfAlgorithm = new PDF20(); } else { pdfAlgorithm = new PDF17(); } if (pdfAlgorithm.checkUserPassword(password, userValidationSalt, userPassword)) { return pdfAlgorithm.getUserKey(password, userKeySalt, userEncryption); } else if (password.length &amp;&amp; pdfAlgorithm.checkOwnerPassword(password, ownerValidationSalt, uBytes, ownerPassword)) { return pdfAlgorithm.getOwnerKey(password, ownerKeySalt, uBytes, ownerEncryption); } return null; } function prepareKeyData(fileId, password, ownerPassword, userPassword, flags, revision, keyLength, encryptMetadata) { const hashDataSize = 40 + ownerPassword.length + fileId.length; const hashData = new Uint8Array(hashDataSize); let i = 0, j, n; if (password) { n = Math.min(32, password.length); for (; i &lt; n; ++i) { hashData[i] = password[i]; } } j = 0; while (i &lt; 32) { hashData[i++] = defaultPasswordBytes[j++]; } for (j = 0, n = ownerPassword.length; j &lt; n; ++j) { hashData[i++] = ownerPassword[j]; } hashData[i++] = flags &amp; 0xff; hashData[i++] = flags &gt;&gt; 8 &amp; 0xff; hashData[i++] = flags &gt;&gt; 16 &amp; 0xff; hashData[i++] = flags &gt;&gt;&gt; 24 &amp; 0xff; for (j = 0, n = fileId.length; j &lt; n; ++j) { hashData[i++] = fileId[j]; } if (revision &gt;= 4 &amp;&amp; !encryptMetadata) { hashData[i++] = 0xff; hashData[i++] = 0xff; hashData[i++] = 0xff; hashData[i++] = 0xff; } let hash = calculateMD5(hashData, 0, i); const keyLengthInBytes = keyLength &gt;&gt; 3; if (revision &gt;= 3) { for (j = 0; j &lt; 50; ++j) { hash = calculateMD5(hash, 0, keyLengthInBytes); } } const encryptionKey = hash.subarray(0, keyLengthInBytes); let cipher, checkData; if (revision &gt;= 3) { for (i = 0; i &lt; 32; ++i) { hashData[i] = defaultPasswordBytes[i]; } for (j = 0, n = fileId.length; j &lt; n; ++j) { hashData[i++] = fileId[j]; } cipher = new ARCFourCipher(encryptionKey); checkData = cipher.encryptBlock(calculateMD5(hashData, 0, i)); n = encryptionKey.length; const derivedKey = new Uint8Array(n); for (j = 1; j &lt;= 19; ++j) { for (let k = 0; k &lt; n; ++k) { derivedKey[k] = encryptionKey[k] ^ j; } cipher = new ARCFourCipher(derivedKey); checkData = cipher.encryptBlock(checkData); } for (j = 0, n = checkData.length; j &lt; n; ++j) { if (userPassword[j] !== checkData[j]) { return null; } } } else { cipher = new ARCFourCipher(encryptionKey); checkData = cipher.encryptBlock(defaultPasswordBytes); for (j = 0, n = checkData.length; j &lt; n; ++j) { if (userPassword[j] !== checkData[j]) { return null; } } } return encryptionKey; } function decodeUserPassword(password, ownerPassword, revision, keyLength) { const hashData = new Uint8Array(32); let i = 0; const n = Math.min(32, password.length); for (; i &lt; n; ++i) { hashData[i] = password[i]; } let j = 0; while (i &lt; 32) { hashData[i++] = defaultPasswordBytes[j++]; } let hash = calculateMD5(hashData, 0, i); const keyLengthInBytes = keyLength &gt;&gt; 3; if (revision &gt;= 3) { for (j = 0; j &lt; 50; ++j) { hash = calculateMD5(hash, 0, hash.length); } } let cipher, userPassword; if (revision &gt;= 3) { userPassword = ownerPassword; const derivedKey = new Uint8Array(keyLengthInBytes); for (j = 19; j &gt;= 0; j--) { for (let k = 0; k &lt; keyLengthInBytes; ++k) { derivedKey[k] = hash[k] ^ j; } cipher = new ARCFourCipher(derivedKey); userPassword = cipher.encryptBlock(userPassword); } } else { cipher = new ARCFourCipher(hash.subarray(0, keyLengthInBytes)); userPassword = cipher.encryptBlock(ownerPassword); } return userPassword; } const identityName = _primitives.Name.get(&quot;Identity&quot;); function buildObjectKey(num, gen, encryptionKey, isAes = false) { const key = new Uint8Array(encryptionKey.length + 9); const n = encryptionKey.length; let i; for (i = 0; i &lt; n; ++i) { key[i] = encryptionKey[i]; } key[i++] = num &amp; 0xff; key[i++] = num &gt;&gt; 8 &amp; 0xff; key[i++] = num &gt;&gt; 16 &amp; 0xff; key[i++] = gen &amp; 0xff; key[i++] = gen &gt;&gt; 8 &amp; 0xff; if (isAes) { key[i++] = 0x73; key[i++] = 0x41; key[i++] = 0x6c; key[i++] = 0x54; } const hash = calculateMD5(key, 0, i); return hash.subarray(0, Math.min(encryptionKey.length + 5, 16)); } function buildCipherConstructor(cf, name, num, gen, key) { if (!(name instanceof _primitives.Name)) { throw new _util.FormatError(&quot;Invalid crypt filter name.&quot;); } const cryptFilter = cf.get(name.name); let cfm; if (cryptFilter !== null &amp;&amp; cryptFilter !== undefined) { cfm = cryptFilter.get(&quot;CFM&quot;); } if (!cfm || cfm.name === &quot;None&quot;) { return function cipherTransformFactoryBuildCipherConstructorNone() { return new NullCipher(); }; } if (cfm.name === &quot;V2&quot;) { return function cipherTransformFactoryBuildCipherConstructorV2() { return new ARCFourCipher(buildObjectKey(num, gen, key, false)); }; } if (cfm.name === &quot;AESV2&quot;) { return function cipherTransformFactoryBuildCipherConstructorAESV2() { return new AES128Cipher(buildObjectKey(num, gen, key, true)); }; } if (cfm.name === &quot;AESV3&quot;) { return function cipherTransformFactoryBuildCipherConstructorAESV3() { return new AES256Cipher(key); }; } throw new _util.FormatError(&quot;Unknown crypto method&quot;); } class CipherTransformFactory { constructor(dict, fileId, password) { const filter = dict.get(&quot;Filter&quot;); if (!(0, _primitives.isName)(filter, &quot;Standard&quot;)) { throw new _util.FormatError(&quot;unknown encryption method&quot;); } this.filterName = filter.name; this.dict = dict; const algorithm = dict.get(&quot;V&quot;); if (!Number.isInteger(algorithm) || algorithm !== 1 &amp;&amp; algorithm !== 2 &amp;&amp; algorithm !== 4 &amp;&amp; algorithm !== 5) { throw new _util.FormatError(&quot;unsupported encryption algorithm&quot;); } this.algorithm = algorithm; let keyLength = dict.get(&quot;Length&quot;); if (!keyLength) { if (algorithm &lt;= 3) { keyLength = 40; } else { const cfDict = dict.get(&quot;CF&quot;); const streamCryptoName = dict.get(&quot;StmF&quot;); if (cfDict instanceof _primitives.Dict &amp;&amp; streamCryptoName instanceof _primitives.Name) { cfDict.suppressEncryption = true; const handlerDict = cfDict.get(streamCryptoName.name); keyLength = handlerDict &amp;&amp; handlerDict.get(&quot;Length&quot;) || 128; if (keyLength &lt; 40) { keyLength &lt;&lt;= 3; } } } } if (!Number.isInteger(keyLength) || keyLength &lt; 40 || keyLength % 8 !== 0) { throw new _util.FormatError(&quot;invalid key length&quot;); } const ownerPassword = (0, _util.stringToBytes)(dict.get(&quot;O&quot;)).subarray(0, 32); const userPassword = (0, _util.stringToBytes)(dict.get(&quot;U&quot;)).subarray(0, 32); const flags = dict.get(&quot;P&quot;); const revision = dict.get(&quot;R&quot;); const encryptMetadata = (algorithm === 4 || algorithm === 5) &amp;&amp; dict.get(&quot;EncryptMetadata&quot;) !== false; this.encryptMetadata = encryptMetadata; const fileIdBytes = (0, _util.stringToBytes)(fileId); let passwordBytes; if (password) { if (revision === 6) { try { password = (0, _util.utf8StringToString)(password); } catch (ex) { (0, _util.warn)(&quot;CipherTransformFactory: &quot; + &quot;Unable to convert UTF8 encoded password.&quot;); } } passwordBytes = (0, _util.stringToBytes)(password); } let encryptionKey; if (algorithm !== 5) { encryptionKey = prepareKeyData(fileIdBytes, passwordBytes, ownerPassword, userPassword, flags, revision, keyLength, encryptMetadata); } else { const ownerValidationSalt = (0, _util.stringToBytes)(dict.get(&quot;O&quot;)).subarray(32, 40); const ownerKeySalt = (0, _util.stringToBytes)(dict.get(&quot;O&quot;)).subarray(40, 48); const uBytes = (0, _util.stringToBytes)(dict.get(&quot;U&quot;)).subarray(0, 48); const userValidationSalt = (0, _util.stringToBytes)(dict.get(&quot;U&quot;)).subarray(32, 40); const userKeySalt = (0, _util.stringToBytes)(dict.get(&quot;U&quot;)).subarray(40, 48); const ownerEncryption = (0, _util.stringToBytes)(dict.get(&quot;OE&quot;)); const userEncryption = (0, _util.stringToBytes)(dict.get(&quot;UE&quot;)); const perms = (0, _util.stringToBytes)(dict.get(&quot;Perms&quot;)); encryptionKey = createEncryptionKey20(revision, passwordBytes, ownerPassword, ownerValidationSalt, ownerKeySalt, uBytes, userPassword, userValidationSalt, userKeySalt, ownerEncryption, userEncryption, perms); } if (!encryptionKey &amp;&amp; !password) { throw new _util.PasswordException(&quot;No password given&quot;, _util.PasswordResponses.NEED_PASSWORD); } else if (!encryptionKey &amp;&amp; password) { const decodedPassword = decodeUserPassword(passwordBytes, ownerPassword, revision, keyLength); encryptionKey = prepareKeyData(fileIdBytes, decodedPassword, ownerPassword, userPassword, flags, revision, keyLength, encryptMetadata); } if (!encryptionKey) { throw new _util.PasswordException(&quot;Incorrect Password&quot;, _util.PasswordResponses.INCORRECT_PASSWORD); } this.encryptionKey = encryptionKey; if (algorithm &gt;= 4) { const cf = dict.get(&quot;CF&quot;); if (cf instanceof _primitives.Dict) { cf.suppressEncryption = true; } this.cf = cf; this.stmf = dict.get(&quot;StmF&quot;) || identityName; this.strf = dict.get(&quot;StrF&quot;) || identityName; this.eff = dict.get(&quot;EFF&quot;) || this.stmf; } } createCipherTransform(num, gen) { if (this.algorithm === 4 || this.algorithm === 5) { return new CipherTransform(buildCipherConstructor(this.cf, this.strf, num, gen, this.encryptionKey), buildCipherConstructor(this.cf, this.stmf, num, gen, this.encryptionKey)); } const key = buildObjectKey(num, gen, this.encryptionKey, false); const cipherConstructor = function buildCipherCipherConstructor() { return new ARCFourCipher(key); }; return new CipherTransform(cipherConstructor, cipherConstructor); } } return CipherTransformFactory; }(); exports.CipherTransformFactory = CipherTransformFactory; /***/ }), /* 66 */ /***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) =&gt; { Object.defineProperty(exports, &quot;__esModule&quot;, ({ value: true })); exports.DecryptStream = void 0; var _decode_stream = __w_pdfjs_require__(17); const chunkSize = 512; class DecryptStream extends _decode_stream.DecodeStream { constructor(str, maybeLength, decrypt) { super(maybeLength); this.str = str; this.dict = str.dict; this.decrypt = decrypt; this.nextChunk = null; this.initialized = false; } readBlock() { let chunk; if (this.initialized) { chunk = this.nextChunk; } else { chunk = this.str.getBytes(chunkSize); this.initialized = true; } if (!chunk || chunk.length === 0) { this.eof = true; return; } this.nextChunk = this.str.getBytes(chunkSize); const hasMoreData = this.nextChunk &amp;&amp; this.nextChunk.length &gt; 0; const decrypt = this.decrypt; chunk = decrypt(chunk, !hasMoreData); const bufferLength = this.bufferLength, newLength = bufferLength + chunk.length, buffer = this.ensureBuffer(newLength); buffer.set(chunk, bufferLength); this.bufferLength = newLength; } } exports.DecryptStream = DecryptStream; /***/ }), /* 67 */ /***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) =&gt; { Object.defineProperty(exports, &quot;__esModule&quot;, ({ value: true })); exports.Catalog = void 0; var _core_utils = __w_pdfjs_require__(4); var _util = __w_pdfjs_require__(2); var _primitives = __w_pdfjs_require__(3); var _name_number_tree = __w_pdfjs_require__(68); var _base_stream = __w_pdfjs_require__(5); var _cleanup_helper = __w_pdfjs_require__(69); var _colorspace = __w_pdfjs_require__(12); var _file_spec = __w_pdfjs_require__(70); var _image_utils = __w_pdfjs_require__(57); var _metadata_parser = __w_pdfjs_require__(71); var _struct_tree = __w_pdfjs_require__(72); function fetchDestination(dest) { if (dest instanceof _primitives.Dict) { dest = dest.get(&quot;D&quot;); } return Array.isArray(dest) ? dest : null; } class Catalog { constructor(pdfManager, xref) { this.pdfManager = pdfManager; this.xref = xref; this._catDict = xref.getCatalogObj(); if (!(this._catDict instanceof _primitives.Dict)) { throw new _util.FormatError(&quot;Catalog object is not a dictionary.&quot;); } this.toplevelPagesDict; this._actualNumPages = null; this.fontCache = new _primitives.RefSetCache(); this.builtInCMapCache = new Map(); this.standardFontDataCache = new Map(); this.globalImageCache = new _image_utils.GlobalImageCache(); this.pageKidsCountCache = new _primitives.RefSetCache(); this.pageIndexCache = new _primitives.RefSetCache(); this.nonBlendModesSet = new _primitives.RefSet(); } get version() { const version = this._catDict.get(&quot;Version&quot;); if (version instanceof _primitives.Name) { if (_core_utils.PDF_VERSION_REGEXP.test(version.name)) { return (0, _util.shadow)(this, &quot;version&quot;, version.name); } (0, _util.warn)(`Invalid PDF catalog version: ${version.name}`); } return (0, _util.shadow)(this, &quot;version&quot;, null); } get lang() { const lang = this._catDict.get(&quot;Lang&quot;); return (0, _util.shadow)(this, &quot;lang&quot;, typeof lang === &quot;string&quot; ? (0, _util.stringToPDFString)(lang) : null); } get needsRendering() { const needsRendering = this._catDict.get(&quot;NeedsRendering&quot;); return (0, _util.shadow)(this, &quot;needsRendering&quot;, typeof needsRendering === &quot;boolean&quot; ? needsRendering : false); } get collection() { let collection = null; try { const obj = this._catDict.get(&quot;Collection&quot;); if (obj instanceof _primitives.Dict &amp;&amp; obj.size &gt; 0) { collection = obj; } } catch (ex) { if (ex instanceof _core_utils.MissingDataException) { throw ex; } (0, _util.info)(&quot;Cannot fetch Collection entry; assuming no collection is present.&quot;); } return (0, _util.shadow)(this, &quot;collection&quot;, collection); } get acroForm() { let acroForm = null; try { const obj = this._catDict.get(&quot;AcroForm&quot;); if (obj instanceof _primitives.Dict &amp;&amp; obj.size &gt; 0) { acroForm = obj; } } catch (ex) { if (ex instanceof _core_utils.MissingDataException) { throw ex; } (0, _util.info)(&quot;Cannot fetch AcroForm entry; assuming no forms are present.&quot;); } return (0, _util.shadow)(this, &quot;acroForm&quot;, acroForm); } get acroFormRef() { const value = this._catDict.getRaw(&quot;AcroForm&quot;); return (0, _util.shadow)(this, &quot;acroFormRef&quot;, value instanceof _primitives.Ref ? value : null); } get metadata() { const streamRef = this._catDict.getRaw(&quot;Metadata&quot;); if (!(streamRef instanceof _primitives.Ref)) { return (0, _util.shadow)(this, &quot;metadata&quot;, null); } let metadata = null; try { const suppressEncryption = !(this.xref.encrypt &amp;&amp; this.xref.encrypt.encryptMetadata); const stream = this.xref.fetch(streamRef, suppressEncryption); if (stream instanceof _base_stream.BaseStream &amp;&amp; stream.dict instanceof _primitives.Dict) { const type = stream.dict.get(&quot;Type&quot;); const subtype = stream.dict.get(&quot;Subtype&quot;); if ((0, _primitives.isName)(type, &quot;Metadata&quot;) &amp;&amp; (0, _primitives.isName)(subtype, &quot;XML&quot;)) { const data = (0, _util.stringToUTF8String)(stream.getString()); if (data) { metadata = new _metadata_parser.MetadataParser(data).serializable; } } } } catch (ex) { if (ex instanceof _core_utils.MissingDataException) { throw ex; } (0, _util.info)(`Skipping invalid Metadata: &quot;${ex}&quot;.`); } return (0, _util.shadow)(this, &quot;metadata&quot;, metadata); } get markInfo() { let markInfo = null; try { markInfo = this._readMarkInfo(); } catch (ex) { if (ex instanceof _core_utils.MissingDataException) { throw ex; } (0, _util.warn)(&quot;Unable to read mark info.&quot;); } return (0, _util.shadow)(this, &quot;markInfo&quot;, markInfo); } _readMarkInfo() { const obj = this._catDict.get(&quot;MarkInfo&quot;); if (!(obj instanceof _primitives.Dict)) { return null; } const markInfo = { Marked: false, UserProperties: false, Suspects: false }; for (const key in markInfo) { const value = obj.get(key); if (typeof value === &quot;boolean&quot;) { markInfo[key] = value; } } return markInfo; } get structTreeRoot() { let structTree = null; try { structTree = this._readStructTreeRoot(); } catch (ex) { if (ex instanceof _core_utils.MissingDataException) { throw ex; } (0, _util.warn)(&quot;Unable read to structTreeRoot info.&quot;); } return (0, _util.shadow)(this, &quot;structTreeRoot&quot;, structTree); } _readStructTreeRoot() { const obj = this._catDict.get(&quot;StructTreeRoot&quot;); if (!(obj instanceof _primitives.Dict)) { return null; } const root = new _struct_tree.StructTreeRoot(obj); root.init(); return root; } get toplevelPagesDict() { const pagesObj = this._catDict.get(&quot;Pages&quot;); if (!(pagesObj instanceof _primitives.Dict)) { throw new _util.FormatError(&quot;Invalid top-level pages dictionary.&quot;); } return (0, _util.shadow)(this, &quot;toplevelPagesDict&quot;, pagesObj); } get documentOutline() { let obj = null; try { obj = this._readDocumentOutline(); } catch (ex) { if (ex instanceof _core_utils.MissingDataException) { throw ex; } (0, _util.warn)(&quot;Unable to read document outline.&quot;); } return (0, _util.shadow)(this, &quot;documentOutline&quot;, obj); } _readDocumentOutline() { let obj = this._catDict.get(&quot;Outlines&quot;); if (!(obj instanceof _primitives.Dict)) { return null; } obj = obj.getRaw(&quot;First&quot;); if (!(obj instanceof _primitives.Ref)) { return null; } const root = { items: [] }; const queue = [{ obj, parent: root }]; const processed = new _primitives.RefSet(); processed.put(obj); const xref = this.xref, blackColor = new Uint8ClampedArray(3); while (queue.length &gt; 0) { const i = queue.shift(); const outlineDict = xref.fetchIfRef(i.obj); if (outlineDict === null) { continue; } if (!outlineDict.has(&quot;Title&quot;)) { throw new _util.FormatError(&quot;Invalid outline item encountered.&quot;); } const data = { url: null, dest: null, action: null }; Catalog.parseDestDictionary({ destDict: outlineDict, resultObj: data, docBaseUrl: this.pdfManager.docBaseUrl, docAttachments: this.attachments }); const title = outlineDict.get(&quot;Title&quot;); const flags = outlineDict.get(&quot;F&quot;) || 0; const color = outlineDict.getArray(&quot;C&quot;); const count = outlineDict.get(&quot;Count&quot;); let rgbColor = blackColor; if (Array.isArray(color) &amp;&amp; color.length === 3 &amp;&amp; (color[0] !== 0 || color[1] !== 0 || color[2] !== 0)) { rgbColor = _colorspace.ColorSpace.singletons.rgb.getRgb(color, 0); } const outlineItem = { action: data.action, attachment: data.attachment, dest: data.dest, url: data.url, unsafeUrl: data.unsafeUrl, newWindow: data.newWindow, setOCGState: data.setOCGState, title: (0, _util.stringToPDFString)(title), color: rgbColor, count: Number.isInteger(count) ? count : undefined, bold: !!(flags &amp; 2), italic: !!(flags &amp; 1), items: [] }; i.parent.items.push(outlineItem); obj = outlineDict.getRaw(&quot;First&quot;); if (obj instanceof _primitives.Ref &amp;&amp; !processed.has(obj)) { queue.push({ obj, parent: outlineItem }); processed.put(obj); } obj = outlineDict.getRaw(&quot;Next&quot;); if (obj instanceof _primitives.Ref &amp;&amp; !processed.has(obj)) { queue.push({ obj, parent: i.parent }); processed.put(obj); } } return root.items.length &gt; 0 ? root.items : null; } get permissions() { let permissions = null; try { permissions = this._readPermissions(); } catch (ex) { if (ex instanceof _core_utils.MissingDataException) { throw ex; } (0, _util.warn)(&quot;Unable to read permissions.&quot;); } return (0, _util.shadow)(this, &quot;permissions&quot;, permissions); } _readPermissions() { const encrypt = this.xref.trailer.get(&quot;Encrypt&quot;); if (!(encrypt instanceof _primitives.Dict)) { return null; } let flags = encrypt.get(&quot;P&quot;); if (typeof flags !== &quot;number&quot;) { return null; } flags += 2 ** 32; const permissions = []; for (const key in _util.PermissionFlag) { const value = _util.PermissionFlag[key]; if (flags &amp; value) { permissions.push(value); } } return permissions; } get optionalContentConfig() { let config = null; try { const properties = this._catDict.get(&quot;OCProperties&quot;); if (!properties) { return (0, _util.shadow)(this, &quot;optionalContentConfig&quot;, null); } const defaultConfig = properties.get(&quot;D&quot;); if (!defaultConfig) { return (0, _util.shadow)(this, &quot;optionalContentConfig&quot;, null); } const groupsData = properties.get(&quot;OCGs&quot;); if (!Array.isArray(groupsData)) { return (0, _util.shadow)(this, &quot;optionalContentConfig&quot;, null); } const groups = []; const groupRefs = []; for (const groupRef of groupsData) { if (!(groupRef instanceof _primitives.Ref)) { continue; } groupRefs.push(groupRef); const group = this.xref.fetchIfRef(groupRef); groups.push({ id: groupRef.toString(), name: typeof group.get(&quot;Name&quot;) === &quot;string&quot; ? (0, _util.stringToPDFString)(group.get(&quot;Name&quot;)) : null, intent: typeof group.get(&quot;Intent&quot;) === &quot;string&quot; ? (0, _util.stringToPDFString)(group.get(&quot;Intent&quot;)) : null }); } config = this._readOptionalContentConfig(defaultConfig, groupRefs); config.groups = groups; } catch (ex) { if (ex instanceof _core_utils.MissingDataException) { throw ex; } (0, _util.warn)(`Unable to read optional content config: ${ex}`); } return (0, _util.shadow)(this, &quot;optionalContentConfig&quot;, config); } _readOptionalContentConfig(config, contentGroupRefs) { function parseOnOff(refs) { const onParsed = []; if (Array.isArray(refs)) { for (const value of refs) { if (!(value instanceof _primitives.Ref)) { continue; } if (contentGroupRefs.includes(value)) { onParsed.push(value.toString()); } } } return onParsed; } function parseOrder(refs, nestedLevels = 0) { if (!Array.isArray(refs)) { return null; } const order = []; for (const value of refs) { if (value instanceof _primitives.Ref &amp;&amp; contentGroupRefs.includes(value)) { parsedOrderRefs.put(value); order.push(value.toString()); continue; } const nestedOrder = parseNestedOrder(value, nestedLevels); if (nestedOrder) { order.push(nestedOrder); } } if (nestedLevels &gt; 0) { return order; } const hiddenGroups = []; for (const groupRef of contentGroupRefs) { if (parsedOrderRefs.has(groupRef)) { continue; } hiddenGroups.push(groupRef.toString()); } if (hiddenGroups.length) { order.push({ name: null, order: hiddenGroups }); } return order; } function parseNestedOrder(ref, nestedLevels) { if (++nestedLevels &gt; MAX_NESTED_LEVELS) { (0, _util.warn)(&quot;parseNestedOrder - reached MAX_NESTED_LEVELS.&quot;); return null; } const value = xref.fetchIfRef(ref); if (!Array.isArray(value)) { return null; } const nestedName = xref.fetchIfRef(value[0]); if (typeof nestedName !== &quot;string&quot;) { return null; } const nestedOrder = parseOrder(value.slice(1), nestedLevels); if (!nestedOrder || !nestedOrder.length) { return null; } return { name: (0, _util.stringToPDFString)(nestedName), order: nestedOrder }; } const xref = this.xref, parsedOrderRefs = new _primitives.RefSet(), MAX_NESTED_LEVELS = 10; return { name: typeof config.get(&quot;Name&quot;) === &quot;string&quot; ? (0, _util.stringToPDFString)(config.get(&quot;Name&quot;)) : null, creator: typeof config.get(&quot;Creator&quot;) === &quot;string&quot; ? (0, _util.stringToPDFString)(config.get(&quot;Creator&quot;)) : null, baseState: config.get(&quot;BaseState&quot;) instanceof _primitives.Name ? config.get(&quot;BaseState&quot;).name : null, on: parseOnOff(config.get(&quot;ON&quot;)), off: parseOnOff(config.get(&quot;OFF&quot;)), order: parseOrder(config.get(&quot;Order&quot;)), groups: null }; } setActualNumPages(num = null) { this._actualNumPages = num; } get hasActualNumPages() { return this._actualNumPages !== null; } get _pagesCount() { const obj = this.toplevelPagesDict.get(&quot;Count&quot;); if (!Number.isInteger(obj)) { throw new _util.FormatError(&quot;Page count in top-level pages dictionary is not an integer.&quot;); } return (0, _util.shadow)(this, &quot;_pagesCount&quot;, obj); } get numPages() { return this.hasActualNumPages ? this._actualNumPages : this._pagesCount; } get destinations() { const obj = this._readDests(), dests = Object.create(null); if (obj instanceof _name_number_tree.NameTree) { for (const [key, value] of obj.getAll()) { const dest = fetchDestination(value); if (dest) { dests[(0, _util.stringToPDFString)(key)] = dest; } } } else if (obj instanceof _primitives.Dict) { obj.forEach(function (key, value) { const dest = fetchDestination(value); if (dest) { dests[key] = dest; } }); } return (0, _util.shadow)(this, &quot;destinations&quot;, dests); } getDestination(id) { const obj = this._readDests(); if (obj instanceof _name_number_tree.NameTree) { const dest = fetchDestination(obj.get(id)); if (dest) { return dest; } const allDest = this.destinations[id]; if (allDest) { (0, _util.warn)(`Found &quot;${id}&quot; at an incorrect position in the NameTree.`); return allDest; } } else if (obj instanceof _primitives.Dict) { const dest = fetchDestination(obj.get(id)); if (dest) { return dest; } } return null; } _readDests() { const obj = this._catDict.get(&quot;Names&quot;); if (obj &amp;&amp; obj.has(&quot;Dests&quot;)) { return new _name_number_tree.NameTree(obj.getRaw(&quot;Dests&quot;), this.xref); } else if (this._catDict.has(&quot;Dests&quot;)) { return this._catDict.get(&quot;Dests&quot;); } return undefined; } get pageLabels() { let obj = null; try { obj = this._readPageLabels(); } catch (ex) { if (ex instanceof _core_utils.MissingDataException) { throw ex; } (0, _util.warn)(&quot;Unable to read page labels.&quot;); } return (0, _util.shadow)(this, &quot;pageLabels&quot;, obj); } _readPageLabels() { const obj = this._catDict.getRaw(&quot;PageLabels&quot;); if (!obj) { return null; } const pageLabels = new Array(this.numPages); let style = null, prefix = &quot;&quot;; const numberTree = new _name_number_tree.NumberTree(obj, this.xref); const nums = numberTree.getAll(); let currentLabel = &quot;&quot;, currentIndex = 1; for (let i = 0, ii = this.numPages; i &lt; ii; i++) { const labelDict = nums.get(i); if (labelDict !== undefined) { if (!(labelDict instanceof _primitives.Dict)) { throw new _util.FormatError(&quot;PageLabel is not a dictionary.&quot;); } if (labelDict.has(&quot;Type&quot;) &amp;&amp; !(0, _primitives.isName)(labelDict.get(&quot;Type&quot;), &quot;PageLabel&quot;)) { throw new _util.FormatError(&quot;Invalid type in PageLabel dictionary.&quot;); } if (labelDict.has(&quot;S&quot;)) { const s = labelDict.get(&quot;S&quot;); if (!(s instanceof _primitives.Name)) { throw new _util.FormatError(&quot;Invalid style in PageLabel dictionary.&quot;); } style = s.name; } else { style = null; } if (labelDict.has(&quot;P&quot;)) { const p = labelDict.get(&quot;P&quot;); if (typeof p !== &quot;string&quot;) { throw new _util.FormatError(&quot;Invalid prefix in PageLabel dictionary.&quot;); } prefix = (0, _util.stringToPDFString)(p); } else { prefix = &quot;&quot;; } if (labelDict.has(&quot;St&quot;)) { const st = labelDict.get(&quot;St&quot;); if (!(Number.isInteger(st) &amp;&amp; st &gt;= 1)) { throw new _util.FormatError(&quot;Invalid start in PageLabel dictionary.&quot;); } currentIndex = st; } else { currentIndex = 1; } } switch (style) { case &quot;D&quot;: currentLabel = currentIndex; break; case &quot;R&quot;: case &quot;r&quot;: currentLabel = (0, _core_utils.toRomanNumerals)(currentIndex, style === &quot;r&quot;); break; case &quot;A&quot;: case &quot;a&quot;: const LIMIT = 26; const A_UPPER_CASE = 0x41, A_LOWER_CASE = 0x61; const baseCharCode = style === &quot;a&quot; ? A_LOWER_CASE : A_UPPER_CASE; const letterIndex = currentIndex - 1; const character = String.fromCharCode(baseCharCode + letterIndex % LIMIT); currentLabel = character.repeat(Math.floor(letterIndex / LIMIT) + 1); break; default: if (style) { throw new _util.FormatError(`Invalid style &quot;${style}&quot; in PageLabel dictionary.`); } currentLabel = &quot;&quot;; } pageLabels[i] = prefix + currentLabel; currentIndex++; } return pageLabels; } get pageLayout() { const obj = this._catDict.get(&quot;PageLayout&quot;); let pageLayout = &quot;&quot;; if (obj instanceof _primitives.Name) { switch (obj.name) { case &quot;SinglePage&quot;: case &quot;OneColumn&quot;: case &quot;TwoColumnLeft&quot;: case &quot;TwoColumnRight&quot;: case &quot;TwoPageLeft&quot;: case &quot;TwoPageRight&quot;: pageLayout = obj.name; } } return (0, _util.shadow)(this, &quot;pageLayout&quot;, pageLayout); } get pageMode() { const obj = this._catDict.get(&quot;PageMode&quot;); let pageMode = &quot;UseNone&quot;; if (obj instanceof _primitives.Name) { switch (obj.name) { case &quot;UseNone&quot;: case &quot;UseOutlines&quot;: case &quot;UseThumbs&quot;: case &quot;FullScreen&quot;: case &quot;UseOC&quot;: case &quot;UseAttachments&quot;: pageMode = obj.name; } } return (0, _util.shadow)(this, &quot;pageMode&quot;, pageMode); } get viewerPreferences() { const obj = this._catDict.get(&quot;ViewerPreferences&quot;); if (!(obj instanceof _primitives.Dict)) { return (0, _util.shadow)(this, &quot;viewerPreferences&quot;, null); } let prefs = null; for (const key of obj.getKeys()) { const value = obj.get(key); let prefValue; switch (key) { case &quot;HideToolbar&quot;: case &quot;HideMenubar&quot;: case &quot;HideWindowUI&quot;: case &quot;FitWindow&quot;: case &quot;CenterWindow&quot;: case &quot;DisplayDocTitle&quot;: case &quot;PickTrayByPDFSize&quot;: if (typeof value === &quot;boolean&quot;) { prefValue = value; } break; case &quot;NonFullScreenPageMode&quot;: if (value instanceof _primitives.Name) { switch (value.name) { case &quot;UseNone&quot;: case &quot;UseOutlines&quot;: case &quot;UseThumbs&quot;: case &quot;UseOC&quot;: prefValue = value.name; break; default: prefValue = &quot;UseNone&quot;; } } break; case &quot;Direction&quot;: if (value instanceof _primitives.Name) { switch (value.name) { case &quot;L2R&quot;: case &quot;R2L&quot;: prefValue = value.name; break; default: prefValue = &quot;L2R&quot;; } } break; case &quot;ViewArea&quot;: case &quot;ViewClip&quot;: case &quot;PrintArea&quot;: case &quot;PrintClip&quot;: if (value instanceof _primitives.Name) { switch (value.name) { case &quot;MediaBox&quot;: case &quot;CropBox&quot;: case &quot;BleedBox&quot;: case &quot;TrimBox&quot;: case &quot;ArtBox&quot;: prefValue = value.name; break; default: prefValue = &quot;CropBox&quot;; } } break; case &quot;PrintScaling&quot;: if (value instanceof _primitives.Name) { switch (value.name) { case &quot;None&quot;: case &quot;AppDefault&quot;: prefValue = value.name; break; default: prefValue = &quot;AppDefault&quot;; } } break; case &quot;Duplex&quot;: if (value instanceof _primitives.Name) { switch (value.name) { case &quot;Simplex&quot;: case &quot;DuplexFlipShortEdge&quot;: case &quot;DuplexFlipLongEdge&quot;: prefValue = value.name; break; default: prefValue = &quot;None&quot;; } } break; case &quot;PrintPageRange&quot;: if (Array.isArray(value) &amp;&amp; value.length % 2 === 0) { const isValid = value.every((page, i, arr) =&gt; { return Number.isInteger(page) &amp;&amp; page &gt; 0 &amp;&amp; (i === 0 || page &gt;= arr[i - 1]) &amp;&amp; page &lt;= this.numPages; }); if (isValid) { prefValue = value; } } break; case &quot;NumCopies&quot;: if (Number.isInteger(value) &amp;&amp; value &gt; 0) { prefValue = value; } break; default: (0, _util.warn)(`Ignoring non-standard key in ViewerPreferences: ${key}.`); continue; } if (prefValue === undefined) { (0, _util.warn)(`Bad value, for key &quot;${key}&quot;, in ViewerPreferences: ${value}.`); continue; } if (!prefs) { prefs = Object.create(null); } prefs[key] = prefValue; } return (0, _util.shadow)(this, &quot;viewerPreferences&quot;, prefs); } get openAction() { const obj = this._catDict.get(&quot;OpenAction&quot;); const openAction = Object.create(null); if (obj instanceof _primitives.Dict) { const destDict = new _primitives.Dict(this.xref); destDict.set(&quot;A&quot;, obj); const resultObj = { url: null, dest: null, action: null }; Catalog.parseDestDictionary({ destDict, resultObj }); if (Array.isArray(resultObj.dest)) { openAction.dest = resultObj.dest; } else if (resultObj.action) { openAction.action = resultObj.action; } } else if (Array.isArray(obj)) { openAction.dest = obj; } return (0, _util.shadow)(this, &quot;openAction&quot;, (0, _util.objectSize)(openAction) &gt; 0 ? openAction : null); } get attachments() { const obj = this._catDict.get(&quot;Names&quot;); let attachments = null; if (obj instanceof _primitives.Dict &amp;&amp; obj.has(&quot;EmbeddedFiles&quot;)) { const nameTree = new _name_number_tree.NameTree(obj.getRaw(&quot;EmbeddedFiles&quot;), this.xref); for (const [key, value] of nameTree.getAll()) { const fs = new _file_spec.FileSpec(value, this.xref); if (!attachments) { attachments = Object.create(null); } attachments[(0, _util.stringToPDFString)(key)] = fs.serializable; } } return (0, _util.shadow)(this, &quot;attachments&quot;, attachments); } get xfaImages() { const obj = this._catDict.get(&quot;Names&quot;); let xfaImages = null; if (obj instanceof _primitives.Dict &amp;&amp; obj.has(&quot;XFAImages&quot;)) { const nameTree = new _name_number_tree.NameTree(obj.getRaw(&quot;XFAImages&quot;), this.xref); for (const [key, value] of nameTree.getAll()) { if (!xfaImages) { xfaImages = new _primitives.Dict(this.xref); } xfaImages.set((0, _util.stringToPDFString)(key), value); } } return (0, _util.shadow)(this, &quot;xfaImages&quot;, xfaImages); } _collectJavaScript() { const obj = this._catDict.get(&quot;Names&quot;); let javaScript = null; function appendIfJavaScriptDict(name, jsDict) { if (!(jsDict instanceof _primitives.Dict)) { return; } if (!(0, _primitives.isName)(jsDict.get(&quot;S&quot;), &quot;JavaScript&quot;)) { return; } let js = jsDict.get(&quot;JS&quot;); if (js instanceof _base_stream.BaseStream) { js = js.getString(); } else if (typeof js !== &quot;string&quot;) { return; } if (javaScript === null) { javaScript = new Map(); } js = (0, _util.stringToPDFString)(js).replace(/\\u0000/g, &quot;&quot;); javaScript.set(name, js); } if (obj instanceof _primitives.Dict &amp;&amp; obj.has(&quot;JavaScript&quot;)) { const nameTree = new _name_number_tree.NameTree(obj.getRaw(&quot;JavaScript&quot;), this.xref); for (const [key, value] of nameTree.getAll()) { appendIfJavaScriptDict((0, _util.stringToPDFString)(key), value); } } const openAction = this._catDict.get(&quot;OpenAction&quot;); if (openAction) { appendIfJavaScriptDict(&quot;OpenAction&quot;, openAction); } return javaScript; } get javaScript() { const javaScript = this._collectJavaScript(); return (0, _util.shadow)(this, &quot;javaScript&quot;, javaScript ? [...javaScript.values()] : null); } get jsActions() { const javaScript = this._collectJavaScript(); let actions = (0, _core_utils.collectActions)(this.xref, this._catDict, _util.DocumentActionEventType); if (javaScript) { if (!actions) { actions = Object.create(null); } for (const [key, val] of javaScript) { if (key in actions) { actions[key].push(val); } else { actions[key] = [val]; } } } return (0, _util.shadow)(this, &quot;jsActions&quot;, actions); } async fontFallback(id, handler) { const translatedFonts = await Promise.all(this.fontCache); for (const translatedFont of translatedFonts) { if (translatedFont.loadedName === id) { translatedFont.fallback(handler); return; } } } async cleanup(manuallyTriggered = false) { (0, _cleanup_helper.clearGlobalCaches)(); this.globalImageCache.clear(manuallyTriggered); this.pageKidsCountCache.clear(); this.pageIndexCache.clear(); this.nonBlendModesSet.clear(); const translatedFonts = await Promise.all(this.fontCache); for (const { dict } of translatedFonts) { delete dict.cacheKey; } this.fontCache.clear(); this.builtInCMapCache.clear(); this.standardFontDataCache.clear(); } async getPageDict(pageIndex) { const nodesToVisit = [this.toplevelPagesDict]; const visitedNodes = new _primitives.RefSet(); const pagesRef = this._catDict.getRaw(&quot;Pages&quot;); if (pagesRef instanceof _primitives.Ref) { visitedNodes.put(pagesRef); } const xref = this.xref, pageKidsCountCache = this.pageKidsCountCache, pageIndexCache = this.pageIndexCache; let currentPageIndex = 0; while (nodesToVisit.length) { const currentNode = nodesToVisit.pop(); if (currentNode instanceof _primitives.Ref) { const count = pageKidsCountCache.get(currentNode); if (count &gt;= 0 &amp;&amp; currentPageIndex + count &lt;= pageIndex) { currentPageIndex += count; continue; } if (visitedNodes.has(currentNode)) { throw new _util.FormatError(&quot;Pages tree contains circular reference.&quot;); } visitedNodes.put(currentNode); const obj = await xref.fetchAsync(currentNode); if (obj instanceof _primitives.Dict) { let type = obj.getRaw(&quot;Type&quot;); if (type instanceof _primitives.Ref) { type = await xref.fetchAsync(type); } if ((0, _primitives.isName)(type, &quot;Page&quot;) || !obj.has(&quot;Kids&quot;)) { if (!pageKidsCountCache.has(currentNode)) { pageKidsCountCache.put(currentNode, 1); } if (!pageIndexCache.has(currentNode)) { pageIndexCache.put(currentNode, currentPageIndex); } if (currentPageIndex === pageIndex) { return [obj, currentNode]; } currentPageIndex++; continue; } } nodesToVisit.push(obj); continue; } if (!(currentNode instanceof _primitives.Dict)) { throw new _util.FormatError(&quot;Page dictionary kid reference points to wrong type of object.&quot;); } const { objId } = currentNode; let count = currentNode.getRaw(&quot;Count&quot;); if (count instanceof _primitives.Ref) { count = await xref.fetchAsync(count); } if (Number.isInteger(count) &amp;&amp; count &gt;= 0) { if (objId &amp;&amp; !pageKidsCountCache.has(objId)) { pageKidsCountCache.put(objId, count); } if (currentPageIndex + count &lt;= pageIndex) { currentPageIndex += count; continue; } } let kids = currentNode.getRaw(&quot;Kids&quot;); if (kids instanceof _primitives.Ref) { kids = await xref.fetchAsync(kids); } if (!Array.isArray(kids)) { let type = currentNode.getRaw(&quot;Type&quot;); if (type instanceof _primitives.Ref) { type = await xref.fetchAsync(type); } if ((0, _primitives.isName)(type, &quot;Page&quot;) || !currentNode.has(&quot;Kids&quot;)) { if (currentPageIndex === pageIndex) { return [currentNode, null]; } currentPageIndex++; continue; } throw new _util.FormatError(&quot;Page dictionary kids object is not an array.&quot;); } for (let last = kids.length - 1; last &gt;= 0; last--) { nodesToVisit.push(kids[last]); } } throw new Error(`Page index ${pageIndex} not found.`); } async getAllPageDicts(recoveryMode = false) { const queue = [{ currentNode: this.toplevelPagesDict, posInKids: 0 }]; const visitedNodes = new _primitives.RefSet(); const pagesRef = this._catDict.getRaw(&quot;Pages&quot;); if (pagesRef instanceof _primitives.Ref) { visitedNodes.put(pagesRef); } const map = new Map(), xref = this.xref, pageIndexCache = this.pageIndexCache; let pageIndex = 0; function addPageDict(pageDict, pageRef) { if (pageRef &amp;&amp; !pageIndexCache.has(pageRef)) { pageIndexCache.put(pageRef, pageIndex); } map.set(pageIndex++, [pageDict, pageRef]); } function addPageError(error) { if (error instanceof _core_utils.XRefEntryException &amp;&amp; !recoveryMode) { throw error; } map.set(pageIndex++, [error, null]); } while (queue.length &gt; 0) { const queueItem = queue.at(-1); const { currentNode, posInKids } = queueItem; let kids = currentNode.getRaw(&quot;Kids&quot;); if (kids instanceof _primitives.Ref) { try { kids = await xref.fetchAsync(kids); } catch (ex) { addPageError(ex); break; } } if (!Array.isArray(kids)) { addPageError(new _util.FormatError(&quot;Page dictionary kids object is not an array.&quot;)); break; } if (posInKids &gt;= kids.length) { queue.pop(); continue; } const kidObj = kids[posInKids]; let obj; if (kidObj instanceof _primitives.Ref) { if (visitedNodes.has(kidObj)) { addPageError(new _util.FormatError(&quot;Pages tree contains circular reference.&quot;)); break; } visitedNodes.put(kidObj); try { obj = await xref.fetchAsync(kidObj); } catch (ex) { addPageError(ex); break; } } else { obj = kidObj; } if (!(obj instanceof _primitives.Dict)) { addPageError(new _util.FormatError(&quot;Page dictionary kid reference points to wrong type of object.&quot;)); break; } let type = obj.getRaw(&quot;Type&quot;); if (type instanceof _primitives.Ref) { try { type = await xref.fetchAsync(type); } catch (ex) { addPageError(ex); break; } } if ((0, _primitives.isName)(type, &quot;Page&quot;) || !obj.has(&quot;Kids&quot;)) { addPageDict(obj, kidObj instanceof _primitives.Ref ? kidObj : null); } else { queue.push({ currentNode: obj, posInKids: 0 }); } queueItem.posInKids++; } return map; } getPageIndex(pageRef) { const cachedPageIndex = this.pageIndexCache.get(pageRef); if (cachedPageIndex !== undefined) { return Promise.resolve(cachedPageIndex); } const xref = this.xref; function pagesBeforeRef(kidRef) { let total = 0, parentRef; return xref.fetchAsync(kidRef).then(function (node) { if ((0, _primitives.isRefsEqual)(kidRef, pageRef) &amp;&amp; !(0, _primitives.isDict)(node, &quot;Page&quot;) &amp;&amp; !(node instanceof _primitives.Dict &amp;&amp; !node.has(&quot;Type&quot;) &amp;&amp; node.has(&quot;Contents&quot;))) { throw new _util.FormatError(&quot;The reference does not point to a /Page dictionary.&quot;); } if (!node) { return null; } if (!(node instanceof _primitives.Dict)) { throw new _util.FormatError(&quot;Node must be a dictionary.&quot;); } parentRef = node.getRaw(&quot;Parent&quot;); return node.getAsync(&quot;Parent&quot;); }).then(function (parent) { if (!parent) { return null; } if (!(parent instanceof _primitives.Dict)) { throw new _util.FormatError(&quot;Parent must be a dictionary.&quot;); } return parent.getAsync(&quot;Kids&quot;); }).then(function (kids) { if (!kids) { return null; } const kidPromises = []; let found = false; for (const kid of kids) { if (!(kid instanceof _primitives.Ref)) { throw new _util.FormatError(&quot;Kid must be a reference.&quot;); } if ((0, _primitives.isRefsEqual)(kid, kidRef)) { found = true; break; } kidPromises.push(xref.fetchAsync(kid).then(function (obj) { if (!(obj instanceof _primitives.Dict)) { throw new _util.FormatError(&quot;Kid node must be a dictionary.&quot;); } if (obj.has(&quot;Count&quot;)) { total += obj.get(&quot;Count&quot;); } else { total++; } })); } if (!found) { throw new _util.FormatError(&quot;Kid reference not found in parent&apos;s kids.&quot;); } return Promise.all(kidPromises).then(function () { return [total, parentRef]; }); }); } let total = 0; const next = ref =&gt; pagesBeforeRef(ref).then(args =&gt; { if (!args) { this.pageIndexCache.put(pageRef, total); return total; } const [count, parentRef] = args; total += count; return next(parentRef); }); return next(pageRef); } get baseUrl() { const uri = this._catDict.get(&quot;URI&quot;); if (uri instanceof _primitives.Dict) { const base = uri.get(&quot;Base&quot;); if (typeof base === &quot;string&quot;) { const absoluteUrl = (0, _util.createValidAbsoluteUrl)(base, null, { tryConvertEncoding: true }); if (absoluteUrl) { return (0, _util.shadow)(this, &quot;baseUrl&quot;, absoluteUrl.href); } } } return (0, _util.shadow)(this, &quot;baseUrl&quot;, null); } static parseDestDictionary(params) { const destDict = params.destDict; if (!(destDict instanceof _primitives.Dict)) { (0, _util.warn)(&quot;parseDestDictionary: `destDict` must be a dictionary.&quot;); return; } const resultObj = params.resultObj; if (typeof resultObj !== &quot;object&quot;) { (0, _util.warn)(&quot;parseDestDictionary: `resultObj` must be an object.&quot;); return; } const docBaseUrl = params.docBaseUrl || null; const docAttachments = params.docAttachments || null; let action = destDict.get(&quot;A&quot;), url, dest; if (!(action instanceof _primitives.Dict)) { if (destDict.has(&quot;Dest&quot;)) { action = destDict.get(&quot;Dest&quot;); } else { action = destDict.get(&quot;AA&quot;); if (action instanceof _primitives.Dict) { if (action.has(&quot;D&quot;)) { action = action.get(&quot;D&quot;); } else if (action.has(&quot;U&quot;)) { action = action.get(&quot;U&quot;); } } } } if (action instanceof _primitives.Dict) { const actionType = action.get(&quot;S&quot;); if (!(actionType instanceof _primitives.Name)) { (0, _util.warn)(&quot;parseDestDictionary: Invalid type in Action dictionary.&quot;); return; } const actionName = actionType.name; switch (actionName) { case &quot;ResetForm&quot;: const flags = action.get(&quot;Flags&quot;); const include = ((typeof flags === &quot;number&quot; ? flags : 0) &amp; 1) === 0; const fields = []; const refs = []; for (const obj of action.get(&quot;Fields&quot;) || []) { if (obj instanceof _primitives.Ref) { refs.push(obj.toString()); } else if (typeof obj === &quot;string&quot;) { fields.push((0, _util.stringToPDFString)(obj)); } } resultObj.resetForm = { fields, refs, include }; break; case &quot;URI&quot;: url = action.get(&quot;URI&quot;); if (url instanceof _primitives.Name) { url = &quot;/&quot; + url.name; } break; case &quot;GoTo&quot;: dest = action.get(&quot;D&quot;); break; case &quot;Launch&quot;: case &quot;GoToR&quot;: const urlDict = action.get(&quot;F&quot;); if (urlDict instanceof _primitives.Dict) { url = urlDict.get(&quot;F&quot;) || null; } else if (typeof urlDict === &quot;string&quot;) { url = urlDict; } let remoteDest = action.get(&quot;D&quot;); if (remoteDest) { if (remoteDest instanceof _primitives.Name) { remoteDest = remoteDest.name; } if (typeof url === &quot;string&quot;) { const baseUrl = url.split(&quot;#&quot;)[0]; if (typeof remoteDest === &quot;string&quot;) { url = baseUrl + &quot;#&quot; + remoteDest; } else if (Array.isArray(remoteDest)) { url = baseUrl + &quot;#&quot; + JSON.stringify(remoteDest); } } } const newWindow = action.get(&quot;NewWindow&quot;); if (typeof newWindow === &quot;boolean&quot;) { resultObj.newWindow = newWindow; } break; case &quot;GoToE&quot;: const target = action.get(&quot;T&quot;); let attachment; if (docAttachments &amp;&amp; target instanceof _primitives.Dict) { const relationship = target.get(&quot;R&quot;); const name = target.get(&quot;N&quot;); if ((0, _primitives.isName)(relationship, &quot;C&quot;) &amp;&amp; typeof name === &quot;string&quot;) { attachment = docAttachments[(0, _util.stringToPDFString)(name)]; } } if (attachment) { resultObj.attachment = attachment; } else { (0, _util.warn)(`parseDestDictionary - unimplemented &quot;GoToE&quot; action.`); } break; case &quot;Named&quot;: const namedAction = action.get(&quot;N&quot;); if (namedAction instanceof _primitives.Name) { resultObj.action = namedAction.name; } break; case &quot;SetOCGState&quot;: const state = action.get(&quot;State&quot;); const preserveRB = action.get(&quot;PreserveRB&quot;); if (!Array.isArray(state) || state.length === 0) { break; } const stateArr = []; for (const elem of state) { if (elem instanceof _primitives.Name) { switch (elem.name) { case &quot;ON&quot;: case &quot;OFF&quot;: case &quot;Toggle&quot;: stateArr.push(elem.name); break; } } else if (elem instanceof _primitives.Ref) { stateArr.push(elem.toString()); } } if (stateArr.length !== state.length) { break; } resultObj.setOCGState = { state: stateArr, preserveRB: typeof preserveRB === &quot;boolean&quot; ? preserveRB : true }; break; case &quot;JavaScript&quot;: const jsAction = action.get(&quot;JS&quot;); let js; if (jsAction instanceof _base_stream.BaseStream) { js = jsAction.getString(); } else if (typeof jsAction === &quot;string&quot;) { js = jsAction; } const jsURL = js &amp;&amp; (0, _core_utils.recoverJsURL)((0, _util.stringToPDFString)(js)); if (jsURL) { url = jsURL.url; resultObj.newWindow = jsURL.newWindow; break; } default: if (actionName === &quot;JavaScript&quot; || actionName === &quot;SubmitForm&quot;) { break; } (0, _util.warn)(`parseDestDictionary - unsupported action: &quot;${actionName}&quot;.`); break; } } else if (destDict.has(&quot;Dest&quot;)) { dest = destDict.get(&quot;Dest&quot;); } if (typeof url === &quot;string&quot;) { const absoluteUrl = (0, _util.createValidAbsoluteUrl)(url, docBaseUrl, { addDefaultProtocol: true, tryConvertEncoding: true }); if (absoluteUrl) { resultObj.url = absoluteUrl.href; } resultObj.unsafeUrl = url; } if (dest) { if (dest instanceof _primitives.Name) { dest = dest.name; } if (typeof dest === &quot;string&quot;) { resultObj.dest = (0, _util.stringToPDFString)(dest); } else if (Array.isArray(dest)) { resultObj.dest = dest; } } } } exports.Catalog = Catalog; /***/ }), /* 68 */ /***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) =&gt; { Object.defineProperty(exports, &quot;__esModule&quot;, ({ value: true })); exports.NumberTree = exports.NameTree = void 0; var _primitives = __w_pdfjs_require__(3); var _util = __w_pdfjs_require__(2); class NameOrNumberTree { constructor(root, xref, type) { if (this.constructor === NameOrNumberTree) { (0, _util.unreachable)(&quot;Cannot initialize NameOrNumberTree.&quot;); } this.root = root; this.xref = xref; this._type = type; } getAll() { const map = new Map(); if (!this.root) { return map; } const xref = this.xref; const processed = new _primitives.RefSet(); processed.put(this.root); const queue = [this.root]; while (queue.length &gt; 0) { const obj = xref.fetchIfRef(queue.shift()); if (!(obj instanceof _primitives.Dict)) { continue; } if (obj.has(&quot;Kids&quot;)) { const kids = obj.get(&quot;Kids&quot;); if (!Array.isArray(kids)) { continue; } for (const kid of kids) { if (processed.has(kid)) { throw new _util.FormatError(`Duplicate entry in &quot;${this._type}&quot; tree.`); } queue.push(kid); processed.put(kid); } continue; } const entries = obj.get(this._type); if (!Array.isArray(entries)) { continue; } for (let i = 0, ii = entries.length; i &lt; ii; i += 2) { map.set(xref.fetchIfRef(entries[i]), xref.fetchIfRef(entries[i + 1])); } } return map; } get(key) { if (!this.root) { return null; } const xref = this.xref; let kidsOrEntries = xref.fetchIfRef(this.root); let loopCount = 0; const MAX_LEVELS = 10; while (kidsOrEntries.has(&quot;Kids&quot;)) { if (++loopCount &gt; MAX_LEVELS) { (0, _util.warn)(`Search depth limit reached for &quot;${this._type}&quot; tree.`); return null; } const kids = kidsOrEntries.get(&quot;Kids&quot;); if (!Array.isArray(kids)) { return null; } let l = 0, r = kids.length - 1; while (l &lt;= r) { const m = l + r &gt;&gt; 1; const kid = xref.fetchIfRef(kids[m]); const limits = kid.get(&quot;Limits&quot;); if (key &lt; xref.fetchIfRef(limits[0])) { r = m - 1; } else if (key &gt; xref.fetchIfRef(limits[1])) { l = m + 1; } else { kidsOrEntries = kid; break; } } if (l &gt; r) { return null; } } const entries = kidsOrEntries.get(this._type); if (Array.isArray(entries)) { let l = 0, r = entries.length - 2; while (l &lt;= r) { const tmp = l + r &gt;&gt; 1, m = tmp + (tmp &amp; 1); const currentKey = xref.fetchIfRef(entries[m]); if (key &lt; currentKey) { r = m - 2; } else if (key &gt; currentKey) { l = m + 2; } else { return xref.fetchIfRef(entries[m + 1]); } } } return null; } } class NameTree extends NameOrNumberTree { constructor(root, xref) { super(root, xref, &quot;Names&quot;); } } exports.NameTree = NameTree; class NumberTree extends NameOrNumberTree { constructor(root, xref) { super(root, xref, &quot;Nums&quot;); } } exports.NumberTree = NumberTree; /***/ }), /* 69 */ /***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) =&gt; { Object.defineProperty(exports, &quot;__esModule&quot;, ({ value: true })); exports.clearGlobalCaches = clearGlobalCaches; var _primitives = __w_pdfjs_require__(3); var _unicode = __w_pdfjs_require__(38); function clearGlobalCaches() { (0, _primitives.clearPrimitiveCaches)(); (0, _unicode.clearUnicodeCaches)(); } /***/ }), /* 70 */ /***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) =&gt; { Object.defineProperty(exports, &quot;__esModule&quot;, ({ value: true })); exports.FileSpec = void 0; var _util = __w_pdfjs_require__(2); var _base_stream = __w_pdfjs_require__(5); var _primitives = __w_pdfjs_require__(3); function pickPlatformItem(dict) { if (dict.has(&quot;UF&quot;)) { return dict.get(&quot;UF&quot;); } else if (dict.has(&quot;F&quot;)) { return dict.get(&quot;F&quot;); } else if (dict.has(&quot;Unix&quot;)) { return dict.get(&quot;Unix&quot;); } else if (dict.has(&quot;Mac&quot;)) { return dict.get(&quot;Mac&quot;); } else if (dict.has(&quot;DOS&quot;)) { return dict.get(&quot;DOS&quot;); } return null; } class FileSpec { constructor(root, xref) { if (!(root instanceof _primitives.Dict)) { return; } this.xref = xref; this.root = root; if (root.has(&quot;FS&quot;)) { this.fs = root.get(&quot;FS&quot;); } this.description = root.has(&quot;Desc&quot;) ? (0, _util.stringToPDFString)(root.get(&quot;Desc&quot;)) : &quot;&quot;; if (root.has(&quot;RF&quot;)) { (0, _util.warn)(&quot;Related file specifications are not supported&quot;); } this.contentAvailable = true; if (!root.has(&quot;EF&quot;)) { this.contentAvailable = false; (0, _util.warn)(&quot;Non-embedded file specifications are not supported&quot;); } } get filename() { if (!this._filename &amp;&amp; this.root) { const filename = pickPlatformItem(this.root) || &quot;unnamed&quot;; this._filename = (0, _util.stringToPDFString)(filename).replace(/\\\\\\\\/g, &quot;\\\\&quot;).replace(/\\\\\\//g, &quot;/&quot;).replace(/\\\\/g, &quot;/&quot;); } return this._filename; } get content() { if (!this.contentAvailable) { return null; } if (!this.contentRef &amp;&amp; this.root) { this.contentRef = pickPlatformItem(this.root.get(&quot;EF&quot;)); } let content = null; if (this.contentRef) { const fileObj = this.xref.fetchIfRef(this.contentRef); if (fileObj instanceof _base_stream.BaseStream) { content = fileObj.getBytes(); } else { (0, _util.warn)(&quot;Embedded file specification points to non-existing/invalid content&quot;); } } else { (0, _util.warn)(&quot;Embedded file specification does not have a content&quot;); } return content; } get serializable() { return { filename: this.filename, content: this.content }; } } exports.FileSpec = FileSpec; /***/ }), /* 71 */ /***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) =&gt; { Object.defineProperty(exports, &quot;__esModule&quot;, ({ value: true })); exports.MetadataParser = void 0; var _xml_parser = __w_pdfjs_require__(64); class MetadataParser { constructor(data) { data = this._repair(data); const parser = new _xml_parser.SimpleXMLParser({ lowerCaseName: true }); const xmlDocument = parser.parseFromString(data); this._metadataMap = new Map(); this._data = data; if (xmlDocument) { this._parse(xmlDocument); } } _repair(data) { return data.replace(/^[^&lt;]+/, &quot;&quot;).replace(/&gt;\\\\376\\\\377([^&lt;]+)/g, function (all, codes) { const bytes = codes.replace(/\\\\([0-3])([0-7])([0-7])/g, function (code, d1, d2, d3) { return String.fromCharCode(d1 * 64 + d2 * 8 + d3 * 1); }).replace(/&amp;(amp|apos|gt|lt|quot);/g, function (str, name) { switch (name) { case &quot;amp&quot;: return &quot;&amp;&quot;; case &quot;apos&quot;: return &quot;&apos;&quot;; case &quot;gt&quot;: return &quot;&gt;&quot;; case &quot;lt&quot;: return &quot;&lt;&quot;; case &quot;quot&quot;: return &apos;&quot;&apos;; } throw new Error(`_repair: ${name} isn&apos;t defined.`); }); const charBuf = []; for (let i = 0, ii = bytes.length; i &lt; ii; i += 2) { const code = bytes.charCodeAt(i) * 256 + bytes.charCodeAt(i + 1); if (code &gt;= 32 &amp;&amp; code &lt; 127 &amp;&amp; code !== 60 &amp;&amp; code !== 62 &amp;&amp; code !== 38) { charBuf.push(String.fromCharCode(code)); } else { charBuf.push(&quot;&amp;#x&quot; + (0x10000 + code).toString(16).substring(1) + &quot;;&quot;); } } return &quot;&gt;&quot; + charBuf.join(&quot;&quot;); }); } _getSequence(entry) { const name = entry.nodeName; if (name !== &quot;rdf:bag&quot; &amp;&amp; name !== &quot;rdf:seq&quot; &amp;&amp; name !== &quot;rdf:alt&quot;) { return null; } return entry.childNodes.filter(node =&gt; node.nodeName === &quot;rdf:li&quot;); } _parseArray(entry) { if (!entry.hasChildNodes()) { return; } const [seqNode] = entry.childNodes; const sequence = this._getSequence(seqNode) || []; this._metadataMap.set(entry.nodeName, sequence.map(node =&gt; node.textContent.trim())); } _parse(xmlDocument) { let rdf = xmlDocument.documentElement; if (rdf.nodeName !== &quot;rdf:rdf&quot;) { rdf = rdf.firstChild; while (rdf &amp;&amp; rdf.nodeName !== &quot;rdf:rdf&quot;) { rdf = rdf.nextSibling; } } if (!rdf || rdf.nodeName !== &quot;rdf:rdf&quot; || !rdf.hasChildNodes()) { return; } for (const desc of rdf.childNodes) { if (desc.nodeName !== &quot;rdf:description&quot;) { continue; } for (const entry of desc.childNodes) { const name = entry.nodeName; switch (name) { case &quot;#text&quot;: continue; case &quot;dc:creator&quot;: case &quot;dc:subject&quot;: this._parseArray(entry); continue; } this._metadataMap.set(name, entry.textContent.trim()); } } } get serializable() { return { parsedData: this._metadataMap, rawData: this._data }; } } exports.MetadataParser = MetadataParser; /***/ }), /* 72 */ /***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) =&gt; { Object.defineProperty(exports, &quot;__esModule&quot;, ({ value: true })); exports.StructTreeRoot = exports.StructTreePage = void 0; var _primitives = __w_pdfjs_require__(3); var _util = __w_pdfjs_require__(2); var _name_number_tree = __w_pdfjs_require__(68); const MAX_DEPTH = 40; const StructElementType = { PAGE_CONTENT: &quot;PAGE_CONTENT&quot;, STREAM_CONTENT: &quot;STREAM_CONTENT&quot;, OBJECT: &quot;OBJECT&quot;, ELEMENT: &quot;ELEMENT&quot; }; class StructTreeRoot { constructor(rootDict) { this.dict = rootDict; this.roleMap = new Map(); } init() { this.readRoleMap(); } readRoleMap() { const roleMapDict = this.dict.get(&quot;RoleMap&quot;); if (!(roleMapDict instanceof _primitives.Dict)) { return; } roleMapDict.forEach((key, value) =&gt; { if (!(value instanceof _primitives.Name)) { return; } this.roleMap.set(key, value.name); }); } } exports.StructTreeRoot = StructTreeRoot; class StructElementNode { constructor(tree, dict) { this.tree = tree; this.dict = dict; this.kids = []; this.parseKids(); } get role() { const nameObj = this.dict.get(&quot;S&quot;); const name = nameObj instanceof _primitives.Name ? nameObj.name : &quot;&quot;; const { root } = this.tree; if (root.roleMap.has(name)) { return root.roleMap.get(name); } return name; } parseKids() { let pageObjId = null; const objRef = this.dict.getRaw(&quot;Pg&quot;); if (objRef instanceof _primitives.Ref) { pageObjId = objRef.toString(); } const kids = this.dict.get(&quot;K&quot;); if (Array.isArray(kids)) { for (const kid of kids) { const element = this.parseKid(pageObjId, kid); if (element) { this.kids.push(element); } } } else { const element = this.parseKid(pageObjId, kids); if (element) { this.kids.push(element); } } } parseKid(pageObjId, kid) { if (Number.isInteger(kid)) { if (this.tree.pageDict.objId !== pageObjId) { return null; } return new StructElement({ type: StructElementType.PAGE_CONTENT, mcid: kid, pageObjId }); } let kidDict = null; if (kid instanceof _primitives.Ref) { kidDict = this.dict.xref.fetch(kid); } else if (kid instanceof _primitives.Dict) { kidDict = kid; } if (!kidDict) { return null; } const pageRef = kidDict.getRaw(&quot;Pg&quot;); if (pageRef instanceof _primitives.Ref) { pageObjId = pageRef.toString(); } const type = kidDict.get(&quot;Type&quot;) instanceof _primitives.Name ? kidDict.get(&quot;Type&quot;).name : null; if (type === &quot;MCR&quot;) { if (this.tree.pageDict.objId !== pageObjId) { return null; } return new StructElement({ type: StructElementType.STREAM_CONTENT, refObjId: kidDict.getRaw(&quot;Stm&quot;) instanceof _primitives.Ref ? kidDict.getRaw(&quot;Stm&quot;).toString() : null, pageObjId, mcid: kidDict.get(&quot;MCID&quot;) }); } if (type === &quot;OBJR&quot;) { if (this.tree.pageDict.objId !== pageObjId) { return null; } return new StructElement({ type: StructElementType.OBJECT, refObjId: kidDict.getRaw(&quot;Obj&quot;) instanceof _primitives.Ref ? kidDict.getRaw(&quot;Obj&quot;).toString() : null, pageObjId }); } return new StructElement({ type: StructElementType.ELEMENT, dict: kidDict }); } } class StructElement { constructor({ type, dict = null, mcid = null, pageObjId = null, refObjId = null }) { this.type = type; this.dict = dict; this.mcid = mcid; this.pageObjId = pageObjId; this.refObjId = refObjId; this.parentNode = null; } } class StructTreePage { constructor(structTreeRoot, pageDict) { this.root = structTreeRoot; this.rootDict = structTreeRoot ? structTreeRoot.dict : null; this.pageDict = pageDict; this.nodes = []; } parse() { if (!this.root || !this.rootDict) { return; } const parentTree = this.rootDict.get(&quot;ParentTree&quot;); if (!parentTree) { return; } const id = this.pageDict.get(&quot;StructParents&quot;); if (!Number.isInteger(id)) { return; } const numberTree = new _name_number_tree.NumberTree(parentTree, this.rootDict.xref); const parentArray = numberTree.get(id); if (!Array.isArray(parentArray)) { return; } const map = new Map(); for (const ref of parentArray) { if (ref instanceof _primitives.Ref) { this.addNode(this.rootDict.xref.fetch(ref), map); } } } addNode(dict, map, level = 0) { if (level &gt; MAX_DEPTH) { (0, _util.warn)(&quot;StructTree MAX_DEPTH reached.&quot;); return null; } if (map.has(dict)) { return map.get(dict); } const element = new StructElementNode(this, dict); map.set(dict, element); const parent = dict.get(&quot;P&quot;); if (!parent || (0, _primitives.isName)(parent.get(&quot;Type&quot;), &quot;StructTreeRoot&quot;)) { if (!this.addTopLevelNode(dict, element)) { map.delete(dict); } return element; } const parentNode = this.addNode(parent, map, level + 1); if (!parentNode) { return element; } let save = false; for (const kid of parentNode.kids) { if (kid.type === StructElementType.ELEMENT &amp;&amp; kid.dict === dict) { kid.parentNode = element; save = true; } } if (!save) { map.delete(dict); } return element; } addTopLevelNode(dict, element) { const obj = this.rootDict.get(&quot;K&quot;); if (!obj) { return false; } if (obj instanceof _primitives.Dict) { if (obj.objId !== dict.objId) { return false; } this.nodes[0] = element; return true; } if (!Array.isArray(obj)) { return true; } let save = false; for (let i = 0; i &lt; obj.length; i++) { const kidRef = obj[i]; if (kidRef &amp;&amp; kidRef.toString() === dict.objId) { this.nodes[i] = element; save = true; } } return save; } get serializable() { function nodeToSerializable(node, parent, level = 0) { if (level &gt; MAX_DEPTH) { (0, _util.warn)(&quot;StructTree too deep to be fully serialized.&quot;); return; } const obj = Object.create(null); obj.role = node.role; obj.children = []; parent.children.push(obj); const alt = node.dict.get(&quot;Alt&quot;); if (typeof alt === &quot;string&quot;) { obj.alt = (0, _util.stringToPDFString)(alt); } const lang = node.dict.get(&quot;Lang&quot;); if (typeof lang === &quot;string&quot;) { obj.lang = (0, _util.stringToPDFString)(lang); } for (const kid of node.kids) { const kidElement = kid.type === StructElementType.ELEMENT ? kid.parentNode : null; if (kidElement) { nodeToSerializable(kidElement, obj, level + 1); continue; } else if (kid.type === StructElementType.PAGE_CONTENT || kid.type === StructElementType.STREAM_CONTENT) { obj.children.push({ type: &quot;content&quot;, id: `page${kid.pageObjId}_mcid${kid.mcid}` }); } else if (kid.type === StructElementType.OBJECT) { obj.children.push({ type: &quot;object&quot;, id: kid.refObjId }); } } } const root = Object.create(null); root.children = []; root.role = &quot;Root&quot;; for (const child of this.nodes) { if (!child) { continue; } nodeToSerializable(child, root); } return root; } } exports.StructTreePage = StructTreePage; /***/ }), /* 73 */ /***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) =&gt; { Object.defineProperty(exports, &quot;__esModule&quot;, ({ value: true })); exports.ObjectLoader = void 0; var _primitives = __w_pdfjs_require__(3); var _base_stream = __w_pdfjs_require__(5); var _core_utils = __w_pdfjs_require__(4); var _util = __w_pdfjs_require__(2); function mayHaveChildren(value) { return value instanceof _primitives.Ref || value instanceof _primitives.Dict || value instanceof _base_stream.BaseStream || Array.isArray(value); } function addChildren(node, nodesToVisit) { if (node instanceof _primitives.Dict) { node = node.getRawValues(); } else if (node instanceof _base_stream.BaseStream) { node = node.dict.getRawValues(); } else if (!Array.isArray(node)) { return; } for (const rawValue of node) { if (mayHaveChildren(rawValue)) { nodesToVisit.push(rawValue); } } } class ObjectLoader { constructor(dict, keys, xref) { this.dict = dict; this.keys = keys; this.xref = xref; this.refSet = null; } async load() { if (this.xref.stream.isDataLoaded) { return undefined; } const { keys, dict } = this; this.refSet = new _primitives.RefSet(); const nodesToVisit = []; for (const key of keys) { const rawValue = dict.getRaw(key); if (rawValue !== undefined) { nodesToVisit.push(rawValue); } } return this._walk(nodesToVisit); } async _walk(nodesToVisit) { const nodesToRevisit = []; const pendingRequests = []; while (nodesToVisit.length) { let currentNode = nodesToVisit.pop(); if (currentNode instanceof _primitives.Ref) { if (this.refSet.has(currentNode)) { continue; } try { this.refSet.put(currentNode); currentNode = this.xref.fetch(currentNode); } catch (ex) { if (!(ex instanceof _core_utils.MissingDataException)) { (0, _util.warn)(`ObjectLoader._walk - requesting all data: &quot;${ex}&quot;.`); this.refSet = null; const { manager } = this.xref.stream; return manager.requestAllChunks(); } nodesToRevisit.push(currentNode); pendingRequests.push({ begin: ex.begin, end: ex.end }); } } if (currentNode instanceof _base_stream.BaseStream) { const baseStreams = currentNode.getBaseStreams(); if (baseStreams) { let foundMissingData = false; for (const stream of baseStreams) { if (stream.isDataLoaded) { continue; } foundMissingData = true; pendingRequests.push({ begin: stream.start, end: stream.end }); } if (foundMissingData) { nodesToRevisit.push(currentNode); } } } addChildren(currentNode, nodesToVisit); } if (pendingRequests.length) { await this.xref.stream.manager.requestRanges(pendingRequests); for (const node of nodesToRevisit) { if (node instanceof _primitives.Ref) { this.refSet.remove(node); } } return this._walk(nodesToRevisit); } this.refSet = null; return undefined; } } exports.ObjectLoader = ObjectLoader; /***/ }), /* 74 */ /***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) =&gt; { Object.defineProperty(exports, &quot;__esModule&quot;, ({ value: true })); exports.XFAFactory = void 0; var _xfa_object = __w_pdfjs_require__(75); var _bind = __w_pdfjs_require__(79); var _data = __w_pdfjs_require__(85); var _fonts = __w_pdfjs_require__(83); var _utils = __w_pdfjs_require__(76); var _util = __w_pdfjs_require__(2); var _parser = __w_pdfjs_require__(86); var _xhtml = __w_pdfjs_require__(96); class XFAFactory { constructor(data) { try { this.root = new _parser.XFAParser().parse(XFAFactory._createDocument(data)); const binder = new _bind.Binder(this.root); this.form = binder.bind(); this.dataHandler = new _data.DataHandler(this.root, binder.getData()); this.form[_xfa_object.$globalData].template = this.form; } catch (e) { (0, _util.warn)(`XFA - an error occurred during parsing and binding: ${e}`); } } isValid() { return this.root &amp;&amp; this.form; } _createPagesHelper() { const iterator = this.form[_xfa_object.$toPages](); return new Promise((resolve, reject) =&gt; { const nextIteration = () =&gt; { try { const value = iterator.next(); if (value.done) { resolve(value.value); } else { setTimeout(nextIteration, 0); } } catch (e) { reject(e); } }; setTimeout(nextIteration, 0); }); } async _createPages() { try { this.pages = await this._createPagesHelper(); this.dims = this.pages.children.map(c =&gt; { const { width, height } = c.attributes.style; return [0, 0, parseInt(width), parseInt(height)]; }); } catch (e) { (0, _util.warn)(`XFA - an error occurred during layout: ${e}`); } } getBoundingBox(pageIndex) { return this.dims[pageIndex]; } async getNumPages() { if (!this.pages) { await this._createPages(); } return this.dims.length; } setImages(images) { this.form[_xfa_object.$globalData].images = images; } setFonts(fonts) { this.form[_xfa_object.$globalData].fontFinder = new _fonts.FontFinder(fonts); const missingFonts = []; for (let typeface of this.form[_xfa_object.$globalData].usedTypefaces) { typeface = (0, _utils.stripQuotes)(typeface); const font = this.form[_xfa_object.$globalData].fontFinder.find(typeface); if (!font) { missingFonts.push(typeface); } } if (missingFonts.length &gt; 0) { return missingFonts; } return null; } appendFonts(fonts, reallyMissingFonts) { this.form[_xfa_object.$globalData].fontFinder.add(fonts, reallyMissingFonts); } async getPages() { if (!this.pages) { await this._createPages(); } const pages = this.pages; this.pages = null; return pages; } serializeData(storage) { return this.dataHandler.serialize(storage); } static _createDocument(data) { if (!data[&quot;/xdp:xdp&quot;]) { return data[&quot;xdp:xdp&quot;]; } return Object.values(data).join(&quot;&quot;); } static getRichTextAsHtml(rc) { if (!rc || typeof rc !== &quot;string&quot;) { return null; } try { let root = new _parser.XFAParser(_xhtml.XhtmlNamespace, true).parse(rc); if (![&quot;body&quot;, &quot;xhtml&quot;].includes(root[_xfa_object.$nodeName])) { const newRoot = _xhtml.XhtmlNamespace.body({}); newRoot[_xfa_object.$appendChild](root); root = newRoot; } const result = root[_xfa_object.$toHTML](); if (!result.success) { return null; } const { html } = result; const { attributes } = html; if (attributes) { if (attributes.class) { attributes.class = attributes.class.filter(attr =&gt; !attr.startsWith(&quot;xfa&quot;)); } attributes.dir = &quot;auto&quot;; } return { html, str: root[_xfa_object.$text]() }; } catch (e) { (0, _util.warn)(`XFA - an error occurred during parsing of rich text: ${e}`); } return null; } } exports.XFAFactory = XFAFactory; /***/ }), /* 75 */ /***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) =&gt; { Object.defineProperty(exports, &quot;__esModule&quot;, ({ value: true })); exports.XmlObject = exports.XFAObjectArray = exports.XFAObject = exports.XFAAttribute = exports.StringObject = exports.OptionObject = exports.Option10 = exports.Option01 = exports.IntegerObject = exports.ContentObject = exports.$uid = exports.$toStyle = exports.$toString = exports.$toPages = exports.$toHTML = exports.$text = exports.$tabIndex = exports.$setValue = exports.$setSetAttributes = exports.$setId = exports.$searchNode = exports.$root = exports.$resolvePrototypes = exports.$removeChild = exports.$pushPara = exports.$pushGlyphs = exports.$popPara = exports.$onText = exports.$onChildCheck = exports.$onChild = exports.$nsAttributes = exports.$nodeName = exports.$namespaceId = exports.$isUsable = exports.$isTransparent = exports.$isThereMoreWidth = exports.$isSplittable = exports.$isNsAgnostic = exports.$isDescendent = exports.$isDataValue = exports.$isCDATAXml = exports.$isBindable = exports.$insertAt = exports.$indexOf = exports.$ids = exports.$hasSettableValue = exports.$globalData = exports.$getTemplateRoot = exports.$getSubformParent = exports.$getRealChildrenByNameIt = exports.$getParent = exports.$getNextPage = exports.$getExtra = exports.$getDataValue = exports.$getContainedChildren = exports.$getChildrenByNameIt = exports.$getChildrenByName = exports.$getChildrenByClass = exports.$getChildren = exports.$getAvailableSpace = exports.$getAttributes = exports.$getAttributeIt = exports.$flushHTML = exports.$finalize = exports.$extra = exports.$dump = exports.$data = exports.$content = exports.$consumed = exports.$clone = exports.$cleanup = exports.$cleanPage = exports.$clean = exports.$childrenToHTML = exports.$appendChild = exports.$addHTML = exports.$acceptWhitespace = void 0; var _utils = __w_pdfjs_require__(76); var _util = __w_pdfjs_require__(2); var _core_utils = __w_pdfjs_require__(4); var _namespaces = __w_pdfjs_require__(77); var _som = __w_pdfjs_require__(78); const $acceptWhitespace = Symbol(); exports.$acceptWhitespace = $acceptWhitespace; const $addHTML = Symbol(); exports.$addHTML = $addHTML; const $appendChild = Symbol(); exports.$appendChild = $appendChild; const $childrenToHTML = Symbol(); exports.$childrenToHTML = $childrenToHTML; const $clean = Symbol(); exports.$clean = $clean; const $cleanPage = Symbol(); exports.$cleanPage = $cleanPage; const $cleanup = Symbol(); exports.$cleanup = $cleanup; const $clone = Symbol(); exports.$clone = $clone; const $consumed = Symbol(); exports.$consumed = $consumed; const $content = Symbol(&quot;content&quot;); exports.$content = $content; const $data = Symbol(&quot;data&quot;); exports.$data = $data; const $dump = Symbol(); exports.$dump = $dump; const $extra = Symbol(&quot;extra&quot;); exports.$extra = $extra; const $finalize = Symbol(); exports.$finalize = $finalize; const $flushHTML = Symbol(); exports.$flushHTML = $flushHTML; const $getAttributeIt = Symbol(); exports.$getAttributeIt = $getAttributeIt; const $getAttributes = Symbol(); exports.$getAttributes = $getAttributes; const $getAvailableSpace = Symbol(); exports.$getAvailableSpace = $getAvailableSpace; const $getChildrenByClass = Symbol(); exports.$getChildrenByClass = $getChildrenByClass; const $getChildrenByName = Symbol(); exports.$getChildrenByName = $getChildrenByName; const $getChildrenByNameIt = Symbol(); exports.$getChildrenByNameIt = $getChildrenByNameIt; const $getDataValue = Symbol(); exports.$getDataValue = $getDataValue; const $getExtra = Symbol(); exports.$getExtra = $getExtra; const $getRealChildrenByNameIt = Symbol(); exports.$getRealChildrenByNameIt = $getRealChildrenByNameIt; const $getChildren = Symbol(); exports.$getChildren = $getChildren; const $getContainedChildren = Symbol(); exports.$getContainedChildren = $getContainedChildren; const $getNextPage = Symbol(); exports.$getNextPage = $getNextPage; const $getSubformParent = Symbol(); exports.$getSubformParent = $getSubformParent; const $getParent = Symbol(); exports.$getParent = $getParent; const $getTemplateRoot = Symbol(); exports.$getTemplateRoot = $getTemplateRoot; const $globalData = Symbol(); exports.$globalData = $globalData; const $hasSettableValue = Symbol(); exports.$hasSettableValue = $hasSettableValue; const $ids = Symbol(); exports.$ids = $ids; const $indexOf = Symbol(); exports.$indexOf = $indexOf; const $insertAt = Symbol(); exports.$insertAt = $insertAt; const $isCDATAXml = Symbol(); exports.$isCDATAXml = $isCDATAXml; const $isBindable = Symbol(); exports.$isBindable = $isBindable; const $isDataValue = Symbol(); exports.$isDataValue = $isDataValue; const $isDescendent = Symbol(); exports.$isDescendent = $isDescendent; const $isNsAgnostic = Symbol(); exports.$isNsAgnostic = $isNsAgnostic; const $isSplittable = Symbol(); exports.$isSplittable = $isSplittable; const $isThereMoreWidth = Symbol(); exports.$isThereMoreWidth = $isThereMoreWidth; const $isTransparent = Symbol(); exports.$isTransparent = $isTransparent; const $isUsable = Symbol(); exports.$isUsable = $isUsable; const $lastAttribute = Symbol(); const $namespaceId = Symbol(&quot;namespaceId&quot;); exports.$namespaceId = $namespaceId; const $nodeName = Symbol(&quot;nodeName&quot;); exports.$nodeName = $nodeName; const $nsAttributes = Symbol(); exports.$nsAttributes = $nsAttributes; const $onChild = Symbol(); exports.$onChild = $onChild; const $onChildCheck = Symbol(); exports.$onChildCheck = $onChildCheck; const $onText = Symbol(); exports.$onText = $onText; const $pushGlyphs = Symbol(); exports.$pushGlyphs = $pushGlyphs; const $popPara = Symbol(); exports.$popPara = $popPara; const $pushPara = Symbol(); exports.$pushPara = $pushPara; const $removeChild = Symbol(); exports.$removeChild = $removeChild; const $root = Symbol(&quot;root&quot;); exports.$root = $root; const $resolvePrototypes = Symbol(); exports.$resolvePrototypes = $resolvePrototypes; const $searchNode = Symbol(); exports.$searchNode = $searchNode; const $setId = Symbol(); exports.$setId = $setId; const $setSetAttributes = Symbol(); exports.$setSetAttributes = $setSetAttributes; const $setValue = Symbol(); exports.$setValue = $setValue; const $tabIndex = Symbol(); exports.$tabIndex = $tabIndex; const $text = Symbol(); exports.$text = $text; const $toPages = Symbol(); exports.$toPages = $toPages; const $toHTML = Symbol(); exports.$toHTML = $toHTML; const $toString = Symbol(); exports.$toString = $toString; const $toStyle = Symbol(); exports.$toStyle = $toStyle; const $uid = Symbol(&quot;uid&quot;); exports.$uid = $uid; const _applyPrototype = Symbol(); const _attributes = Symbol(); const _attributeNames = Symbol(); const _children = Symbol(&quot;_children&quot;); const _cloneAttribute = Symbol(); const _dataValue = Symbol(); const _defaultValue = Symbol(); const _filteredChildrenGenerator = Symbol(); const _getPrototype = Symbol(); const _getUnsetAttributes = Symbol(); const _hasChildren = Symbol(); const _max = Symbol(); const _options = Symbol(); const _parent = Symbol(&quot;parent&quot;); const _resolvePrototypesHelper = Symbol(); const _setAttributes = Symbol(); const _validator = Symbol(); let uid = 0; const NS_DATASETS = _namespaces.NamespaceIds.datasets.id; class XFAObject { constructor(nsId, name, hasChildren = false) { this[$namespaceId] = nsId; this[$nodeName] = name; this[_hasChildren] = hasChildren; this[_parent] = null; this[_children] = []; this[$uid] = `${name}${uid++}`; this[$globalData] = null; } [$onChild](child) { if (!this[_hasChildren] || !this[$onChildCheck](child)) { return false; } const name = child[$nodeName]; const node = this[name]; if (node instanceof XFAObjectArray) { if (node.push(child)) { this[$appendChild](child); return true; } } else { if (node !== null) { this[$removeChild](node); } this[name] = child; this[$appendChild](child); return true; } let id = &quot;&quot;; if (this.id) { id = ` (id: ${this.id})`; } else if (this.name) { id = ` (name: ${this.name} ${this.h.value})`; } (0, _util.warn)(`XFA - node &quot;${this[$nodeName]}&quot;${id} has already enough &quot;${name}&quot;!`); return false; } [$onChildCheck](child) { return this.hasOwnProperty(child[$nodeName]) &amp;&amp; child[$namespaceId] === this[$namespaceId]; } [$isNsAgnostic]() { return false; } [$acceptWhitespace]() { return false; } [$isCDATAXml]() { return false; } [$isBindable]() { return false; } [$popPara]() { if (this.para) { this[$getTemplateRoot]()[$extra].paraStack.pop(); } } [$pushPara]() { this[$getTemplateRoot]()[$extra].paraStack.push(this.para); } [$setId](ids) { if (this.id &amp;&amp; this[$namespaceId] === _namespaces.NamespaceIds.template.id) { ids.set(this.id, this); } } [$getTemplateRoot]() { return this[$globalData].template; } [$isSplittable]() { return false; } [$isThereMoreWidth]() { return false; } [$appendChild](child) { child[_parent] = this; this[_children].push(child); if (!child[$globalData] &amp;&amp; this[$globalData]) { child[$globalData] = this[$globalData]; } } [$removeChild](child) { const i = this[_children].indexOf(child); this[_children].splice(i, 1); } [$hasSettableValue]() { return this.hasOwnProperty(&quot;value&quot;); } [$setValue](_) {} [$onText](_) {} [$finalize]() {} [$clean](builder) { delete this[_hasChildren]; if (this[$cleanup]) { builder.clean(this[$cleanup]); delete this[$cleanup]; } } [$indexOf](child) { return this[_children].indexOf(child); } [$insertAt](i, child) { child[_parent] = this; this[_children].splice(i, 0, child); if (!child[$globalData] &amp;&amp; this[$globalData]) { child[$globalData] = this[$globalData]; } } [$isTransparent]() { return !this.name; } [$lastAttribute]() { return &quot;&quot;; } [$text]() { if (this[_children].length === 0) { return this[$content]; } return this[_children].map(c =&gt; c[$text]()).join(&quot;&quot;); } get [_attributeNames]() { const proto = Object.getPrototypeOf(this); if (!proto._attributes) { const attributes = proto._attributes = new Set(); for (const name of Object.getOwnPropertyNames(this)) { if (this[name] === null || this[name] instanceof XFAObject || this[name] instanceof XFAObjectArray) { break; } attributes.add(name); } } return (0, _util.shadow)(this, _attributeNames, proto._attributes); } [$isDescendent](parent) { let node = this; while (node) { if (node === parent) { return true; } node = node[$getParent](); } return false; } [$getParent]() { return this[_parent]; } [$getSubformParent]() { return this[$getParent](); } [$getChildren](name = null) { if (!name) { return this[_children]; } return this[name]; } [$dump]() { const dumped = Object.create(null); if (this[$content]) { dumped.$content = this[$content]; } for (const name of Object.getOwnPropertyNames(this)) { const value = this[name]; if (value === null) { continue; } if (value instanceof XFAObject) { dumped[name] = value[$dump](); } else if (value instanceof XFAObjectArray) { if (!value.isEmpty()) { dumped[name] = value.dump(); } } else { dumped[name] = value; } } return dumped; } [$toStyle]() { return null; } [$toHTML]() { return _utils.HTMLResult.EMPTY; } *[$getContainedChildren]() { for (const node of this[$getChildren]()) { yield node; } } *[_filteredChildrenGenerator](filter, include) { for (const node of this[$getContainedChildren]()) { if (!filter || include === filter.has(node[$nodeName])) { const availableSpace = this[$getAvailableSpace](); const res = node[$toHTML](availableSpace); if (!res.success) { this[$extra].failingNode = node; } yield res; } } } [$flushHTML]() { return null; } [$addHTML](html, bbox) { this[$extra].children.push(html); } [$getAvailableSpace]() {} [$childrenToHTML]({ filter = null, include = true }) { if (!this[$extra].generator) { this[$extra].generator = this[_filteredChildrenGenerator](filter, include); } else { const availableSpace = this[$getAvailableSpace](); const res = this[$extra].failingNode[$toHTML](availableSpace); if (!res.success) { return res; } if (res.html) { this[$addHTML](res.html, res.bbox); } delete this[$extra].failingNode; } while (true) { const gen = this[$extra].generator.next(); if (gen.done) { break; } const res = gen.value; if (!res.success) { return res; } if (res.html) { this[$addHTML](res.html, res.bbox); } } this[$extra].generator = null; return _utils.HTMLResult.EMPTY; } [$setSetAttributes](attributes) { this[_setAttributes] = new Set(Object.keys(attributes)); } [_getUnsetAttributes](protoAttributes) { const allAttr = this[_attributeNames]; const setAttr = this[_setAttributes]; return [...protoAttributes].filter(x =&gt; allAttr.has(x) &amp;&amp; !setAttr.has(x)); } [$resolvePrototypes](ids, ancestors = new Set()) { for (const child of this[_children]) { child[_resolvePrototypesHelper](ids, ancestors); } } [_resolvePrototypesHelper](ids, ancestors) { const proto = this[_getPrototype](ids, ancestors); if (proto) { this[_applyPrototype](proto, ids, ancestors); } else { this[$resolvePrototypes](ids, ancestors); } } [_getPrototype](ids, ancestors) { const { use, usehref } = this; if (!use &amp;&amp; !usehref) { return null; } let proto = null; let somExpression = null; let id = null; let ref = use; if (usehref) { ref = usehref; if (usehref.startsWith(&quot;#som(&quot;) &amp;&amp; usehref.endsWith(&quot;)&quot;)) { somExpression = usehref.slice(&quot;#som(&quot;.length, usehref.length - 1); } else if (usehref.startsWith(&quot;.#som(&quot;) &amp;&amp; usehref.endsWith(&quot;)&quot;)) { somExpression = usehref.slice(&quot;.#som(&quot;.length, usehref.length - 1); } else if (usehref.startsWith(&quot;#&quot;)) { id = usehref.slice(1); } else if (usehref.startsWith(&quot;.#&quot;)) { id = usehref.slice(2); } } else if (use.startsWith(&quot;#&quot;)) { id = use.slice(1); } else { somExpression = use; } this.use = this.usehref = &quot;&quot;; if (id) { proto = ids.get(id); } else { proto = (0, _som.searchNode)(ids.get($root), this, somExpression, true, false); if (proto) { proto = proto[0]; } } if (!proto) { (0, _util.warn)(`XFA - Invalid prototype reference: ${ref}.`); return null; } if (proto[$nodeName] !== this[$nodeName]) { (0, _util.warn)(`XFA - Incompatible prototype: ${proto[$nodeName]} !== ${this[$nodeName]}.`); return null; } if (ancestors.has(proto)) { (0, _util.warn)(`XFA - Cycle detected in prototypes use.`); return null; } ancestors.add(proto); const protoProto = proto[_getPrototype](ids, ancestors); if (protoProto) { proto[_applyPrototype](protoProto, ids, ancestors); } proto[$resolvePrototypes](ids, ancestors); ancestors.delete(proto); return proto; } [_applyPrototype](proto, ids, ancestors) { if (ancestors.has(proto)) { (0, _util.warn)(`XFA - Cycle detected in prototypes use.`); return; } if (!this[$content] &amp;&amp; proto[$content]) { this[$content] = proto[$content]; } const newAncestors = new Set(ancestors); newAncestors.add(proto); for (const unsetAttrName of this[_getUnsetAttributes](proto[_setAttributes])) { this[unsetAttrName] = proto[unsetAttrName]; if (this[_setAttributes]) { this[_setAttributes].add(unsetAttrName); } } for (const name of Object.getOwnPropertyNames(this)) { if (this[_attributeNames].has(name)) { continue; } const value = this[name]; const protoValue = proto[name]; if (value instanceof XFAObjectArray) { for (const child of value[_children]) { child[_resolvePrototypesHelper](ids, ancestors); } for (let i = value[_children].length, ii = protoValue[_children].length; i &lt; ii; i++) { const child = proto[_children][i][$clone](); if (value.push(child)) { child[_parent] = this; this[_children].push(child); child[_resolvePrototypesHelper](ids, ancestors); } else { break; } } continue; } if (value !== null) { value[$resolvePrototypes](ids, ancestors); if (protoValue) { value[_applyPrototype](protoValue, ids, ancestors); } continue; } if (protoValue !== null) { const child = protoValue[$clone](); child[_parent] = this; this[name] = child; this[_children].push(child); child[_resolvePrototypesHelper](ids, ancestors); } } } static [_cloneAttribute](obj) { if (Array.isArray(obj)) { return obj.map(x =&gt; XFAObject[_cloneAttribute](x)); } if (typeof obj === &quot;object&quot; &amp;&amp; obj !== null) { return Object.assign({}, obj); } return obj; } [$clone]() { const clone = Object.create(Object.getPrototypeOf(this)); for (const $symbol of Object.getOwnPropertySymbols(this)) { try { clone[$symbol] = this[$symbol]; } catch (_) { (0, _util.shadow)(clone, $symbol, this[$symbol]); } } clone[$uid] = `${clone[$nodeName]}${uid++}`; clone[_children] = []; for (const name of Object.getOwnPropertyNames(this)) { if (this[_attributeNames].has(name)) { clone[name] = XFAObject[_cloneAttribute](this[name]); continue; } const value = this[name]; if (value instanceof XFAObjectArray) { clone[name] = new XFAObjectArray(value[_max]); } else { clone[name] = null; } } for (const child of this[_children]) { const name = child[$nodeName]; const clonedChild = child[$clone](); clone[_children].push(clonedChild); clonedChild[_parent] = clone; if (clone[name] === null) { clone[name] = clonedChild; } else { clone[name][_children].push(clonedChild); } } return clone; } [$getChildren](name = null) { if (!name) { return this[_children]; } return this[_children].filter(c =&gt; c[$nodeName] === name); } [$getChildrenByClass](name) { return this[name]; } [$getChildrenByName](name, allTransparent, first = true) { return Array.from(this[$getChildrenByNameIt](name, allTransparent, first)); } *[$getChildrenByNameIt](name, allTransparent, first = true) { if (name === &quot;parent&quot;) { yield this[_parent]; return; } for (const child of this[_children]) { if (child[$nodeName] === name) { yield child; } if (child.name === name) { yield child; } if (allTransparent || child[$isTransparent]()) { yield* child[$getChildrenByNameIt](name, allTransparent, false); } } if (first &amp;&amp; this[_attributeNames].has(name)) { yield new XFAAttribute(this, name, this[name]); } } } exports.XFAObject = XFAObject; class XFAObjectArray { constructor(max = Infinity) { this[_max] = max; this[_children] = []; } push(child) { const len = this[_children].length; if (len &lt;= this[_max]) { this[_children].push(child); return true; } (0, _util.warn)(`XFA - node &quot;${child[$nodeName]}&quot; accepts no more than ${this[_max]} children`); return false; } isEmpty() { return this[_children].length === 0; } dump() { return this[_children].length === 1 ? this[_children][0][$dump]() : this[_children].map(x =&gt; x[$dump]()); } [$clone]() { const clone = new XFAObjectArray(this[_max]); clone[_children] = this[_children].map(c =&gt; c[$clone]()); return clone; } get children() { return this[_children]; } clear() { this[_children].length = 0; } } exports.XFAObjectArray = XFAObjectArray; class XFAAttribute { constructor(node, name, value) { this[_parent] = node; this[$nodeName] = name; this[$content] = value; this[$consumed] = false; this[$uid] = `attribute${uid++}`; } [$getParent]() { return this[_parent]; } [$isDataValue]() { return true; } [$getDataValue]() { return this[$content].trim(); } [$setValue](value) { value = value.value || &quot;&quot;; this[$content] = value.toString(); } [$text]() { return this[$content]; } [$isDescendent](parent) { return this[_parent] === parent || this[_parent][$isDescendent](parent); } } exports.XFAAttribute = XFAAttribute; class XmlObject extends XFAObject { constructor(nsId, name, attributes = {}) { super(nsId, name); this[$content] = &quot;&quot;; this[_dataValue] = null; if (name !== &quot;#text&quot;) { const map = new Map(); this[_attributes] = map; for (const [attrName, value] of Object.entries(attributes)) { map.set(attrName, new XFAAttribute(this, attrName, value)); } if (attributes.hasOwnProperty($nsAttributes)) { const dataNode = attributes[$nsAttributes].xfa.dataNode; if (dataNode !== undefined) { if (dataNode === &quot;dataGroup&quot;) { this[_dataValue] = false; } else if (dataNode === &quot;dataValue&quot;) { this[_dataValue] = true; } } } } this[$consumed] = false; } [$toString](buf) { const tagName = this[$nodeName]; if (tagName === &quot;#text&quot;) { buf.push((0, _core_utils.encodeToXmlString)(this[$content])); return; } const utf8TagName = (0, _util.utf8StringToString)(tagName); const prefix = this[$namespaceId] === NS_DATASETS ? &quot;xfa:&quot; : &quot;&quot;; buf.push(`&lt;${prefix}${utf8TagName}`); for (const [name, value] of this[_attributes].entries()) { const utf8Name = (0, _util.utf8StringToString)(name); buf.push(` ${utf8Name}=&quot;${(0, _core_utils.encodeToXmlString)(value[$content])}&quot;`); } if (this[_dataValue] !== null) { if (this[_dataValue]) { buf.push(` xfa:dataNode=&quot;dataValue&quot;`); } else { buf.push(` xfa:dataNode=&quot;dataGroup&quot;`); } } if (!this[$content] &amp;&amp; this[_children].length === 0) { buf.push(&quot;/&gt;&quot;); return; } buf.push(&quot;&gt;&quot;); if (this[$content]) { if (typeof this[$content] === &quot;string&quot;) { buf.push((0, _core_utils.encodeToXmlString)(this[$content])); } else { this[$content][$toString](buf); } } else { for (const child of this[_children]) { child[$toString](buf); } } buf.push(``); } [$onChild](child) { if (this[$content]) { const node = new XmlObject(this[$namespaceId], &quot;#text&quot;); this[$appendChild](node); node[$content] = this[$content]; this[$content] = &quot;&quot;; } this[$appendChild](child); return true; } [$onText](str) { this[$content] += str; } [$finalize]() { if (this[$content] &amp;&amp; this[_children].length &gt; 0) { const node = new XmlObject(this[$namespaceId], &quot;#text&quot;); this[$appendChild](node); node[$content] = this[$content]; delete this[$content]; } } [$toHTML]() { if (this[$nodeName] === &quot;#text&quot;) { return _utils.HTMLResult.success({ name: &quot;#text&quot;, value: this[$content] }); } return _utils.HTMLResult.EMPTY; } [$getChildren](name = null) { if (!name) { return this[_children]; } return this[_children].filter(c =&gt; c[$nodeName] === name); } [$getAttributes]() { return this[_attributes]; } [$getChildrenByClass](name) { const value = this[_attributes].get(name); if (value !== undefined) { return value; } return this[$getChildren](name); } *[$getChildrenByNameIt](name, allTransparent) { const value = this[_attributes].get(name); if (value) { yield value; } for (const child of this[_children]) { if (child[$nodeName] === name) { yield child; } if (allTransparent) { yield* child[$getChildrenByNameIt](name, allTransparent); } } } *[$getAttributeIt](name, skipConsumed) { const value = this[_attributes].get(name); if (value &amp;&amp; (!skipConsumed || !value[$consumed])) { yield value; } for (const child of this[_children]) { yield* child[$getAttributeIt](name, skipConsumed); } } *[$getRealChildrenByNameIt](name, allTransparent, skipConsumed) { for (const child of this[_children]) { if (child[$nodeName] === name &amp;&amp; (!skipConsumed || !child[$consumed])) { yield child; } if (allTransparent) { yield* child[$getRealChildrenByNameIt](name, allTransparent, skipConsumed); } } } [$isDataValue]() { if (this[_dataValue] === null) { return this[_children].length === 0 || this[_children][0][$namespaceId] === _namespaces.NamespaceIds.xhtml.id; } return this[_dataValue]; } [$getDataValue]() { if (this[_dataValue] === null) { if (this[_children].length === 0) { return this[$content].trim(); } if (this[_children][0][$namespaceId] === _namespaces.NamespaceIds.xhtml.id) { return this[_children][0][$text]().trim(); } return null; } return this[$content].trim(); } [$setValue](value) { value = value.value || &quot;&quot;; this[$content] = value.toString(); } [$dump](hasNS = false) { const dumped = Object.create(null); if (hasNS) { dumped.$ns = this[$namespaceId]; } if (this[$content]) { dumped.$content = this[$content]; } dumped.$name = this[$nodeName]; dumped.children = []; for (const child of this[_children]) { dumped.children.push(child[$dump](hasNS)); } dumped.attributes = Object.create(null); for (const [name, value] of this[_attributes]) { dumped.attributes[name] = value[$content]; } return dumped; } } exports.XmlObject = XmlObject; class ContentObject extends XFAObject { constructor(nsId, name) { super(nsId, name); this[$content] = &quot;&quot;; } [$onText](text) { this[$content] += text; } [$finalize]() {} } exports.ContentObject = ContentObject; class OptionObject extends ContentObject { constructor(nsId, name, options) { super(nsId, name); this[_options] = options; } [$finalize]() { this[$content] = (0, _utils.getKeyword)({ data: this[$content], defaultValue: this[_options][0], validate: k =&gt; this[_options].includes(k) }); } [$clean](builder) { super[$clean](builder); delete this[_options]; } } exports.OptionObject = OptionObject; class StringObject extends ContentObject { [$finalize]() { this[$content] = this[$content].trim(); } } exports.StringObject = StringObject; class IntegerObject extends ContentObject { constructor(nsId, name, defaultValue, validator) { super(nsId, name); this[_defaultValue] = defaultValue; this[_validator] = validator; } [$finalize]() { this[$content] = (0, _utils.getInteger)({ data: this[$content], defaultValue: this[_defaultValue], validate: this[_validator] }); } [$clean](builder) { super[$clean](builder); delete this[_defaultValue]; delete this[_validator]; } } exports.IntegerObject = IntegerObject; class Option01 extends IntegerObject { constructor(nsId, name) { super(nsId, name, 0, n =&gt; n === 1); } } exports.Option01 = Option01; class Option10 extends IntegerObject { constructor(nsId, name) { super(nsId, name, 1, n =&gt; n === 0); } } exports.Option10 = Option10; /***/ }), /* 76 */ /***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) =&gt; { Object.defineProperty(exports, &quot;__esModule&quot;, ({ value: true })); exports.HTMLResult = void 0; exports.getBBox = getBBox; exports.getColor = getColor; exports.getFloat = getFloat; exports.getInteger = getInteger; exports.getKeyword = getKeyword; exports.getMeasurement = getMeasurement; exports.getRatio = getRatio; exports.getRelevant = getRelevant; exports.getStringOption = getStringOption; exports.stripQuotes = stripQuotes; var _util = __w_pdfjs_require__(2); const dimConverters = { pt: x =&gt; x, cm: x =&gt; x / 2.54 * 72, mm: x =&gt; x / (10 * 2.54) * 72, in: x =&gt; x * 72, px: x =&gt; x }; const measurementPattern = /([+-]?\\d+\\.?\\d*)(.*)/; function stripQuotes(str) { if (str.startsWith(&quot;&apos;&quot;) || str.startsWith(&apos;&quot;&apos;)) { return str.slice(1, str.length - 1); } return str; } function getInteger({ data, defaultValue, validate }) { if (!data) { return defaultValue; } data = data.trim(); const n = parseInt(data, 10); if (!isNaN(n) &amp;&amp; validate(n)) { return n; } return defaultValue; } function getFloat({ data, defaultValue, validate }) { if (!data) { return defaultValue; } data = data.trim(); const n = parseFloat(data); if (!isNaN(n) &amp;&amp; validate(n)) { return n; } return defaultValue; } function getKeyword({ data, defaultValue, validate }) { if (!data) { return defaultValue; } data = data.trim(); if (validate(data)) { return data; } return defaultValue; } function getStringOption(data, options) { return getKeyword({ data, defaultValue: options[0], validate: k =&gt; options.includes(k) }); } function getMeasurement(str, def = &quot;0&quot;) { def = def || &quot;0&quot;; if (!str) { return getMeasurement(def); } const match = str.trim().match(measurementPattern); if (!match) { return getMeasurement(def); } const [, valueStr, unit] = match; const value = parseFloat(valueStr); if (isNaN(value)) { return getMeasurement(def); } if (value === 0) { return 0; } const conv = dimConverters[unit]; if (conv) { return conv(value); } return value; } function getRatio(data) { if (!data) { return { num: 1, den: 1 }; } const ratio = data.trim().split(/\\s*:\\s*/).map(x =&gt; parseFloat(x)).filter(x =&gt; !isNaN(x)); if (ratio.length === 1) { ratio.push(1); } if (ratio.length === 0) { return { num: 1, den: 1 }; } const [num, den] = ratio; return { num, den }; } function getRelevant(data) { if (!data) { return []; } return data.trim().split(/\\s+/).map(e =&gt; { return { excluded: e[0] === &quot;-&quot;, viewname: e.substring(1) }; }); } function getColor(data, def = [0, 0, 0]) { let [r, g, b] = def; if (!data) { return { r, g, b }; } const color = data.trim().split(/\\s*,\\s*/).map(c =&gt; Math.min(Math.max(0, parseInt(c.trim(), 10)), 255)).map(c =&gt; isNaN(c) ? 0 : c); if (color.length &lt; 3) { return { r, g, b }; } [r, g, b] = color; return { r, g, b }; } function getBBox(data) { const def = -1; if (!data) { return { x: def, y: def, width: def, height: def }; } const bbox = data.trim().split(/\\s*,\\s*/).map(m =&gt; getMeasurement(m, &quot;-1&quot;)); if (bbox.length &lt; 4 || bbox[2] &lt; 0 || bbox[3] &lt; 0) { return { x: def, y: def, width: def, height: def }; } const [x, y, width, height] = bbox; return { x, y, width, height }; } class HTMLResult { static get FAILURE() { return (0, _util.shadow)(this, &quot;FAILURE&quot;, new HTMLResult(false, null, null, null)); } static get EMPTY() { return (0, _util.shadow)(this, &quot;EMPTY&quot;, new HTMLResult(true, null, null, null)); } constructor(success, html, bbox, breakNode) { this.success = success; this.html = html; this.bbox = bbox; this.breakNode = breakNode; } isBreak() { return !!this.breakNode; } static breakNode(node) { return new HTMLResult(false, null, null, node); } static success(html, bbox = null) { return new HTMLResult(true, html, bbox, null); } } exports.HTMLResult = HTMLResult; /***/ }), /* 77 */ /***/ ((__unused_webpack_module, exports) =&gt; { Object.defineProperty(exports, &quot;__esModule&quot;, ({ value: true })); exports.NamespaceIds = exports.$buildXFAObject = void 0; const $buildXFAObject = Symbol(); exports.$buildXFAObject = $buildXFAObject; const NamespaceIds = { config: { id: 0, check: ns =&gt; ns.startsWith(&quot;http://www.xfa.org/schema/xci/&quot;) }, connectionSet: { id: 1, check: ns =&gt; ns.startsWith(&quot;http://www.xfa.org/schema/xfa-connection-set/&quot;) }, datasets: { id: 2, check: ns =&gt; ns.startsWith(&quot;http://www.xfa.org/schema/xfa-data/&quot;) }, form: { id: 3, check: ns =&gt; ns.startsWith(&quot;http://www.xfa.org/schema/xfa-form/&quot;) }, localeSet: { id: 4, check: ns =&gt; ns.startsWith(&quot;http://www.xfa.org/schema/xfa-locale-set/&quot;) }, pdf: { id: 5, check: ns =&gt; ns === &quot;http://ns.adobe.com/xdp/pdf/&quot; }, signature: { id: 6, check: ns =&gt; ns === &quot;http://www.w3.org/2000/09/xmldsig#&quot; }, sourceSet: { id: 7, check: ns =&gt; ns.startsWith(&quot;http://www.xfa.org/schema/xfa-source-set/&quot;) }, stylesheet: { id: 8, check: ns =&gt; ns === &quot;http://www.w3.org/1999/XSL/Transform&quot; }, template: { id: 9, check: ns =&gt; ns.startsWith(&quot;http://www.xfa.org/schema/xfa-template/&quot;) }, xdc: { id: 10, check: ns =&gt; ns.startsWith(&quot;http://www.xfa.org/schema/xdc/&quot;) }, xdp: { id: 11, check: ns =&gt; ns === &quot;http://ns.adobe.com/xdp/&quot; }, xfdf: { id: 12, check: ns =&gt; ns === &quot;http://ns.adobe.com/xfdf/&quot; }, xhtml: { id: 13, check: ns =&gt; ns === &quot;http://www.w3.org/1999/xhtml&quot; }, xmpmeta: { id: 14, check: ns =&gt; ns === &quot;http://ns.adobe.com/xmpmeta/&quot; } }; exports.NamespaceIds = NamespaceIds; /***/ }), /* 78 */ /***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) =&gt; { Object.defineProperty(exports, &quot;__esModule&quot;, ({ value: true })); exports.createDataNode = createDataNode; exports.searchNode = searchNode; var _xfa_object = __w_pdfjs_require__(75); var _namespaces = __w_pdfjs_require__(77); var _util = __w_pdfjs_require__(2); const namePattern = /^[^.[]+/; const indexPattern = /^[^\\]]+/; const operators = { dot: 0, dotDot: 1, dotHash: 2, dotBracket: 3, dotParen: 4 }; const shortcuts = new Map([[&quot;$data&quot;, (root, current) =&gt; root.datasets ? root.datasets.data : root], [&quot;$record&quot;, (root, current) =&gt; (root.datasets ? root.datasets.data : root)[_xfa_object.$getChildren]()[0]], [&quot;$template&quot;, (root, current) =&gt; root.template], [&quot;$connectionSet&quot;, (root, current) =&gt; root.connectionSet], [&quot;$form&quot;, (root, current) =&gt; root.form], [&quot;$layout&quot;, (root, current) =&gt; root.layout], [&quot;$host&quot;, (root, current) =&gt; root.host], [&quot;$dataWindow&quot;, (root, current) =&gt; root.dataWindow], [&quot;$event&quot;, (root, current) =&gt; root.event], [&quot;!&quot;, (root, current) =&gt; root.datasets], [&quot;$xfa&quot;, (root, current) =&gt; root], [&quot;xfa&quot;, (root, current) =&gt; root], [&quot;$&quot;, (root, current) =&gt; current]]); const somCache = new WeakMap(); const NS_DATASETS = _namespaces.NamespaceIds.datasets.id; function parseIndex(index) { index = index.trim(); if (index === &quot;*&quot;) { return Infinity; } return parseInt(index, 10) || 0; } function parseExpression(expr, dotDotAllowed, noExpr = true) { let match = expr.match(namePattern); if (!match) { return null; } let [name] = match; const parsed = [{ name, cacheName: &quot;.&quot; + name, index: 0, js: null, formCalc: null, operator: operators.dot }]; let pos = name.length; while (pos &lt; expr.length) { const spos = pos; const char = expr.charAt(pos++); if (char === &quot;[&quot;) { match = expr.slice(pos).match(indexPattern); if (!match) { (0, _util.warn)(&quot;XFA - Invalid index in SOM expression&quot;); return null; } parsed.at(-1).index = parseIndex(match[0]); pos += match[0].length + 1; continue; } let operator; switch (expr.charAt(pos)) { case &quot;.&quot;: if (!dotDotAllowed) { return null; } pos++; operator = operators.dotDot; break; case &quot;#&quot;: pos++; operator = operators.dotHash; break; case &quot;[&quot;: if (noExpr) { (0, _util.warn)(&quot;XFA - SOM expression contains a FormCalc subexpression which is not supported for now.&quot;); return null; } operator = operators.dotBracket; break; case &quot;(&quot;: if (noExpr) { (0, _util.warn)(&quot;XFA - SOM expression contains a JavaScript subexpression which is not supported for now.&quot;); return null; } operator = operators.dotParen; break; default: operator = operators.dot; break; } match = expr.slice(pos).match(namePattern); if (!match) { break; } [name] = match; pos += name.length; parsed.push({ name, cacheName: expr.slice(spos, pos), operator, index: 0, js: null, formCalc: null }); } return parsed; } function searchNode(root, container, expr, dotDotAllowed = true, useCache = true) { const parsed = parseExpression(expr, dotDotAllowed); if (!parsed) { return null; } const fn = shortcuts.get(parsed[0].name); let i = 0; let isQualified; if (fn) { isQualified = true; root = [fn(root, container)]; i = 1; } else { isQualified = container === null; root = [container || root]; } for (let ii = parsed.length; i &lt; ii; i++) { const { name, cacheName, operator, index } = parsed[i]; const nodes = []; for (const node of root) { if (!(node instanceof _xfa_object.XFAObject)) { continue; } let children, cached; if (useCache) { cached = somCache.get(node); if (!cached) { cached = new Map(); somCache.set(node, cached); } children = cached.get(cacheName); } if (!children) { switch (operator) { case operators.dot: children = node[_xfa_object.$getChildrenByName](name, false); break; case operators.dotDot: children = node[_xfa_object.$getChildrenByName](name, true); break; case operators.dotHash: children = node[_xfa_object.$getChildrenByClass](name); if (children instanceof _xfa_object.XFAObjectArray) { children = children.children; } else { children = [children]; } break; default: break; } if (useCache) { cached.set(cacheName, children); } } if (children.length &gt; 0) { nodes.push(children); } } if (nodes.length === 0 &amp;&amp; !isQualified &amp;&amp; i === 0) { const parent = container[_xfa_object.$getParent](); container = parent; if (!container) { return null; } i = -1; root = [container]; continue; } if (isFinite(index)) { root = nodes.filter(node =&gt; index &lt; node.length).map(node =&gt; node[index]); } else { root = nodes.flat(); } } if (root.length === 0) { return null; } return root; } function createNodes(root, path) { let node = null; for (const { name, index } of path) { for (let i = 0, ii = !isFinite(index) ? 0 : index; i &lt;= ii; i++) { const nsId = root[_xfa_object.$namespaceId] === NS_DATASETS ? -1 : root[_xfa_object.$namespaceId]; node = new _xfa_object.XmlObject(nsId, name); root[_xfa_object.$appendChild](node); } root = node; } return node; } function createDataNode(root, container, expr) { const parsed = parseExpression(expr); if (!parsed) { return null; } if (parsed.some(x =&gt; x.operator === operators.dotDot)) { return null; } const fn = shortcuts.get(parsed[0].name); let i = 0; if (fn) { root = fn(root, container); i = 1; } else { root = container || root; } for (let ii = parsed.length; i &lt; ii; i++) { const { name, operator, index } = parsed[i]; if (!isFinite(index)) { parsed[i].index = 0; return createNodes(root, parsed.slice(i)); } let children; switch (operator) { case operators.dot: children = root[_xfa_object.$getChildrenByName](name, false); break; case operators.dotDot: children = root[_xfa_object.$getChildrenByName](name, true); break; case operators.dotHash: children = root[_xfa_object.$getChildrenByClass](name); if (children instanceof _xfa_object.XFAObjectArray) { children = children.children; } else { children = [children]; } break; default: break; } if (children.length === 0) { return createNodes(root, parsed.slice(i)); } if (index &lt; children.length) { const child = children[index]; if (!(child instanceof _xfa_object.XFAObject)) { (0, _util.warn)(`XFA - Cannot create a node.`); return null; } root = child; } else { parsed[i].index = index - children.length; return createNodes(root, parsed.slice(i)); } } return null; } /***/ }), /* 79 */ /***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) =&gt; { Object.defineProperty(exports, &quot;__esModule&quot;, ({ value: true })); exports.Binder = void 0; var _xfa_object = __w_pdfjs_require__(75); var _template = __w_pdfjs_require__(80); var _som = __w_pdfjs_require__(78); var _namespaces = __w_pdfjs_require__(77); var _util = __w_pdfjs_require__(2); const NS_DATASETS = _namespaces.NamespaceIds.datasets.id; function createText(content) { const node = new _template.Text({}); node[_xfa_object.$content] = content; return node; } class Binder { constructor(root) { this.root = root; this.datasets = root.datasets; if (root.datasets &amp;&amp; root.datasets.data) { this.data = root.datasets.data; } else { this.data = new _xfa_object.XmlObject(_namespaces.NamespaceIds.datasets.id, &quot;data&quot;); } this.emptyMerge = this.data[_xfa_object.$getChildren]().length === 0; this.root.form = this.form = root.template[_xfa_object.$clone](); } _isConsumeData() { return !this.emptyMerge &amp;&amp; this._mergeMode; } _isMatchTemplate() { return !this._isConsumeData(); } bind() { this._bindElement(this.form, this.data); return this.form; } getData() { return this.data; } _bindValue(formNode, data, picture) { formNode[_xfa_object.$data] = data; if (formNode[_xfa_object.$hasSettableValue]()) { if (data[_xfa_object.$isDataValue]()) { const value = data[_xfa_object.$getDataValue](); formNode[_xfa_object.$setValue](createText(value)); } else if (formNode instanceof _template.Field &amp;&amp; formNode.ui &amp;&amp; formNode.ui.choiceList &amp;&amp; formNode.ui.choiceList.open === &quot;multiSelect&quot;) { const value = data[_xfa_object.$getChildren]().map(child =&gt; child[_xfa_object.$content].trim()).join(&quot;\\n&quot;); formNode[_xfa_object.$setValue](createText(value)); } else if (this._isConsumeData()) { (0, _util.warn)(`XFA - Nodes haven&apos;t the same type.`); } } else if (!data[_xfa_object.$isDataValue]() || this._isMatchTemplate()) { this._bindElement(formNode, data); } else { (0, _util.warn)(`XFA - Nodes haven&apos;t the same type.`); } } _findDataByNameToConsume(name, isValue, dataNode, global) { if (!name) { return null; } let generator, match; for (let i = 0; i &lt; 3; i++) { generator = dataNode[_xfa_object.$getRealChildrenByNameIt](name, false, true); while (true) { match = generator.next().value; if (!match) { break; } if (isValue === match[_xfa_object.$isDataValue]()) { return match; } } if (dataNode[_xfa_object.$namespaceId] === _namespaces.NamespaceIds.datasets.id &amp;&amp; dataNode[_xfa_object.$nodeName] === &quot;data&quot;) { break; } dataNode = dataNode[_xfa_object.$getParent](); } if (!global) { return null; } generator = this.data[_xfa_object.$getRealChildrenByNameIt](name, true, false); match = generator.next().value; if (match) { return match; } generator = this.data[_xfa_object.$getAttributeIt](name, true); match = generator.next().value; if (match &amp;&amp; match[_xfa_object.$isDataValue]()) { return match; } return null; } _setProperties(formNode, dataNode) { if (!formNode.hasOwnProperty(&quot;setProperty&quot;)) { return; } for (const { ref, target, connection } of formNode.setProperty.children) { if (connection) { continue; } if (!ref) { continue; } const nodes = (0, _som.searchNode)(this.root, dataNode, ref, false, false); if (!nodes) { (0, _util.warn)(`XFA - Invalid reference: ${ref}.`); continue; } const [node] = nodes; if (!node[_xfa_object.$isDescendent](this.data)) { (0, _util.warn)(`XFA - Invalid node: must be a data node.`); continue; } const targetNodes = (0, _som.searchNode)(this.root, formNode, target, false, false); if (!targetNodes) { (0, _util.warn)(`XFA - Invalid target: ${target}.`); continue; } const [targetNode] = targetNodes; if (!targetNode[_xfa_object.$isDescendent](formNode)) { (0, _util.warn)(`XFA - Invalid target: must be a property or subproperty.`); continue; } const targetParent = targetNode[_xfa_object.$getParent](); if (targetNode instanceof _template.SetProperty || targetParent instanceof _template.SetProperty) { (0, _util.warn)(`XFA - Invalid target: cannot be a setProperty or one of its properties.`); continue; } if (targetNode instanceof _template.BindItems || targetParent instanceof _template.BindItems) { (0, _util.warn)(`XFA - Invalid target: cannot be a bindItems or one of its properties.`); continue; } const content = node[_xfa_object.$text](); const name = targetNode[_xfa_object.$nodeName]; if (targetNode instanceof _xfa_object.XFAAttribute) { const attrs = Object.create(null); attrs[name] = content; const obj = Reflect.construct(Object.getPrototypeOf(targetParent).constructor, [attrs]); targetParent[name] = obj[name]; continue; } if (!targetNode.hasOwnProperty(_xfa_object.$content)) { (0, _util.warn)(`XFA - Invalid node to use in setProperty`); continue; } targetNode[_xfa_object.$data] = node; targetNode[_xfa_object.$content] = content; targetNode[_xfa_object.$finalize](); } } _bindItems(formNode, dataNode) { if (!formNode.hasOwnProperty(&quot;items&quot;) || !formNode.hasOwnProperty(&quot;bindItems&quot;) || formNode.bindItems.isEmpty()) { return; } for (const item of formNode.items.children) { formNode[_xfa_object.$removeChild](item); } formNode.items.clear(); const labels = new _template.Items({}); const values = new _template.Items({}); formNode[_xfa_object.$appendChild](labels); formNode.items.push(labels); formNode[_xfa_object.$appendChild](values); formNode.items.push(values); for (const { ref, labelRef, valueRef, connection } of formNode.bindItems.children) { if (connection) { continue; } if (!ref) { continue; } const nodes = (0, _som.searchNode)(this.root, dataNode, ref, false, false); if (!nodes) { (0, _util.warn)(`XFA - Invalid reference: ${ref}.`); continue; } for (const node of nodes) { if (!node[_xfa_object.$isDescendent](this.datasets)) { (0, _util.warn)(`XFA - Invalid ref (${ref}): must be a datasets child.`); continue; } const labelNodes = (0, _som.searchNode)(this.root, node, labelRef, true, false); if (!labelNodes) { (0, _util.warn)(`XFA - Invalid label: ${labelRef}.`); continue; } const [labelNode] = labelNodes; if (!labelNode[_xfa_object.$isDescendent](this.datasets)) { (0, _util.warn)(`XFA - Invalid label: must be a datasets child.`); continue; } const valueNodes = (0, _som.searchNode)(this.root, node, valueRef, true, false); if (!valueNodes) { (0, _util.warn)(`XFA - Invalid value: ${valueRef}.`); continue; } const [valueNode] = valueNodes; if (!valueNode[_xfa_object.$isDescendent](this.datasets)) { (0, _util.warn)(`XFA - Invalid value: must be a datasets child.`); continue; } const label = createText(labelNode[_xfa_object.$text]()); const value = createText(valueNode[_xfa_object.$text]()); labels[_xfa_object.$appendChild](label); labels.text.push(label); values[_xfa_object.$appendChild](value); values.text.push(value); } } } _bindOccurrences(formNode, matches, picture) { let baseClone; if (matches.length &gt; 1) { baseClone = formNode[_xfa_object.$clone](); baseClone[_xfa_object.$removeChild](baseClone.occur); baseClone.occur = null; } this._bindValue(formNode, matches[0], picture); this._setProperties(formNode, matches[0]); this._bindItems(formNode, matches[0]); if (matches.length === 1) { return; } const parent = formNode[_xfa_object.$getParent](); const name = formNode[_xfa_object.$nodeName]; const pos = parent[_xfa_object.$indexOf](formNode); for (let i = 1, ii = matches.length; i &lt; ii; i++) { const match = matches[i]; const clone = baseClone[_xfa_object.$clone](); parent[name].push(clone); parent[_xfa_object.$insertAt](pos + i, clone); this._bindValue(clone, match, picture); this._setProperties(clone, match); this._bindItems(clone, match); } } _createOccurrences(formNode) { if (!this.emptyMerge) { return; } const { occur } = formNode; if (!occur || occur.initial &lt;= 1) { return; } const parent = formNode[_xfa_object.$getParent](); const name = formNode[_xfa_object.$nodeName]; if (!(parent[name] instanceof _xfa_object.XFAObjectArray)) { return; } let currentNumber; if (formNode.name) { currentNumber = parent[name].children.filter(e =&gt; e.name === formNode.name).length; } else { currentNumber = parent[name].children.length; } const pos = parent[_xfa_object.$indexOf](formNode) + 1; const ii = occur.initial - currentNumber; if (ii) { const nodeClone = formNode[_xfa_object.$clone](); nodeClone[_xfa_object.$removeChild](nodeClone.occur); nodeClone.occur = null; parent[name].push(nodeClone); parent[_xfa_object.$insertAt](pos, nodeClone); for (let i = 1; i &lt; ii; i++) { const clone = nodeClone[_xfa_object.$clone](); parent[name].push(clone); parent[_xfa_object.$insertAt](pos + i, clone); } } } _getOccurInfo(formNode) { const { name, occur } = formNode; if (!occur || !name) { return [1, 1]; } const max = occur.max === -1 ? Infinity : occur.max; return [occur.min, max]; } _setAndBind(formNode, dataNode) { this._setProperties(formNode, dataNode); this._bindItems(formNode, dataNode); this._bindElement(formNode, dataNode); } _bindElement(formNode, dataNode) { const uselessNodes = []; this._createOccurrences(formNode); for (const child of formNode[_xfa_object.$getChildren]()) { if (child[_xfa_object.$data]) { continue; } if (this._mergeMode === undefined &amp;&amp; child[_xfa_object.$nodeName] === &quot;subform&quot;) { this._mergeMode = child.mergeMode === &quot;consumeData&quot;; const dataChildren = dataNode[_xfa_object.$getChildren](); if (dataChildren.length &gt; 0) { this._bindOccurrences(child, [dataChildren[0]], null); } else if (this.emptyMerge) { const nsId = dataNode[_xfa_object.$namespaceId] === NS_DATASETS ? -1 : dataNode[_xfa_object.$namespaceId]; const dataChild = child[_xfa_object.$data] = new _xfa_object.XmlObject(nsId, child.name || &quot;root&quot;); dataNode[_xfa_object.$appendChild](dataChild); this._bindElement(child, dataChild); } continue; } if (!child[_xfa_object.$isBindable]()) { continue; } let global = false; let picture = null; let ref = null; let match = null; if (child.bind) { switch (child.bind.match) { case &quot;none&quot;: this._setAndBind(child, dataNode); continue; case &quot;global&quot;: global = true; break; case &quot;dataRef&quot;: if (!child.bind.ref) { (0, _util.warn)(`XFA - ref is empty in node ${child[_xfa_object.$nodeName]}.`); this._setAndBind(child, dataNode); continue; } ref = child.bind.ref; break; default: break; } if (child.bind.picture) { picture = child.bind.picture[_xfa_object.$content]; } } const [min, max] = this._getOccurInfo(child); if (ref) { match = (0, _som.searchNode)(this.root, dataNode, ref, true, false); if (match === null) { match = (0, _som.createDataNode)(this.data, dataNode, ref); if (!match) { continue; } if (this._isConsumeData()) { match[_xfa_object.$consumed] = true; } this._setAndBind(child, match); continue; } else { if (this._isConsumeData()) { match = match.filter(node =&gt; !node[_xfa_object.$consumed]); } if (match.length &gt; max) { match = match.slice(0, max); } else if (match.length === 0) { match = null; } if (match &amp;&amp; this._isConsumeData()) { match.forEach(node =&gt; { node[_xfa_object.$consumed] = true; }); } } } else { if (!child.name) { this._setAndBind(child, dataNode); continue; } if (this._isConsumeData()) { const matches = []; while (matches.length &lt; max) { const found = this._findDataByNameToConsume(child.name, child[_xfa_object.$hasSettableValue](), dataNode, global); if (!found) { break; } found[_xfa_object.$consumed] = true; matches.push(found); } match = matches.length &gt; 0 ? matches : null; } else { match = dataNode[_xfa_object.$getRealChildrenByNameIt](child.name, false, this.emptyMerge).next().value; if (!match) { if (min === 0) { uselessNodes.push(child); continue; } const nsId = dataNode[_xfa_object.$namespaceId] === NS_DATASETS ? -1 : dataNode[_xfa_object.$namespaceId]; match = child[_xfa_object.$data] = new _xfa_object.XmlObject(nsId, child.name); if (this.emptyMerge) { match[_xfa_object.$consumed] = true; } dataNode[_xfa_object.$appendChild](match); this._setAndBind(child, match); continue; } if (this.emptyMerge) { match[_xfa_object.$consumed] = true; } match = [match]; } } if (match) { this._bindOccurrences(child, match, picture); } else if (min &gt; 0) { this._setAndBind(child, dataNode); } else { uselessNodes.push(child); } } uselessNodes.forEach(node =&gt; node[_xfa_object.$getParent]()[_xfa_object.$removeChild](node)); } } exports.Binder = Binder; /***/ }), /* 80 */ /***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) =&gt; { Object.defineProperty(exports, &quot;__esModule&quot;, ({ value: true })); exports.Value = exports.Text = exports.TemplateNamespace = exports.Template = exports.SetProperty = exports.Items = exports.Field = exports.BindItems = void 0; var _xfa_object = __w_pdfjs_require__(75); var _namespaces = __w_pdfjs_require__(77); var _layout = __w_pdfjs_require__(81); var _html_utils = __w_pdfjs_require__(82); var _utils = __w_pdfjs_require__(76); var _util = __w_pdfjs_require__(2); var _fonts = __w_pdfjs_require__(83); var _core_utils = __w_pdfjs_require__(4); var _som = __w_pdfjs_require__(78); const TEMPLATE_NS_ID = _namespaces.NamespaceIds.template.id; const SVG_NS = &quot;http://www.w3.org/2000/svg&quot;; const MAX_ATTEMPTS_FOR_LRTB_LAYOUT = 2; const MAX_EMPTY_PAGES = 3; const DEFAULT_TAB_INDEX = 5000; const HEADING_PATTERN = /^H(\\d+)$/; const MIMES = new Set([&quot;image/gif&quot;, &quot;image/jpeg&quot;, &quot;image/jpg&quot;, &quot;image/pjpeg&quot;, &quot;image/png&quot;, &quot;image/apng&quot;, &quot;image/x-png&quot;, &quot;image/bmp&quot;, &quot;image/x-ms-bmp&quot;, &quot;image/tiff&quot;, &quot;image/tif&quot;, &quot;application/octet-stream&quot;]); const IMAGES_HEADERS = [[[0x42, 0x4d], &quot;image/bmp&quot;], [[0xff, 0xd8, 0xff], &quot;image/jpeg&quot;], [[0x49, 0x49, 0x2a, 0x00], &quot;image/tiff&quot;], [[0x4d, 0x4d, 0x00, 0x2a], &quot;image/tiff&quot;], [[0x47, 0x49, 0x46, 0x38, 0x39, 0x61], &quot;image/gif&quot;], [[0x89, 0x50, 0x4e, 0x47, 0x0d, 0x0a, 0x1a, 0x0a], &quot;image/png&quot;]]; function getBorderDims(node) { if (!node || !node.border) { return { w: 0, h: 0 }; } const borderExtra = node.border[_xfa_object.$getExtra](); if (!borderExtra) { return { w: 0, h: 0 }; } return { w: borderExtra.widths[0] + borderExtra.widths[2] + borderExtra.insets[0] + borderExtra.insets[2], h: borderExtra.widths[1] + borderExtra.widths[3] + borderExtra.insets[1] + borderExtra.insets[3] }; } function hasMargin(node) { return node.margin &amp;&amp; (node.margin.topInset || node.margin.rightInset || node.margin.bottomInset || node.margin.leftInset); } function _setValue(templateNode, value) { if (!templateNode.value) { const nodeValue = new Value({}); templateNode[_xfa_object.$appendChild](nodeValue); templateNode.value = nodeValue; } templateNode.value[_xfa_object.$setValue](value); } function* getContainedChildren(node) { for (const child of node[_xfa_object.$getChildren]()) { if (child instanceof SubformSet) { yield* child[_xfa_object.$getContainedChildren](); continue; } yield child; } } function isRequired(node) { return node.validate &amp;&amp; node.validate.nullTest === &quot;error&quot;; } function setTabIndex(node) { while (node) { if (!node.traversal) { node[_xfa_object.$tabIndex] = node[_xfa_object.$getParent]()[_xfa_object.$tabIndex]; return; } if (node[_xfa_object.$tabIndex]) { return; } let next = null; for (const child of node.traversal[_xfa_object.$getChildren]()) { if (child.operation === &quot;next&quot;) { next = child; break; } } if (!next || !next.ref) { node[_xfa_object.$tabIndex] = node[_xfa_object.$getParent]()[_xfa_object.$tabIndex]; return; } const root = node[_xfa_object.$getTemplateRoot](); node[_xfa_object.$tabIndex] = ++root[_xfa_object.$tabIndex]; const ref = root[_xfa_object.$searchNode](next.ref, node); if (!ref) { return; } node = ref[0]; } } function applyAssist(obj, attributes) { const assist = obj.assist; if (assist) { const assistTitle = assist[_xfa_object.$toHTML](); if (assistTitle) { attributes.title = assistTitle; } const role = assist.role; const match = role.match(HEADING_PATTERN); if (match) { const ariaRole = &quot;heading&quot;; const ariaLevel = match[1]; attributes.role = ariaRole; attributes[&quot;aria-level&quot;] = ariaLevel; } } if (obj.layout === &quot;table&quot;) { attributes.role = &quot;table&quot;; } else if (obj.layout === &quot;row&quot;) { attributes.role = &quot;row&quot;; } else { const parent = obj[_xfa_object.$getParent](); if (parent.layout === &quot;row&quot;) { if (parent.assist &amp;&amp; parent.assist.role === &quot;TH&quot;) { attributes.role = &quot;columnheader&quot;; } else { attributes.role = &quot;cell&quot;; } } } } function ariaLabel(obj) { if (!obj.assist) { return null; } const assist = obj.assist; if (assist.speak &amp;&amp; assist.speak[_xfa_object.$content] !== &quot;&quot;) { return assist.speak[_xfa_object.$content]; } if (assist.toolTip) { return assist.toolTip[_xfa_object.$content]; } return null; } function valueToHtml(value) { return _utils.HTMLResult.success({ name: &quot;div&quot;, attributes: { class: [&quot;xfaRich&quot;], style: Object.create(null) }, children: [{ name: &quot;span&quot;, attributes: { style: Object.create(null) }, value }] }); } function setFirstUnsplittable(node) { const root = node[_xfa_object.$getTemplateRoot](); if (root[_xfa_object.$extra].firstUnsplittable === null) { root[_xfa_object.$extra].firstUnsplittable = node; root[_xfa_object.$extra].noLayoutFailure = true; } } function unsetFirstUnsplittable(node) { const root = node[_xfa_object.$getTemplateRoot](); if (root[_xfa_object.$extra].firstUnsplittable === node) { root[_xfa_object.$extra].noLayoutFailure = false; } } function handleBreak(node) { if (node[_xfa_object.$extra]) { return false; } node[_xfa_object.$extra] = Object.create(null); if (node.targetType === &quot;auto&quot;) { return false; } const root = node[_xfa_object.$getTemplateRoot](); let target = null; if (node.target) { target = root[_xfa_object.$searchNode](node.target, node[_xfa_object.$getParent]()); if (!target) { return false; } target = target[0]; } const { currentPageArea, currentContentArea } = root[_xfa_object.$extra]; if (node.targetType === &quot;pageArea&quot;) { if (!(target instanceof PageArea)) { target = null; } if (node.startNew) { node[_xfa_object.$extra].target = target || currentPageArea; return true; } else if (target &amp;&amp; target !== currentPageArea) { node[_xfa_object.$extra].target = target; return true; } return false; } if (!(target instanceof ContentArea)) { target = null; } const pageArea = target &amp;&amp; target[_xfa_object.$getParent](); let index; let nextPageArea = pageArea; if (node.startNew) { if (target) { const contentAreas = pageArea.contentArea.children; const indexForCurrent = contentAreas.indexOf(currentContentArea); const indexForTarget = contentAreas.indexOf(target); if (indexForCurrent !== -1 &amp;&amp; indexForCurrent &lt; indexForTarget) { nextPageArea = null; } index = indexForTarget - 1; } else { index = currentPageArea.contentArea.children.indexOf(currentContentArea); } } else if (target &amp;&amp; target !== currentContentArea) { const contentAreas = pageArea.contentArea.children; index = contentAreas.indexOf(target) - 1; nextPageArea = pageArea === currentPageArea ? null : pageArea; } else { return false; } node[_xfa_object.$extra].target = nextPageArea; node[_xfa_object.$extra].index = index; return true; } function handleOverflow(node, extraNode, space) { const root = node[_xfa_object.$getTemplateRoot](); const saved = root[_xfa_object.$extra].noLayoutFailure; const savedMethod = extraNode[_xfa_object.$getSubformParent]; extraNode[_xfa_object.$getSubformParent] = () =&gt; node; root[_xfa_object.$extra].noLayoutFailure = true; const res = extraNode[_xfa_object.$toHTML](space); node[_xfa_object.$addHTML](res.html, res.bbox); root[_xfa_object.$extra].noLayoutFailure = saved; extraNode[_xfa_object.$getSubformParent] = savedMethod; } class AppearanceFilter extends _xfa_object.StringObject { constructor(attributes) { super(TEMPLATE_NS_ID, &quot;appearanceFilter&quot;); this.id = attributes.id || &quot;&quot;; this.type = (0, _utils.getStringOption)(attributes.type, [&quot;optional&quot;, &quot;required&quot;]); this.use = attributes.use || &quot;&quot;; this.usehref = attributes.usehref || &quot;&quot;; } } class Arc extends _xfa_object.XFAObject { constructor(attributes) { super(TEMPLATE_NS_ID, &quot;arc&quot;, true); this.circular = (0, _utils.getInteger)({ data: attributes.circular, defaultValue: 0, validate: x =&gt; x === 1 }); this.hand = (0, _utils.getStringOption)(attributes.hand, [&quot;even&quot;, &quot;left&quot;, &quot;right&quot;]); this.id = attributes.id || &quot;&quot;; this.startAngle = (0, _utils.getFloat)({ data: attributes.startAngle, defaultValue: 0, validate: x =&gt; true }); this.sweepAngle = (0, _utils.getFloat)({ data: attributes.sweepAngle, defaultValue: 360, validate: x =&gt; true }); this.use = attributes.use || &quot;&quot;; this.usehref = attributes.usehref || &quot;&quot;; this.edge = null; this.fill = null; } [_xfa_object.$toHTML]() { const edge = this.edge || new Edge({}); const edgeStyle = edge[_xfa_object.$toStyle](); const style = Object.create(null); if (this.fill &amp;&amp; this.fill.presence === &quot;visible&quot;) { Object.assign(style, this.fill[_xfa_object.$toStyle]()); } else { style.fill = &quot;transparent&quot;; } style.strokeWidth = (0, _html_utils.measureToString)(edge.presence === &quot;visible&quot; ? edge.thickness : 0); style.stroke = edgeStyle.color; let arc; const attributes = { xmlns: SVG_NS, style: { width: &quot;100%&quot;, height: &quot;100%&quot;, overflow: &quot;visible&quot; } }; if (this.sweepAngle === 360) { arc = { name: &quot;ellipse&quot;, attributes: { xmlns: SVG_NS, cx: &quot;50%&quot;, cy: &quot;50%&quot;, rx: &quot;50%&quot;, ry: &quot;50%&quot;, style } }; } else { const startAngle = this.startAngle * Math.PI / 180; const sweepAngle = this.sweepAngle * Math.PI / 180; const largeArc = this.sweepAngle &gt; 180 ? 1 : 0; const [x1, y1, x2, y2] = [50 * (1 + Math.cos(startAngle)), 50 * (1 - Math.sin(startAngle)), 50 * (1 + Math.cos(startAngle + sweepAngle)), 50 * (1 - Math.sin(startAngle + sweepAngle))]; arc = { name: &quot;path&quot;, attributes: { xmlns: SVG_NS, d: `M ${x1} ${y1} A 50 50 0 ${largeArc} 0 ${x2} ${y2}`, vectorEffect: &quot;non-scaling-stroke&quot;, style } }; Object.assign(attributes, { viewBox: &quot;0 0 100 100&quot;, preserveAspectRatio: &quot;none&quot; }); } const svg = { name: &quot;svg&quot;, children: [arc], attributes }; const parent = this[_xfa_object.$getParent]()[_xfa_object.$getParent](); if (hasMargin(parent)) { return _utils.HTMLResult.success({ name: &quot;div&quot;, attributes: { style: { display: &quot;inline&quot;, width: &quot;100%&quot;, height: &quot;100%&quot; } }, children: [svg] }); } svg.attributes.style.position = &quot;absolute&quot;; return _utils.HTMLResult.success(svg); } } class Area extends _xfa_object.XFAObject { constructor(attributes) { super(TEMPLATE_NS_ID, &quot;area&quot;, true); this.colSpan = (0, _utils.getInteger)({ data: attributes.colSpan, defaultValue: 1, validate: n =&gt; n &gt;= 1 || n === -1 }); this.id = attributes.id || &quot;&quot;; this.name = attributes.name || &quot;&quot;; this.relevant = (0, _utils.getRelevant)(attributes.relevant); this.use = attributes.use || &quot;&quot;; this.usehref = attributes.usehref || &quot;&quot;; this.x = (0, _utils.getMeasurement)(attributes.x, &quot;0pt&quot;); this.y = (0, _utils.getMeasurement)(attributes.y, &quot;0pt&quot;); this.desc = null; this.extras = null; this.area = new _xfa_object.XFAObjectArray(); this.draw = new _xfa_object.XFAObjectArray(); this.exObject = new _xfa_object.XFAObjectArray(); this.exclGroup = new _xfa_object.XFAObjectArray(); this.field = new _xfa_object.XFAObjectArray(); this.subform = new _xfa_object.XFAObjectArray(); this.subformSet = new _xfa_object.XFAObjectArray(); } *[_xfa_object.$getContainedChildren]() { yield* getContainedChildren(this); } [_xfa_object.$isTransparent]() { return true; } [_xfa_object.$isBindable]() { return true; } [_xfa_object.$addHTML](html, bbox) { const [x, y, w, h] = bbox; this[_xfa_object.$extra].width = Math.max(this[_xfa_object.$extra].width, x + w); this[_xfa_object.$extra].height = Math.max(this[_xfa_object.$extra].height, y + h); this[_xfa_object.$extra].children.push(html); } [_xfa_object.$getAvailableSpace]() { return this[_xfa_object.$extra].availableSpace; } [_xfa_object.$toHTML](availableSpace) { const style = (0, _html_utils.toStyle)(this, &quot;position&quot;); const attributes = { style, id: this[_xfa_object.$uid], class: [&quot;xfaArea&quot;] }; if ((0, _html_utils.isPrintOnly)(this)) { attributes.class.push(&quot;xfaPrintOnly&quot;); } if (this.name) { attributes.xfaName = this.name; } const children = []; this[_xfa_object.$extra] = { children, width: 0, height: 0, availableSpace }; const result = this[_xfa_object.$childrenToHTML]({ filter: new Set([&quot;area&quot;, &quot;draw&quot;, &quot;field&quot;, &quot;exclGroup&quot;, &quot;subform&quot;, &quot;subformSet&quot;]), include: true }); if (!result.success) { if (result.isBreak()) { return result; } delete this[_xfa_object.$extra]; return _utils.HTMLResult.FAILURE; } style.width = (0, _html_utils.measureToString)(this[_xfa_object.$extra].width); style.height = (0, _html_utils.measureToString)(this[_xfa_object.$extra].height); const html = { name: &quot;div&quot;, attributes, children }; const bbox = [this.x, this.y, this[_xfa_object.$extra].width, this[_xfa_object.$extra].height]; delete this[_xfa_object.$extra]; return _utils.HTMLResult.success(html, bbox); } } class Assist extends _xfa_object.XFAObject { constructor(attributes) { super(TEMPLATE_NS_ID, &quot;assist&quot;, true); this.id = attributes.id || &quot;&quot;; this.role = attributes.role || &quot;&quot;; this.use = attributes.use || &quot;&quot;; this.usehref = attributes.usehref || &quot;&quot;; this.speak = null; this.toolTip = null; } [_xfa_object.$toHTML]() { return this.toolTip &amp;&amp; this.toolTip[_xfa_object.$content] ? this.toolTip[_xfa_object.$content] : null; } } class Barcode extends _xfa_object.XFAObject { constructor(attributes) { super(TEMPLATE_NS_ID, &quot;barcode&quot;, true); this.charEncoding = (0, _utils.getKeyword)({ data: attributes.charEncoding ? attributes.charEncoding.toLowerCase() : &quot;&quot;, defaultValue: &quot;&quot;, validate: k =&gt; [&quot;utf-8&quot;, &quot;big-five&quot;, &quot;fontspecific&quot;, &quot;gbk&quot;, &quot;gb-18030&quot;, &quot;gb-2312&quot;, &quot;ksc-5601&quot;, &quot;none&quot;, &quot;shift-jis&quot;, &quot;ucs-2&quot;, &quot;utf-16&quot;].includes(k) || k.match(/iso-8859-\\d{2}/) }); this.checksum = (0, _utils.getStringOption)(attributes.checksum, [&quot;none&quot;, &quot;1mod10&quot;, &quot;1mod10_1mod11&quot;, &quot;2mod10&quot;, &quot;auto&quot;]); this.dataColumnCount = (0, _utils.getInteger)({ data: attributes.dataColumnCount, defaultValue: -1, validate: x =&gt; x &gt;= 0 }); this.dataLength = (0, _utils.getInteger)({ data: attributes.dataLength, defaultValue: -1, validate: x =&gt; x &gt;= 0 }); this.dataPrep = (0, _utils.getStringOption)(attributes.dataPrep, [&quot;none&quot;, &quot;flateCompress&quot;]); this.dataRowCount = (0, _utils.getInteger)({ data: attributes.dataRowCount, defaultValue: -1, validate: x =&gt; x &gt;= 0 }); this.endChar = attributes.endChar || &quot;&quot;; this.errorCorrectionLevel = (0, _utils.getInteger)({ data: attributes.errorCorrectionLevel, defaultValue: -1, validate: x =&gt; x &gt;= 0 &amp;&amp; x &lt;= 8 }); this.id = attributes.id || &quot;&quot;; this.moduleHeight = (0, _utils.getMeasurement)(attributes.moduleHeight, &quot;5mm&quot;); this.moduleWidth = (0, _utils.getMeasurement)(attributes.moduleWidth, &quot;0.25mm&quot;); this.printCheckDigit = (0, _utils.getInteger)({ data: attributes.printCheckDigit, defaultValue: 0, validate: x =&gt; x === 1 }); this.rowColumnRatio = (0, _utils.getRatio)(attributes.rowColumnRatio); this.startChar = attributes.startChar || &quot;&quot;; this.textLocation = (0, _utils.getStringOption)(attributes.textLocation, [&quot;below&quot;, &quot;above&quot;, &quot;aboveEmbedded&quot;, &quot;belowEmbedded&quot;, &quot;none&quot;]); this.truncate = (0, _utils.getInteger)({ data: attributes.truncate, defaultValue: 0, validate: x =&gt; x === 1 }); this.type = (0, _utils.getStringOption)(attributes.type ? attributes.type.toLowerCase() : &quot;&quot;, [&quot;aztec&quot;, &quot;codabar&quot;, &quot;code2of5industrial&quot;, &quot;code2of5interleaved&quot;, &quot;code2of5matrix&quot;, &quot;code2of5standard&quot;, &quot;code3of9&quot;, &quot;code3of9extended&quot;, &quot;code11&quot;, &quot;code49&quot;, &quot;code93&quot;, &quot;code128&quot;, &quot;code128a&quot;, &quot;code128b&quot;, &quot;code128c&quot;, &quot;code128sscc&quot;, &quot;datamatrix&quot;, &quot;ean8&quot;, &quot;ean8add2&quot;, &quot;ean8add5&quot;, &quot;ean13&quot;, &quot;ean13add2&quot;, &quot;ean13add5&quot;, &quot;ean13pwcd&quot;, &quot;fim&quot;, &quot;logmars&quot;, &quot;maxicode&quot;, &quot;msi&quot;, &quot;pdf417&quot;, &quot;pdf417macro&quot;, &quot;plessey&quot;, &quot;postauscust2&quot;, &quot;postauscust3&quot;, &quot;postausreplypaid&quot;, &quot;postausstandard&quot;, &quot;postukrm4scc&quot;, &quot;postusdpbc&quot;, &quot;postusimb&quot;, &quot;postusstandard&quot;, &quot;postus5zip&quot;, &quot;qrcode&quot;, &quot;rfid&quot;, &quot;rss14&quot;, &quot;rss14expanded&quot;, &quot;rss14limited&quot;, &quot;rss14stacked&quot;, &quot;rss14stackedomni&quot;, &quot;rss14truncated&quot;, &quot;telepen&quot;, &quot;ucc128&quot;, &quot;ucc128random&quot;, &quot;ucc128sscc&quot;, &quot;upca&quot;, &quot;upcaadd2&quot;, &quot;upcaadd5&quot;, &quot;upcapwcd&quot;, &quot;upce&quot;, &quot;upceadd2&quot;, &quot;upceadd5&quot;, &quot;upcean2&quot;, &quot;upcean5&quot;, &quot;upsmaxicode&quot;]); this.upsMode = (0, _utils.getStringOption)(attributes.upsMode, [&quot;usCarrier&quot;, &quot;internationalCarrier&quot;, &quot;secureSymbol&quot;, &quot;standardSymbol&quot;]); this.use = attributes.use || &quot;&quot;; this.usehref = attributes.usehref || &quot;&quot;; this.wideNarrowRatio = (0, _utils.getRatio)(attributes.wideNarrowRatio); this.encrypt = null; this.extras = null; } } class Bind extends _xfa_object.XFAObject { constructor(attributes) { super(TEMPLATE_NS_ID, &quot;bind&quot;, true); this.match = (0, _utils.getStringOption)(attributes.match, [&quot;once&quot;, &quot;dataRef&quot;, &quot;global&quot;, &quot;none&quot;]); this.ref = attributes.ref || &quot;&quot;; this.picture = null; } } class BindItems extends _xfa_object.XFAObject { constructor(attributes) { super(TEMPLATE_NS_ID, &quot;bindItems&quot;); this.connection = attributes.connection || &quot;&quot;; this.labelRef = attributes.labelRef || &quot;&quot;; this.ref = attributes.ref || &quot;&quot;; this.valueRef = attributes.valueRef || &quot;&quot;; } } exports.BindItems = BindItems; class Bookend extends _xfa_object.XFAObject { constructor(attributes) { super(TEMPLATE_NS_ID, &quot;bookend&quot;); this.id = attributes.id || &quot;&quot;; this.leader = attributes.leader || &quot;&quot;; this.trailer = attributes.trailer || &quot;&quot;; this.use = attributes.use || &quot;&quot;; this.usehref = attributes.usehref || &quot;&quot;; } } class BooleanElement extends _xfa_object.Option01 { constructor(attributes) { super(TEMPLATE_NS_ID, &quot;boolean&quot;); this.id = attributes.id || &quot;&quot;; this.name = attributes.name || &quot;&quot;; this.use = attributes.use || &quot;&quot;; this.usehref = attributes.usehref || &quot;&quot;; } [_xfa_object.$toHTML](availableSpace) { return valueToHtml(this[_xfa_object.$content] === 1 ? &quot;1&quot; : &quot;0&quot;); } } class Border extends _xfa_object.XFAObject { constructor(attributes) { super(TEMPLATE_NS_ID, &quot;border&quot;, true); this.break = (0, _utils.getStringOption)(attributes.break, [&quot;close&quot;, &quot;open&quot;]); this.hand = (0, _utils.getStringOption)(attributes.hand, [&quot;even&quot;, &quot;left&quot;, &quot;right&quot;]); this.id = attributes.id || &quot;&quot;; this.presence = (0, _utils.getStringOption)(attributes.presence, [&quot;visible&quot;, &quot;hidden&quot;, &quot;inactive&quot;, &quot;invisible&quot;]); this.relevant = (0, _utils.getRelevant)(attributes.relevant); this.use = attributes.use || &quot;&quot;; this.usehref = attributes.usehref || &quot;&quot;; this.corner = new _xfa_object.XFAObjectArray(4); this.edge = new _xfa_object.XFAObjectArray(4); this.extras = null; this.fill = null; this.margin = null; } [_xfa_object.$getExtra]() { if (!this[_xfa_object.$extra]) { const edges = this.edge.children.slice(); if (edges.length &lt; 4) { const defaultEdge = edges.at(-1) || new Edge({}); for (let i = edges.length; i &lt; 4; i++) { edges.push(defaultEdge); } } const widths = edges.map(edge =&gt; edge.thickness); const insets = [0, 0, 0, 0]; if (this.margin) { insets[0] = this.margin.topInset; insets[1] = this.margin.rightInset; insets[2] = this.margin.bottomInset; insets[3] = this.margin.leftInset; } this[_xfa_object.$extra] = { widths, insets, edges }; } return this[_xfa_object.$extra]; } [_xfa_object.$toStyle]() { const { edges } = this[_xfa_object.$getExtra](); const edgeStyles = edges.map(node =&gt; { const style = node[_xfa_object.$toStyle](); style.color = style.color || &quot;#000000&quot;; return style; }); const style = Object.create(null); if (this.margin) { Object.assign(style, this.margin[_xfa_object.$toStyle]()); } if (this.fill &amp;&amp; this.fill.presence === &quot;visible&quot;) { Object.assign(style, this.fill[_xfa_object.$toStyle]()); } if (this.corner.children.some(node =&gt; node.radius !== 0)) { const cornerStyles = this.corner.children.map(node =&gt; node[_xfa_object.$toStyle]()); if (cornerStyles.length === 2 || cornerStyles.length === 3) { const last = cornerStyles.at(-1); for (let i = cornerStyles.length; i &lt; 4; i++) { cornerStyles.push(last); } } style.borderRadius = cornerStyles.map(s =&gt; s.radius).join(&quot; &quot;); } switch (this.presence) { case &quot;invisible&quot;: case &quot;hidden&quot;: style.borderStyle = &quot;&quot;; break; case &quot;inactive&quot;: style.borderStyle = &quot;none&quot;; break; default: style.borderStyle = edgeStyles.map(s =&gt; s.style).join(&quot; &quot;); break; } style.borderWidth = edgeStyles.map(s =&gt; s.width).join(&quot; &quot;); style.borderColor = edgeStyles.map(s =&gt; s.color).join(&quot; &quot;); return style; } } class Break extends _xfa_object.XFAObject { constructor(attributes) { super(TEMPLATE_NS_ID, &quot;break&quot;, true); this.after = (0, _utils.getStringOption)(attributes.after, [&quot;auto&quot;, &quot;contentArea&quot;, &quot;pageArea&quot;, &quot;pageEven&quot;, &quot;pageOdd&quot;]); this.afterTarget = attributes.afterTarget || &quot;&quot;; this.before = (0, _utils.getStringOption)(attributes.before, [&quot;auto&quot;, &quot;contentArea&quot;, &quot;pageArea&quot;, &quot;pageEven&quot;, &quot;pageOdd&quot;]); this.beforeTarget = attributes.beforeTarget || &quot;&quot;; this.bookendLeader = attributes.bookendLeader || &quot;&quot;; this.bookendTrailer = attributes.bookendTrailer || &quot;&quot;; this.id = attributes.id || &quot;&quot;; this.overflowLeader = attributes.overflowLeader || &quot;&quot;; this.overflowTarget = attributes.overflowTarget || &quot;&quot;; this.overflowTrailer = attributes.overflowTrailer || &quot;&quot;; this.startNew = (0, _utils.getInteger)({ data: attributes.startNew, defaultValue: 0, validate: x =&gt; x === 1 }); this.use = attributes.use || &quot;&quot;; this.usehref = attributes.usehref || &quot;&quot;; this.extras = null; } } class BreakAfter extends _xfa_object.XFAObject { constructor(attributes) { super(TEMPLATE_NS_ID, &quot;breakAfter&quot;, true); this.id = attributes.id || &quot;&quot;; this.leader = attributes.leader || &quot;&quot;; this.startNew = (0, _utils.getInteger)({ data: attributes.startNew, defaultValue: 0, validate: x =&gt; x === 1 }); this.target = attributes.target || &quot;&quot;; this.targetType = (0, _utils.getStringOption)(attributes.targetType, [&quot;auto&quot;, &quot;contentArea&quot;, &quot;pageArea&quot;]); this.trailer = attributes.trailer || &quot;&quot;; this.use = attributes.use || &quot;&quot;; this.usehref = attributes.usehref || &quot;&quot;; this.script = null; } } class BreakBefore extends _xfa_object.XFAObject { constructor(attributes) { super(TEMPLATE_NS_ID, &quot;breakBefore&quot;, true); this.id = attributes.id || &quot;&quot;; this.leader = attributes.leader || &quot;&quot;; this.startNew = (0, _utils.getInteger)({ data: attributes.startNew, defaultValue: 0, validate: x =&gt; x === 1 }); this.target = attributes.target || &quot;&quot;; this.targetType = (0, _utils.getStringOption)(attributes.targetType, [&quot;auto&quot;, &quot;contentArea&quot;, &quot;pageArea&quot;]); this.trailer = attributes.trailer || &quot;&quot;; this.use = attributes.use || &quot;&quot;; this.usehref = attributes.usehref || &quot;&quot;; this.script = null; } [_xfa_object.$toHTML](availableSpace) { this[_xfa_object.$extra] = {}; return _utils.HTMLResult.FAILURE; } } class Button extends _xfa_object.XFAObject { constructor(attributes) { super(TEMPLATE_NS_ID, &quot;button&quot;, true); this.highlight = (0, _utils.getStringOption)(attributes.highlight, [&quot;inverted&quot;, &quot;none&quot;, &quot;outline&quot;, &quot;push&quot;]); this.id = attributes.id || &quot;&quot;; this.use = attributes.use || &quot;&quot;; this.usehref = attributes.usehref || &quot;&quot;; this.extras = null; } [_xfa_object.$toHTML](availableSpace) { const parent = this[_xfa_object.$getParent](); const grandpa = parent[_xfa_object.$getParent](); const htmlButton = { name: &quot;button&quot;, attributes: { id: this[_xfa_object.$uid], class: [&quot;xfaButton&quot;], style: {} }, children: [] }; for (const event of grandpa.event.children) { if (event.activity !== &quot;click&quot; || !event.script) { continue; } const jsURL = (0, _core_utils.recoverJsURL)(event.script[_xfa_object.$content]); if (!jsURL) { continue; } const href = (0, _html_utils.fixURL)(jsURL.url); if (!href) { continue; } htmlButton.children.push({ name: &quot;a&quot;, attributes: { id: &quot;link&quot; + this[_xfa_object.$uid], href, newWindow: jsURL.newWindow, class: [&quot;xfaLink&quot;], style: {} }, children: [] }); } return _utils.HTMLResult.success(htmlButton); } } class Calculate extends _xfa_object.XFAObject { constructor(attributes) { super(TEMPLATE_NS_ID, &quot;calculate&quot;, true); this.id = attributes.id || &quot;&quot;; this.override = (0, _utils.getStringOption)(attributes.override, [&quot;disabled&quot;, &quot;error&quot;, &quot;ignore&quot;, &quot;warning&quot;]); this.use = attributes.use || &quot;&quot;; this.usehref = attributes.usehref || &quot;&quot;; this.extras = null; this.message = null; this.script = null; } } class Caption extends _xfa_object.XFAObject { constructor(attributes) { super(TEMPLATE_NS_ID, &quot;caption&quot;, true); this.id = attributes.id || &quot;&quot;; this.placement = (0, _utils.getStringOption)(attributes.placement, [&quot;left&quot;, &quot;bottom&quot;, &quot;inline&quot;, &quot;right&quot;, &quot;top&quot;]); this.presence = (0, _utils.getStringOption)(attributes.presence, [&quot;visible&quot;, &quot;hidden&quot;, &quot;inactive&quot;, &quot;invisible&quot;]); this.reserve = Math.ceil((0, _utils.getMeasurement)(attributes.reserve)); this.use = attributes.use || &quot;&quot;; this.usehref = attributes.usehref || &quot;&quot;; this.extras = null; this.font = null; this.margin = null; this.para = null; this.value = null; } [_xfa_object.$setValue](value) { _setValue(this, value); } [_xfa_object.$getExtra](availableSpace) { if (!this[_xfa_object.$extra]) { let { width, height } = availableSpace; switch (this.placement) { case &quot;left&quot;: case &quot;right&quot;: case &quot;inline&quot;: width = this.reserve &lt;= 0 ? width : this.reserve; break; case &quot;top&quot;: case &quot;bottom&quot;: height = this.reserve &lt;= 0 ? height : this.reserve; break; } this[_xfa_object.$extra] = (0, _html_utils.layoutNode)(this, { width, height }); } return this[_xfa_object.$extra]; } [_xfa_object.$toHTML](availableSpace) { if (!this.value) { return _utils.HTMLResult.EMPTY; } this[_xfa_object.$pushPara](); const value = this.value[_xfa_object.$toHTML](availableSpace).html; if (!value) { this[_xfa_object.$popPara](); return _utils.HTMLResult.EMPTY; } const savedReserve = this.reserve; if (this.reserve &lt;= 0) { const { w, h } = this[_xfa_object.$getExtra](availableSpace); switch (this.placement) { case &quot;left&quot;: case &quot;right&quot;: case &quot;inline&quot;: this.reserve = w; break; case &quot;top&quot;: case &quot;bottom&quot;: this.reserve = h; break; } } const children = []; if (typeof value === &quot;string&quot;) { children.push({ name: &quot;#text&quot;, value }); } else { children.push(value); } const style = (0, _html_utils.toStyle)(this, &quot;font&quot;, &quot;margin&quot;, &quot;visibility&quot;); switch (this.placement) { case &quot;left&quot;: case &quot;right&quot;: if (this.reserve &gt; 0) { style.width = (0, _html_utils.measureToString)(this.reserve); } break; case &quot;top&quot;: case &quot;bottom&quot;: if (this.reserve &gt; 0) { style.height = (0, _html_utils.measureToString)(this.reserve); } break; } (0, _html_utils.setPara)(this, null, value); this[_xfa_object.$popPara](); this.reserve = savedReserve; return _utils.HTMLResult.success({ name: &quot;div&quot;, attributes: { style, class: [&quot;xfaCaption&quot;] }, children }); } } class Certificate extends _xfa_object.StringObject { constructor(attributes) { super(TEMPLATE_NS_ID, &quot;certificate&quot;); this.id = attributes.id || &quot;&quot;; this.name = attributes.name || &quot;&quot;; this.use = attributes.use || &quot;&quot;; this.usehref = attributes.usehref || &quot;&quot;; } } class Certificates extends _xfa_object.XFAObject { constructor(attributes) { super(TEMPLATE_NS_ID, &quot;certificates&quot;, true); this.credentialServerPolicy = (0, _utils.getStringOption)(attributes.credentialServerPolicy, [&quot;optional&quot;, &quot;required&quot;]); this.id = attributes.id || &quot;&quot;; this.url = attributes.url || &quot;&quot;; this.urlPolicy = attributes.urlPolicy || &quot;&quot;; this.use = attributes.use || &quot;&quot;; this.usehref = attributes.usehref || &quot;&quot;; this.encryption = null; this.issuers = null; this.keyUsage = null; this.oids = null; this.signing = null; this.subjectDNs = null; } } class CheckButton extends _xfa_object.XFAObject { constructor(attributes) { super(TEMPLATE_NS_ID, &quot;checkButton&quot;, true); this.id = attributes.id || &quot;&quot;; this.mark = (0, _utils.getStringOption)(attributes.mark, [&quot;default&quot;, &quot;check&quot;, &quot;circle&quot;, &quot;cross&quot;, &quot;diamond&quot;, &quot;square&quot;, &quot;star&quot;]); this.shape = (0, _utils.getStringOption)(attributes.shape, [&quot;square&quot;, &quot;round&quot;]); this.size = (0, _utils.getMeasurement)(attributes.size, &quot;10pt&quot;); this.use = attributes.use || &quot;&quot;; this.usehref = attributes.usehref || &quot;&quot;; this.border = null; this.extras = null; this.margin = null; } [_xfa_object.$toHTML](availableSpace) { const style = (0, _html_utils.toStyle)(&quot;margin&quot;); const size = (0, _html_utils.measureToString)(this.size); style.width = style.height = size; let type; let className; let groupId; const field = this[_xfa_object.$getParent]()[_xfa_object.$getParent](); const items = field.items.children.length &amp;&amp; field.items.children[0][_xfa_object.$toHTML]().html || []; const exportedValue = { on: (items[0] !== undefined ? items[0] : &quot;on&quot;).toString(), off: (items[1] !== undefined ? items[1] : &quot;off&quot;).toString() }; const value = field.value &amp;&amp; field.value[_xfa_object.$text]() || &quot;off&quot;; const checked = value === exportedValue.on || undefined; const container = field[_xfa_object.$getSubformParent](); const fieldId = field[_xfa_object.$uid]; let dataId; if (container instanceof ExclGroup) { groupId = container[_xfa_object.$uid]; type = &quot;radio&quot;; className = &quot;xfaRadio&quot;; dataId = container[_xfa_object.$data] &amp;&amp; container[_xfa_object.$data][_xfa_object.$uid] || container[_xfa_object.$uid]; } else { type = &quot;checkbox&quot;; className = &quot;xfaCheckbox&quot;; dataId = field[_xfa_object.$data] &amp;&amp; field[_xfa_object.$data][_xfa_object.$uid] || field[_xfa_object.$uid]; } const input = { name: &quot;input&quot;, attributes: { class: [className], style, fieldId, dataId, type, checked, xfaOn: exportedValue.on, xfaOff: exportedValue.off, &quot;aria-label&quot;: ariaLabel(field), &quot;aria-required&quot;: false } }; if (groupId) { input.attributes.name = groupId; } if (isRequired(field)) { input.attributes[&quot;aria-required&quot;] = true; input.attributes.required = true; } return _utils.HTMLResult.success({ name: &quot;label&quot;, attributes: { class: [&quot;xfaLabel&quot;] }, children: [input] }); } } class ChoiceList extends _xfa_object.XFAObject { constructor(attributes) { super(TEMPLATE_NS_ID, &quot;choiceList&quot;, true); this.commitOn = (0, _utils.getStringOption)(attributes.commitOn, [&quot;select&quot;, &quot;exit&quot;]); this.id = attributes.id || &quot;&quot;; this.open = (0, _utils.getStringOption)(attributes.open, [&quot;userControl&quot;, &quot;always&quot;, &quot;multiSelect&quot;, &quot;onEntry&quot;]); this.textEntry = (0, _utils.getInteger)({ data: attributes.textEntry, defaultValue: 0, validate: x =&gt; x === 1 }); this.use = attributes.use || &quot;&quot;; this.usehref = attributes.usehref || &quot;&quot;; this.border = null; this.extras = null; this.margin = null; } [_xfa_object.$toHTML](availableSpace) { const style = (0, _html_utils.toStyle)(this, &quot;border&quot;, &quot;margin&quot;); const ui = this[_xfa_object.$getParent](); const field = ui[_xfa_object.$getParent](); const fontSize = field.font &amp;&amp; field.font.size || 10; const optionStyle = { fontSize: `calc(${fontSize}px * var(--scale-factor))` }; const children = []; if (field.items.children.length &gt; 0) { const items = field.items; let displayedIndex = 0; let saveIndex = 0; if (items.children.length === 2) { displayedIndex = items.children[0].save; saveIndex = 1 - displayedIndex; } const displayed = items.children[displayedIndex][_xfa_object.$toHTML]().html; const values = items.children[saveIndex][_xfa_object.$toHTML]().html; let selected = false; const value = field.value &amp;&amp; field.value[_xfa_object.$text]() || &quot;&quot;; for (let i = 0, ii = displayed.length; i &lt; ii; i++) { const option = { name: &quot;option&quot;, attributes: { value: values[i] || displayed[i], style: optionStyle }, value: displayed[i] }; if (values[i] === value) { option.attributes.selected = selected = true; } children.push(option); } if (!selected) { children.splice(0, 0, { name: &quot;option&quot;, attributes: { hidden: true, selected: true }, value: &quot; &quot; }); } } const selectAttributes = { class: [&quot;xfaSelect&quot;], fieldId: field[_xfa_object.$uid], dataId: field[_xfa_object.$data] &amp;&amp; field[_xfa_object.$data][_xfa_object.$uid] || field[_xfa_object.$uid], style, &quot;aria-label&quot;: ariaLabel(field), &quot;aria-required&quot;: false }; if (isRequired(field)) { selectAttributes[&quot;aria-required&quot;] = true; selectAttributes.required = true; } if (this.open === &quot;multiSelect&quot;) { selectAttributes.multiple = true; } return _utils.HTMLResult.success({ name: &quot;label&quot;, attributes: { class: [&quot;xfaLabel&quot;] }, children: [{ name: &quot;select&quot;, children, attributes: selectAttributes }] }); } } class Color extends _xfa_object.XFAObject { constructor(attributes) { super(TEMPLATE_NS_ID, &quot;color&quot;, true); this.cSpace = (0, _utils.getStringOption)(attributes.cSpace, [&quot;SRGB&quot;]); this.id = attributes.id || &quot;&quot;; this.use = attributes.use || &quot;&quot;; this.usehref = attributes.usehref || &quot;&quot;; this.value = attributes.value ? (0, _utils.getColor)(attributes.value) : &quot;&quot;; this.extras = null; } [_xfa_object.$hasSettableValue]() { return false; } [_xfa_object.$toStyle]() { return this.value ? _util.Util.makeHexColor(this.value.r, this.value.g, this.value.b) : null; } } class Comb extends _xfa_object.XFAObject { constructor(attributes) { super(TEMPLATE_NS_ID, &quot;comb&quot;); this.id = attributes.id || &quot;&quot;; this.numberOfCells = (0, _utils.getInteger)({ data: attributes.numberOfCells, defaultValue: 0, validate: x =&gt; x &gt;= 0 }); this.use = attributes.use || &quot;&quot;; this.usehref = attributes.usehref || &quot;&quot;; } } class Connect extends _xfa_object.XFAObject { constructor(attributes) { super(TEMPLATE_NS_ID, &quot;connect&quot;, true); this.connection = attributes.connection || &quot;&quot;; this.id = attributes.id || &quot;&quot;; this.ref = attributes.ref || &quot;&quot;; this.usage = (0, _utils.getStringOption)(attributes.usage, [&quot;exportAndImport&quot;, &quot;exportOnly&quot;, &quot;importOnly&quot;]); this.use = attributes.use || &quot;&quot;; this.usehref = attributes.usehref || &quot;&quot;; this.picture = null; } } class ContentArea extends _xfa_object.XFAObject { constructor(attributes) { super(TEMPLATE_NS_ID, &quot;contentArea&quot;, true); this.h = (0, _utils.getMeasurement)(attributes.h); this.id = attributes.id || &quot;&quot;; this.name = attributes.name || &quot;&quot;; this.relevant = (0, _utils.getRelevant)(attributes.relevant); this.use = attributes.use || &quot;&quot;; this.usehref = attributes.usehref || &quot;&quot;; this.w = (0, _utils.getMeasurement)(attributes.w); this.x = (0, _utils.getMeasurement)(attributes.x, &quot;0pt&quot;); this.y = (0, _utils.getMeasurement)(attributes.y, &quot;0pt&quot;); this.desc = null; this.extras = null; } [_xfa_object.$toHTML](availableSpace) { const left = (0, _html_utils.measureToString)(this.x); const top = (0, _html_utils.measureToString)(this.y); const style = { left, top, width: (0, _html_utils.measureToString)(this.w), height: (0, _html_utils.measureToString)(this.h) }; const classNames = [&quot;xfaContentarea&quot;]; if ((0, _html_utils.isPrintOnly)(this)) { classNames.push(&quot;xfaPrintOnly&quot;); } return _utils.HTMLResult.success({ name: &quot;div&quot;, children: [], attributes: { style, class: classNames, id: this[_xfa_object.$uid] } }); } } class Corner extends _xfa_object.XFAObject { constructor(attributes) { super(TEMPLATE_NS_ID, &quot;corner&quot;, true); this.id = attributes.id || &quot;&quot;; this.inverted = (0, _utils.getInteger)({ data: attributes.inverted, defaultValue: 0, validate: x =&gt; x === 1 }); this.join = (0, _utils.getStringOption)(attributes.join, [&quot;square&quot;, &quot;round&quot;]); this.presence = (0, _utils.getStringOption)(attributes.presence, [&quot;visible&quot;, &quot;hidden&quot;, &quot;inactive&quot;, &quot;invisible&quot;]); this.radius = (0, _utils.getMeasurement)(attributes.radius); this.stroke = (0, _utils.getStringOption)(attributes.stroke, [&quot;solid&quot;, &quot;dashDot&quot;, &quot;dashDotDot&quot;, &quot;dashed&quot;, &quot;dotted&quot;, &quot;embossed&quot;, &quot;etched&quot;, &quot;lowered&quot;, &quot;raised&quot;]); this.thickness = (0, _utils.getMeasurement)(attributes.thickness, &quot;0.5pt&quot;); this.use = attributes.use || &quot;&quot;; this.usehref = attributes.usehref || &quot;&quot;; this.color = null; this.extras = null; } [_xfa_object.$toStyle]() { const style = (0, _html_utils.toStyle)(this, &quot;visibility&quot;); style.radius = (0, _html_utils.measureToString)(this.join === &quot;square&quot; ? 0 : this.radius); return style; } } class DateElement extends _xfa_object.ContentObject { constructor(attributes) { super(TEMPLATE_NS_ID, &quot;date&quot;); this.id = attributes.id || &quot;&quot;; this.name = attributes.name || &quot;&quot;; this.use = attributes.use || &quot;&quot;; this.usehref = attributes.usehref || &quot;&quot;; } [_xfa_object.$finalize]() { const date = this[_xfa_object.$content].trim(); this[_xfa_object.$content] = date ? new Date(date) : null; } [_xfa_object.$toHTML](availableSpace) { return valueToHtml(this[_xfa_object.$content] ? this[_xfa_object.$content].toString() : &quot;&quot;); } } class DateTime extends _xfa_object.ContentObject { constructor(attributes) { super(TEMPLATE_NS_ID, &quot;dateTime&quot;); this.id = attributes.id || &quot;&quot;; this.name = attributes.name || &quot;&quot;; this.use = attributes.use || &quot;&quot;; this.usehref = attributes.usehref || &quot;&quot;; } [_xfa_object.$finalize]() { const date = this[_xfa_object.$content].trim(); this[_xfa_object.$content] = date ? new Date(date) : null; } [_xfa_object.$toHTML](availableSpace) { return valueToHtml(this[_xfa_object.$content] ? this[_xfa_object.$content].toString() : &quot;&quot;); } } class DateTimeEdit extends _xfa_object.XFAObject { constructor(attributes) { super(TEMPLATE_NS_ID, &quot;dateTimeEdit&quot;, true); this.hScrollPolicy = (0, _utils.getStringOption)(attributes.hScrollPolicy, [&quot;auto&quot;, &quot;off&quot;, &quot;on&quot;]); this.id = attributes.id || &quot;&quot;; this.picker = (0, _utils.getStringOption)(attributes.picker, [&quot;host&quot;, &quot;none&quot;]); this.use = attributes.use || &quot;&quot;; this.usehref = attributes.usehref || &quot;&quot;; this.border = null; this.comb = null; this.extras = null; this.margin = null; } [_xfa_object.$toHTML](availableSpace) { const style = (0, _html_utils.toStyle)(this, &quot;border&quot;, &quot;font&quot;, &quot;margin&quot;); const field = this[_xfa_object.$getParent]()[_xfa_object.$getParent](); const html = { name: &quot;input&quot;, attributes: { type: &quot;text&quot;, fieldId: field[_xfa_object.$uid], dataId: field[_xfa_object.$data] &amp;&amp; field[_xfa_object.$data][_xfa_object.$uid] || field[_xfa_object.$uid], class: [&quot;xfaTextfield&quot;], style, &quot;aria-label&quot;: ariaLabel(field), &quot;aria-required&quot;: false } }; if (isRequired(field)) { html.attributes[&quot;aria-required&quot;] = true; html.attributes.required = true; } return _utils.HTMLResult.success({ name: &quot;label&quot;, attributes: { class: [&quot;xfaLabel&quot;] }, children: [html] }); } } class Decimal extends _xfa_object.ContentObject { constructor(attributes) { super(TEMPLATE_NS_ID, &quot;decimal&quot;); this.fracDigits = (0, _utils.getInteger)({ data: attributes.fracDigits, defaultValue: 2, validate: x =&gt; true }); this.id = attributes.id || &quot;&quot;; this.leadDigits = (0, _utils.getInteger)({ data: attributes.leadDigits, defaultValue: -1, validate: x =&gt; true }); this.name = attributes.name || &quot;&quot;; this.use = attributes.use || &quot;&quot;; this.usehref = attributes.usehref || &quot;&quot;; } [_xfa_object.$finalize]() { const number = parseFloat(this[_xfa_object.$content].trim()); this[_xfa_object.$content] = isNaN(number) ? null : number; } [_xfa_object.$toHTML](availableSpace) { return valueToHtml(this[_xfa_object.$content] !== null ? this[_xfa_object.$content].toString() : &quot;&quot;); } } class DefaultUi extends _xfa_object.XFAObject { constructor(attributes) { super(TEMPLATE_NS_ID, &quot;defaultUi&quot;, true); this.id = attributes.id || &quot;&quot;; this.use = attributes.use || &quot;&quot;; this.usehref = attributes.usehref || &quot;&quot;; this.extras = null; } } class Desc extends _xfa_object.XFAObject { constructor(attributes) { super(TEMPLATE_NS_ID, &quot;desc&quot;, true); this.id = attributes.id || &quot;&quot;; this.use = attributes.use || &quot;&quot;; this.usehref = attributes.usehref || &quot;&quot;; this.boolean = new _xfa_object.XFAObjectArray(); this.date = new _xfa_object.XFAObjectArray(); this.dateTime = new _xfa_object.XFAObjectArray(); this.decimal = new _xfa_object.XFAObjectArray(); this.exData = new _xfa_object.XFAObjectArray(); this.float = new _xfa_object.XFAObjectArray(); this.image = new _xfa_object.XFAObjectArray(); this.integer = new _xfa_object.XFAObjectArray(); this.text = new _xfa_object.XFAObjectArray(); this.time = new _xfa_object.XFAObjectArray(); } } class DigestMethod extends _xfa_object.OptionObject { constructor(attributes) { super(TEMPLATE_NS_ID, &quot;digestMethod&quot;, [&quot;&quot;, &quot;SHA1&quot;, &quot;SHA256&quot;, &quot;SHA512&quot;, &quot;RIPEMD160&quot;]); this.id = attributes.id || &quot;&quot;; this.use = attributes.use || &quot;&quot;; this.usehref = attributes.usehref || &quot;&quot;; } } class DigestMethods extends _xfa_object.XFAObject { constructor(attributes) { super(TEMPLATE_NS_ID, &quot;digestMethods&quot;, true); this.id = attributes.id || &quot;&quot;; this.type = (0, _utils.getStringOption)(attributes.type, [&quot;optional&quot;, &quot;required&quot;]); this.use = attributes.use || &quot;&quot;; this.usehref = attributes.usehref || &quot;&quot;; this.digestMethod = new _xfa_object.XFAObjectArray(); } } class Draw extends _xfa_object.XFAObject { constructor(attributes) { super(TEMPLATE_NS_ID, &quot;draw&quot;, true); this.anchorType = (0, _utils.getStringOption)(attributes.anchorType, [&quot;topLeft&quot;, &quot;bottomCenter&quot;, &quot;bottomLeft&quot;, &quot;bottomRight&quot;, &quot;middleCenter&quot;, &quot;middleLeft&quot;, &quot;middleRight&quot;, &quot;topCenter&quot;, &quot;topRight&quot;]); this.colSpan = (0, _utils.getInteger)({ data: attributes.colSpan, defaultValue: 1, validate: n =&gt; n &gt;= 1 || n === -1 }); this.h = attributes.h ? (0, _utils.getMeasurement)(attributes.h) : &quot;&quot;; this.hAlign = (0, _utils.getStringOption)(attributes.hAlign, [&quot;left&quot;, &quot;center&quot;, &quot;justify&quot;, &quot;justifyAll&quot;, &quot;radix&quot;, &quot;right&quot;]); this.id = attributes.id || &quot;&quot;; this.locale = attributes.locale || &quot;&quot;; this.maxH = (0, _utils.getMeasurement)(attributes.maxH, &quot;0pt&quot;); this.maxW = (0, _utils.getMeasurement)(attributes.maxW, &quot;0pt&quot;); this.minH = (0, _utils.getMeasurement)(attributes.minH, &quot;0pt&quot;); this.minW = (0, _utils.getMeasurement)(attributes.minW, &quot;0pt&quot;); this.name = attributes.name || &quot;&quot;; this.presence = (0, _utils.getStringOption)(attributes.presence, [&quot;visible&quot;, &quot;hidden&quot;, &quot;inactive&quot;, &quot;invisible&quot;]); this.relevant = (0, _utils.getRelevant)(attributes.relevant); this.rotate = (0, _utils.getInteger)({ data: attributes.rotate, defaultValue: 0, validate: x =&gt; x % 90 === 0 }); this.use = attributes.use || &quot;&quot;; this.usehref = attributes.usehref || &quot;&quot;; this.w = attributes.w ? (0, _utils.getMeasurement)(attributes.w) : &quot;&quot;; this.x = (0, _utils.getMeasurement)(attributes.x, &quot;0pt&quot;); this.y = (0, _utils.getMeasurement)(attributes.y, &quot;0pt&quot;); this.assist = null; this.border = null; this.caption = null; this.desc = null; this.extras = null; this.font = null; this.keep = null; this.margin = null; this.para = null; this.traversal = null; this.ui = null; this.value = null; this.setProperty = new _xfa_object.XFAObjectArray(); } [_xfa_object.$setValue](value) { _setValue(this, value); } [_xfa_object.$toHTML](availableSpace) { setTabIndex(this); if (this.presence === &quot;hidden&quot; || this.presence === &quot;inactive&quot;) { return _utils.HTMLResult.EMPTY; } (0, _html_utils.fixDimensions)(this); this[_xfa_object.$pushPara](); const savedW = this.w; const savedH = this.h; const { w, h, isBroken } = (0, _html_utils.layoutNode)(this, availableSpace); if (w &amp;&amp; this.w === &quot;&quot;) { if (isBroken &amp;&amp; this[_xfa_object.$getSubformParent]()[_xfa_object.$isThereMoreWidth]()) { this[_xfa_object.$popPara](); return _utils.HTMLResult.FAILURE; } this.w = w; } if (h &amp;&amp; this.h === &quot;&quot;) { this.h = h; } setFirstUnsplittable(this); if (!(0, _layout.checkDimensions)(this, availableSpace)) { this.w = savedW; this.h = savedH; this[_xfa_object.$popPara](); return _utils.HTMLResult.FAILURE; } unsetFirstUnsplittable(this); const style = (0, _html_utils.toStyle)(this, &quot;font&quot;, &quot;hAlign&quot;, &quot;dimensions&quot;, &quot;position&quot;, &quot;presence&quot;, &quot;rotate&quot;, &quot;anchorType&quot;, &quot;border&quot;, &quot;margin&quot;); (0, _html_utils.setMinMaxDimensions)(this, style); if (style.margin) { style.padding = style.margin; delete style.margin; } const classNames = [&quot;xfaDraw&quot;]; if (this.font) { classNames.push(&quot;xfaFont&quot;); } if ((0, _html_utils.isPrintOnly)(this)) { classNames.push(&quot;xfaPrintOnly&quot;); } const attributes = { style, id: this[_xfa_object.$uid], class: classNames }; if (this.name) { attributes.xfaName = this.name; } const html = { name: &quot;div&quot;, attributes, children: [] }; applyAssist(this, attributes); const bbox = (0, _html_utils.computeBbox)(this, html, availableSpace); const value = this.value ? this.value[_xfa_object.$toHTML](availableSpace).html : null; if (value === null) { this.w = savedW; this.h = savedH; this[_xfa_object.$popPara](); return _utils.HTMLResult.success((0, _html_utils.createWrapper)(this, html), bbox); } html.children.push(value); (0, _html_utils.setPara)(this, style, value); this.w = savedW; this.h = savedH; this[_xfa_object.$popPara](); return _utils.HTMLResult.success((0, _html_utils.createWrapper)(this, html), bbox); } } class Edge extends _xfa_object.XFAObject { constructor(attributes) { super(TEMPLATE_NS_ID, &quot;edge&quot;, true); this.cap = (0, _utils.getStringOption)(attributes.cap, [&quot;square&quot;, &quot;butt&quot;, &quot;round&quot;]); this.id = attributes.id || &quot;&quot;; this.presence = (0, _utils.getStringOption)(attributes.presence, [&quot;visible&quot;, &quot;hidden&quot;, &quot;inactive&quot;, &quot;invisible&quot;]); this.stroke = (0, _utils.getStringOption)(attributes.stroke, [&quot;solid&quot;, &quot;dashDot&quot;, &quot;dashDotDot&quot;, &quot;dashed&quot;, &quot;dotted&quot;, &quot;embossed&quot;, &quot;etched&quot;, &quot;lowered&quot;, &quot;raised&quot;]); this.thickness = (0, _utils.getMeasurement)(attributes.thickness, &quot;0.5pt&quot;); this.use = attributes.use || &quot;&quot;; this.usehref = attributes.usehref || &quot;&quot;; this.color = null; this.extras = null; } [_xfa_object.$toStyle]() { const style = (0, _html_utils.toStyle)(this, &quot;visibility&quot;); Object.assign(style, { linecap: this.cap, width: (0, _html_utils.measureToString)(this.thickness), color: this.color ? this.color[_xfa_object.$toStyle]() : &quot;#000000&quot;, style: &quot;&quot; }); if (this.presence !== &quot;visible&quot;) { style.style = &quot;none&quot;; } else { switch (this.stroke) { case &quot;solid&quot;: style.style = &quot;solid&quot;; break; case &quot;dashDot&quot;: style.style = &quot;dashed&quot;; break; case &quot;dashDotDot&quot;: style.style = &quot;dashed&quot;; break; case &quot;dashed&quot;: style.style = &quot;dashed&quot;; break; case &quot;dotted&quot;: style.style = &quot;dotted&quot;; break; case &quot;embossed&quot;: style.style = &quot;ridge&quot;; break; case &quot;etched&quot;: style.style = &quot;groove&quot;; break; case &quot;lowered&quot;: style.style = &quot;inset&quot;; break; case &quot;raised&quot;: style.style = &quot;outset&quot;; break; } } return style; } } class Encoding extends _xfa_object.OptionObject { constructor(attributes) { super(TEMPLATE_NS_ID, &quot;encoding&quot;, [&quot;adbe.x509.rsa_sha1&quot;, &quot;adbe.pkcs7.detached&quot;, &quot;adbe.pkcs7.sha1&quot;]); this.id = attributes.id || &quot;&quot;; this.use = attributes.use || &quot;&quot;; this.usehref = attributes.usehref || &quot;&quot;; } } class Encodings extends _xfa_object.XFAObject { constructor(attributes) { super(TEMPLATE_NS_ID, &quot;encodings&quot;, true); this.id = attributes.id || &quot;&quot;; this.type = (0, _utils.getStringOption)(attributes.type, [&quot;optional&quot;, &quot;required&quot;]); this.use = attributes.use || &quot;&quot;; this.usehref = attributes.usehref || &quot;&quot;; this.encoding = new _xfa_object.XFAObjectArray(); } } class Encrypt extends _xfa_object.XFAObject { constructor(attributes) { super(TEMPLATE_NS_ID, &quot;encrypt&quot;, true); this.id = attributes.id || &quot;&quot;; this.use = attributes.use || &quot;&quot;; this.usehref = attributes.usehref || &quot;&quot;; this.certificate = null; } } class EncryptData extends _xfa_object.XFAObject { constructor(attributes) { super(TEMPLATE_NS_ID, &quot;encryptData&quot;, true); this.id = attributes.id || &quot;&quot;; this.operation = (0, _utils.getStringOption)(attributes.operation, [&quot;encrypt&quot;, &quot;decrypt&quot;]); this.target = attributes.target || &quot;&quot;; this.use = attributes.use || &quot;&quot;; this.usehref = attributes.usehref || &quot;&quot;; this.filter = null; this.manifest = null; } } class Encryption extends _xfa_object.XFAObject { constructor(attributes) { super(TEMPLATE_NS_ID, &quot;encryption&quot;, true); this.id = attributes.id || &quot;&quot;; this.type = (0, _utils.getStringOption)(attributes.type, [&quot;optional&quot;, &quot;required&quot;]); this.use = attributes.use || &quot;&quot;; this.usehref = attributes.usehref || &quot;&quot;; this.certificate = new _xfa_object.XFAObjectArray(); } } class EncryptionMethod extends _xfa_object.OptionObject { constructor(attributes) { super(TEMPLATE_NS_ID, &quot;encryptionMethod&quot;, [&quot;&quot;, &quot;AES256-CBC&quot;, &quot;TRIPLEDES-CBC&quot;, &quot;AES128-CBC&quot;, &quot;AES192-CBC&quot;]); this.id = attributes.id || &quot;&quot;; this.use = attributes.use || &quot;&quot;; this.usehref = attributes.usehref || &quot;&quot;; } } class EncryptionMethods extends _xfa_object.XFAObject { constructor(attributes) { super(TEMPLATE_NS_ID, &quot;encryptionMethods&quot;, true); this.id = attributes.id || &quot;&quot;; this.type = (0, _utils.getStringOption)(attributes.type, [&quot;optional&quot;, &quot;required&quot;]); this.use = attributes.use || &quot;&quot;; this.usehref = attributes.usehref || &quot;&quot;; this.encryptionMethod = new _xfa_object.XFAObjectArray(); } } class Event extends _xfa_object.XFAObject { constructor(attributes) { super(TEMPLATE_NS_ID, &quot;event&quot;, true); this.activity = (0, _utils.getStringOption)(attributes.activity, [&quot;click&quot;, &quot;change&quot;, &quot;docClose&quot;, &quot;docReady&quot;, &quot;enter&quot;, &quot;exit&quot;, &quot;full&quot;, &quot;indexChange&quot;, &quot;initialize&quot;, &quot;mouseDown&quot;, &quot;mouseEnter&quot;, &quot;mouseExit&quot;, &quot;mouseUp&quot;, &quot;postExecute&quot;, &quot;postOpen&quot;, &quot;postPrint&quot;, &quot;postSave&quot;, &quot;postSign&quot;, &quot;postSubmit&quot;, &quot;preExecute&quot;, &quot;preOpen&quot;, &quot;prePrint&quot;, &quot;preSave&quot;, &quot;preSign&quot;, &quot;preSubmit&quot;, &quot;ready&quot;, &quot;validationState&quot;]); this.id = attributes.id || &quot;&quot;; this.listen = (0, _utils.getStringOption)(attributes.listen, [&quot;refOnly&quot;, &quot;refAndDescendents&quot;]); this.name = attributes.name || &quot;&quot;; this.ref = attributes.ref || &quot;&quot;; this.use = attributes.use || &quot;&quot;; this.usehref = attributes.usehref || &quot;&quot;; this.extras = null; this.encryptData = null; this.execute = null; this.script = null; this.signData = null; this.submit = null; } } class ExData extends _xfa_object.ContentObject { constructor(attributes) { super(TEMPLATE_NS_ID, &quot;exData&quot;); this.contentType = attributes.contentType || &quot;&quot;; this.href = attributes.href || &quot;&quot;; this.id = attributes.id || &quot;&quot;; this.maxLength = (0, _utils.getInteger)({ data: attributes.maxLength, defaultValue: -1, validate: x =&gt; x &gt;= -1 }); this.name = attributes.name || &quot;&quot;; this.rid = attributes.rid || &quot;&quot;; this.transferEncoding = (0, _utils.getStringOption)(attributes.transferEncoding, [&quot;none&quot;, &quot;base64&quot;, &quot;package&quot;]); this.use = attributes.use || &quot;&quot;; this.usehref = attributes.usehref || &quot;&quot;; } [_xfa_object.$isCDATAXml]() { return this.contentType === &quot;text/html&quot;; } [_xfa_object.$onChild](child) { if (this.contentType === &quot;text/html&quot; &amp;&amp; child[_xfa_object.$namespaceId] === _namespaces.NamespaceIds.xhtml.id) { this[_xfa_object.$content] = child; return true; } if (this.contentType === &quot;text/xml&quot;) { this[_xfa_object.$content] = child; return true; } return false; } [_xfa_object.$toHTML](availableSpace) { if (this.contentType !== &quot;text/html&quot; || !this[_xfa_object.$content]) { return _utils.HTMLResult.EMPTY; } return this[_xfa_object.$content][_xfa_object.$toHTML](availableSpace); } } class ExObject extends _xfa_object.XFAObject { constructor(attributes) { super(TEMPLATE_NS_ID, &quot;exObject&quot;, true); this.archive = attributes.archive || &quot;&quot;; this.classId = attributes.classId || &quot;&quot;; this.codeBase = attributes.codeBase || &quot;&quot;; this.codeType = attributes.codeType || &quot;&quot;; this.id = attributes.id || &quot;&quot;; this.name = attributes.name || &quot;&quot;; this.use = attributes.use || &quot;&quot;; this.usehref = attributes.usehref || &quot;&quot;; this.extras = null; this.boolean = new _xfa_object.XFAObjectArray(); this.date = new _xfa_object.XFAObjectArray(); this.dateTime = new _xfa_object.XFAObjectArray(); this.decimal = new _xfa_object.XFAObjectArray(); this.exData = new _xfa_object.XFAObjectArray(); this.exObject = new _xfa_object.XFAObjectArray(); this.float = new _xfa_object.XFAObjectArray(); this.image = new _xfa_object.XFAObjectArray(); this.integer = new _xfa_object.XFAObjectArray(); this.text = new _xfa_object.XFAObjectArray(); this.time = new _xfa_object.XFAObjectArray(); } } class ExclGroup extends _xfa_object.XFAObject { constructor(attributes) { super(TEMPLATE_NS_ID, &quot;exclGroup&quot;, true); this.access = (0, _utils.getStringOption)(attributes.access, [&quot;open&quot;, &quot;nonInteractive&quot;, &quot;protected&quot;, &quot;readOnly&quot;]); this.accessKey = attributes.accessKey || &quot;&quot;; this.anchorType = (0, _utils.getStringOption)(attributes.anchorType, [&quot;topLeft&quot;, &quot;bottomCenter&quot;, &quot;bottomLeft&quot;, &quot;bottomRight&quot;, &quot;middleCenter&quot;, &quot;middleLeft&quot;, &quot;middleRight&quot;, &quot;topCenter&quot;, &quot;topRight&quot;]); this.colSpan = (0, _utils.getInteger)({ data: attributes.colSpan, defaultValue: 1, validate: n =&gt; n &gt;= 1 || n === -1 }); this.h = attributes.h ? (0, _utils.getMeasurement)(attributes.h) : &quot;&quot;; this.hAlign = (0, _utils.getStringOption)(attributes.hAlign, [&quot;left&quot;, &quot;center&quot;, &quot;justify&quot;, &quot;justifyAll&quot;, &quot;radix&quot;, &quot;right&quot;]); this.id = attributes.id || &quot;&quot;; this.layout = (0, _utils.getStringOption)(attributes.layout, [&quot;position&quot;, &quot;lr-tb&quot;, &quot;rl-row&quot;, &quot;rl-tb&quot;, &quot;row&quot;, &quot;table&quot;, &quot;tb&quot;]); this.maxH = (0, _utils.getMeasurement)(attributes.maxH, &quot;0pt&quot;); this.maxW = (0, _utils.getMeasurement)(attributes.maxW, &quot;0pt&quot;); this.minH = (0, _utils.getMeasurement)(attributes.minH, &quot;0pt&quot;); this.minW = (0, _utils.getMeasurement)(attributes.minW, &quot;0pt&quot;); this.name = attributes.name || &quot;&quot;; this.presence = (0, _utils.getStringOption)(attributes.presence, [&quot;visible&quot;, &quot;hidden&quot;, &quot;inactive&quot;, &quot;invisible&quot;]); this.relevant = (0, _utils.getRelevant)(attributes.relevant); this.use = attributes.use || &quot;&quot;; this.usehref = attributes.usehref || &quot;&quot;; this.w = attributes.w ? (0, _utils.getMeasurement)(attributes.w) : &quot;&quot;; this.x = (0, _utils.getMeasurement)(attributes.x, &quot;0pt&quot;); this.y = (0, _utils.getMeasurement)(attributes.y, &quot;0pt&quot;); this.assist = null; this.bind = null; this.border = null; this.calculate = null; this.caption = null; this.desc = null; this.extras = null; this.margin = null; this.para = null; this.traversal = null; this.validate = null; this.connect = new _xfa_object.XFAObjectArray(); this.event = new _xfa_object.XFAObjectArray(); this.field = new _xfa_object.XFAObjectArray(); this.setProperty = new _xfa_object.XFAObjectArray(); } [_xfa_object.$isBindable]() { return true; } [_xfa_object.$hasSettableValue]() { return true; } [_xfa_object.$setValue](value) { for (const field of this.field.children) { if (!field.value) { const nodeValue = new Value({}); field[_xfa_object.$appendChild](nodeValue); field.value = nodeValue; } field.value[_xfa_object.$setValue](value); } } [_xfa_object.$isThereMoreWidth]() { return this.layout.endsWith(&quot;-tb&quot;) &amp;&amp; this[_xfa_object.$extra].attempt === 0 &amp;&amp; this[_xfa_object.$extra].numberInLine &gt; 0 || this[_xfa_object.$getParent]()[_xfa_object.$isThereMoreWidth](); } [_xfa_object.$isSplittable]() { const parent = this[_xfa_object.$getSubformParent](); if (!parent[_xfa_object.$isSplittable]()) { return false; } if (this[_xfa_object.$extra]._isSplittable !== undefined) { return this[_xfa_object.$extra]._isSplittable; } if (this.layout === &quot;position&quot; || this.layout.includes(&quot;row&quot;)) { this[_xfa_object.$extra]._isSplittable = false; return false; } if (parent.layout &amp;&amp; parent.layout.endsWith(&quot;-tb&quot;) &amp;&amp; parent[_xfa_object.$extra].numberInLine !== 0) { return false; } this[_xfa_object.$extra]._isSplittable = true; return true; } [_xfa_object.$flushHTML]() { return (0, _layout.flushHTML)(this); } [_xfa_object.$addHTML](html, bbox) { (0, _layout.addHTML)(this, html, bbox); } [_xfa_object.$getAvailableSpace]() { return (0, _layout.getAvailableSpace)(this); } [_xfa_object.$toHTML](availableSpace) { setTabIndex(this); if (this.presence === &quot;hidden&quot; || this.presence === &quot;inactive&quot; || this.h === 0 || this.w === 0) { return _utils.HTMLResult.EMPTY; } (0, _html_utils.fixDimensions)(this); const children = []; const attributes = { id: this[_xfa_object.$uid], class: [] }; (0, _html_utils.setAccess)(this, attributes.class); if (!this[_xfa_object.$extra]) { this[_xfa_object.$extra] = Object.create(null); } Object.assign(this[_xfa_object.$extra], { children, attributes, attempt: 0, line: null, numberInLine: 0, availableSpace: { width: Math.min(this.w || Infinity, availableSpace.width), height: Math.min(this.h || Infinity, availableSpace.height) }, width: 0, height: 0, prevHeight: 0, currentWidth: 0 }); const isSplittable = this[_xfa_object.$isSplittable](); if (!isSplittable) { setFirstUnsplittable(this); } if (!(0, _layout.checkDimensions)(this, availableSpace)) { return _utils.HTMLResult.FAILURE; } const filter = new Set([&quot;field&quot;]); if (this.layout.includes(&quot;row&quot;)) { const columnWidths = this[_xfa_object.$getSubformParent]().columnWidths; if (Array.isArray(columnWidths) &amp;&amp; columnWidths.length &gt; 0) { this[_xfa_object.$extra].columnWidths = columnWidths; this[_xfa_object.$extra].currentColumn = 0; } } const style = (0, _html_utils.toStyle)(this, &quot;anchorType&quot;, &quot;dimensions&quot;, &quot;position&quot;, &quot;presence&quot;, &quot;border&quot;, &quot;margin&quot;, &quot;hAlign&quot;); const classNames = [&quot;xfaExclgroup&quot;]; const cl = (0, _html_utils.layoutClass)(this); if (cl) { classNames.push(cl); } if ((0, _html_utils.isPrintOnly)(this)) { classNames.push(&quot;xfaPrintOnly&quot;); } attributes.style = style; attributes.class = classNames; if (this.name) { attributes.xfaName = this.name; } this[_xfa_object.$pushPara](); const isLrTb = this.layout === &quot;lr-tb&quot; || this.layout === &quot;rl-tb&quot;; const maxRun = isLrTb ? MAX_ATTEMPTS_FOR_LRTB_LAYOUT : 1; for (; this[_xfa_object.$extra].attempt &lt; maxRun; this[_xfa_object.$extra].attempt++) { if (isLrTb &amp;&amp; this[_xfa_object.$extra].attempt === MAX_ATTEMPTS_FOR_LRTB_LAYOUT - 1) { this[_xfa_object.$extra].numberInLine = 0; } const result = this[_xfa_object.$childrenToHTML]({ filter, include: true }); if (result.success) { break; } if (result.isBreak()) { this[_xfa_object.$popPara](); return result; } if (isLrTb &amp;&amp; this[_xfa_object.$extra].attempt === 0 &amp;&amp; this[_xfa_object.$extra].numberInLine === 0 &amp;&amp; !this[_xfa_object.$getTemplateRoot]()[_xfa_object.$extra].noLayoutFailure) { this[_xfa_object.$extra].attempt = maxRun; break; } } this[_xfa_object.$popPara](); if (!isSplittable) { unsetFirstUnsplittable(this); } if (this[_xfa_object.$extra].attempt === maxRun) { if (!isSplittable) { delete this[_xfa_object.$extra]; } return _utils.HTMLResult.FAILURE; } let marginH = 0; let marginV = 0; if (this.margin) { marginH = this.margin.leftInset + this.margin.rightInset; marginV = this.margin.topInset + this.margin.bottomInset; } const width = Math.max(this[_xfa_object.$extra].width + marginH, this.w || 0); const height = Math.max(this[_xfa_object.$extra].height + marginV, this.h || 0); const bbox = [this.x, this.y, width, height]; if (this.w === &quot;&quot;) { style.width = (0, _html_utils.measureToString)(width); } if (this.h === &quot;&quot;) { style.height = (0, _html_utils.measureToString)(height); } const html = { name: &quot;div&quot;, attributes, children }; applyAssist(this, attributes); delete this[_xfa_object.$extra]; return _utils.HTMLResult.success((0, _html_utils.createWrapper)(this, html), bbox); } } class Execute extends _xfa_object.XFAObject { constructor(attributes) { super(TEMPLATE_NS_ID, &quot;execute&quot;); this.connection = attributes.connection || &quot;&quot;; this.executeType = (0, _utils.getStringOption)(attributes.executeType, [&quot;import&quot;, &quot;remerge&quot;]); this.id = attributes.id || &quot;&quot;; this.runAt = (0, _utils.getStringOption)(attributes.runAt, [&quot;client&quot;, &quot;both&quot;, &quot;server&quot;]); this.use = attributes.use || &quot;&quot;; this.usehref = attributes.usehref || &quot;&quot;; } } class Extras extends _xfa_object.XFAObject { constructor(attributes) { super(TEMPLATE_NS_ID, &quot;extras&quot;, true); this.id = attributes.id || &quot;&quot;; this.name = attributes.name || &quot;&quot;; this.use = attributes.use || &quot;&quot;; this.usehref = attributes.usehref || &quot;&quot;; this.boolean = new _xfa_object.XFAObjectArray(); this.date = new _xfa_object.XFAObjectArray(); this.dateTime = new _xfa_object.XFAObjectArray(); this.decimal = new _xfa_object.XFAObjectArray(); this.exData = new _xfa_object.XFAObjectArray(); this.extras = new _xfa_object.XFAObjectArray(); this.float = new _xfa_object.XFAObjectArray(); this.image = new _xfa_object.XFAObjectArray(); this.integer = new _xfa_object.XFAObjectArray(); this.text = new _xfa_object.XFAObjectArray(); this.time = new _xfa_object.XFAObjectArray(); } } class Field extends _xfa_object.XFAObject { constructor(attributes) { super(TEMPLATE_NS_ID, &quot;field&quot;, true); this.access = (0, _utils.getStringOption)(attributes.access, [&quot;open&quot;, &quot;nonInteractive&quot;, &quot;protected&quot;, &quot;readOnly&quot;]); this.accessKey = attributes.accessKey || &quot;&quot;; this.anchorType = (0, _utils.getStringOption)(attributes.anchorType, [&quot;topLeft&quot;, &quot;bottomCenter&quot;, &quot;bottomLeft&quot;, &quot;bottomRight&quot;, &quot;middleCenter&quot;, &quot;middleLeft&quot;, &quot;middleRight&quot;, &quot;topCenter&quot;, &quot;topRight&quot;]); this.colSpan = (0, _utils.getInteger)({ data: attributes.colSpan, defaultValue: 1, validate: n =&gt; n &gt;= 1 || n === -1 }); this.h = attributes.h ? (0, _utils.getMeasurement)(attributes.h) : &quot;&quot;; this.hAlign = (0, _utils.getStringOption)(attributes.hAlign, [&quot;left&quot;, &quot;center&quot;, &quot;justify&quot;, &quot;justifyAll&quot;, &quot;radix&quot;, &quot;right&quot;]); this.id = attributes.id || &quot;&quot;; this.locale = attributes.locale || &quot;&quot;; this.maxH = (0, _utils.getMeasurement)(attributes.maxH, &quot;0pt&quot;); this.maxW = (0, _utils.getMeasurement)(attributes.maxW, &quot;0pt&quot;); this.minH = (0, _utils.getMeasurement)(attributes.minH, &quot;0pt&quot;); this.minW = (0, _utils.getMeasurement)(attributes.minW, &quot;0pt&quot;); this.name = attributes.name || &quot;&quot;; this.presence = (0, _utils.getStringOption)(attributes.presence, [&quot;visible&quot;, &quot;hidden&quot;, &quot;inactive&quot;, &quot;invisible&quot;]); this.relevant = (0, _utils.getRelevant)(attributes.relevant); this.rotate = (0, _utils.getInteger)({ data: attributes.rotate, defaultValue: 0, validate: x =&gt; x % 90 === 0 }); this.use = attributes.use || &quot;&quot;; this.usehref = attributes.usehref || &quot;&quot;; this.w = attributes.w ? (0, _utils.getMeasurement)(attributes.w) : &quot;&quot;; this.x = (0, _utils.getMeasurement)(attributes.x, &quot;0pt&quot;); this.y = (0, _utils.getMeasurement)(attributes.y, &quot;0pt&quot;); this.assist = null; this.bind = null; this.border = null; this.calculate = null; this.caption = null; this.desc = null; this.extras = null; this.font = null; this.format = null; this.items = new _xfa_object.XFAObjectArray(2); this.keep = null; this.margin = null; this.para = null; this.traversal = null; this.ui = null; this.validate = null; this.value = null; this.bindItems = new _xfa_object.XFAObjectArray(); this.connect = new _xfa_object.XFAObjectArray(); this.event = new _xfa_object.XFAObjectArray(); this.setProperty = new _xfa_object.XFAObjectArray(); } [_xfa_object.$isBindable]() { return true; } [_xfa_object.$setValue](value) { _setValue(this, value); } [_xfa_object.$toHTML](availableSpace) { setTabIndex(this); if (!this.ui) { this.ui = new Ui({}); this.ui[_xfa_object.$globalData] = this[_xfa_object.$globalData]; this[_xfa_object.$appendChild](this.ui); let node; switch (this.items.children.length) { case 0: node = new TextEdit({}); this.ui.textEdit = node; break; case 1: node = new CheckButton({}); this.ui.checkButton = node; break; case 2: node = new ChoiceList({}); this.ui.choiceList = node; break; } this.ui[_xfa_object.$appendChild](node); } if (!this.ui || this.presence === &quot;hidden&quot; || this.presence === &quot;inactive&quot; || this.h === 0 || this.w === 0) { return _utils.HTMLResult.EMPTY; } if (this.caption) { delete this.caption[_xfa_object.$extra]; } this[_xfa_object.$pushPara](); const caption = this.caption ? this.caption[_xfa_object.$toHTML](availableSpace).html : null; const savedW = this.w; const savedH = this.h; let marginH = 0; let marginV = 0; if (this.margin) { marginH = this.margin.leftInset + this.margin.rightInset; marginV = this.margin.topInset + this.margin.bottomInset; } let borderDims = null; if (this.w === &quot;&quot; || this.h === &quot;&quot;) { let width = null; let height = null; let uiW = 0; let uiH = 0; if (this.ui.checkButton) { uiW = uiH = this.ui.checkButton.size; } else { const { w, h } = (0, _html_utils.layoutNode)(this, availableSpace); if (w !== null) { uiW = w; uiH = h; } else { uiH = (0, _fonts.getMetrics)(this.font, true).lineNoGap; } } borderDims = getBorderDims(this.ui[_xfa_object.$getExtra]()); uiW += borderDims.w; uiH += borderDims.h; if (this.caption) { const { w, h, isBroken } = this.caption[_xfa_object.$getExtra](availableSpace); if (isBroken &amp;&amp; this[_xfa_object.$getSubformParent]()[_xfa_object.$isThereMoreWidth]()) { this[_xfa_object.$popPara](); return _utils.HTMLResult.FAILURE; } width = w; height = h; switch (this.caption.placement) { case &quot;left&quot;: case &quot;right&quot;: case &quot;inline&quot;: width += uiW; break; case &quot;top&quot;: case &quot;bottom&quot;: height += uiH; break; } } else { width = uiW; height = uiH; } if (width &amp;&amp; this.w === &quot;&quot;) { width += marginH; this.w = Math.min(this.maxW &lt;= 0 ? Infinity : this.maxW, this.minW + 1 &lt; width ? width : this.minW); } if (height &amp;&amp; this.h === &quot;&quot;) { height += marginV; this.h = Math.min(this.maxH &lt;= 0 ? Infinity : this.maxH, this.minH + 1 &lt; height ? height : this.minH); } } this[_xfa_object.$popPara](); (0, _html_utils.fixDimensions)(this); setFirstUnsplittable(this); if (!(0, _layout.checkDimensions)(this, availableSpace)) { this.w = savedW; this.h = savedH; this[_xfa_object.$popPara](); return _utils.HTMLResult.FAILURE; } unsetFirstUnsplittable(this); const style = (0, _html_utils.toStyle)(this, &quot;font&quot;, &quot;dimensions&quot;, &quot;position&quot;, &quot;rotate&quot;, &quot;anchorType&quot;, &quot;presence&quot;, &quot;margin&quot;, &quot;hAlign&quot;); (0, _html_utils.setMinMaxDimensions)(this, style); const classNames = [&quot;xfaField&quot;]; if (this.font) { classNames.push(&quot;xfaFont&quot;); } if ((0, _html_utils.isPrintOnly)(this)) { classNames.push(&quot;xfaPrintOnly&quot;); } const attributes = { style, id: this[_xfa_object.$uid], class: classNames }; if (style.margin) { style.padding = style.margin; delete style.margin; } (0, _html_utils.setAccess)(this, classNames); if (this.name) { attributes.xfaName = this.name; } const children = []; const html = { name: &quot;div&quot;, attributes, children }; applyAssist(this, attributes); const borderStyle = this.border ? this.border[_xfa_object.$toStyle]() : null; const bbox = (0, _html_utils.computeBbox)(this, html, availableSpace); const ui = this.ui[_xfa_object.$toHTML]().html; if (!ui) { Object.assign(style, borderStyle); return _utils.HTMLResult.success((0, _html_utils.createWrapper)(this, html), bbox); } if (this[_xfa_object.$tabIndex]) { if (ui.children &amp;&amp; ui.children[0]) { ui.children[0].attributes.tabindex = this[_xfa_object.$tabIndex]; } else { ui.attributes.tabindex = this[_xfa_object.$tabIndex]; } } if (!ui.attributes.style) { ui.attributes.style = Object.create(null); } let aElement = null; if (this.ui.button) { if (ui.children.length === 1) { [aElement] = ui.children.splice(0, 1); } Object.assign(ui.attributes.style, borderStyle); } else { Object.assign(style, borderStyle); } children.push(ui); if (this.value) { if (this.ui.imageEdit) { ui.children.push(this.value[_xfa_object.$toHTML]().html); } else if (!this.ui.button) { let value = &quot;&quot;; if (this.value.exData) { value = this.value.exData[_xfa_object.$text](); } else if (this.value.text) { value = this.value.text[_xfa_object.$getExtra](); } else { const htmlValue = this.value[_xfa_object.$toHTML]().html; if (htmlValue !== null) { value = htmlValue.children[0].value; } } if (this.ui.textEdit &amp;&amp; this.value.text &amp;&amp; this.value.text.maxChars) { ui.children[0].attributes.maxLength = this.value.text.maxChars; } if (value) { if (this.ui.numericEdit) { value = parseFloat(value); value = isNaN(value) ? &quot;&quot; : value.toString(); } if (ui.children[0].name === &quot;textarea&quot;) { ui.children[0].attributes.textContent = value; } else { ui.children[0].attributes.value = value; } } } } if (!this.ui.imageEdit &amp;&amp; ui.children &amp;&amp; ui.children[0] &amp;&amp; this.h) { borderDims = borderDims || getBorderDims(this.ui[_xfa_object.$getExtra]()); let captionHeight = 0; if (this.caption &amp;&amp; [&quot;top&quot;, &quot;bottom&quot;].includes(this.caption.placement)) { captionHeight = this.caption.reserve; if (captionHeight &lt;= 0) { captionHeight = this.caption[_xfa_object.$getExtra](availableSpace).h; } const inputHeight = this.h - captionHeight - marginV - borderDims.h; ui.children[0].attributes.style.height = (0, _html_utils.measureToString)(inputHeight); } else { ui.children[0].attributes.style.height = &quot;100%&quot;; } } if (aElement) { ui.children.push(aElement); } if (!caption) { if (ui.attributes.class) { ui.attributes.class.push(&quot;xfaLeft&quot;); } this.w = savedW; this.h = savedH; return _utils.HTMLResult.success((0, _html_utils.createWrapper)(this, html), bbox); } if (this.ui.button) { if (style.padding) { delete style.padding; } if (caption.name === &quot;div&quot;) { caption.name = &quot;span&quot;; } ui.children.push(caption); return _utils.HTMLResult.success(html, bbox); } else if (this.ui.checkButton) { caption.attributes.class[0] = &quot;xfaCaptionForCheckButton&quot;; } if (!ui.attributes.class) { ui.attributes.class = []; } ui.children.splice(0, 0, caption); switch (this.caption.placement) { case &quot;left&quot;: ui.attributes.class.push(&quot;xfaLeft&quot;); break; case &quot;right&quot;: ui.attributes.class.push(&quot;xfaRight&quot;); break; case &quot;top&quot;: ui.attributes.class.push(&quot;xfaTop&quot;); break; case &quot;bottom&quot;: ui.attributes.class.push(&quot;xfaBottom&quot;); break; case &quot;inline&quot;: ui.attributes.class.push(&quot;xfaLeft&quot;); break; } this.w = savedW; this.h = savedH; return _utils.HTMLResult.success((0, _html_utils.createWrapper)(this, html), bbox); } } exports.Field = Field; class Fill extends _xfa_object.XFAObject { constructor(attributes) { super(TEMPLATE_NS_ID, &quot;fill&quot;, true); this.id = attributes.id || &quot;&quot;; this.presence = (0, _utils.getStringOption)(attributes.presence, [&quot;visible&quot;, &quot;hidden&quot;, &quot;inactive&quot;, &quot;invisible&quot;]); this.use = attributes.use || &quot;&quot;; this.usehref = attributes.usehref || &quot;&quot;; this.color = null; this.extras = null; this.linear = null; this.pattern = null; this.radial = null; this.solid = null; this.stipple = null; } [_xfa_object.$toStyle]() { const parent = this[_xfa_object.$getParent](); const grandpa = parent[_xfa_object.$getParent](); const ggrandpa = grandpa[_xfa_object.$getParent](); const style = Object.create(null); let propName = &quot;color&quot;; let altPropName = propName; if (parent instanceof Border) { propName = &quot;background-color&quot;; altPropName = &quot;background&quot;; if (ggrandpa instanceof Ui) { style.backgroundColor = &quot;white&quot;; } } if (parent instanceof Rectangle || parent instanceof Arc) { propName = altPropName = &quot;fill&quot;; style.fill = &quot;white&quot;; } for (const name of Object.getOwnPropertyNames(this)) { if (name === &quot;extras&quot; || name === &quot;color&quot;) { continue; } const obj = this[name]; if (!(obj instanceof _xfa_object.XFAObject)) { continue; } const color = obj[_xfa_object.$toStyle](this.color); if (color) { style[color.startsWith(&quot;#&quot;) ? propName : altPropName] = color; } return style; } if (this.color &amp;&amp; this.color.value) { const color = this.color[_xfa_object.$toStyle](); style[color.startsWith(&quot;#&quot;) ? propName : altPropName] = color; } return style; } } class Filter extends _xfa_object.XFAObject { constructor(attributes) { super(TEMPLATE_NS_ID, &quot;filter&quot;, true); this.addRevocationInfo = (0, _utils.getStringOption)(attributes.addRevocationInfo, [&quot;&quot;, &quot;required&quot;, &quot;optional&quot;, &quot;none&quot;]); this.id = attributes.id || &quot;&quot;; this.name = attributes.name || &quot;&quot;; this.use = attributes.use || &quot;&quot;; this.usehref = attributes.usehref || &quot;&quot;; this.version = (0, _utils.getInteger)({ data: this.version, defaultValue: 5, validate: x =&gt; x &gt;= 1 &amp;&amp; x &lt;= 5 }); this.appearanceFilter = null; this.certificates = null; this.digestMethods = null; this.encodings = null; this.encryptionMethods = null; this.handler = null; this.lockDocument = null; this.mdp = null; this.reasons = null; this.timeStamp = null; } } class Float extends _xfa_object.ContentObject { constructor(attributes) { super(TEMPLATE_NS_ID, &quot;float&quot;); this.id = attributes.id || &quot;&quot;; this.name = attributes.name || &quot;&quot;; this.use = attributes.use || &quot;&quot;; this.usehref = attributes.usehref || &quot;&quot;; } [_xfa_object.$finalize]() { const number = parseFloat(this[_xfa_object.$content].trim()); this[_xfa_object.$content] = isNaN(number) ? null : number; } [_xfa_object.$toHTML](availableSpace) { return valueToHtml(this[_xfa_object.$content] !== null ? this[_xfa_object.$content].toString() : &quot;&quot;); } } class Font extends _xfa_object.XFAObject { constructor(attributes) { super(TEMPLATE_NS_ID, &quot;font&quot;, true); this.baselineShift = (0, _utils.getMeasurement)(attributes.baselineShift); this.fontHorizontalScale = (0, _utils.getFloat)({ data: attributes.fontHorizontalScale, defaultValue: 100, validate: x =&gt; x &gt;= 0 }); this.fontVerticalScale = (0, _utils.getFloat)({ data: attributes.fontVerticalScale, defaultValue: 100, validate: x =&gt; x &gt;= 0 }); this.id = attributes.id || &quot;&quot;; this.kerningMode = (0, _utils.getStringOption)(attributes.kerningMode, [&quot;none&quot;, &quot;pair&quot;]); this.letterSpacing = (0, _utils.getMeasurement)(attributes.letterSpacing, &quot;0&quot;); this.lineThrough = (0, _utils.getInteger)({ data: attributes.lineThrough, defaultValue: 0, validate: x =&gt; x === 1 || x === 2 }); this.lineThroughPeriod = (0, _utils.getStringOption)(attributes.lineThroughPeriod, [&quot;all&quot;, &quot;word&quot;]); this.overline = (0, _utils.getInteger)({ data: attributes.overline, defaultValue: 0, validate: x =&gt; x === 1 || x === 2 }); this.overlinePeriod = (0, _utils.getStringOption)(attributes.overlinePeriod, [&quot;all&quot;, &quot;word&quot;]); this.posture = (0, _utils.getStringOption)(attributes.posture, [&quot;normal&quot;, &quot;italic&quot;]); this.size = (0, _utils.getMeasurement)(attributes.size, &quot;10pt&quot;); this.typeface = attributes.typeface || &quot;Courier&quot;; this.underline = (0, _utils.getInteger)({ data: attributes.underline, defaultValue: 0, validate: x =&gt; x === 1 || x === 2 }); this.underlinePeriod = (0, _utils.getStringOption)(attributes.underlinePeriod, [&quot;all&quot;, &quot;word&quot;]); this.use = attributes.use || &quot;&quot;; this.usehref = attributes.usehref || &quot;&quot;; this.weight = (0, _utils.getStringOption)(attributes.weight, [&quot;normal&quot;, &quot;bold&quot;]); this.extras = null; this.fill = null; } [_xfa_object.$clean](builder) { super[_xfa_object.$clean](builder); this[_xfa_object.$globalData].usedTypefaces.add(this.typeface); } [_xfa_object.$toStyle]() { const style = (0, _html_utils.toStyle)(this, &quot;fill&quot;); const color = style.color; if (color) { if (color === &quot;#000000&quot;) { delete style.color; } else if (!color.startsWith(&quot;#&quot;)) { style.background = color; style.backgroundClip = &quot;text&quot;; style.color = &quot;transparent&quot;; } } if (this.baselineShift) { style.verticalAlign = (0, _html_utils.measureToString)(this.baselineShift); } style.fontKerning = this.kerningMode === &quot;none&quot; ? &quot;none&quot; : &quot;normal&quot;; style.letterSpacing = (0, _html_utils.measureToString)(this.letterSpacing); if (this.lineThrough !== 0) { style.textDecoration = &quot;line-through&quot;; if (this.lineThrough === 2) { style.textDecorationStyle = &quot;double&quot;; } } if (this.overline !== 0) { style.textDecoration = &quot;overline&quot;; if (this.overline === 2) { style.textDecorationStyle = &quot;double&quot;; } } style.fontStyle = this.posture; style.fontSize = (0, _html_utils.measureToString)(0.99 * this.size); (0, _html_utils.setFontFamily)(this, this, this[_xfa_object.$globalData].fontFinder, style); if (this.underline !== 0) { style.textDecoration = &quot;underline&quot;; if (this.underline === 2) { style.textDecorationStyle = &quot;double&quot;; } } style.fontWeight = this.weight; return style; } } class Format extends _xfa_object.XFAObject { constructor(attributes) { super(TEMPLATE_NS_ID, &quot;format&quot;, true); this.id = attributes.id || &quot;&quot;; this.use = attributes.use || &quot;&quot;; this.usehref = attributes.usehref || &quot;&quot;; this.extras = null; this.picture = null; } } class Handler extends _xfa_object.StringObject { constructor(attributes) { super(TEMPLATE_NS_ID, &quot;handler&quot;); this.id = attributes.id || &quot;&quot;; this.type = (0, _utils.getStringOption)(attributes.type, [&quot;optional&quot;, &quot;required&quot;]); this.use = attributes.use || &quot;&quot;; this.usehref = attributes.usehref || &quot;&quot;; } } class Hyphenation extends _xfa_object.XFAObject { constructor(attributes) { super(TEMPLATE_NS_ID, &quot;hyphenation&quot;); this.excludeAllCaps = (0, _utils.getInteger)({ data: attributes.excludeAllCaps, defaultValue: 0, validate: x =&gt; x === 1 }); this.excludeInitialCap = (0, _utils.getInteger)({ data: attributes.excludeInitialCap, defaultValue: 0, validate: x =&gt; x === 1 }); this.hyphenate = (0, _utils.getInteger)({ data: attributes.hyphenate, defaultValue: 0, validate: x =&gt; x === 1 }); this.id = attributes.id || &quot;&quot;; this.pushCharacterCount = (0, _utils.getInteger)({ data: attributes.pushCharacterCount, defaultValue: 3, validate: x =&gt; x &gt;= 0 }); this.remainCharacterCount = (0, _utils.getInteger)({ data: attributes.remainCharacterCount, defaultValue: 3, validate: x =&gt; x &gt;= 0 }); this.use = attributes.use || &quot;&quot;; this.usehref = attributes.usehref || &quot;&quot;; this.wordCharacterCount = (0, _utils.getInteger)({ data: attributes.wordCharacterCount, defaultValue: 7, validate: x =&gt; x &gt;= 0 }); } } class Image extends _xfa_object.StringObject { constructor(attributes) { super(TEMPLATE_NS_ID, &quot;image&quot;); this.aspect = (0, _utils.getStringOption)(attributes.aspect, [&quot;fit&quot;, &quot;actual&quot;, &quot;height&quot;, &quot;none&quot;, &quot;width&quot;]); this.contentType = attributes.contentType || &quot;&quot;; this.href = attributes.href || &quot;&quot;; this.id = attributes.id || &quot;&quot;; this.name = attributes.name || &quot;&quot;; this.transferEncoding = (0, _utils.getStringOption)(attributes.transferEncoding, [&quot;base64&quot;, &quot;none&quot;, &quot;package&quot;]); this.use = attributes.use || &quot;&quot;; this.usehref = attributes.usehref || &quot;&quot;; } [_xfa_object.$toHTML]() { if (this.contentType &amp;&amp; !MIMES.has(this.contentType.toLowerCase())) { return _utils.HTMLResult.EMPTY; } let buffer = this[_xfa_object.$globalData].images &amp;&amp; this[_xfa_object.$globalData].images.get(this.href); if (!buffer &amp;&amp; (this.href || !this[_xfa_object.$content])) { return _utils.HTMLResult.EMPTY; } if (!buffer &amp;&amp; this.transferEncoding === &quot;base64&quot;) { buffer = (0, _util.stringToBytes)(atob(this[_xfa_object.$content])); } if (!buffer) { return _utils.HTMLResult.EMPTY; } if (!this.contentType) { for (const [header, type] of IMAGES_HEADERS) { if (buffer.length &gt; header.length &amp;&amp; header.every((x, i) =&gt; x === buffer[i])) { this.contentType = type; break; } } if (!this.contentType) { return _utils.HTMLResult.EMPTY; } } const blob = new Blob([buffer], { type: this.contentType }); let style; switch (this.aspect) { case &quot;fit&quot;: case &quot;actual&quot;: break; case &quot;height&quot;: style = { height: &quot;100%&quot;, objectFit: &quot;fill&quot; }; break; case &quot;none&quot;: style = { width: &quot;100%&quot;, height: &quot;100%&quot;, objectFit: &quot;fill&quot; }; break; case &quot;width&quot;: style = { width: &quot;100%&quot;, objectFit: &quot;fill&quot; }; break; } const parent = this[_xfa_object.$getParent](); return _utils.HTMLResult.success({ name: &quot;img&quot;, attributes: { class: [&quot;xfaImage&quot;], style, src: URL.createObjectURL(blob), alt: parent ? ariaLabel(parent[_xfa_object.$getParent]()) : null } }); } } class ImageEdit extends _xfa_object.XFAObject { constructor(attributes) { super(TEMPLATE_NS_ID, &quot;imageEdit&quot;, true); this.data = (0, _utils.getStringOption)(attributes.data, [&quot;link&quot;, &quot;embed&quot;]); this.id = attributes.id || &quot;&quot;; this.use = attributes.use || &quot;&quot;; this.usehref = attributes.usehref || &quot;&quot;; this.border = null; this.extras = null; this.margin = null; } [_xfa_object.$toHTML](availableSpace) { if (this.data === &quot;embed&quot;) { return _utils.HTMLResult.success({ name: &quot;div&quot;, children: [], attributes: {} }); } return _utils.HTMLResult.EMPTY; } } class Integer extends _xfa_object.ContentObject { constructor(attributes) { super(TEMPLATE_NS_ID, &quot;integer&quot;); this.id = attributes.id || &quot;&quot;; this.name = attributes.name || &quot;&quot;; this.use = attributes.use || &quot;&quot;; this.usehref = attributes.usehref || &quot;&quot;; } [_xfa_object.$finalize]() { const number = parseInt(this[_xfa_object.$content].trim(), 10); this[_xfa_object.$content] = isNaN(number) ? null : number; } [_xfa_object.$toHTML](availableSpace) { return valueToHtml(this[_xfa_object.$content] !== null ? this[_xfa_object.$content].toString() : &quot;&quot;); } } class Issuers extends _xfa_object.XFAObject { constructor(attributes) { super(TEMPLATE_NS_ID, &quot;issuers&quot;, true); this.id = attributes.id || &quot;&quot;; this.type = (0, _utils.getStringOption)(attributes.type, [&quot;optional&quot;, &quot;required&quot;]); this.use = attributes.use || &quot;&quot;; this.usehref = attributes.usehref || &quot;&quot;; this.certificate = new _xfa_object.XFAObjectArray(); } } class Items extends _xfa_object.XFAObject { constructor(attributes) { super(TEMPLATE_NS_ID, &quot;items&quot;, true); this.id = attributes.id || &quot;&quot;; this.name = attributes.name || &quot;&quot;; this.presence = (0, _utils.getStringOption)(attributes.presence, [&quot;visible&quot;, &quot;hidden&quot;, &quot;inactive&quot;, &quot;invisible&quot;]); this.ref = attributes.ref || &quot;&quot;; this.save = (0, _utils.getInteger)({ data: attributes.save, defaultValue: 0, validate: x =&gt; x === 1 }); this.use = attributes.use || &quot;&quot;; this.usehref = attributes.usehref || &quot;&quot;; this.boolean = new _xfa_object.XFAObjectArray(); this.date = new _xfa_object.XFAObjectArray(); this.dateTime = new _xfa_object.XFAObjectArray(); this.decimal = new _xfa_object.XFAObjectArray(); this.exData = new _xfa_object.XFAObjectArray(); this.float = new _xfa_object.XFAObjectArray(); this.image = new _xfa_object.XFAObjectArray(); this.integer = new _xfa_object.XFAObjectArray(); this.text = new _xfa_object.XFAObjectArray(); this.time = new _xfa_object.XFAObjectArray(); } [_xfa_object.$toHTML]() { const output = []; for (const child of this[_xfa_object.$getChildren]()) { output.push(child[_xfa_object.$text]()); } return _utils.HTMLResult.success(output); } } exports.Items = Items; class Keep extends _xfa_object.XFAObject { constructor(attributes) { super(TEMPLATE_NS_ID, &quot;keep&quot;, true); this.id = attributes.id || &quot;&quot;; const options = [&quot;none&quot;, &quot;contentArea&quot;, &quot;pageArea&quot;]; this.intact = (0, _utils.getStringOption)(attributes.intact, options); this.next = (0, _utils.getStringOption)(attributes.next, options); this.previous = (0, _utils.getStringOption)(attributes.previous, options); this.use = attributes.use || &quot;&quot;; this.usehref = attributes.usehref || &quot;&quot;; this.extras = null; } } class KeyUsage extends _xfa_object.XFAObject { constructor(attributes) { super(TEMPLATE_NS_ID, &quot;keyUsage&quot;); const options = [&quot;&quot;, &quot;yes&quot;, &quot;no&quot;]; this.crlSign = (0, _utils.getStringOption)(attributes.crlSign, options); this.dataEncipherment = (0, _utils.getStringOption)(attributes.dataEncipherment, options); this.decipherOnly = (0, _utils.getStringOption)(attributes.decipherOnly, options); this.digitalSignature = (0, _utils.getStringOption)(attributes.digitalSignature, options); this.encipherOnly = (0, _utils.getStringOption)(attributes.encipherOnly, options); this.id = attributes.id || &quot;&quot;; this.keyAgreement = (0, _utils.getStringOption)(attributes.keyAgreement, options); this.keyCertSign = (0, _utils.getStringOption)(attributes.keyCertSign, options); this.keyEncipherment = (0, _utils.getStringOption)(attributes.keyEncipherment, options); this.nonRepudiation = (0, _utils.getStringOption)(attributes.nonRepudiation, options); this.type = (0, _utils.getStringOption)(attributes.type, [&quot;optional&quot;, &quot;required&quot;]); this.use = attributes.use || &quot;&quot;; this.usehref = attributes.usehref || &quot;&quot;; } } class Line extends _xfa_object.XFAObject { constructor(attributes) { super(TEMPLATE_NS_ID, &quot;line&quot;, true); this.hand = (0, _utils.getStringOption)(attributes.hand, [&quot;even&quot;, &quot;left&quot;, &quot;right&quot;]); this.id = attributes.id || &quot;&quot;; this.slope = (0, _utils.getStringOption)(attributes.slope, [&quot;\\\\&quot;, &quot;/&quot;]); this.use = attributes.use || &quot;&quot;; this.usehref = attributes.usehref || &quot;&quot;; this.edge = null; } [_xfa_object.$toHTML]() { const parent = this[_xfa_object.$getParent]()[_xfa_object.$getParent](); const edge = this.edge || new Edge({}); const edgeStyle = edge[_xfa_object.$toStyle](); const style = Object.create(null); const thickness = edge.presence === &quot;visible&quot; ? edge.thickness : 0; style.strokeWidth = (0, _html_utils.measureToString)(thickness); style.stroke = edgeStyle.color; let x1, y1, x2, y2; let width = &quot;100%&quot;; let height = &quot;100%&quot;; if (parent.w &lt;= thickness) { [x1, y1, x2, y2] = [&quot;50%&quot;, 0, &quot;50%&quot;, &quot;100%&quot;]; width = style.strokeWidth; } else if (parent.h &lt;= thickness) { [x1, y1, x2, y2] = [0, &quot;50%&quot;, &quot;100%&quot;, &quot;50%&quot;]; height = style.strokeWidth; } else { if (this.slope === &quot;\\\\&quot;) { [x1, y1, x2, y2] = [0, 0, &quot;100%&quot;, &quot;100%&quot;]; } else { [x1, y1, x2, y2] = [0, &quot;100%&quot;, &quot;100%&quot;, 0]; } } const line = { name: &quot;line&quot;, attributes: { xmlns: SVG_NS, x1, y1, x2, y2, style } }; const svg = { name: &quot;svg&quot;, children: [line], attributes: { xmlns: SVG_NS, width, height, style: { overflow: &quot;visible&quot; } } }; if (hasMargin(parent)) { return _utils.HTMLResult.success({ name: &quot;div&quot;, attributes: { style: { display: &quot;inline&quot;, width: &quot;100%&quot;, height: &quot;100%&quot; } }, children: [svg] }); } svg.attributes.style.position = &quot;absolute&quot;; return _utils.HTMLResult.success(svg); } } class Linear extends _xfa_object.XFAObject { constructor(attributes) { super(TEMPLATE_NS_ID, &quot;linear&quot;, true); this.id = attributes.id || &quot;&quot;; this.type = (0, _utils.getStringOption)(attributes.type, [&quot;toRight&quot;, &quot;toBottom&quot;, &quot;toLeft&quot;, &quot;toTop&quot;]); this.use = attributes.use || &quot;&quot;; this.usehref = attributes.usehref || &quot;&quot;; this.color = null; this.extras = null; } [_xfa_object.$toStyle](startColor) { startColor = startColor ? startColor[_xfa_object.$toStyle]() : &quot;#FFFFFF&quot;; const transf = this.type.replace(/([RBLT])/, &quot; $1&quot;).toLowerCase(); const endColor = this.color ? this.color[_xfa_object.$toStyle]() : &quot;#000000&quot;; return `linear-gradient(${transf}, ${startColor}, ${endColor})`; } } class LockDocument extends _xfa_object.ContentObject { constructor(attributes) { super(TEMPLATE_NS_ID, &quot;lockDocument&quot;); this.id = attributes.id || &quot;&quot;; this.type = (0, _utils.getStringOption)(attributes.type, [&quot;optional&quot;, &quot;required&quot;]); this.use = attributes.use || &quot;&quot;; this.usehref = attributes.usehref || &quot;&quot;; } [_xfa_object.$finalize]() { this[_xfa_object.$content] = (0, _utils.getStringOption)(this[_xfa_object.$content], [&quot;auto&quot;, &quot;0&quot;, &quot;1&quot;]); } } class Manifest extends _xfa_object.XFAObject { constructor(attributes) { super(TEMPLATE_NS_ID, &quot;manifest&quot;, true); this.action = (0, _utils.getStringOption)(attributes.action, [&quot;include&quot;, &quot;all&quot;, &quot;exclude&quot;]); this.id = attributes.id || &quot;&quot;; this.name = attributes.name || &quot;&quot;; this.use = attributes.use || &quot;&quot;; this.usehref = attributes.usehref || &quot;&quot;; this.extras = null; this.ref = new _xfa_object.XFAObjectArray(); } } class Margin extends _xfa_object.XFAObject { constructor(attributes) { super(TEMPLATE_NS_ID, &quot;margin&quot;, true); this.bottomInset = (0, _utils.getMeasurement)(attributes.bottomInset, &quot;0&quot;); this.id = attributes.id || &quot;&quot;; this.leftInset = (0, _utils.getMeasurement)(attributes.leftInset, &quot;0&quot;); this.rightInset = (0, _utils.getMeasurement)(attributes.rightInset, &quot;0&quot;); this.topInset = (0, _utils.getMeasurement)(attributes.topInset, &quot;0&quot;); this.use = attributes.use || &quot;&quot;; this.usehref = attributes.usehref || &quot;&quot;; this.extras = null; } [_xfa_object.$toStyle]() { return { margin: (0, _html_utils.measureToString)(this.topInset) + &quot; &quot; + (0, _html_utils.measureToString)(this.rightInset) + &quot; &quot; + (0, _html_utils.measureToString)(this.bottomInset) + &quot; &quot; + (0, _html_utils.measureToString)(this.leftInset) }; } } class Mdp extends _xfa_object.XFAObject { constructor(attributes) { super(TEMPLATE_NS_ID, &quot;mdp&quot;); this.id = attributes.id || &quot;&quot;; this.permissions = (0, _utils.getInteger)({ data: attributes.permissions, defaultValue: 2, validate: x =&gt; x === 1 || x === 3 }); this.signatureType = (0, _utils.getStringOption)(attributes.signatureType, [&quot;filler&quot;, &quot;author&quot;]); this.use = attributes.use || &quot;&quot;; this.usehref = attributes.usehref || &quot;&quot;; } } class Medium extends _xfa_object.XFAObject { constructor(attributes) { super(TEMPLATE_NS_ID, &quot;medium&quot;); this.id = attributes.id || &quot;&quot;; this.imagingBBox = (0, _utils.getBBox)(attributes.imagingBBox); this.long = (0, _utils.getMeasurement)(attributes.long); this.orientation = (0, _utils.getStringOption)(attributes.orientation, [&quot;portrait&quot;, &quot;landscape&quot;]); this.short = (0, _utils.getMeasurement)(attributes.short); this.stock = attributes.stock || &quot;&quot;; this.trayIn = (0, _utils.getStringOption)(attributes.trayIn, [&quot;auto&quot;, &quot;delegate&quot;, &quot;pageFront&quot;]); this.trayOut = (0, _utils.getStringOption)(attributes.trayOut, [&quot;auto&quot;, &quot;delegate&quot;]); this.use = attributes.use || &quot;&quot;; this.usehref = attributes.usehref || &quot;&quot;; } } class Message extends _xfa_object.XFAObject { constructor(attributes) { super(TEMPLATE_NS_ID, &quot;message&quot;, true); this.id = attributes.id || &quot;&quot;; this.use = attributes.use || &quot;&quot;; this.usehref = attributes.usehref || &quot;&quot;; this.text = new _xfa_object.XFAObjectArray(); } } class NumericEdit extends _xfa_object.XFAObject { constructor(attributes) { super(TEMPLATE_NS_ID, &quot;numericEdit&quot;, true); this.hScrollPolicy = (0, _utils.getStringOption)(attributes.hScrollPolicy, [&quot;auto&quot;, &quot;off&quot;, &quot;on&quot;]); this.id = attributes.id || &quot;&quot;; this.use = attributes.use || &quot;&quot;; this.usehref = attributes.usehref || &quot;&quot;; this.border = null; this.comb = null; this.extras = null; this.margin = null; } [_xfa_object.$toHTML](availableSpace) { const style = (0, _html_utils.toStyle)(this, &quot;border&quot;, &quot;font&quot;, &quot;margin&quot;); const field = this[_xfa_object.$getParent]()[_xfa_object.$getParent](); const html = { name: &quot;input&quot;, attributes: { type: &quot;text&quot;, fieldId: field[_xfa_object.$uid], dataId: field[_xfa_object.$data] &amp;&amp; field[_xfa_object.$data][_xfa_object.$uid] || field[_xfa_object.$uid], class: [&quot;xfaTextfield&quot;], style, &quot;aria-label&quot;: ariaLabel(field), &quot;aria-required&quot;: false } }; if (isRequired(field)) { html.attributes[&quot;aria-required&quot;] = true; html.attributes.required = true; } return _utils.HTMLResult.success({ name: &quot;label&quot;, attributes: { class: [&quot;xfaLabel&quot;] }, children: [html] }); } } class Occur extends _xfa_object.XFAObject { constructor(attributes) { super(TEMPLATE_NS_ID, &quot;occur&quot;, true); this.id = attributes.id || &quot;&quot;; this.initial = attributes.initial !== &quot;&quot; ? (0, _utils.getInteger)({ data: attributes.initial, defaultValue: &quot;&quot;, validate: x =&gt; true }) : &quot;&quot;; this.max = attributes.max !== &quot;&quot; ? (0, _utils.getInteger)({ data: attributes.max, defaultValue: 1, validate: x =&gt; true }) : &quot;&quot;; this.min = attributes.min !== &quot;&quot; ? (0, _utils.getInteger)({ data: attributes.min, defaultValue: 1, validate: x =&gt; true }) : &quot;&quot;; this.use = attributes.use || &quot;&quot;; this.usehref = attributes.usehref || &quot;&quot;; this.extras = null; } [_xfa_object.$clean]() { const parent = this[_xfa_object.$getParent](); const originalMin = this.min; if (this.min === &quot;&quot;) { this.min = parent instanceof PageArea || parent instanceof PageSet ? 0 : 1; } if (this.max === &quot;&quot;) { if (originalMin === &quot;&quot;) { this.max = parent instanceof PageArea || parent instanceof PageSet ? -1 : 1; } else { this.max = this.min; } } if (this.max !== -1 &amp;&amp; this.max &lt; this.min) { this.max = this.min; } if (this.initial === &quot;&quot;) { this.initial = parent instanceof Template ? 1 : this.min; } } } class Oid extends _xfa_object.StringObject { constructor(attributes) { super(TEMPLATE_NS_ID, &quot;oid&quot;); this.id = attributes.id || &quot;&quot;; this.name = attributes.name || &quot;&quot;; this.use = attributes.use || &quot;&quot;; this.usehref = attributes.usehref || &quot;&quot;; } } class Oids extends _xfa_object.XFAObject { constructor(attributes) { super(TEMPLATE_NS_ID, &quot;oids&quot;, true); this.id = attributes.id || &quot;&quot;; this.type = (0, _utils.getStringOption)(attributes.type, [&quot;optional&quot;, &quot;required&quot;]); this.use = attributes.use || &quot;&quot;; this.usehref = attributes.usehref || &quot;&quot;; this.oid = new _xfa_object.XFAObjectArray(); } } class Overflow extends _xfa_object.XFAObject { constructor(attributes) { super(TEMPLATE_NS_ID, &quot;overflow&quot;); this.id = attributes.id || &quot;&quot;; this.leader = attributes.leader || &quot;&quot;; this.target = attributes.target || &quot;&quot;; this.trailer = attributes.trailer || &quot;&quot;; this.use = attributes.use || &quot;&quot;; this.usehref = attributes.usehref || &quot;&quot;; } [_xfa_object.$getExtra]() { if (!this[_xfa_object.$extra]) { const parent = this[_xfa_object.$getParent](); const root = this[_xfa_object.$getTemplateRoot](); const target = root[_xfa_object.$searchNode](this.target, parent); const leader = root[_xfa_object.$searchNode](this.leader, parent); const trailer = root[_xfa_object.$searchNode](this.trailer, parent); this[_xfa_object.$extra] = { target: target &amp;&amp; target[0] || null, leader: leader &amp;&amp; leader[0] || null, trailer: trailer &amp;&amp; trailer[0] || null, addLeader: false, addTrailer: false }; } return this[_xfa_object.$extra]; } } class PageArea extends _xfa_object.XFAObject { constructor(attributes) { super(TEMPLATE_NS_ID, &quot;pageArea&quot;, true); this.blankOrNotBlank = (0, _utils.getStringOption)(attributes.blankOrNotBlank, [&quot;any&quot;, &quot;blank&quot;, &quot;notBlank&quot;]); this.id = attributes.id || &quot;&quot;; this.initialNumber = (0, _utils.getInteger)({ data: attributes.initialNumber, defaultValue: 1, validate: x =&gt; true }); this.name = attributes.name || &quot;&quot;; this.numbered = (0, _utils.getInteger)({ data: attributes.numbered, defaultValue: 1, validate: x =&gt; true }); this.oddOrEven = (0, _utils.getStringOption)(attributes.oddOrEven, [&quot;any&quot;, &quot;even&quot;, &quot;odd&quot;]); this.pagePosition = (0, _utils.getStringOption)(attributes.pagePosition, [&quot;any&quot;, &quot;first&quot;, &quot;last&quot;, &quot;only&quot;, &quot;rest&quot;]); this.relevant = (0, _utils.getRelevant)(attributes.relevant); this.use = attributes.use || &quot;&quot;; this.usehref = attributes.usehref || &quot;&quot;; this.desc = null; this.extras = null; this.medium = null; this.occur = null; this.area = new _xfa_object.XFAObjectArray(); this.contentArea = new _xfa_object.XFAObjectArray(); this.draw = new _xfa_object.XFAObjectArray(); this.exclGroup = new _xfa_object.XFAObjectArray(); this.field = new _xfa_object.XFAObjectArray(); this.subform = new _xfa_object.XFAObjectArray(); } [_xfa_object.$isUsable]() { if (!this[_xfa_object.$extra]) { this[_xfa_object.$extra] = { numberOfUse: 0 }; return true; } return !this.occur || this.occur.max === -1 || this[_xfa_object.$extra].numberOfUse &lt; this.occur.max; } [_xfa_object.$cleanPage]() { delete this[_xfa_object.$extra]; } [_xfa_object.$getNextPage]() { if (!this[_xfa_object.$extra]) { this[_xfa_object.$extra] = { numberOfUse: 0 }; } const parent = this[_xfa_object.$getParent](); if (parent.relation === &quot;orderedOccurrence&quot;) { if (this[_xfa_object.$isUsable]()) { this[_xfa_object.$extra].numberOfUse += 1; return this; } } return parent[_xfa_object.$getNextPage](); } [_xfa_object.$getAvailableSpace]() { return this[_xfa_object.$extra].space || { width: 0, height: 0 }; } [_xfa_object.$toHTML]() { if (!this[_xfa_object.$extra]) { this[_xfa_object.$extra] = { numberOfUse: 1 }; } const children = []; this[_xfa_object.$extra].children = children; const style = Object.create(null); if (this.medium &amp;&amp; this.medium.short &amp;&amp; this.medium.long) { style.width = (0, _html_utils.measureToString)(this.medium.short); style.height = (0, _html_utils.measureToString)(this.medium.long); this[_xfa_object.$extra].space = { width: this.medium.short, height: this.medium.long }; if (this.medium.orientation === &quot;landscape&quot;) { const x = style.width; style.width = style.height; style.height = x; this[_xfa_object.$extra].space = { width: this.medium.long, height: this.medium.short }; } } else { (0, _util.warn)(&quot;XFA - No medium specified in pageArea: please file a bug.&quot;); } this[_xfa_object.$childrenToHTML]({ filter: new Set([&quot;area&quot;, &quot;draw&quot;, &quot;field&quot;, &quot;subform&quot;]), include: true }); this[_xfa_object.$childrenToHTML]({ filter: new Set([&quot;contentArea&quot;]), include: true }); return _utils.HTMLResult.success({ name: &quot;div&quot;, children, attributes: { class: [&quot;xfaPage&quot;], id: this[_xfa_object.$uid], style, xfaName: this.name } }); } } class PageSet extends _xfa_object.XFAObject { constructor(attributes) { super(TEMPLATE_NS_ID, &quot;pageSet&quot;, true); this.duplexImposition = (0, _utils.getStringOption)(attributes.duplexImposition, [&quot;longEdge&quot;, &quot;shortEdge&quot;]); this.id = attributes.id || &quot;&quot;; this.name = attributes.name || &quot;&quot;; this.relation = (0, _utils.getStringOption)(attributes.relation, [&quot;orderedOccurrence&quot;, &quot;duplexPaginated&quot;, &quot;simplexPaginated&quot;]); this.relevant = (0, _utils.getRelevant)(attributes.relevant); this.use = attributes.use || &quot;&quot;; this.usehref = attributes.usehref || &quot;&quot;; this.extras = null; this.occur = null; this.pageArea = new _xfa_object.XFAObjectArray(); this.pageSet = new _xfa_object.XFAObjectArray(); } [_xfa_object.$cleanPage]() { for (const page of this.pageArea.children) { page[_xfa_object.$cleanPage](); } for (const page of this.pageSet.children) { page[_xfa_object.$cleanPage](); } } [_xfa_object.$isUsable]() { return !this.occur || this.occur.max === -1 || this[_xfa_object.$extra].numberOfUse &lt; this.occur.max; } [_xfa_object.$getNextPage]() { if (!this[_xfa_object.$extra]) { this[_xfa_object.$extra] = { numberOfUse: 1, pageIndex: -1, pageSetIndex: -1 }; } if (this.relation === &quot;orderedOccurrence&quot;) { if (this[_xfa_object.$extra].pageIndex + 1 &lt; this.pageArea.children.length) { this[_xfa_object.$extra].pageIndex += 1; const pageArea = this.pageArea.children[this[_xfa_object.$extra].pageIndex]; return pageArea[_xfa_object.$getNextPage](); } if (this[_xfa_object.$extra].pageSetIndex + 1 &lt; this.pageSet.children.length) { this[_xfa_object.$extra].pageSetIndex += 1; return this.pageSet.children[this[_xfa_object.$extra].pageSetIndex][_xfa_object.$getNextPage](); } if (this[_xfa_object.$isUsable]()) { this[_xfa_object.$extra].numberOfUse += 1; this[_xfa_object.$extra].pageIndex = -1; this[_xfa_object.$extra].pageSetIndex = -1; return this[_xfa_object.$getNextPage](); } const parent = this[_xfa_object.$getParent](); if (parent instanceof PageSet) { return parent[_xfa_object.$getNextPage](); } this[_xfa_object.$cleanPage](); return this[_xfa_object.$getNextPage](); } const pageNumber = this[_xfa_object.$getTemplateRoot]()[_xfa_object.$extra].pageNumber; const parity = pageNumber % 2 === 0 ? &quot;even&quot; : &quot;odd&quot;; const position = pageNumber === 0 ? &quot;first&quot; : &quot;rest&quot;; let page = this.pageArea.children.find(p =&gt; p.oddOrEven === parity &amp;&amp; p.pagePosition === position); if (page) { return page; } page = this.pageArea.children.find(p =&gt; p.oddOrEven === &quot;any&quot; &amp;&amp; p.pagePosition === position); if (page) { return page; } page = this.pageArea.children.find(p =&gt; p.oddOrEven === &quot;any&quot; &amp;&amp; p.pagePosition === &quot;any&quot;); if (page) { return page; } return this.pageArea.children[0]; } } class Para extends _xfa_object.XFAObject { constructor(attributes) { super(TEMPLATE_NS_ID, &quot;para&quot;, true); this.hAlign = (0, _utils.getStringOption)(attributes.hAlign, [&quot;left&quot;, &quot;center&quot;, &quot;justify&quot;, &quot;justifyAll&quot;, &quot;radix&quot;, &quot;right&quot;]); this.id = attributes.id || &quot;&quot;; this.lineHeight = attributes.lineHeight ? (0, _utils.getMeasurement)(attributes.lineHeight, &quot;0pt&quot;) : &quot;&quot;; this.marginLeft = attributes.marginLeft ? (0, _utils.getMeasurement)(attributes.marginLeft, &quot;0pt&quot;) : &quot;&quot;; this.marginRight = attributes.marginRight ? (0, _utils.getMeasurement)(attributes.marginRight, &quot;0pt&quot;) : &quot;&quot;; this.orphans = (0, _utils.getInteger)({ data: attributes.orphans, defaultValue: 0, validate: x =&gt; x &gt;= 0 }); this.preserve = attributes.preserve || &quot;&quot;; this.radixOffset = attributes.radixOffset ? (0, _utils.getMeasurement)(attributes.radixOffset, &quot;0pt&quot;) : &quot;&quot;; this.spaceAbove = attributes.spaceAbove ? (0, _utils.getMeasurement)(attributes.spaceAbove, &quot;0pt&quot;) : &quot;&quot;; this.spaceBelow = attributes.spaceBelow ? (0, _utils.getMeasurement)(attributes.spaceBelow, &quot;0pt&quot;) : &quot;&quot;; this.tabDefault = attributes.tabDefault ? (0, _utils.getMeasurement)(this.tabDefault) : &quot;&quot;; this.tabStops = (attributes.tabStops || &quot;&quot;).trim().split(/\\s+/).map((x, i) =&gt; i % 2 === 1 ? (0, _utils.getMeasurement)(x) : x); this.textIndent = attributes.textIndent ? (0, _utils.getMeasurement)(attributes.textIndent, &quot;0pt&quot;) : &quot;&quot;; this.use = attributes.use || &quot;&quot;; this.usehref = attributes.usehref || &quot;&quot;; this.vAlign = (0, _utils.getStringOption)(attributes.vAlign, [&quot;top&quot;, &quot;bottom&quot;, &quot;middle&quot;]); this.widows = (0, _utils.getInteger)({ data: attributes.widows, defaultValue: 0, validate: x =&gt; x &gt;= 0 }); this.hyphenation = null; } [_xfa_object.$toStyle]() { const style = (0, _html_utils.toStyle)(this, &quot;hAlign&quot;); if (this.marginLeft !== &quot;&quot;) { style.paddingLeft = (0, _html_utils.measureToString)(this.marginLeft); } if (this.marginRight !== &quot;&quot;) { style.paddingight = (0, _html_utils.measureToString)(this.marginRight); } if (this.spaceAbove !== &quot;&quot;) { style.paddingTop = (0, _html_utils.measureToString)(this.spaceAbove); } if (this.spaceBelow !== &quot;&quot;) { style.paddingBottom = (0, _html_utils.measureToString)(this.spaceBelow); } if (this.textIndent !== &quot;&quot;) { style.textIndent = (0, _html_utils.measureToString)(this.textIndent); (0, _html_utils.fixTextIndent)(style); } if (this.lineHeight &gt; 0) { style.lineHeight = (0, _html_utils.measureToString)(this.lineHeight); } if (this.tabDefault !== &quot;&quot;) { style.tabSize = (0, _html_utils.measureToString)(this.tabDefault); } if (this.tabStops.length &gt; 0) {} if (this.hyphenatation) { Object.assign(style, this.hyphenatation[_xfa_object.$toStyle]()); } return style; } } class PasswordEdit extends _xfa_object.XFAObject { constructor(attributes) { super(TEMPLATE_NS_ID, &quot;passwordEdit&quot;, true); this.hScrollPolicy = (0, _utils.getStringOption)(attributes.hScrollPolicy, [&quot;auto&quot;, &quot;off&quot;, &quot;on&quot;]); this.id = attributes.id || &quot;&quot;; this.passwordChar = attributes.passwordChar || &quot;*&quot;; this.use = attributes.use || &quot;&quot;; this.usehref = attributes.usehref || &quot;&quot;; this.border = null; this.extras = null; this.margin = null; } } class Pattern extends _xfa_object.XFAObject { constructor(attributes) { super(TEMPLATE_NS_ID, &quot;pattern&quot;, true); this.id = attributes.id || &quot;&quot;; this.type = (0, _utils.getStringOption)(attributes.type, [&quot;crossHatch&quot;, &quot;crossDiagonal&quot;, &quot;diagonalLeft&quot;, &quot;diagonalRight&quot;, &quot;horizontal&quot;, &quot;vertical&quot;]); this.use = attributes.use || &quot;&quot;; this.usehref = attributes.usehref || &quot;&quot;; this.color = null; this.extras = null; } [_xfa_object.$toStyle](startColor) { startColor = startColor ? startColor[_xfa_object.$toStyle]() : &quot;#FFFFFF&quot;; const endColor = this.color ? this.color[_xfa_object.$toStyle]() : &quot;#000000&quot;; const width = 5; const cmd = &quot;repeating-linear-gradient&quot;; const colors = `${startColor},${startColor} ${width}px,${endColor} ${width}px,${endColor} ${2 * width}px`; switch (this.type) { case &quot;crossHatch&quot;: return `${cmd}(to top,${colors}) ${cmd}(to right,${colors})`; case &quot;crossDiagonal&quot;: return `${cmd}(45deg,${colors}) ${cmd}(-45deg,${colors})`; case &quot;diagonalLeft&quot;: return `${cmd}(45deg,${colors})`; case &quot;diagonalRight&quot;: return `${cmd}(-45deg,${colors})`; case &quot;horizontal&quot;: return `${cmd}(to top,${colors})`; case &quot;vertical&quot;: return `${cmd}(to right,${colors})`; } return &quot;&quot;; } } class Picture extends _xfa_object.StringObject { constructor(attributes) { super(TEMPLATE_NS_ID, &quot;picture&quot;); this.id = attributes.id || &quot;&quot;; this.use = attributes.use || &quot;&quot;; this.usehref = attributes.usehref || &quot;&quot;; } } class Proto extends _xfa_object.XFAObject { constructor(attributes) { super(TEMPLATE_NS_ID, &quot;proto&quot;, true); this.appearanceFilter = new _xfa_object.XFAObjectArray(); this.arc = new _xfa_object.XFAObjectArray(); this.area = new _xfa_object.XFAObjectArray(); this.assist = new _xfa_object.XFAObjectArray(); this.barcode = new _xfa_object.XFAObjectArray(); this.bindItems = new _xfa_object.XFAObjectArray(); this.bookend = new _xfa_object.XFAObjectArray(); this.boolean = new _xfa_object.XFAObjectArray(); this.border = new _xfa_object.XFAObjectArray(); this.break = new _xfa_object.XFAObjectArray(); this.breakAfter = new _xfa_object.XFAObjectArray(); this.breakBefore = new _xfa_object.XFAObjectArray(); this.button = new _xfa_object.XFAObjectArray(); this.calculate = new _xfa_object.XFAObjectArray(); this.caption = new _xfa_object.XFAObjectArray(); this.certificate = new _xfa_object.XFAObjectArray(); this.certificates = new _xfa_object.XFAObjectArray(); this.checkButton = new _xfa_object.XFAObjectArray(); this.choiceList = new _xfa_object.XFAObjectArray(); this.color = new _xfa_object.XFAObjectArray(); this.comb = new _xfa_object.XFAObjectArray(); this.connect = new _xfa_object.XFAObjectArray(); this.contentArea = new _xfa_object.XFAObjectArray(); this.corner = new _xfa_object.XFAObjectArray(); this.date = new _xfa_object.XFAObjectArray(); this.dateTime = new _xfa_object.XFAObjectArray(); this.dateTimeEdit = new _xfa_object.XFAObjectArray(); this.decimal = new _xfa_object.XFAObjectArray(); this.defaultUi = new _xfa_object.XFAObjectArray(); this.desc = new _xfa_object.XFAObjectArray(); this.digestMethod = new _xfa_object.XFAObjectArray(); this.digestMethods = new _xfa_object.XFAObjectArray(); this.draw = new _xfa_object.XFAObjectArray(); this.edge = new _xfa_object.XFAObjectArray(); this.encoding = new _xfa_object.XFAObjectArray(); this.encodings = new _xfa_object.XFAObjectArray(); this.encrypt = new _xfa_object.XFAObjectArray(); this.encryptData = new _xfa_object.XFAObjectArray(); this.encryption = new _xfa_object.XFAObjectArray(); this.encryptionMethod = new _xfa_object.XFAObjectArray(); this.encryptionMethods = new _xfa_object.XFAObjectArray(); this.event = new _xfa_object.XFAObjectArray(); this.exData = new _xfa_object.XFAObjectArray(); this.exObject = new _xfa_object.XFAObjectArray(); this.exclGroup = new _xfa_object.XFAObjectArray(); this.execute = new _xfa_object.XFAObjectArray(); this.extras = new _xfa_object.XFAObjectArray(); this.field = new _xfa_object.XFAObjectArray(); this.fill = new _xfa_object.XFAObjectArray(); this.filter = new _xfa_object.XFAObjectArray(); this.float = new _xfa_object.XFAObjectArray(); this.font = new _xfa_object.XFAObjectArray(); this.format = new _xfa_object.XFAObjectArray(); this.handler = new _xfa_object.XFAObjectArray(); this.hyphenation = new _xfa_object.XFAObjectArray(); this.image = new _xfa_object.XFAObjectArray(); this.imageEdit = new _xfa_object.XFAObjectArray(); this.integer = new _xfa_object.XFAObjectArray(); this.issuers = new _xfa_object.XFAObjectArray(); this.items = new _xfa_object.XFAObjectArray(); this.keep = new _xfa_object.XFAObjectArray(); this.keyUsage = new _xfa_object.XFAObjectArray(); this.line = new _xfa_object.XFAObjectArray(); this.linear = new _xfa_object.XFAObjectArray(); this.lockDocument = new _xfa_object.XFAObjectArray(); this.manifest = new _xfa_object.XFAObjectArray(); this.margin = new _xfa_object.XFAObjectArray(); this.mdp = new _xfa_object.XFAObjectArray(); this.medium = new _xfa_object.XFAObjectArray(); this.message = new _xfa_object.XFAObjectArray(); this.numericEdit = new _xfa_object.XFAObjectArray(); this.occur = new _xfa_object.XFAObjectArray(); this.oid = new _xfa_object.XFAObjectArray(); this.oids = new _xfa_object.XFAObjectArray(); this.overflow = new _xfa_object.XFAObjectArray(); this.pageArea = new _xfa_object.XFAObjectArray(); this.pageSet = new _xfa_object.XFAObjectArray(); this.para = new _xfa_object.XFAObjectArray(); this.passwordEdit = new _xfa_object.XFAObjectArray(); this.pattern = new _xfa_object.XFAObjectArray(); this.picture = new _xfa_object.XFAObjectArray(); this.radial = new _xfa_object.XFAObjectArray(); this.reason = new _xfa_object.XFAObjectArray(); this.reasons = new _xfa_object.XFAObjectArray(); this.rectangle = new _xfa_object.XFAObjectArray(); this.ref = new _xfa_object.XFAObjectArray(); this.script = new _xfa_object.XFAObjectArray(); this.setProperty = new _xfa_object.XFAObjectArray(); this.signData = new _xfa_object.XFAObjectArray(); this.signature = new _xfa_object.XFAObjectArray(); this.signing = new _xfa_object.XFAObjectArray(); this.solid = new _xfa_object.XFAObjectArray(); this.speak = new _xfa_object.XFAObjectArray(); this.stipple = new _xfa_object.XFAObjectArray(); this.subform = new _xfa_object.XFAObjectArray(); this.subformSet = new _xfa_object.XFAObjectArray(); this.subjectDN = new _xfa_object.XFAObjectArray(); this.subjectDNs = new _xfa_object.XFAObjectArray(); this.submit = new _xfa_object.XFAObjectArray(); this.text = new _xfa_object.XFAObjectArray(); this.textEdit = new _xfa_object.XFAObjectArray(); this.time = new _xfa_object.XFAObjectArray(); this.timeStamp = new _xfa_object.XFAObjectArray(); this.toolTip = new _xfa_object.XFAObjectArray(); this.traversal = new _xfa_object.XFAObjectArray(); this.traverse = new _xfa_object.XFAObjectArray(); this.ui = new _xfa_object.XFAObjectArray(); this.validate = new _xfa_object.XFAObjectArray(); this.value = new _xfa_object.XFAObjectArray(); this.variables = new _xfa_object.XFAObjectArray(); } } class Radial extends _xfa_object.XFAObject { constructor(attributes) { super(TEMPLATE_NS_ID, &quot;radial&quot;, true); this.id = attributes.id || &quot;&quot;; this.type = (0, _utils.getStringOption)(attributes.type, [&quot;toEdge&quot;, &quot;toCenter&quot;]); this.use = attributes.use || &quot;&quot;; this.usehref = attributes.usehref || &quot;&quot;; this.color = null; this.extras = null; } [_xfa_object.$toStyle](startColor) { startColor = startColor ? startColor[_xfa_object.$toStyle]() : &quot;#FFFFFF&quot;; const endColor = this.color ? this.color[_xfa_object.$toStyle]() : &quot;#000000&quot;; const colors = this.type === &quot;toEdge&quot; ? `${startColor},${endColor}` : `${endColor},${startColor}`; return `radial-gradient(circle at center, ${colors})`; } } class Reason extends _xfa_object.StringObject { constructor(attributes) { super(TEMPLATE_NS_ID, &quot;reason&quot;); this.id = attributes.id || &quot;&quot;; this.name = attributes.name || &quot;&quot;; this.use = attributes.use || &quot;&quot;; this.usehref = attributes.usehref || &quot;&quot;; } } class Reasons extends _xfa_object.XFAObject { constructor(attributes) { super(TEMPLATE_NS_ID, &quot;reasons&quot;, true); this.id = attributes.id || &quot;&quot;; this.type = (0, _utils.getStringOption)(attributes.type, [&quot;optional&quot;, &quot;required&quot;]); this.use = attributes.use || &quot;&quot;; this.usehref = attributes.usehref || &quot;&quot;; this.reason = new _xfa_object.XFAObjectArray(); } } class Rectangle extends _xfa_object.XFAObject { constructor(attributes) { super(TEMPLATE_NS_ID, &quot;rectangle&quot;, true); this.hand = (0, _utils.getStringOption)(attributes.hand, [&quot;even&quot;, &quot;left&quot;, &quot;right&quot;]); this.id = attributes.id || &quot;&quot;; this.use = attributes.use || &quot;&quot;; this.usehref = attributes.usehref || &quot;&quot;; this.corner = new _xfa_object.XFAObjectArray(4); this.edge = new _xfa_object.XFAObjectArray(4); this.fill = null; } [_xfa_object.$toHTML]() { const edge = this.edge.children.length ? this.edge.children[0] : new Edge({}); const edgeStyle = edge[_xfa_object.$toStyle](); const style = Object.create(null); if (this.fill &amp;&amp; this.fill.presence === &quot;visible&quot;) { Object.assign(style, this.fill[_xfa_object.$toStyle]()); } else { style.fill = &quot;transparent&quot;; } style.strokeWidth = (0, _html_utils.measureToString)(edge.presence === &quot;visible&quot; ? edge.thickness : 0); style.stroke = edgeStyle.color; const corner = this.corner.children.length ? this.corner.children[0] : new Corner({}); const cornerStyle = corner[_xfa_object.$toStyle](); const rect = { name: &quot;rect&quot;, attributes: { xmlns: SVG_NS, width: &quot;100%&quot;, height: &quot;100%&quot;, x: 0, y: 0, rx: cornerStyle.radius, ry: cornerStyle.radius, style } }; const svg = { name: &quot;svg&quot;, children: [rect], attributes: { xmlns: SVG_NS, style: { overflow: &quot;visible&quot; }, width: &quot;100%&quot;, height: &quot;100%&quot; } }; const parent = this[_xfa_object.$getParent]()[_xfa_object.$getParent](); if (hasMargin(parent)) { return _utils.HTMLResult.success({ name: &quot;div&quot;, attributes: { style: { display: &quot;inline&quot;, width: &quot;100%&quot;, height: &quot;100%&quot; } }, children: [svg] }); } svg.attributes.style.position = &quot;absolute&quot;; return _utils.HTMLResult.success(svg); } } class RefElement extends _xfa_object.StringObject { constructor(attributes) { super(TEMPLATE_NS_ID, &quot;ref&quot;); this.id = attributes.id || &quot;&quot;; this.use = attributes.use || &quot;&quot;; this.usehref = attributes.usehref || &quot;&quot;; } } class Script extends _xfa_object.StringObject { constructor(attributes) { super(TEMPLATE_NS_ID, &quot;script&quot;); this.binding = attributes.binding || &quot;&quot;; this.contentType = attributes.contentType || &quot;&quot;; this.id = attributes.id || &quot;&quot;; this.name = attributes.name || &quot;&quot;; this.runAt = (0, _utils.getStringOption)(attributes.runAt, [&quot;client&quot;, &quot;both&quot;, &quot;server&quot;]); this.use = attributes.use || &quot;&quot;; this.usehref = attributes.usehref || &quot;&quot;; } } class SetProperty extends _xfa_object.XFAObject { constructor(attributes) { super(TEMPLATE_NS_ID, &quot;setProperty&quot;); this.connection = attributes.connection || &quot;&quot;; this.ref = attributes.ref || &quot;&quot;; this.target = attributes.target || &quot;&quot;; } } exports.SetProperty = SetProperty; class SignData extends _xfa_object.XFAObject { constructor(attributes) { super(TEMPLATE_NS_ID, &quot;signData&quot;, true); this.id = attributes.id || &quot;&quot;; this.operation = (0, _utils.getStringOption)(attributes.operation, [&quot;sign&quot;, &quot;clear&quot;, &quot;verify&quot;]); this.ref = attributes.ref || &quot;&quot;; this.target = attributes.target || &quot;&quot;; this.use = attributes.use || &quot;&quot;; this.usehref = attributes.usehref || &quot;&quot;; this.filter = null; this.manifest = null; } } class Signature extends _xfa_object.XFAObject { constructor(attributes) { super(TEMPLATE_NS_ID, &quot;signature&quot;, true); this.id = attributes.id || &quot;&quot;; this.type = (0, _utils.getStringOption)(attributes.type, [&quot;PDF1.3&quot;, &quot;PDF1.6&quot;]); this.use = attributes.use || &quot;&quot;; this.usehref = attributes.usehref || &quot;&quot;; this.border = null; this.extras = null; this.filter = null; this.manifest = null; this.margin = null; } } class Signing extends _xfa_object.XFAObject { constructor(attributes) { super(TEMPLATE_NS_ID, &quot;signing&quot;, true); this.id = attributes.id || &quot;&quot;; this.type = (0, _utils.getStringOption)(attributes.type, [&quot;optional&quot;, &quot;required&quot;]); this.use = attributes.use || &quot;&quot;; this.usehref = attributes.usehref || &quot;&quot;; this.certificate = new _xfa_object.XFAObjectArray(); } } class Solid extends _xfa_object.XFAObject { constructor(attributes) { super(TEMPLATE_NS_ID, &quot;solid&quot;, true); this.id = attributes.id || &quot;&quot;; this.use = attributes.use || &quot;&quot;; this.usehref = attributes.usehref || &quot;&quot;; this.extras = null; } [_xfa_object.$toStyle](startColor) { return startColor ? startColor[_xfa_object.$toStyle]() : &quot;#FFFFFF&quot;; } } class Speak extends _xfa_object.StringObject { constructor(attributes) { super(TEMPLATE_NS_ID, &quot;speak&quot;); this.disable = (0, _utils.getInteger)({ data: attributes.disable, defaultValue: 0, validate: x =&gt; x === 1 }); this.id = attributes.id || &quot;&quot;; this.priority = (0, _utils.getStringOption)(attributes.priority, [&quot;custom&quot;, &quot;caption&quot;, &quot;name&quot;, &quot;toolTip&quot;]); this.rid = attributes.rid || &quot;&quot;; this.use = attributes.use || &quot;&quot;; this.usehref = attributes.usehref || &quot;&quot;; } } class Stipple extends _xfa_object.XFAObject { constructor(attributes) { super(TEMPLATE_NS_ID, &quot;stipple&quot;, true); this.id = attributes.id || &quot;&quot;; this.rate = (0, _utils.getInteger)({ data: attributes.rate, defaultValue: 50, validate: x =&gt; x &gt;= 0 &amp;&amp; x &lt;= 100 }); this.use = attributes.use || &quot;&quot;; this.usehref = attributes.usehref || &quot;&quot;; this.color = null; this.extras = null; } [_xfa_object.$toStyle](bgColor) { const alpha = this.rate / 100; return _util.Util.makeHexColor(Math.round(bgColor.value.r * (1 - alpha) + this.value.r * alpha), Math.round(bgColor.value.g * (1 - alpha) + this.value.g * alpha), Math.round(bgColor.value.b * (1 - alpha) + this.value.b * alpha)); } } class Subform extends _xfa_object.XFAObject { constructor(attributes) { super(TEMPLATE_NS_ID, &quot;subform&quot;, true); this.access = (0, _utils.getStringOption)(attributes.access, [&quot;open&quot;, &quot;nonInteractive&quot;, &quot;protected&quot;, &quot;readOnly&quot;]); this.allowMacro = (0, _utils.getInteger)({ data: attributes.allowMacro, defaultValue: 0, validate: x =&gt; x === 1 }); this.anchorType = (0, _utils.getStringOption)(attributes.anchorType, [&quot;topLeft&quot;, &quot;bottomCenter&quot;, &quot;bottomLeft&quot;, &quot;bottomRight&quot;, &quot;middleCenter&quot;, &quot;middleLeft&quot;, &quot;middleRight&quot;, &quot;topCenter&quot;, &quot;topRight&quot;]); this.colSpan = (0, _utils.getInteger)({ data: attributes.colSpan, defaultValue: 1, validate: n =&gt; n &gt;= 1 || n === -1 }); this.columnWidths = (attributes.columnWidths || &quot;&quot;).trim().split(/\\s+/).map(x =&gt; x === &quot;-1&quot; ? -1 : (0, _utils.getMeasurement)(x)); this.h = attributes.h ? (0, _utils.getMeasurement)(attributes.h) : &quot;&quot;; this.hAlign = (0, _utils.getStringOption)(attributes.hAlign, [&quot;left&quot;, &quot;center&quot;, &quot;justify&quot;, &quot;justifyAll&quot;, &quot;radix&quot;, &quot;right&quot;]); this.id = attributes.id || &quot;&quot;; this.layout = (0, _utils.getStringOption)(attributes.layout, [&quot;position&quot;, &quot;lr-tb&quot;, &quot;rl-row&quot;, &quot;rl-tb&quot;, &quot;row&quot;, &quot;table&quot;, &quot;tb&quot;]); this.locale = attributes.locale || &quot;&quot;; this.maxH = (0, _utils.getMeasurement)(attributes.maxH, &quot;0pt&quot;); this.maxW = (0, _utils.getMeasurement)(attributes.maxW, &quot;0pt&quot;); this.mergeMode = (0, _utils.getStringOption)(attributes.mergeMode, [&quot;consumeData&quot;, &quot;matchTemplate&quot;]); this.minH = (0, _utils.getMeasurement)(attributes.minH, &quot;0pt&quot;); this.minW = (0, _utils.getMeasurement)(attributes.minW, &quot;0pt&quot;); this.name = attributes.name || &quot;&quot;; this.presence = (0, _utils.getStringOption)(attributes.presence, [&quot;visible&quot;, &quot;hidden&quot;, &quot;inactive&quot;, &quot;invisible&quot;]); this.relevant = (0, _utils.getRelevant)(attributes.relevant); this.restoreState = (0, _utils.getStringOption)(attributes.restoreState, [&quot;manual&quot;, &quot;auto&quot;]); this.scope = (0, _utils.getStringOption)(attributes.scope, [&quot;name&quot;, &quot;none&quot;]); this.use = attributes.use || &quot;&quot;; this.usehref = attributes.usehref || &quot;&quot;; this.w = attributes.w ? (0, _utils.getMeasurement)(attributes.w) : &quot;&quot;; this.x = (0, _utils.getMeasurement)(attributes.x, &quot;0pt&quot;); this.y = (0, _utils.getMeasurement)(attributes.y, &quot;0pt&quot;); this.assist = null; this.bind = null; this.bookend = null; this.border = null; this.break = null; this.calculate = null; this.desc = null; this.extras = null; this.keep = null; this.margin = null; this.occur = null; this.overflow = null; this.pageSet = null; this.para = null; this.traversal = null; this.validate = null; this.variables = null; this.area = new _xfa_object.XFAObjectArray(); this.breakAfter = new _xfa_object.XFAObjectArray(); this.breakBefore = new _xfa_object.XFAObjectArray(); this.connect = new _xfa_object.XFAObjectArray(); this.draw = new _xfa_object.XFAObjectArray(); this.event = new _xfa_object.XFAObjectArray(); this.exObject = new _xfa_object.XFAObjectArray(); this.exclGroup = new _xfa_object.XFAObjectArray(); this.field = new _xfa_object.XFAObjectArray(); this.proto = new _xfa_object.XFAObjectArray(); this.setProperty = new _xfa_object.XFAObjectArray(); this.subform = new _xfa_object.XFAObjectArray(); this.subformSet = new _xfa_object.XFAObjectArray(); } [_xfa_object.$getSubformParent]() { const parent = this[_xfa_object.$getParent](); if (parent instanceof SubformSet) { return parent[_xfa_object.$getSubformParent](); } return parent; } [_xfa_object.$isBindable]() { return true; } [_xfa_object.$isThereMoreWidth]() { return this.layout.endsWith(&quot;-tb&quot;) &amp;&amp; this[_xfa_object.$extra].attempt === 0 &amp;&amp; this[_xfa_object.$extra].numberInLine &gt; 0 || this[_xfa_object.$getParent]()[_xfa_object.$isThereMoreWidth](); } *[_xfa_object.$getContainedChildren]() { yield* getContainedChildren(this); } [_xfa_object.$flushHTML]() { return (0, _layout.flushHTML)(this); } [_xfa_object.$addHTML](html, bbox) { (0, _layout.addHTML)(this, html, bbox); } [_xfa_object.$getAvailableSpace]() { return (0, _layout.getAvailableSpace)(this); } [_xfa_object.$isSplittable]() { const parent = this[_xfa_object.$getSubformParent](); if (!parent[_xfa_object.$isSplittable]()) { return false; } if (this[_xfa_object.$extra]._isSplittable !== undefined) { return this[_xfa_object.$extra]._isSplittable; } if (this.layout === &quot;position&quot; || this.layout.includes(&quot;row&quot;)) { this[_xfa_object.$extra]._isSplittable = false; return false; } if (this.keep &amp;&amp; this.keep.intact !== &quot;none&quot;) { this[_xfa_object.$extra]._isSplittable = false; return false; } if (parent.layout &amp;&amp; parent.layout.endsWith(&quot;-tb&quot;) &amp;&amp; parent[_xfa_object.$extra].numberInLine !== 0) { return false; } this[_xfa_object.$extra]._isSplittable = true; return true; } [_xfa_object.$toHTML](availableSpace) { setTabIndex(this); if (this.break) { if (this.break.after !== &quot;auto&quot; || this.break.afterTarget !== &quot;&quot;) { const node = new BreakAfter({ targetType: this.break.after, target: this.break.afterTarget, startNew: this.break.startNew.toString() }); node[_xfa_object.$globalData] = this[_xfa_object.$globalData]; this[_xfa_object.$appendChild](node); this.breakAfter.push(node); } if (this.break.before !== &quot;auto&quot; || this.break.beforeTarget !== &quot;&quot;) { const node = new BreakBefore({ targetType: this.break.before, target: this.break.beforeTarget, startNew: this.break.startNew.toString() }); node[_xfa_object.$globalData] = this[_xfa_object.$globalData]; this[_xfa_object.$appendChild](node); this.breakBefore.push(node); } if (this.break.overflowTarget !== &quot;&quot;) { const node = new Overflow({ target: this.break.overflowTarget, leader: this.break.overflowLeader, trailer: this.break.overflowTrailer }); node[_xfa_object.$globalData] = this[_xfa_object.$globalData]; this[_xfa_object.$appendChild](node); this.overflow.push(node); } this[_xfa_object.$removeChild](this.break); this.break = null; } if (this.presence === &quot;hidden&quot; || this.presence === &quot;inactive&quot;) { return _utils.HTMLResult.EMPTY; } if (this.breakBefore.children.length &gt; 1 || this.breakAfter.children.length &gt; 1) { (0, _util.warn)(&quot;XFA - Several breakBefore or breakAfter in subforms: please file a bug.&quot;); } if (this.breakBefore.children.length &gt;= 1) { const breakBefore = this.breakBefore.children[0]; if (handleBreak(breakBefore)) { return _utils.HTMLResult.breakNode(breakBefore); } } if (this[_xfa_object.$extra] &amp;&amp; this[_xfa_object.$extra].afterBreakAfter) { return _utils.HTMLResult.EMPTY; } (0, _html_utils.fixDimensions)(this); const children = []; const attributes = { id: this[_xfa_object.$uid], class: [] }; (0, _html_utils.setAccess)(this, attributes.class); if (!this[_xfa_object.$extra]) { this[_xfa_object.$extra] = Object.create(null); } Object.assign(this[_xfa_object.$extra], { children, line: null, attributes, attempt: 0, numberInLine: 0, availableSpace: { width: Math.min(this.w || Infinity, availableSpace.width), height: Math.min(this.h || Infinity, availableSpace.height) }, width: 0, height: 0, prevHeight: 0, currentWidth: 0 }); const root = this[_xfa_object.$getTemplateRoot](); const savedNoLayoutFailure = root[_xfa_object.$extra].noLayoutFailure; const isSplittable = this[_xfa_object.$isSplittable](); if (!isSplittable) { setFirstUnsplittable(this); } if (!(0, _layout.checkDimensions)(this, availableSpace)) { return _utils.HTMLResult.FAILURE; } const filter = new Set([&quot;area&quot;, &quot;draw&quot;, &quot;exclGroup&quot;, &quot;field&quot;, &quot;subform&quot;, &quot;subformSet&quot;]); if (this.layout.includes(&quot;row&quot;)) { const columnWidths = this[_xfa_object.$getSubformParent]().columnWidths; if (Array.isArray(columnWidths) &amp;&amp; columnWidths.length &gt; 0) { this[_xfa_object.$extra].columnWidths = columnWidths; this[_xfa_object.$extra].currentColumn = 0; } } const style = (0, _html_utils.toStyle)(this, &quot;anchorType&quot;, &quot;dimensions&quot;, &quot;position&quot;, &quot;presence&quot;, &quot;border&quot;, &quot;margin&quot;, &quot;hAlign&quot;); const classNames = [&quot;xfaSubform&quot;]; const cl = (0, _html_utils.layoutClass)(this); if (cl) { classNames.push(cl); } attributes.style = style; attributes.class = classNames; if (this.name) { attributes.xfaName = this.name; } if (this.overflow) { const overflowExtra = this.overflow[_xfa_object.$getExtra](); if (overflowExtra.addLeader) { overflowExtra.addLeader = false; handleOverflow(this, overflowExtra.leader, availableSpace); } } this[_xfa_object.$pushPara](); const isLrTb = this.layout === &quot;lr-tb&quot; || this.layout === &quot;rl-tb&quot;; const maxRun = isLrTb ? MAX_ATTEMPTS_FOR_LRTB_LAYOUT : 1; for (; this[_xfa_object.$extra].attempt &lt; maxRun; this[_xfa_object.$extra].attempt++) { if (isLrTb &amp;&amp; this[_xfa_object.$extra].attempt === MAX_ATTEMPTS_FOR_LRTB_LAYOUT - 1) { this[_xfa_object.$extra].numberInLine = 0; } const result = this[_xfa_object.$childrenToHTML]({ filter, include: true }); if (result.success) { break; } if (result.isBreak()) { this[_xfa_object.$popPara](); return result; } if (isLrTb &amp;&amp; this[_xfa_object.$extra].attempt === 0 &amp;&amp; this[_xfa_object.$extra].numberInLine === 0 &amp;&amp; !root[_xfa_object.$extra].noLayoutFailure) { this[_xfa_object.$extra].attempt = maxRun; break; } } this[_xfa_object.$popPara](); if (!isSplittable) { unsetFirstUnsplittable(this); } root[_xfa_object.$extra].noLayoutFailure = savedNoLayoutFailure; if (this[_xfa_object.$extra].attempt === maxRun) { if (this.overflow) { this[_xfa_object.$getTemplateRoot]()[_xfa_object.$extra].overflowNode = this.overflow; } if (!isSplittable) { delete this[_xfa_object.$extra]; } return _utils.HTMLResult.FAILURE; } if (this.overflow) { const overflowExtra = this.overflow[_xfa_object.$getExtra](); if (overflowExtra.addTrailer) { overflowExtra.addTrailer = false; handleOverflow(this, overflowExtra.trailer, availableSpace); } } let marginH = 0; let marginV = 0; if (this.margin) { marginH = this.margin.leftInset + this.margin.rightInset; marginV = this.margin.topInset + this.margin.bottomInset; } const width = Math.max(this[_xfa_object.$extra].width + marginH, this.w || 0); const height = Math.max(this[_xfa_object.$extra].height + marginV, this.h || 0); const bbox = [this.x, this.y, width, height]; if (this.w === &quot;&quot;) { style.width = (0, _html_utils.measureToString)(width); } if (this.h === &quot;&quot;) { style.height = (0, _html_utils.measureToString)(height); } if ((style.width === &quot;0px&quot; || style.height === &quot;0px&quot;) &amp;&amp; children.length === 0) { return _utils.HTMLResult.EMPTY; } const html = { name: &quot;div&quot;, attributes, children }; applyAssist(this, attributes); const result = _utils.HTMLResult.success((0, _html_utils.createWrapper)(this, html), bbox); if (this.breakAfter.children.length &gt;= 1) { const breakAfter = this.breakAfter.children[0]; if (handleBreak(breakAfter)) { this[_xfa_object.$extra].afterBreakAfter = result; return _utils.HTMLResult.breakNode(breakAfter); } } delete this[_xfa_object.$extra]; return result; } } class SubformSet extends _xfa_object.XFAObject { constructor(attributes) { super(TEMPLATE_NS_ID, &quot;subformSet&quot;, true); this.id = attributes.id || &quot;&quot;; this.name = attributes.name || &quot;&quot;; this.relation = (0, _utils.getStringOption)(attributes.relation, [&quot;ordered&quot;, &quot;choice&quot;, &quot;unordered&quot;]); this.relevant = (0, _utils.getRelevant)(attributes.relevant); this.use = attributes.use || &quot;&quot;; this.usehref = attributes.usehref || &quot;&quot;; this.bookend = null; this.break = null; this.desc = null; this.extras = null; this.occur = null; this.overflow = null; this.breakAfter = new _xfa_object.XFAObjectArray(); this.breakBefore = new _xfa_object.XFAObjectArray(); this.subform = new _xfa_object.XFAObjectArray(); this.subformSet = new _xfa_object.XFAObjectArray(); } *[_xfa_object.$getContainedChildren]() { yield* getContainedChildren(this); } [_xfa_object.$getSubformParent]() { let parent = this[_xfa_object.$getParent](); while (!(parent instanceof Subform)) { parent = parent[_xfa_object.$getParent](); } return parent; } [_xfa_object.$isBindable]() { return true; } } class SubjectDN extends _xfa_object.ContentObject { constructor(attributes) { super(TEMPLATE_NS_ID, &quot;subjectDN&quot;); this.delimiter = attributes.delimiter || &quot;,&quot;; this.id = attributes.id || &quot;&quot;; this.name = attributes.name || &quot;&quot;; this.use = attributes.use || &quot;&quot;; this.usehref = attributes.usehref || &quot;&quot;; } [_xfa_object.$finalize]() { this[_xfa_object.$content] = new Map(this[_xfa_object.$content].split(this.delimiter).map(kv =&gt; { kv = kv.split(&quot;=&quot;, 2); kv[0] = kv[0].trim(); return kv; })); } } class SubjectDNs extends _xfa_object.XFAObject { constructor(attributes) { super(TEMPLATE_NS_ID, &quot;subjectDNs&quot;, true); this.id = attributes.id || &quot;&quot;; this.type = (0, _utils.getStringOption)(attributes.type, [&quot;optional&quot;, &quot;required&quot;]); this.use = attributes.use || &quot;&quot;; this.usehref = attributes.usehref || &quot;&quot;; this.subjectDN = new _xfa_object.XFAObjectArray(); } } class Submit extends _xfa_object.XFAObject { constructor(attributes) { super(TEMPLATE_NS_ID, &quot;submit&quot;, true); this.embedPDF = (0, _utils.getInteger)({ data: attributes.embedPDF, defaultValue: 0, validate: x =&gt; x === 1 }); this.format = (0, _utils.getStringOption)(attributes.format, [&quot;xdp&quot;, &quot;formdata&quot;, &quot;pdf&quot;, &quot;urlencoded&quot;, &quot;xfd&quot;, &quot;xml&quot;]); this.id = attributes.id || &quot;&quot;; this.target = attributes.target || &quot;&quot;; this.textEncoding = (0, _utils.getKeyword)({ data: attributes.textEncoding ? attributes.textEncoding.toLowerCase() : &quot;&quot;, defaultValue: &quot;&quot;, validate: k =&gt; [&quot;utf-8&quot;, &quot;big-five&quot;, &quot;fontspecific&quot;, &quot;gbk&quot;, &quot;gb-18030&quot;, &quot;gb-2312&quot;, &quot;ksc-5601&quot;, &quot;none&quot;, &quot;shift-jis&quot;, &quot;ucs-2&quot;, &quot;utf-16&quot;].includes(k) || k.match(/iso-8859-\\d{2}/) }); this.use = attributes.use || &quot;&quot;; this.usehref = attributes.usehref || &quot;&quot;; this.xdpContent = attributes.xdpContent || &quot;&quot;; this.encrypt = null; this.encryptData = new _xfa_object.XFAObjectArray(); this.signData = new _xfa_object.XFAObjectArray(); } } class Template extends _xfa_object.XFAObject { constructor(attributes) { super(TEMPLATE_NS_ID, &quot;template&quot;, true); this.baseProfile = (0, _utils.getStringOption)(attributes.baseProfile, [&quot;full&quot;, &quot;interactiveForms&quot;]); this.extras = null; this.subform = new _xfa_object.XFAObjectArray(); } [_xfa_object.$finalize]() { if (this.subform.children.length === 0) { (0, _util.warn)(&quot;XFA - No subforms in template node.&quot;); } if (this.subform.children.length &gt;= 2) { (0, _util.warn)(&quot;XFA - Several subforms in template node: please file a bug.&quot;); } this[_xfa_object.$tabIndex] = DEFAULT_TAB_INDEX; } [_xfa_object.$isSplittable]() { return true; } [_xfa_object.$searchNode](expr, container) { if (expr.startsWith(&quot;#&quot;)) { return [this[_xfa_object.$ids].get(expr.slice(1))]; } return (0, _som.searchNode)(this, container, expr, true, true); } *[_xfa_object.$toPages]() { if (!this.subform.children.length) { return _utils.HTMLResult.success({ name: &quot;div&quot;, children: [] }); } this[_xfa_object.$extra] = { overflowNode: null, firstUnsplittable: null, currentContentArea: null, currentPageArea: null, noLayoutFailure: false, pageNumber: 1, pagePosition: &quot;first&quot;, oddOrEven: &quot;odd&quot;, blankOrNotBlank: &quot;nonBlank&quot;, paraStack: [] }; const root = this.subform.children[0]; root.pageSet[_xfa_object.$cleanPage](); const pageAreas = root.pageSet.pageArea.children; const mainHtml = { name: &quot;div&quot;, children: [] }; let pageArea = null; let breakBefore = null; let breakBeforeTarget = null; if (root.breakBefore.children.length &gt;= 1) { breakBefore = root.breakBefore.children[0]; breakBeforeTarget = breakBefore.target; } else if (root.subform.children.length &gt;= 1 &amp;&amp; root.subform.children[0].breakBefore.children.length &gt;= 1) { breakBefore = root.subform.children[0].breakBefore.children[0]; breakBeforeTarget = breakBefore.target; } else if (root.break &amp;&amp; root.break.beforeTarget) { breakBefore = root.break; breakBeforeTarget = breakBefore.beforeTarget; } else if (root.subform.children.length &gt;= 1 &amp;&amp; root.subform.children[0].break &amp;&amp; root.subform.children[0].break.beforeTarget) { breakBefore = root.subform.children[0].break; breakBeforeTarget = breakBefore.beforeTarget; } if (breakBefore) { const target = this[_xfa_object.$searchNode](breakBeforeTarget, breakBefore[_xfa_object.$getParent]()); if (target instanceof PageArea) { pageArea = target; breakBefore[_xfa_object.$extra] = {}; } } if (!pageArea) { pageArea = pageAreas[0]; } pageArea[_xfa_object.$extra] = { numberOfUse: 1 }; const pageAreaParent = pageArea[_xfa_object.$getParent](); pageAreaParent[_xfa_object.$extra] = { numberOfUse: 1, pageIndex: pageAreaParent.pageArea.children.indexOf(pageArea), pageSetIndex: 0 }; let targetPageArea; let leader = null; let trailer = null; let hasSomething = true; let hasSomethingCounter = 0; let startIndex = 0; while (true) { if (!hasSomething) { mainHtml.children.pop(); if (++hasSomethingCounter === MAX_EMPTY_PAGES) { (0, _util.warn)(&quot;XFA - Something goes wrong: please file a bug.&quot;); return mainHtml; } } else { hasSomethingCounter = 0; } targetPageArea = null; this[_xfa_object.$extra].currentPageArea = pageArea; const page = pageArea[_xfa_object.$toHTML]().html; mainHtml.children.push(page); if (leader) { this[_xfa_object.$extra].noLayoutFailure = true; page.children.push(leader[_xfa_object.$toHTML](pageArea[_xfa_object.$extra].space).html); leader = null; } if (trailer) { this[_xfa_object.$extra].noLayoutFailure = true; page.children.push(trailer[_xfa_object.$toHTML](pageArea[_xfa_object.$extra].space).html); trailer = null; } const contentAreas = pageArea.contentArea.children; const htmlContentAreas = page.children.filter(node =&gt; node.attributes.class.includes(&quot;xfaContentarea&quot;)); hasSomething = false; this[_xfa_object.$extra].firstUnsplittable = null; this[_xfa_object.$extra].noLayoutFailure = false; const flush = index =&gt; { const html = root[_xfa_object.$flushHTML](); if (html) { hasSomething = hasSomething || html.children &amp;&amp; html.children.length !== 0; htmlContentAreas[index].children.push(html); } }; for (let i = startIndex, ii = contentAreas.length; i &lt; ii; i++) { const contentArea = this[_xfa_object.$extra].currentContentArea = contentAreas[i]; const space = { width: contentArea.w, height: contentArea.h }; startIndex = 0; if (leader) { htmlContentAreas[i].children.push(leader[_xfa_object.$toHTML](space).html); leader = null; } if (trailer) { htmlContentAreas[i].children.push(trailer[_xfa_object.$toHTML](space).html); trailer = null; } const html = root[_xfa_object.$toHTML](space); if (html.success) { if (html.html) { hasSomething = hasSomething || html.html.children &amp;&amp; html.html.children.length !== 0; htmlContentAreas[i].children.push(html.html); } else if (!hasSomething &amp;&amp; mainHtml.children.length &gt; 1) { mainHtml.children.pop(); } return mainHtml; } if (html.isBreak()) { const node = html.breakNode; flush(i); if (node.targetType === &quot;auto&quot;) { continue; } if (node.leader) { leader = this[_xfa_object.$searchNode](node.leader, node[_xfa_object.$getParent]()); leader = leader ? leader[0] : null; } if (node.trailer) { trailer = this[_xfa_object.$searchNode](node.trailer, node[_xfa_object.$getParent]()); trailer = trailer ? trailer[0] : null; } if (node.targetType === &quot;pageArea&quot;) { targetPageArea = node[_xfa_object.$extra].target; i = Infinity; } else if (!node[_xfa_object.$extra].target) { i = node[_xfa_object.$extra].index; } else { targetPageArea = node[_xfa_object.$extra].target; startIndex = node[_xfa_object.$extra].index + 1; i = Infinity; } continue; } if (this[_xfa_object.$extra].overflowNode) { const node = this[_xfa_object.$extra].overflowNode; this[_xfa_object.$extra].overflowNode = null; const overflowExtra = node[_xfa_object.$getExtra](); const target = overflowExtra.target; overflowExtra.addLeader = overflowExtra.leader !== null; overflowExtra.addTrailer = overflowExtra.trailer !== null; flush(i); const currentIndex = i; i = Infinity; if (target instanceof PageArea) { targetPageArea = target; } else if (target instanceof ContentArea) { const index = contentAreas.indexOf(target); if (index !== -1) { if (index &gt; currentIndex) { i = index - 1; } else { startIndex = index; } } else { targetPageArea = target[_xfa_object.$getParent](); startIndex = targetPageArea.contentArea.children.indexOf(target); } } continue; } flush(i); } this[_xfa_object.$extra].pageNumber += 1; if (targetPageArea) { if (targetPageArea[_xfa_object.$isUsable]()) { targetPageArea[_xfa_object.$extra].numberOfUse += 1; } else { targetPageArea = null; } } pageArea = targetPageArea || pageArea[_xfa_object.$getNextPage](); yield null; } } } exports.Template = Template; class Text extends _xfa_object.ContentObject { constructor(attributes) { super(TEMPLATE_NS_ID, &quot;text&quot;); this.id = attributes.id || &quot;&quot;; this.maxChars = (0, _utils.getInteger)({ data: attributes.maxChars, defaultValue: 0, validate: x =&gt; x &gt;= 0 }); this.name = attributes.name || &quot;&quot;; this.rid = attributes.rid || &quot;&quot;; this.use = attributes.use || &quot;&quot;; this.usehref = attributes.usehref || &quot;&quot;; } [_xfa_object.$acceptWhitespace]() { return true; } [_xfa_object.$onChild](child) { if (child[_xfa_object.$namespaceId] === _namespaces.NamespaceIds.xhtml.id) { this[_xfa_object.$content] = child; return true; } (0, _util.warn)(`XFA - Invalid content in Text: ${child[_xfa_object.$nodeName]}.`); return false; } [_xfa_object.$onText](str) { if (this[_xfa_object.$content] instanceof _xfa_object.XFAObject) { return; } super[_xfa_object.$onText](str); } [_xfa_object.$finalize]() { if (typeof this[_xfa_object.$content] === &quot;string&quot;) { this[_xfa_object.$content] = this[_xfa_object.$content].replace(/\\r\\n/g, &quot;\\n&quot;); } } [_xfa_object.$getExtra]() { if (typeof this[_xfa_object.$content] === &quot;string&quot;) { return this[_xfa_object.$content].split(/[\\u2029\\u2028\\n]/).reduce((acc, line) =&gt; { if (line) { acc.push(line); } return acc; }, []).join(&quot;\\n&quot;); } return this[_xfa_object.$content][_xfa_object.$text](); } [_xfa_object.$toHTML](availableSpace) { if (typeof this[_xfa_object.$content] === &quot;string&quot;) { const html = valueToHtml(this[_xfa_object.$content]).html; if (this[_xfa_object.$content].includes(&quot;\\u2029&quot;)) { html.name = &quot;div&quot;; html.children = []; this[_xfa_object.$content].split(&quot;\\u2029&quot;).map(para =&gt; para.split(/[\\u2028\\n]/).reduce((acc, line) =&gt; { acc.push({ name: &quot;span&quot;, value: line }, { name: &quot;br&quot; }); return acc; }, [])).forEach(lines =&gt; { html.children.push({ name: &quot;p&quot;, children: lines }); }); } else if (/[\\u2028\\n]/.test(this[_xfa_object.$content])) { html.name = &quot;div&quot;; html.children = []; this[_xfa_object.$content].split(/[\\u2028\\n]/).forEach(line =&gt; { html.children.push({ name: &quot;span&quot;, value: line }, { name: &quot;br&quot; }); }); } return _utils.HTMLResult.success(html); } return this[_xfa_object.$content][_xfa_object.$toHTML](availableSpace); } } exports.Text = Text; class TextEdit extends _xfa_object.XFAObject { constructor(attributes) { super(TEMPLATE_NS_ID, &quot;textEdit&quot;, true); this.allowRichText = (0, _utils.getInteger)({ data: attributes.allowRichText, defaultValue: 0, validate: x =&gt; x === 1 }); this.hScrollPolicy = (0, _utils.getStringOption)(attributes.hScrollPolicy, [&quot;auto&quot;, &quot;off&quot;, &quot;on&quot;]); this.id = attributes.id || &quot;&quot;; this.multiLine = (0, _utils.getInteger)({ data: attributes.multiLine, defaultValue: &quot;&quot;, validate: x =&gt; x === 0 || x === 1 }); this.use = attributes.use || &quot;&quot;; this.usehref = attributes.usehref || &quot;&quot;; this.vScrollPolicy = (0, _utils.getStringOption)(attributes.vScrollPolicy, [&quot;auto&quot;, &quot;off&quot;, &quot;on&quot;]); this.border = null; this.comb = null; this.extras = null; this.margin = null; } [_xfa_object.$toHTML](availableSpace) { const style = (0, _html_utils.toStyle)(this, &quot;border&quot;, &quot;font&quot;, &quot;margin&quot;); let html; const field = this[_xfa_object.$getParent]()[_xfa_object.$getParent](); if (this.multiLine === &quot;&quot;) { this.multiLine = field instanceof Draw ? 1 : 0; } if (this.multiLine === 1) { html = { name: &quot;textarea&quot;, attributes: { dataId: field[_xfa_object.$data] &amp;&amp; field[_xfa_object.$data][_xfa_object.$uid] || field[_xfa_object.$uid], fieldId: field[_xfa_object.$uid], class: [&quot;xfaTextfield&quot;], style, &quot;aria-label&quot;: ariaLabel(field), &quot;aria-required&quot;: false } }; } else { html = { name: &quot;input&quot;, attributes: { type: &quot;text&quot;, dataId: field[_xfa_object.$data] &amp;&amp; field[_xfa_object.$data][_xfa_object.$uid] || field[_xfa_object.$uid], fieldId: field[_xfa_object.$uid], class: [&quot;xfaTextfield&quot;], style, &quot;aria-label&quot;: ariaLabel(field), &quot;aria-required&quot;: false } }; } if (isRequired(field)) { html.attributes[&quot;aria-required&quot;] = true; html.attributes.required = true; } return _utils.HTMLResult.success({ name: &quot;label&quot;, attributes: { class: [&quot;xfaLabel&quot;] }, children: [html] }); } } class Time extends _xfa_object.StringObject { constructor(attributes) { super(TEMPLATE_NS_ID, &quot;time&quot;); this.id = attributes.id || &quot;&quot;; this.name = attributes.name || &quot;&quot;; this.use = attributes.use || &quot;&quot;; this.usehref = attributes.usehref || &quot;&quot;; } [_xfa_object.$finalize]() { const date = this[_xfa_object.$content].trim(); this[_xfa_object.$content] = date ? new Date(date) : null; } [_xfa_object.$toHTML](availableSpace) { return valueToHtml(this[_xfa_object.$content] ? this[_xfa_object.$content].toString() : &quot;&quot;); } } class TimeStamp extends _xfa_object.XFAObject { constructor(attributes) { super(TEMPLATE_NS_ID, &quot;timeStamp&quot;); this.id = attributes.id || &quot;&quot;; this.server = attributes.server || &quot;&quot;; this.type = (0, _utils.getStringOption)(attributes.type, [&quot;optional&quot;, &quot;required&quot;]); this.use = attributes.use || &quot;&quot;; this.usehref = attributes.usehref || &quot;&quot;; } } class ToolTip extends _xfa_object.StringObject { constructor(attributes) { super(TEMPLATE_NS_ID, &quot;toolTip&quot;); this.id = attributes.id || &quot;&quot;; this.rid = attributes.rid || &quot;&quot;; this.use = attributes.use || &quot;&quot;; this.usehref = attributes.usehref || &quot;&quot;; } } class Traversal extends _xfa_object.XFAObject { constructor(attributes) { super(TEMPLATE_NS_ID, &quot;traversal&quot;, true); this.id = attributes.id || &quot;&quot;; this.use = attributes.use || &quot;&quot;; this.usehref = attributes.usehref || &quot;&quot;; this.extras = null; this.traverse = new _xfa_object.XFAObjectArray(); } } class Traverse extends _xfa_object.XFAObject { constructor(attributes) { super(TEMPLATE_NS_ID, &quot;traverse&quot;, true); this.id = attributes.id || &quot;&quot;; this.operation = (0, _utils.getStringOption)(attributes.operation, [&quot;next&quot;, &quot;back&quot;, &quot;down&quot;, &quot;first&quot;, &quot;left&quot;, &quot;right&quot;, &quot;up&quot;]); this.ref = attributes.ref || &quot;&quot;; this.use = attributes.use || &quot;&quot;; this.usehref = attributes.usehref || &quot;&quot;; this.extras = null; this.script = null; } get name() { return this.operation; } [_xfa_object.$isTransparent]() { return false; } } class Ui extends _xfa_object.XFAObject { constructor(attributes) { super(TEMPLATE_NS_ID, &quot;ui&quot;, true); this.id = attributes.id || &quot;&quot;; this.use = attributes.use || &quot;&quot;; this.usehref = attributes.usehref || &quot;&quot;; this.extras = null; this.picture = null; this.barcode = null; this.button = null; this.checkButton = null; this.choiceList = null; this.dateTimeEdit = null; this.defaultUi = null; this.imageEdit = null; this.numericEdit = null; this.passwordEdit = null; this.signature = null; this.textEdit = null; } [_xfa_object.$getExtra]() { if (this[_xfa_object.$extra] === undefined) { for (const name of Object.getOwnPropertyNames(this)) { if (name === &quot;extras&quot; || name === &quot;picture&quot;) { continue; } const obj = this[name]; if (!(obj instanceof _xfa_object.XFAObject)) { continue; } this[_xfa_object.$extra] = obj; return obj; } this[_xfa_object.$extra] = null; } return this[_xfa_object.$extra]; } [_xfa_object.$toHTML](availableSpace) { const obj = this[_xfa_object.$getExtra](); if (obj) { return obj[_xfa_object.$toHTML](availableSpace); } return _utils.HTMLResult.EMPTY; } } class Validate extends _xfa_object.XFAObject { constructor(attributes) { super(TEMPLATE_NS_ID, &quot;validate&quot;, true); this.formatTest = (0, _utils.getStringOption)(attributes.formatTest, [&quot;warning&quot;, &quot;disabled&quot;, &quot;error&quot;]); this.id = attributes.id || &quot;&quot;; this.nullTest = (0, _utils.getStringOption)(attributes.nullTest, [&quot;disabled&quot;, &quot;error&quot;, &quot;warning&quot;]); this.scriptTest = (0, _utils.getStringOption)(attributes.scriptTest, [&quot;error&quot;, &quot;disabled&quot;, &quot;warning&quot;]); this.use = attributes.use || &quot;&quot;; this.usehref = attributes.usehref || &quot;&quot;; this.extras = null; this.message = null; this.picture = null; this.script = null; } } class Value extends _xfa_object.XFAObject { constructor(attributes) { super(TEMPLATE_NS_ID, &quot;value&quot;, true); this.id = attributes.id || &quot;&quot;; this.override = (0, _utils.getInteger)({ data: attributes.override, defaultValue: 0, validate: x =&gt; x === 1 }); this.relevant = (0, _utils.getRelevant)(attributes.relevant); this.use = attributes.use || &quot;&quot;; this.usehref = attributes.usehref || &quot;&quot;; this.arc = null; this.boolean = null; this.date = null; this.dateTime = null; this.decimal = null; this.exData = null; this.float = null; this.image = null; this.integer = null; this.line = null; this.rectangle = null; this.text = null; this.time = null; } [_xfa_object.$setValue](value) { const parent = this[_xfa_object.$getParent](); if (parent instanceof Field) { if (parent.ui &amp;&amp; parent.ui.imageEdit) { if (!this.image) { this.image = new Image({}); this[_xfa_object.$appendChild](this.image); } this.image[_xfa_object.$content] = value[_xfa_object.$content]; return; } } const valueName = value[_xfa_object.$nodeName]; if (this[valueName] !== null) { this[valueName][_xfa_object.$content] = value[_xfa_object.$content]; return; } for (const name of Object.getOwnPropertyNames(this)) { const obj = this[name]; if (obj instanceof _xfa_object.XFAObject) { this[name] = null; this[_xfa_object.$removeChild](obj); } } this[value[_xfa_object.$nodeName]] = value; this[_xfa_object.$appendChild](value); } [_xfa_object.$text]() { if (this.exData) { if (typeof this.exData[_xfa_object.$content] === &quot;string&quot;) { return this.exData[_xfa_object.$content].trim(); } return this.exData[_xfa_object.$content][_xfa_object.$text]().trim(); } for (const name of Object.getOwnPropertyNames(this)) { if (name === &quot;image&quot;) { continue; } const obj = this[name]; if (obj instanceof _xfa_object.XFAObject) { return (obj[_xfa_object.$content] || &quot;&quot;).toString().trim(); } } return null; } [_xfa_object.$toHTML](availableSpace) { for (const name of Object.getOwnPropertyNames(this)) { const obj = this[name]; if (!(obj instanceof _xfa_object.XFAObject)) { continue; } return obj[_xfa_object.$toHTML](availableSpace); } return _utils.HTMLResult.EMPTY; } } exports.Value = Value; class Variables extends _xfa_object.XFAObject { constructor(attributes) { super(TEMPLATE_NS_ID, &quot;variables&quot;, true); this.id = attributes.id || &quot;&quot;; this.use = attributes.use || &quot;&quot;; this.usehref = attributes.usehref || &quot;&quot;; this.boolean = new _xfa_object.XFAObjectArray(); this.date = new _xfa_object.XFAObjectArray(); this.dateTime = new _xfa_object.XFAObjectArray(); this.decimal = new _xfa_object.XFAObjectArray(); this.exData = new _xfa_object.XFAObjectArray(); this.float = new _xfa_object.XFAObjectArray(); this.image = new _xfa_object.XFAObjectArray(); this.integer = new _xfa_object.XFAObjectArray(); this.manifest = new _xfa_object.XFAObjectArray(); this.script = new _xfa_object.XFAObjectArray(); this.text = new _xfa_object.XFAObjectArray(); this.time = new _xfa_object.XFAObjectArray(); } [_xfa_object.$isTransparent]() { return true; } } class TemplateNamespace { static [_namespaces.$buildXFAObject](name, attributes) { if (TemplateNamespace.hasOwnProperty(name)) { const node = TemplateNamespace[name](attributes); node[_xfa_object.$setSetAttributes](attributes); return node; } return undefined; } static appearanceFilter(attrs) { return new AppearanceFilter(attrs); } static arc(attrs) { return new Arc(attrs); } static area(attrs) { return new Area(attrs); } static assist(attrs) { return new Assist(attrs); } static barcode(attrs) { return new Barcode(attrs); } static bind(attrs) { return new Bind(attrs); } static bindItems(attrs) { return new BindItems(attrs); } static bookend(attrs) { return new Bookend(attrs); } static boolean(attrs) { return new BooleanElement(attrs); } static border(attrs) { return new Border(attrs); } static break(attrs) { return new Break(attrs); } static breakAfter(attrs) { return new BreakAfter(attrs); } static breakBefore(attrs) { return new BreakBefore(attrs); } static button(attrs) { return new Button(attrs); } static calculate(attrs) { return new Calculate(attrs); } static caption(attrs) { return new Caption(attrs); } static certificate(attrs) { return new Certificate(attrs); } static certificates(attrs) { return new Certificates(attrs); } static checkButton(attrs) { return new CheckButton(attrs); } static choiceList(attrs) { return new ChoiceList(attrs); } static color(attrs) { return new Color(attrs); } static comb(attrs) { return new Comb(attrs); } static connect(attrs) { return new Connect(attrs); } static contentArea(attrs) { return new ContentArea(attrs); } static corner(attrs) { return new Corner(attrs); } static date(attrs) { return new DateElement(attrs); } static dateTime(attrs) { return new DateTime(attrs); } static dateTimeEdit(attrs) { return new DateTimeEdit(attrs); } static decimal(attrs) { return new Decimal(attrs); } static defaultUi(attrs) { return new DefaultUi(attrs); } static desc(attrs) { return new Desc(attrs); } static digestMethod(attrs) { return new DigestMethod(attrs); } static digestMethods(attrs) { return new DigestMethods(attrs); } static draw(attrs) { return new Draw(attrs); } static edge(attrs) { return new Edge(attrs); } static encoding(attrs) { return new Encoding(attrs); } static encodings(attrs) { return new Encodings(attrs); } static encrypt(attrs) { return new Encrypt(attrs); } static encryptData(attrs) { return new EncryptData(attrs); } static encryption(attrs) { return new Encryption(attrs); } static encryptionMethod(attrs) { return new EncryptionMethod(attrs); } static encryptionMethods(attrs) { return new EncryptionMethods(attrs); } static event(attrs) { return new Event(attrs); } static exData(attrs) { return new ExData(attrs); } static exObject(attrs) { return new ExObject(attrs); } static exclGroup(attrs) { return new ExclGroup(attrs); } static execute(attrs) { return new Execute(attrs); } static extras(attrs) { return new Extras(attrs); } static field(attrs) { return new Field(attrs); } static fill(attrs) { return new Fill(attrs); } static filter(attrs) { return new Filter(attrs); } static float(attrs) { return new Float(attrs); } static font(attrs) { return new Font(attrs); } static format(attrs) { return new Format(attrs); } static handler(attrs) { return new Handler(attrs); } static hyphenation(attrs) { return new Hyphenation(attrs); } static image(attrs) { return new Image(attrs); } static imageEdit(attrs) { return new ImageEdit(attrs); } static integer(attrs) { return new Integer(attrs); } static issuers(attrs) { return new Issuers(attrs); } static items(attrs) { return new Items(attrs); } static keep(attrs) { return new Keep(attrs); } static keyUsage(attrs) { return new KeyUsage(attrs); } static line(attrs) { return new Line(attrs); } static linear(attrs) { return new Linear(attrs); } static lockDocument(attrs) { return new LockDocument(attrs); } static manifest(attrs) { return new Manifest(attrs); } static margin(attrs) { return new Margin(attrs); } static mdp(attrs) { return new Mdp(attrs); } static medium(attrs) { return new Medium(attrs); } static message(attrs) { return new Message(attrs); } static numericEdit(attrs) { return new NumericEdit(attrs); } static occur(attrs) { return new Occur(attrs); } static oid(attrs) { return new Oid(attrs); } static oids(attrs) { return new Oids(attrs); } static overflow(attrs) { return new Overflow(attrs); } static pageArea(attrs) { return new PageArea(attrs); } static pageSet(attrs) { return new PageSet(attrs); } static para(attrs) { return new Para(attrs); } static passwordEdit(attrs) { return new PasswordEdit(attrs); } static pattern(attrs) { return new Pattern(attrs); } static picture(attrs) { return new Picture(attrs); } static proto(attrs) { return new Proto(attrs); } static radial(attrs) { return new Radial(attrs); } static reason(attrs) { return new Reason(attrs); } static reasons(attrs) { return new Reasons(attrs); } static rectangle(attrs) { return new Rectangle(attrs); } static ref(attrs) { return new RefElement(attrs); } static script(attrs) { return new Script(attrs); } static setProperty(attrs) { return new SetProperty(attrs); } static signData(attrs) { return new SignData(attrs); } static signature(attrs) { return new Signature(attrs); } static signing(attrs) { return new Signing(attrs); } static solid(attrs) { return new Solid(attrs); } static speak(attrs) { return new Speak(attrs); } static stipple(attrs) { return new Stipple(attrs); } static subform(attrs) { return new Subform(attrs); } static subformSet(attrs) { return new SubformSet(attrs); } static subjectDN(attrs) { return new SubjectDN(attrs); } static subjectDNs(attrs) { return new SubjectDNs(attrs); } static submit(attrs) { return new Submit(attrs); } static template(attrs) { return new Template(attrs); } static text(attrs) { return new Text(attrs); } static textEdit(attrs) { return new TextEdit(attrs); } static time(attrs) { return new Time(attrs); } static timeStamp(attrs) { return new TimeStamp(attrs); } static toolTip(attrs) { return new ToolTip(attrs); } static traversal(attrs) { return new Traversal(attrs); } static traverse(attrs) { return new Traverse(attrs); } static ui(attrs) { return new Ui(attrs); } static validate(attrs) { return new Validate(attrs); } static value(attrs) { return new Value(attrs); } static variables(attrs) { return new Variables(attrs); } } exports.TemplateNamespace = TemplateNamespace; /***/ }), /* 81 */ /***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) =&gt; { Object.defineProperty(exports, &quot;__esModule&quot;, ({ value: true })); exports.addHTML = addHTML; exports.checkDimensions = checkDimensions; exports.flushHTML = flushHTML; exports.getAvailableSpace = getAvailableSpace; var _xfa_object = __w_pdfjs_require__(75); var _html_utils = __w_pdfjs_require__(82); function createLine(node, children) { return { name: &quot;div&quot;, attributes: { class: [node.layout === &quot;lr-tb&quot; ? &quot;xfaLr&quot; : &quot;xfaRl&quot;] }, children }; } function flushHTML(node) { if (!node[_xfa_object.$extra]) { return null; } const attributes = node[_xfa_object.$extra].attributes; const html = { name: &quot;div&quot;, attributes, children: node[_xfa_object.$extra].children }; if (node[_xfa_object.$extra].failingNode) { const htmlFromFailing = node[_xfa_object.$extra].failingNode[_xfa_object.$flushHTML](); if (htmlFromFailing) { if (node.layout.endsWith(&quot;-tb&quot;)) { html.children.push(createLine(node, [htmlFromFailing])); } else { html.children.push(htmlFromFailing); } } } if (html.children.length === 0) { return null; } return html; } function addHTML(node, html, bbox) { const extra = node[_xfa_object.$extra]; const availableSpace = extra.availableSpace; const [x, y, w, h] = bbox; switch (node.layout) { case &quot;position&quot;: { extra.width = Math.max(extra.width, x + w); extra.height = Math.max(extra.height, y + h); extra.children.push(html); break; } case &quot;lr-tb&quot;: case &quot;rl-tb&quot;: if (!extra.line || extra.attempt === 1) { extra.line = createLine(node, []); extra.children.push(extra.line); extra.numberInLine = 0; } extra.numberInLine += 1; extra.line.children.push(html); if (extra.attempt === 0) { extra.currentWidth += w; extra.height = Math.max(extra.height, extra.prevHeight + h); } else { extra.currentWidth = w; extra.prevHeight = extra.height; extra.height += h; extra.attempt = 0; } extra.width = Math.max(extra.width, extra.currentWidth); break; case &quot;rl-row&quot;: case &quot;row&quot;: { extra.children.push(html); extra.width += w; extra.height = Math.max(extra.height, h); const height = (0, _html_utils.measureToString)(extra.height); for (const child of extra.children) { child.attributes.style.height = height; } break; } case &quot;table&quot;: { extra.width = Math.min(availableSpace.width, Math.max(extra.width, w)); extra.height += h; extra.children.push(html); break; } case &quot;tb&quot;: { extra.width = Math.min(availableSpace.width, Math.max(extra.width, w)); extra.height += h; extra.children.push(html); break; } } } function getAvailableSpace(node) { const availableSpace = node[_xfa_object.$extra].availableSpace; const marginV = node.margin ? node.margin.topInset + node.margin.bottomInset : 0; const marginH = node.margin ? node.margin.leftInset + node.margin.rightInset : 0; switch (node.layout) { case &quot;lr-tb&quot;: case &quot;rl-tb&quot;: if (node[_xfa_object.$extra].attempt === 0) { return { width: availableSpace.width - marginH - node[_xfa_object.$extra].currentWidth, height: availableSpace.height - marginV - node[_xfa_object.$extra].prevHeight }; } return { width: availableSpace.width - marginH, height: availableSpace.height - marginV - node[_xfa_object.$extra].height }; case &quot;rl-row&quot;: case &quot;row&quot;: const width = node[_xfa_object.$extra].columnWidths.slice(node[_xfa_object.$extra].currentColumn).reduce((a, x) =&gt; a + x); return { width, height: availableSpace.height - marginH }; case &quot;table&quot;: case &quot;tb&quot;: return { width: availableSpace.width - marginH, height: availableSpace.height - marginV - node[_xfa_object.$extra].height }; case &quot;position&quot;: default: return availableSpace; } } function getTransformedBBox(node) { let w = node.w === &quot;&quot; ? NaN : node.w; let h = node.h === &quot;&quot; ? NaN : node.h; let [centerX, centerY] = [0, 0]; switch (node.anchorType || &quot;&quot;) { case &quot;bottomCenter&quot;: [centerX, centerY] = [w / 2, h]; break; case &quot;bottomLeft&quot;: [centerX, centerY] = [0, h]; break; case &quot;bottomRight&quot;: [centerX, centerY] = [w, h]; break; case &quot;middleCenter&quot;: [centerX, centerY] = [w / 2, h / 2]; break; case &quot;middleLeft&quot;: [centerX, centerY] = [0, h / 2]; break; case &quot;middleRight&quot;: [centerX, centerY] = [w, h / 2]; break; case &quot;topCenter&quot;: [centerX, centerY] = [w / 2, 0]; break; case &quot;topRight&quot;: [centerX, centerY] = [w, 0]; break; } let x, y; switch (node.rotate || 0) { case 0: [x, y] = [-centerX, -centerY]; break; case 90: [x, y] = [-centerY, centerX]; [w, h] = [h, -w]; break; case 180: [x, y] = [centerX, centerY]; [w, h] = [-w, -h]; break; case 270: [x, y] = [centerY, -centerX]; [w, h] = [-h, w]; break; } return [node.x + x + Math.min(0, w), node.y + y + Math.min(0, h), Math.abs(w), Math.abs(h)]; } function checkDimensions(node, space) { if (node[_xfa_object.$getTemplateRoot]()[_xfa_object.$extra].firstUnsplittable === null) { return true; } if (node.w === 0 || node.h === 0) { return true; } const ERROR = 2; const parent = node[_xfa_object.$getSubformParent](); const attempt = parent[_xfa_object.$extra] &amp;&amp; parent[_xfa_object.$extra].attempt || 0; const [, y, w, h] = getTransformedBBox(node); switch (parent.layout) { case &quot;lr-tb&quot;: case &quot;rl-tb&quot;: if (attempt === 0) { if (!node[_xfa_object.$getTemplateRoot]()[_xfa_object.$extra].noLayoutFailure) { if (node.h !== &quot;&quot; &amp;&amp; Math.round(h - space.height) &gt; ERROR) { return false; } if (node.w !== &quot;&quot;) { if (Math.round(w - space.width) &lt;= ERROR) { return true; } if (parent[_xfa_object.$extra].numberInLine === 0) { return space.height &gt; ERROR; } return false; } return space.width &gt; ERROR; } if (node.w !== &quot;&quot;) { return Math.round(w - space.width) &lt;= ERROR; } return space.width &gt; ERROR; } if (node[_xfa_object.$getTemplateRoot]()[_xfa_object.$extra].noLayoutFailure) { return true; } if (node.h !== &quot;&quot; &amp;&amp; Math.round(h - space.height) &gt; ERROR) { return false; } if (node.w === &quot;&quot; || Math.round(w - space.width) &lt;= ERROR) { return space.height &gt; ERROR; } if (parent[_xfa_object.$isThereMoreWidth]()) { return false; } return space.height &gt; ERROR; case &quot;table&quot;: case &quot;tb&quot;: if (node[_xfa_object.$getTemplateRoot]()[_xfa_object.$extra].noLayoutFailure) { return true; } if (node.h !== &quot;&quot; &amp;&amp; !node[_xfa_object.$isSplittable]()) { return Math.round(h - space.height) &lt;= ERROR; } if (node.w === &quot;&quot; || Math.round(w - space.width) &lt;= ERROR) { return space.height &gt; ERROR; } if (parent[_xfa_object.$isThereMoreWidth]()) { return false; } return space.height &gt; ERROR; case &quot;position&quot;: if (node[_xfa_object.$getTemplateRoot]()[_xfa_object.$extra].noLayoutFailure) { return true; } if (node.h === &quot;&quot; || Math.round(h + y - space.height) &lt;= ERROR) { return true; } const area = node[_xfa_object.$getTemplateRoot]()[_xfa_object.$extra].currentContentArea; return h + y &gt; area.h; case &quot;rl-row&quot;: case &quot;row&quot;: if (node[_xfa_object.$getTemplateRoot]()[_xfa_object.$extra].noLayoutFailure) { return true; } if (node.h !== &quot;&quot;) { return Math.round(h - space.height) &lt;= ERROR; } return true; default: return true; } } /***/ }), /* 82 */ /***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) =&gt; { Object.defineProperty(exports, &quot;__esModule&quot;, ({ value: true })); exports.computeBbox = computeBbox; exports.createWrapper = createWrapper; exports.fixDimensions = fixDimensions; exports.fixTextIndent = fixTextIndent; exports.fixURL = fixURL; exports.isPrintOnly = isPrintOnly; exports.layoutClass = layoutClass; exports.layoutNode = layoutNode; exports.measureToString = measureToString; exports.setAccess = setAccess; exports.setFontFamily = setFontFamily; exports.setMinMaxDimensions = setMinMaxDimensions; exports.setPara = setPara; exports.toStyle = toStyle; var _xfa_object = __w_pdfjs_require__(75); var _util = __w_pdfjs_require__(2); var _utils = __w_pdfjs_require__(76); var _fonts = __w_pdfjs_require__(83); var _text = __w_pdfjs_require__(84); function measureToString(m) { if (typeof m === &quot;string&quot;) { return &quot;0px&quot;; } return Number.isInteger(m) ? `${m}px` : `${m.toFixed(2)}px`; } const converters = { anchorType(node, style) { const parent = node[_xfa_object.$getSubformParent](); if (!parent || parent.layout &amp;&amp; parent.layout !== &quot;position&quot;) { return; } if (!(&quot;transform&quot; in style)) { style.transform = &quot;&quot;; } switch (node.anchorType) { case &quot;bottomCenter&quot;: style.transform += &quot;translate(-50%, -100%)&quot;; break; case &quot;bottomLeft&quot;: style.transform += &quot;translate(0,-100%)&quot;; break; case &quot;bottomRight&quot;: style.transform += &quot;translate(-100%,-100%)&quot;; break; case &quot;middleCenter&quot;: style.transform += &quot;translate(-50%,-50%)&quot;; break; case &quot;middleLeft&quot;: style.transform += &quot;translate(0,-50%)&quot;; break; case &quot;middleRight&quot;: style.transform += &quot;translate(-100%,-50%)&quot;; break; case &quot;topCenter&quot;: style.transform += &quot;translate(-50%,0)&quot;; break; case &quot;topRight&quot;: style.transform += &quot;translate(-100%,0)&quot;; break; } }, dimensions(node, style) { const parent = node[_xfa_object.$getSubformParent](); let width = node.w; const height = node.h; if (parent.layout &amp;&amp; parent.layout.includes(&quot;row&quot;)) { const extra = parent[_xfa_object.$extra]; const colSpan = node.colSpan; let w; if (colSpan === -1) { w = extra.columnWidths.slice(extra.currentColumn).reduce((a, x) =&gt; a + x, 0); extra.currentColumn = 0; } else { w = extra.columnWidths.slice(extra.currentColumn, extra.currentColumn + colSpan).reduce((a, x) =&gt; a + x, 0); extra.currentColumn = (extra.currentColumn + node.colSpan) % extra.columnWidths.length; } if (!isNaN(w)) { width = node.w = w; } } if (width !== &quot;&quot;) { style.width = measureToString(width); } else { style.width = &quot;auto&quot;; } if (height !== &quot;&quot;) { style.height = measureToString(height); } else { style.height = &quot;auto&quot;; } }, position(node, style) { const parent = node[_xfa_object.$getSubformParent](); if (parent &amp;&amp; parent.layout &amp;&amp; parent.layout !== &quot;position&quot;) { return; } style.position = &quot;absolute&quot;; style.left = measureToString(node.x); style.top = measureToString(node.y); }, rotate(node, style) { if (node.rotate) { if (!(&quot;transform&quot; in style)) { style.transform = &quot;&quot;; } style.transform += `rotate(-${node.rotate}deg)`; style.transformOrigin = &quot;top left&quot;; } }, presence(node, style) { switch (node.presence) { case &quot;invisible&quot;: style.visibility = &quot;hidden&quot;; break; case &quot;hidden&quot;: case &quot;inactive&quot;: style.display = &quot;none&quot;; break; } }, hAlign(node, style) { if (node[_xfa_object.$nodeName] === &quot;para&quot;) { switch (node.hAlign) { case &quot;justifyAll&quot;: style.textAlign = &quot;justify-all&quot;; break; case &quot;radix&quot;: style.textAlign = &quot;left&quot;; break; default: style.textAlign = node.hAlign; } } else { switch (node.hAlign) { case &quot;left&quot;: style.alignSelf = &quot;start&quot;; break; case &quot;center&quot;: style.alignSelf = &quot;center&quot;; break; case &quot;right&quot;: style.alignSelf = &quot;end&quot;; break; } } }, margin(node, style) { if (node.margin) { style.margin = node.margin[_xfa_object.$toStyle]().margin; } } }; function setMinMaxDimensions(node, style) { const parent = node[_xfa_object.$getSubformParent](); if (parent.layout === &quot;position&quot;) { if (node.minW &gt; 0) { style.minWidth = measureToString(node.minW); } if (node.maxW &gt; 0) { style.maxWidth = measureToString(node.maxW); } if (node.minH &gt; 0) { style.minHeight = measureToString(node.minH); } if (node.maxH &gt; 0) { style.maxHeight = measureToString(node.maxH); } } } function layoutText(text, xfaFont, margin, lineHeight, fontFinder, width) { const measure = new _text.TextMeasure(xfaFont, margin, lineHeight, fontFinder); if (typeof text === &quot;string&quot;) { measure.addString(text); } else { text[_xfa_object.$pushGlyphs](measure); } return measure.compute(width); } function layoutNode(node, availableSpace) { let height = null; let width = null; let isBroken = false; if ((!node.w || !node.h) &amp;&amp; node.value) { let marginH = 0; let marginV = 0; if (node.margin) { marginH = node.margin.leftInset + node.margin.rightInset; marginV = node.margin.topInset + node.margin.bottomInset; } let lineHeight = null; let margin = null; if (node.para) { margin = Object.create(null); lineHeight = node.para.lineHeight === &quot;&quot; ? null : node.para.lineHeight; margin.top = node.para.spaceAbove === &quot;&quot; ? 0 : node.para.spaceAbove; margin.bottom = node.para.spaceBelow === &quot;&quot; ? 0 : node.para.spaceBelow; margin.left = node.para.marginLeft === &quot;&quot; ? 0 : node.para.marginLeft; margin.right = node.para.marginRight === &quot;&quot; ? 0 : node.para.marginRight; } let font = node.font; if (!font) { const root = node[_xfa_object.$getTemplateRoot](); let parent = node[_xfa_object.$getParent](); while (parent &amp;&amp; parent !== root) { if (parent.font) { font = parent.font; break; } parent = parent[_xfa_object.$getParent](); } } const maxWidth = (node.w || availableSpace.width) - marginH; const fontFinder = node[_xfa_object.$globalData].fontFinder; if (node.value.exData &amp;&amp; node.value.exData[_xfa_object.$content] &amp;&amp; node.value.exData.contentType === &quot;text/html&quot;) { const res = layoutText(node.value.exData[_xfa_object.$content], font, margin, lineHeight, fontFinder, maxWidth); width = res.width; height = res.height; isBroken = res.isBroken; } else { const text = node.value[_xfa_object.$text](); if (text) { const res = layoutText(text, font, margin, lineHeight, fontFinder, maxWidth); width = res.width; height = res.height; isBroken = res.isBroken; } } if (width !== null &amp;&amp; !node.w) { width += marginH; } if (height !== null &amp;&amp; !node.h) { height += marginV; } } return { w: width, h: height, isBroken }; } function computeBbox(node, html, availableSpace) { let bbox; if (node.w !== &quot;&quot; &amp;&amp; node.h !== &quot;&quot;) { bbox = [node.x, node.y, node.w, node.h]; } else { if (!availableSpace) { return null; } let width = node.w; if (width === &quot;&quot;) { if (node.maxW === 0) { const parent = node[_xfa_object.$getSubformParent](); if (parent.layout === &quot;position&quot; &amp;&amp; parent.w !== &quot;&quot;) { width = 0; } else { width = node.minW; } } else { width = Math.min(node.maxW, availableSpace.width); } html.attributes.style.width = measureToString(width); } let height = node.h; if (height === &quot;&quot;) { if (node.maxH === 0) { const parent = node[_xfa_object.$getSubformParent](); if (parent.layout === &quot;position&quot; &amp;&amp; parent.h !== &quot;&quot;) { height = 0; } else { height = node.minH; } } else { height = Math.min(node.maxH, availableSpace.height); } html.attributes.style.height = measureToString(height); } bbox = [node.x, node.y, width, height]; } return bbox; } function fixDimensions(node) { const parent = node[_xfa_object.$getSubformParent](); if (parent.layout &amp;&amp; parent.layout.includes(&quot;row&quot;)) { const extra = parent[_xfa_object.$extra]; const colSpan = node.colSpan; let width; if (colSpan === -1) { width = extra.columnWidths.slice(extra.currentColumn).reduce((a, w) =&gt; a + w, 0); } else { width = extra.columnWidths.slice(extra.currentColumn, extra.currentColumn + colSpan).reduce((a, w) =&gt; a + w, 0); } if (!isNaN(width)) { node.w = width; } } if (parent.layout &amp;&amp; parent.layout !== &quot;position&quot;) { node.x = node.y = 0; } if (node.layout === &quot;table&quot;) { if (node.w === &quot;&quot; &amp;&amp; Array.isArray(node.columnWidths)) { node.w = node.columnWidths.reduce((a, x) =&gt; a + x, 0); } } } function layoutClass(node) { switch (node.layout) { case &quot;position&quot;: return &quot;xfaPosition&quot;; case &quot;lr-tb&quot;: return &quot;xfaLrTb&quot;; case &quot;rl-row&quot;: return &quot;xfaRlRow&quot;; case &quot;rl-tb&quot;: return &quot;xfaRlTb&quot;; case &quot;row&quot;: return &quot;xfaRow&quot;; case &quot;table&quot;: return &quot;xfaTable&quot;; case &quot;tb&quot;: return &quot;xfaTb&quot;; default: return &quot;xfaPosition&quot;; } } function toStyle(node, ...names) { const style = Object.create(null); for (const name of names) { const value = node[name]; if (value === null) { continue; } if (converters.hasOwnProperty(name)) { converters[name](node, style); continue; } if (value instanceof _xfa_object.XFAObject) { const newStyle = value[_xfa_object.$toStyle](); if (newStyle) { Object.assign(style, newStyle); } else { (0, _util.warn)(`(DEBUG) - XFA - style for ${name} not implemented yet`); } } } return style; } function createWrapper(node, html) { const { attributes } = html; const { style } = attributes; const wrapper = { name: &quot;div&quot;, attributes: { class: [&quot;xfaWrapper&quot;], style: Object.create(null) }, children: [] }; attributes.class.push(&quot;xfaWrapped&quot;); if (node.border) { const { widths, insets } = node.border[_xfa_object.$extra]; let width, height; let top = insets[0]; let left = insets[3]; const insetsH = insets[0] + insets[2]; const insetsW = insets[1] + insets[3]; switch (node.border.hand) { case &quot;even&quot;: top -= widths[0] / 2; left -= widths[3] / 2; width = `calc(100% + ${(widths[1] + widths[3]) / 2 - insetsW}px)`; height = `calc(100% + ${(widths[0] + widths[2]) / 2 - insetsH}px)`; break; case &quot;left&quot;: top -= widths[0]; left -= widths[3]; width = `calc(100% + ${widths[1] + widths[3] - insetsW}px)`; height = `calc(100% + ${widths[0] + widths[2] - insetsH}px)`; break; case &quot;right&quot;: width = insetsW ? `calc(100% - ${insetsW}px)` : &quot;100%&quot;; height = insetsH ? `calc(100% - ${insetsH}px)` : &quot;100%&quot;; break; } const classNames = [&quot;xfaBorder&quot;]; if (isPrintOnly(node.border)) { classNames.push(&quot;xfaPrintOnly&quot;); } const border = { name: &quot;div&quot;, attributes: { class: classNames, style: { top: `${top}px`, left: `${left}px`, width, height } }, children: [] }; for (const key of [&quot;border&quot;, &quot;borderWidth&quot;, &quot;borderColor&quot;, &quot;borderRadius&quot;, &quot;borderStyle&quot;]) { if (style[key] !== undefined) { border.attributes.style[key] = style[key]; delete style[key]; } } wrapper.children.push(border, html); } else { wrapper.children.push(html); } for (const key of [&quot;background&quot;, &quot;backgroundClip&quot;, &quot;top&quot;, &quot;left&quot;, &quot;width&quot;, &quot;height&quot;, &quot;minWidth&quot;, &quot;minHeight&quot;, &quot;maxWidth&quot;, &quot;maxHeight&quot;, &quot;transform&quot;, &quot;transformOrigin&quot;, &quot;visibility&quot;]) { if (style[key] !== undefined) { wrapper.attributes.style[key] = style[key]; delete style[key]; } } if (style.position === &quot;absolute&quot;) { wrapper.attributes.style.position = &quot;absolute&quot;; } else { wrapper.attributes.style.position = &quot;relative&quot;; } delete style.position; if (style.alignSelf) { wrapper.attributes.style.alignSelf = style.alignSelf; delete style.alignSelf; } return wrapper; } function fixTextIndent(styles) { const indent = (0, _utils.getMeasurement)(styles.textIndent, &quot;0px&quot;); if (indent &gt;= 0) { return; } const align = styles.textAlign === &quot;right&quot; ? &quot;right&quot; : &quot;left&quot;; const name = &quot;padding&quot; + (align === &quot;left&quot; ? &quot;Left&quot; : &quot;Right&quot;); const padding = (0, _utils.getMeasurement)(styles[name], &quot;0px&quot;); styles[name] = `${padding - indent}px`; } function setAccess(node, classNames) { switch (node.access) { case &quot;nonInteractive&quot;: classNames.push(&quot;xfaNonInteractive&quot;); break; case &quot;readOnly&quot;: classNames.push(&quot;xfaReadOnly&quot;); break; case &quot;protected&quot;: classNames.push(&quot;xfaDisabled&quot;); break; } } function isPrintOnly(node) { return node.relevant.length &gt; 0 &amp;&amp; !node.relevant[0].excluded &amp;&amp; node.relevant[0].viewname === &quot;print&quot;; } function getCurrentPara(node) { const stack = node[_xfa_object.$getTemplateRoot]()[_xfa_object.$extra].paraStack; return stack.length ? stack.at(-1) : null; } function setPara(node, nodeStyle, value) { if (value.attributes.class &amp;&amp; value.attributes.class.includes(&quot;xfaRich&quot;)) { if (nodeStyle) { if (node.h === &quot;&quot;) { nodeStyle.height = &quot;auto&quot;; } if (node.w === &quot;&quot;) { nodeStyle.width = &quot;auto&quot;; } } const para = getCurrentPara(node); if (para) { const valueStyle = value.attributes.style; valueStyle.display = &quot;flex&quot;; valueStyle.flexDirection = &quot;column&quot;; switch (para.vAlign) { case &quot;top&quot;: valueStyle.justifyContent = &quot;start&quot;; break; case &quot;bottom&quot;: valueStyle.justifyContent = &quot;end&quot;; break; case &quot;middle&quot;: valueStyle.justifyContent = &quot;center&quot;; break; } const paraStyle = para[_xfa_object.$toStyle](); for (const [key, val] of Object.entries(paraStyle)) { if (!(key in valueStyle)) { valueStyle[key] = val; } } } } } function setFontFamily(xfaFont, node, fontFinder, style) { if (!fontFinder) { delete style.fontFamily; return; } const name = (0, _utils.stripQuotes)(xfaFont.typeface); style.fontFamily = `&quot;${name}&quot;`; const typeface = fontFinder.find(name); if (typeface) { const { fontFamily } = typeface.regular.cssFontInfo; if (fontFamily !== name) { style.fontFamily = `&quot;${fontFamily}&quot;`; } const para = getCurrentPara(node); if (para &amp;&amp; para.lineHeight !== &quot;&quot;) { return; } if (style.lineHeight) { return; } const pdfFont = (0, _fonts.selectFont)(xfaFont, typeface); if (pdfFont) { style.lineHeight = Math.max(1.2, pdfFont.lineHeight); } } } function fixURL(str) { const absoluteUrl = (0, _util.createValidAbsoluteUrl)(str, null, { addDefaultProtocol: true, tryConvertEncoding: true }); return absoluteUrl ? absoluteUrl.href : null; } /***/ }), /* 83 */ /***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) =&gt; { Object.defineProperty(exports, &quot;__esModule&quot;, ({ value: true })); exports.FontFinder = void 0; exports.getMetrics = getMetrics; exports.selectFont = selectFont; var _xfa_object = __w_pdfjs_require__(75); var _utils = __w_pdfjs_require__(76); var _util = __w_pdfjs_require__(2); class FontFinder { constructor(pdfFonts) { this.fonts = new Map(); this.cache = new Map(); this.warned = new Set(); this.defaultFont = null; this.add(pdfFonts); } add(pdfFonts, reallyMissingFonts = null) { for (const pdfFont of pdfFonts) { this.addPdfFont(pdfFont); } for (const pdfFont of this.fonts.values()) { if (!pdfFont.regular) { pdfFont.regular = pdfFont.italic || pdfFont.bold || pdfFont.bolditalic; } } if (!reallyMissingFonts || reallyMissingFonts.size === 0) { return; } const myriad = this.fonts.get(&quot;PdfJS-Fallback-PdfJS-XFA&quot;); for (const missing of reallyMissingFonts) { this.fonts.set(missing, myriad); } } addPdfFont(pdfFont) { const cssFontInfo = pdfFont.cssFontInfo; const name = cssFontInfo.fontFamily; let font = this.fonts.get(name); if (!font) { font = Object.create(null); this.fonts.set(name, font); if (!this.defaultFont) { this.defaultFont = font; } } let property = &quot;&quot;; const fontWeight = parseFloat(cssFontInfo.fontWeight); if (parseFloat(cssFontInfo.italicAngle) !== 0) { property = fontWeight &gt;= 700 ? &quot;bolditalic&quot; : &quot;italic&quot;; } else if (fontWeight &gt;= 700) { property = &quot;bold&quot;; } if (!property) { if (pdfFont.name.includes(&quot;Bold&quot;) || pdfFont.psName &amp;&amp; pdfFont.psName.includes(&quot;Bold&quot;)) { property = &quot;bold&quot;; } if (pdfFont.name.includes(&quot;Italic&quot;) || pdfFont.name.endsWith(&quot;It&quot;) || pdfFont.psName &amp;&amp; (pdfFont.psName.includes(&quot;Italic&quot;) || pdfFont.psName.endsWith(&quot;It&quot;))) { property += &quot;italic&quot;; } } if (!property) { property = &quot;regular&quot;; } font[property] = pdfFont; } getDefault() { return this.defaultFont; } find(fontName, mustWarn = true) { let font = this.fonts.get(fontName) || this.cache.get(fontName); if (font) { return font; } const pattern = /,|-|_| |bolditalic|bold|italic|regular|it/gi; let name = fontName.replace(pattern, &quot;&quot;); font = this.fonts.get(name); if (font) { this.cache.set(fontName, font); return font; } name = name.toLowerCase(); const maybe = []; for (const [family, pdfFont] of this.fonts.entries()) { if (family.replace(pattern, &quot;&quot;).toLowerCase().startsWith(name)) { maybe.push(pdfFont); } } if (maybe.length === 0) { for (const [, pdfFont] of this.fonts.entries()) { if (pdfFont.regular.name &amp;&amp; pdfFont.regular.name.replace(pattern, &quot;&quot;).toLowerCase().startsWith(name)) { maybe.push(pdfFont); } } } if (maybe.length === 0) { name = name.replace(/psmt|mt/gi, &quot;&quot;); for (const [family, pdfFont] of this.fonts.entries()) { if (family.replace(pattern, &quot;&quot;).toLowerCase().startsWith(name)) { maybe.push(pdfFont); } } } if (maybe.length === 0) { for (const pdfFont of this.fonts.values()) { if (pdfFont.regular.name &amp;&amp; pdfFont.regular.name.replace(pattern, &quot;&quot;).toLowerCase().startsWith(name)) { maybe.push(pdfFont); } } } if (maybe.length &gt;= 1) { if (maybe.length !== 1 &amp;&amp; mustWarn) { (0, _util.warn)(`XFA - Too many choices to guess the correct font: ${fontName}`); } this.cache.set(fontName, maybe[0]); return maybe[0]; } if (mustWarn &amp;&amp; !this.warned.has(fontName)) { this.warned.add(fontName); (0, _util.warn)(`XFA - Cannot find the font: ${fontName}`); } return null; } } exports.FontFinder = FontFinder; function selectFont(xfaFont, typeface) { if (xfaFont.posture === &quot;italic&quot;) { if (xfaFont.weight === &quot;bold&quot;) { return typeface.bolditalic; } return typeface.italic; } else if (xfaFont.weight === &quot;bold&quot;) { return typeface.bold; } return typeface.regular; } function getMetrics(xfaFont, real = false) { let pdfFont = null; if (xfaFont) { const name = (0, _utils.stripQuotes)(xfaFont.typeface); const typeface = xfaFont[_xfa_object.$globalData].fontFinder.find(name); pdfFont = selectFont(xfaFont, typeface); } if (!pdfFont) { return { lineHeight: 12, lineGap: 2, lineNoGap: 10 }; } const size = xfaFont.size || 10; const lineHeight = pdfFont.lineHeight ? Math.max(real ? 0 : 1.2, pdfFont.lineHeight) : 1.2; const lineGap = pdfFont.lineGap === undefined ? 0.2 : pdfFont.lineGap; return { lineHeight: lineHeight * size, lineGap: lineGap * size, lineNoGap: Math.max(1, lineHeight - lineGap) * size }; } /***/ }), /* 84 */ /***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) =&gt; { Object.defineProperty(exports, &quot;__esModule&quot;, ({ value: true })); exports.TextMeasure = void 0; var _fonts = __w_pdfjs_require__(83); const WIDTH_FACTOR = 1.02; class FontInfo { constructor(xfaFont, margin, lineHeight, fontFinder) { this.lineHeight = lineHeight; this.paraMargin = margin || { top: 0, bottom: 0, left: 0, right: 0 }; if (!xfaFont) { [this.pdfFont, this.xfaFont] = this.defaultFont(fontFinder); return; } this.xfaFont = { typeface: xfaFont.typeface, posture: xfaFont.posture, weight: xfaFont.weight, size: xfaFont.size, letterSpacing: xfaFont.letterSpacing }; const typeface = fontFinder.find(xfaFont.typeface); if (!typeface) { [this.pdfFont, this.xfaFont] = this.defaultFont(fontFinder); return; } this.pdfFont = (0, _fonts.selectFont)(xfaFont, typeface); if (!this.pdfFont) { [this.pdfFont, this.xfaFont] = this.defaultFont(fontFinder); } } defaultFont(fontFinder) { const font = fontFinder.find(&quot;Helvetica&quot;, false) || fontFinder.find(&quot;Myriad Pro&quot;, false) || fontFinder.find(&quot;Arial&quot;, false) || fontFinder.getDefault(); if (font &amp;&amp; font.regular) { const pdfFont = font.regular; const info = pdfFont.cssFontInfo; const xfaFont = { typeface: info.fontFamily, posture: &quot;normal&quot;, weight: &quot;normal&quot;, size: 10, letterSpacing: 0 }; return [pdfFont, xfaFont]; } const xfaFont = { typeface: &quot;Courier&quot;, posture: &quot;normal&quot;, weight: &quot;normal&quot;, size: 10, letterSpacing: 0 }; return [null, xfaFont]; } } class FontSelector { constructor(defaultXfaFont, defaultParaMargin, defaultLineHeight, fontFinder) { this.fontFinder = fontFinder; this.stack = [new FontInfo(defaultXfaFont, defaultParaMargin, defaultLineHeight, fontFinder)]; } pushData(xfaFont, margin, lineHeight) { const lastFont = this.stack.at(-1); for (const name of [&quot;typeface&quot;, &quot;posture&quot;, &quot;weight&quot;, &quot;size&quot;, &quot;letterSpacing&quot;]) { if (!xfaFont[name]) { xfaFont[name] = lastFont.xfaFont[name]; } } for (const name of [&quot;top&quot;, &quot;bottom&quot;, &quot;left&quot;, &quot;right&quot;]) { if (isNaN(margin[name])) { margin[name] = lastFont.paraMargin[name]; } } const fontInfo = new FontInfo(xfaFont, margin, lineHeight || lastFont.lineHeight, this.fontFinder); if (!fontInfo.pdfFont) { fontInfo.pdfFont = lastFont.pdfFont; } this.stack.push(fontInfo); } popFont() { this.stack.pop(); } topFont() { return this.stack.at(-1); } } class TextMeasure { constructor(defaultXfaFont, defaultParaMargin, defaultLineHeight, fonts) { this.glyphs = []; this.fontSelector = new FontSelector(defaultXfaFont, defaultParaMargin, defaultLineHeight, fonts); this.extraHeight = 0; } pushData(xfaFont, margin, lineHeight) { this.fontSelector.pushData(xfaFont, margin, lineHeight); } popFont(xfaFont) { return this.fontSelector.popFont(); } addPara() { const lastFont = this.fontSelector.topFont(); this.extraHeight += lastFont.paraMargin.top + lastFont.paraMargin.bottom; } addString(str) { if (!str) { return; } const lastFont = this.fontSelector.topFont(); const fontSize = lastFont.xfaFont.size; if (lastFont.pdfFont) { const letterSpacing = lastFont.xfaFont.letterSpacing; const pdfFont = lastFont.pdfFont; const fontLineHeight = pdfFont.lineHeight || 1.2; const lineHeight = lastFont.lineHeight || Math.max(1.2, fontLineHeight) * fontSize; const lineGap = pdfFont.lineGap === undefined ? 0.2 : pdfFont.lineGap; const noGap = fontLineHeight - lineGap; const firstLineHeight = Math.max(1, noGap) * fontSize; const scale = fontSize / 1000; const fallbackWidth = pdfFont.defaultWidth || pdfFont.charsToGlyphs(&quot; &quot;)[0].width; for (const line of str.split(/[\\u2029\\n]/)) { const encodedLine = pdfFont.encodeString(line).join(&quot;&quot;); const glyphs = pdfFont.charsToGlyphs(encodedLine); for (const glyph of glyphs) { const width = glyph.width || fallbackWidth; this.glyphs.push([width * scale + letterSpacing, lineHeight, firstLineHeight, glyph.unicode, false]); } this.glyphs.push([0, 0, 0, &quot;\\n&quot;, true]); } this.glyphs.pop(); return; } for (const line of str.split(/[\\u2029\\n]/)) { for (const char of line.split(&quot;&quot;)) { this.glyphs.push([fontSize, 1.2 * fontSize, fontSize, char, false]); } this.glyphs.push([0, 0, 0, &quot;\\n&quot;, true]); } this.glyphs.pop(); } compute(maxWidth) { let lastSpacePos = -1, lastSpaceWidth = 0, width = 0, height = 0, currentLineWidth = 0, currentLineHeight = 0; let isBroken = false; let isFirstLine = true; for (let i = 0, ii = this.glyphs.length; i &lt; ii; i++) { const [glyphWidth, lineHeight, firstLineHeight, char, isEOL] = this.glyphs[i]; const isSpace = char === &quot; &quot;; const glyphHeight = isFirstLine ? firstLineHeight : lineHeight; if (isEOL) { width = Math.max(width, currentLineWidth); currentLineWidth = 0; height += currentLineHeight; currentLineHeight = glyphHeight; lastSpacePos = -1; lastSpaceWidth = 0; isFirstLine = false; continue; } if (isSpace) { if (currentLineWidth + glyphWidth &gt; maxWidth) { width = Math.max(width, currentLineWidth); currentLineWidth = 0; height += currentLineHeight; currentLineHeight = glyphHeight; lastSpacePos = -1; lastSpaceWidth = 0; isBroken = true; isFirstLine = false; } else { currentLineHeight = Math.max(glyphHeight, currentLineHeight); lastSpaceWidth = currentLineWidth; currentLineWidth += glyphWidth; lastSpacePos = i; } continue; } if (currentLineWidth + glyphWidth &gt; maxWidth) { height += currentLineHeight; currentLineHeight = glyphHeight; if (lastSpacePos !== -1) { i = lastSpacePos; width = Math.max(width, lastSpaceWidth); currentLineWidth = 0; lastSpacePos = -1; lastSpaceWidth = 0; } else { width = Math.max(width, currentLineWidth); currentLineWidth = glyphWidth; } isBroken = true; isFirstLine = false; continue; } currentLineWidth += glyphWidth; currentLineHeight = Math.max(glyphHeight, currentLineHeight); } width = Math.max(width, currentLineWidth); height += currentLineHeight + this.extraHeight; return { width: WIDTH_FACTOR * width, height, isBroken }; } } exports.TextMeasure = TextMeasure; /***/ }), /* 85 */ /***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) =&gt; { Object.defineProperty(exports, &quot;__esModule&quot;, ({ value: true })); exports.DataHandler = void 0; var _xfa_object = __w_pdfjs_require__(75); class DataHandler { constructor(root, data) { this.data = data; this.dataset = root.datasets || null; } serialize(storage) { const stack = [[-1, this.data[_xfa_object.$getChildren]()]]; while (stack.length &gt; 0) { const last = stack.at(-1); const [i, children] = last; if (i + 1 === children.length) { stack.pop(); continue; } const child = children[++last[0]]; const storageEntry = storage.get(child[_xfa_object.$uid]); if (storageEntry) { child[_xfa_object.$setValue](storageEntry); } else { const attributes = child[_xfa_object.$getAttributes](); for (const value of attributes.values()) { const entry = storage.get(value[_xfa_object.$uid]); if (entry) { value[_xfa_object.$setValue](entry); break; } } } const nodes = child[_xfa_object.$getChildren](); if (nodes.length &gt; 0) { stack.push([-1, nodes]); } } const buf = [``]; if (this.dataset) { for (const child of this.dataset[_xfa_object.$getChildren]()) { if (child[_xfa_object.$nodeName] !== &quot;data&quot;) { child[_xfa_object.$toString](buf); } } } this.data[_xfa_object.$toString](buf); buf.push(&quot;&quot;); return buf.join(&quot;&quot;); } } exports.DataHandler = DataHandler; /***/ }), /* 86 */ /***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) =&gt; { Object.defineProperty(exports, &quot;__esModule&quot;, ({ value: true })); exports.XFAParser = void 0; var _xfa_object = __w_pdfjs_require__(75); var _xml_parser = __w_pdfjs_require__(64); var _builder = __w_pdfjs_require__(87); var _util = __w_pdfjs_require__(2); class XFAParser extends _xml_parser.XMLParserBase { constructor(rootNameSpace = null, richText = false) { super(); this._builder = new _builder.Builder(rootNameSpace); this._stack = []; this._globalData = { usedTypefaces: new Set() }; this._ids = new Map(); this._current = this._builder.buildRoot(this._ids); this._errorCode = _xml_parser.XMLParserErrorCode.NoError; this._whiteRegex = /^\\s+$/; this._nbsps = /\\xa0+/g; this._richText = richText; } parse(data) { this.parseXml(data); if (this._errorCode !== _xml_parser.XMLParserErrorCode.NoError) { return undefined; } this._current[_xfa_object.$finalize](); return this._current.element; } onText(text) { text = text.replace(this._nbsps, match =&gt; match.slice(1) + &quot; &quot;); if (this._richText || this._current[_xfa_object.$acceptWhitespace]()) { this._current[_xfa_object.$onText](text, this._richText); return; } if (this._whiteRegex.test(text)) { return; } this._current[_xfa_object.$onText](text.trim()); } onCdata(text) { this._current[_xfa_object.$onText](text); } _mkAttributes(attributes, tagName) { let namespace = null; let prefixes = null; const attributeObj = Object.create({}); for (const { name, value } of attributes) { if (name === &quot;xmlns&quot;) { if (!namespace) { namespace = value; } else { (0, _util.warn)(`XFA - multiple namespace definition in &lt;${tagName}&gt;`); } } else if (name.startsWith(&quot;xmlns:&quot;)) { const prefix = name.substring(&quot;xmlns:&quot;.length); if (!prefixes) { prefixes = []; } prefixes.push({ prefix, value }); } else { const i = name.indexOf(&quot;:&quot;); if (i === -1) { attributeObj[name] = value; } else { let nsAttrs = attributeObj[_xfa_object.$nsAttributes]; if (!nsAttrs) { nsAttrs = attributeObj[_xfa_object.$nsAttributes] = Object.create(null); } const [ns, attrName] = [name.slice(0, i), name.slice(i + 1)]; let attrs = nsAttrs[ns]; if (!attrs) { attrs = nsAttrs[ns] = Object.create(null); } attrs[attrName] = value; } } } return [namespace, prefixes, attributeObj]; } _getNameAndPrefix(name, nsAgnostic) { const i = name.indexOf(&quot;:&quot;); if (i === -1) { return [name, null]; } return [name.substring(i + 1), nsAgnostic ? &quot;&quot; : name.substring(0, i)]; } onBeginElement(tagName, attributes, isEmpty) { const [namespace, prefixes, attributesObj] = this._mkAttributes(attributes, tagName); const [name, nsPrefix] = this._getNameAndPrefix(tagName, this._builder.isNsAgnostic()); const node = this._builder.build({ nsPrefix, name, attributes: attributesObj, namespace, prefixes }); node[_xfa_object.$globalData] = this._globalData; if (isEmpty) { node[_xfa_object.$finalize](); if (this._current[_xfa_object.$onChild](node)) { node[_xfa_object.$setId](this._ids); } node[_xfa_object.$clean](this._builder); return; } this._stack.push(this._current); this._current = node; } onEndElement(name) { const node = this._current; if (node[_xfa_object.$isCDATAXml]() &amp;&amp; typeof node[_xfa_object.$content] === &quot;string&quot;) { const parser = new XFAParser(); parser._globalData = this._globalData; const root = parser.parse(node[_xfa_object.$content]); node[_xfa_object.$content] = null; node[_xfa_object.$onChild](root); } node[_xfa_object.$finalize](); this._current = this._stack.pop(); if (this._current[_xfa_object.$onChild](node)) { node[_xfa_object.$setId](this._ids); } node[_xfa_object.$clean](this._builder); } onError(code) { this._errorCode = code; } } exports.XFAParser = XFAParser; /***/ }), /* 87 */ /***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) =&gt; { Object.defineProperty(exports, &quot;__esModule&quot;, ({ value: true })); exports.Builder = void 0; var _namespaces = __w_pdfjs_require__(77); var _xfa_object = __w_pdfjs_require__(75); var _setup = __w_pdfjs_require__(88); var _template = __w_pdfjs_require__(80); var _unknown = __w_pdfjs_require__(97); var _util = __w_pdfjs_require__(2); class Root extends _xfa_object.XFAObject { constructor(ids) { super(-1, &quot;root&quot;, Object.create(null)); this.element = null; this[_xfa_object.$ids] = ids; } [_xfa_object.$onChild](child) { this.element = child; return true; } [_xfa_object.$finalize]() { super[_xfa_object.$finalize](); if (this.element.template instanceof _template.Template) { this[_xfa_object.$ids].set(_xfa_object.$root, this.element); this.element.template[_xfa_object.$resolvePrototypes](this[_xfa_object.$ids]); this.element.template[_xfa_object.$ids] = this[_xfa_object.$ids]; } } } class Empty extends _xfa_object.XFAObject { constructor() { super(-1, &quot;&quot;, Object.create(null)); } [_xfa_object.$onChild](_) { return false; } } class Builder { constructor(rootNameSpace = null) { this._namespaceStack = []; this._nsAgnosticLevel = 0; this._namespacePrefixes = new Map(); this._namespaces = new Map(); this._nextNsId = Math.max(...Object.values(_namespaces.NamespaceIds).map(({ id }) =&gt; id)); this._currentNamespace = rootNameSpace || new _unknown.UnknownNamespace(++this._nextNsId); } buildRoot(ids) { return new Root(ids); } build({ nsPrefix, name, attributes, namespace, prefixes }) { const hasNamespaceDef = namespace !== null; if (hasNamespaceDef) { this._namespaceStack.push(this._currentNamespace); this._currentNamespace = this._searchNamespace(namespace); } if (prefixes) { this._addNamespacePrefix(prefixes); } if (attributes.hasOwnProperty(_xfa_object.$nsAttributes)) { const dataTemplate = _setup.NamespaceSetUp.datasets; const nsAttrs = attributes[_xfa_object.$nsAttributes]; let xfaAttrs = null; for (const [ns, attrs] of Object.entries(nsAttrs)) { const nsToUse = this._getNamespaceToUse(ns); if (nsToUse === dataTemplate) { xfaAttrs = { xfa: attrs }; break; } } if (xfaAttrs) { attributes[_xfa_object.$nsAttributes] = xfaAttrs; } else { delete attributes[_xfa_object.$nsAttributes]; } } const namespaceToUse = this._getNamespaceToUse(nsPrefix); const node = namespaceToUse &amp;&amp; namespaceToUse[_namespaces.$buildXFAObject](name, attributes) || new Empty(); if (node[_xfa_object.$isNsAgnostic]()) { this._nsAgnosticLevel++; } if (hasNamespaceDef || prefixes || node[_xfa_object.$isNsAgnostic]()) { node[_xfa_object.$cleanup] = { hasNamespace: hasNamespaceDef, prefixes, nsAgnostic: node[_xfa_object.$isNsAgnostic]() }; } return node; } isNsAgnostic() { return this._nsAgnosticLevel &gt; 0; } _searchNamespace(nsName) { let ns = this._namespaces.get(nsName); if (ns) { return ns; } for (const [name, { check }] of Object.entries(_namespaces.NamespaceIds)) { if (check(nsName)) { ns = _setup.NamespaceSetUp[name]; if (ns) { this._namespaces.set(nsName, ns); return ns; } break; } } ns = new _unknown.UnknownNamespace(++this._nextNsId); this._namespaces.set(nsName, ns); return ns; } _addNamespacePrefix(prefixes) { for (const { prefix, value } of prefixes) { const namespace = this._searchNamespace(value); let prefixStack = this._namespacePrefixes.get(prefix); if (!prefixStack) { prefixStack = []; this._namespacePrefixes.set(prefix, prefixStack); } prefixStack.push(namespace); } } _getNamespaceToUse(prefix) { if (!prefix) { return this._currentNamespace; } const prefixStack = this._namespacePrefixes.get(prefix); if (prefixStack &amp;&amp; prefixStack.length &gt; 0) { return prefixStack.at(-1); } (0, _util.warn)(`Unknown namespace prefix: ${prefix}.`); return null; } clean(data) { const { hasNamespace, prefixes, nsAgnostic } = data; if (hasNamespace) { this._currentNamespace = this._namespaceStack.pop(); } if (prefixes) { prefixes.forEach(({ prefix }) =&gt; { this._namespacePrefixes.get(prefix).pop(); }); } if (nsAgnostic) { this._nsAgnosticLevel--; } } } exports.Builder = Builder; /***/ }), /* 88 */ /***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) =&gt; { Object.defineProperty(exports, &quot;__esModule&quot;, ({ value: true })); exports.NamespaceSetUp = void 0; var _config = __w_pdfjs_require__(89); var _connection_set = __w_pdfjs_require__(90); var _datasets = __w_pdfjs_require__(91); var _locale_set = __w_pdfjs_require__(92); var _signature = __w_pdfjs_require__(93); var _stylesheet = __w_pdfjs_require__(94); var _template = __w_pdfjs_require__(80); var _xdp = __w_pdfjs_require__(95); var _xhtml = __w_pdfjs_require__(96); const NamespaceSetUp = { config: _config.ConfigNamespace, connection: _connection_set.ConnectionSetNamespace, datasets: _datasets.DatasetsNamespace, localeSet: _locale_set.LocaleSetNamespace, signature: _signature.SignatureNamespace, stylesheet: _stylesheet.StylesheetNamespace, template: _template.TemplateNamespace, xdp: _xdp.XdpNamespace, xhtml: _xhtml.XhtmlNamespace }; exports.NamespaceSetUp = NamespaceSetUp; /***/ }), /* 89 */ /***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) =&gt; { Object.defineProperty(exports, &quot;__esModule&quot;, ({ value: true })); exports.ConfigNamespace = void 0; var _namespaces = __w_pdfjs_require__(77); var _xfa_object = __w_pdfjs_require__(75); var _utils = __w_pdfjs_require__(76); var _util = __w_pdfjs_require__(2); const CONFIG_NS_ID = _namespaces.NamespaceIds.config.id; class Acrobat extends _xfa_object.XFAObject { constructor(attributes) { super(CONFIG_NS_ID, &quot;acrobat&quot;, true); this.acrobat7 = null; this.autoSave = null; this.common = null; this.validate = null; this.validateApprovalSignatures = null; this.submitUrl = new _xfa_object.XFAObjectArray(); } } class Acrobat7 extends _xfa_object.XFAObject { constructor(attributes) { super(CONFIG_NS_ID, &quot;acrobat7&quot;, true); this.dynamicRender = null; } } class ADBE_JSConsole extends _xfa_object.OptionObject { constructor(attributes) { super(CONFIG_NS_ID, &quot;ADBE_JSConsole&quot;, [&quot;delegate&quot;, &quot;Enable&quot;, &quot;Disable&quot;]); } } class ADBE_JSDebugger extends _xfa_object.OptionObject { constructor(attributes) { super(CONFIG_NS_ID, &quot;ADBE_JSDebugger&quot;, [&quot;delegate&quot;, &quot;Enable&quot;, &quot;Disable&quot;]); } } class AddSilentPrint extends _xfa_object.Option01 { constructor(attributes) { super(CONFIG_NS_ID, &quot;addSilentPrint&quot;); } } class AddViewerPreferences extends _xfa_object.Option01 { constructor(attributes) { super(CONFIG_NS_ID, &quot;addViewerPreferences&quot;); } } class AdjustData extends _xfa_object.Option10 { constructor(attributes) { super(CONFIG_NS_ID, &quot;adjustData&quot;); } } class AdobeExtensionLevel extends _xfa_object.IntegerObject { constructor(attributes) { super(CONFIG_NS_ID, &quot;adobeExtensionLevel&quot;, 0, n =&gt; n &gt;= 1 &amp;&amp; n &lt;= 8); } } class Agent extends _xfa_object.XFAObject { constructor(attributes) { super(CONFIG_NS_ID, &quot;agent&quot;, true); this.name = attributes.name ? attributes.name.trim() : &quot;&quot;; this.common = new _xfa_object.XFAObjectArray(); } } class AlwaysEmbed extends _xfa_object.ContentObject { constructor(attributes) { super(CONFIG_NS_ID, &quot;alwaysEmbed&quot;); } } class Amd extends _xfa_object.StringObject { constructor(attributes) { super(CONFIG_NS_ID, &quot;amd&quot;); } } class Area extends _xfa_object.XFAObject { constructor(attributes) { super(CONFIG_NS_ID, &quot;area&quot;); this.level = (0, _utils.getInteger)({ data: attributes.level, defaultValue: 0, validate: n =&gt; n &gt;= 1 &amp;&amp; n &lt;= 3 }); this.name = (0, _utils.getStringOption)(attributes.name, [&quot;&quot;, &quot;barcode&quot;, &quot;coreinit&quot;, &quot;deviceDriver&quot;, &quot;font&quot;, &quot;general&quot;, &quot;layout&quot;, &quot;merge&quot;, &quot;script&quot;, &quot;signature&quot;, &quot;sourceSet&quot;, &quot;templateCache&quot;]); } } class Attributes extends _xfa_object.OptionObject { constructor(attributes) { super(CONFIG_NS_ID, &quot;attributes&quot;, [&quot;preserve&quot;, &quot;delegate&quot;, &quot;ignore&quot;]); } } class AutoSave extends _xfa_object.OptionObject { constructor(attributes) { super(CONFIG_NS_ID, &quot;autoSave&quot;, [&quot;disabled&quot;, &quot;enabled&quot;]); } } class Base extends _xfa_object.StringObject { constructor(attributes) { super(CONFIG_NS_ID, &quot;base&quot;); } } class BatchOutput extends _xfa_object.XFAObject { constructor(attributes) { super(CONFIG_NS_ID, &quot;batchOutput&quot;); this.format = (0, _utils.getStringOption)(attributes.format, [&quot;none&quot;, &quot;concat&quot;, &quot;zip&quot;, &quot;zipCompress&quot;]); } } class BehaviorOverride extends _xfa_object.ContentObject { constructor(attributes) { super(CONFIG_NS_ID, &quot;behaviorOverride&quot;); } [_xfa_object.$finalize]() { this[_xfa_object.$content] = new Map(this[_xfa_object.$content].trim().split(/\\s+/).filter(x =&gt; x.includes(&quot;:&quot;)).map(x =&gt; x.split(&quot;:&quot;, 2))); } } class Cache extends _xfa_object.XFAObject { constructor(attributes) { super(CONFIG_NS_ID, &quot;cache&quot;, true); this.templateCache = null; } } class Change extends _xfa_object.Option01 { constructor(attributes) { super(CONFIG_NS_ID, &quot;change&quot;); } } class Common extends _xfa_object.XFAObject { constructor(attributes) { super(CONFIG_NS_ID, &quot;common&quot;, true); this.data = null; this.locale = null; this.localeSet = null; this.messaging = null; this.suppressBanner = null; this.template = null; this.validationMessaging = null; this.versionControl = null; this.log = new _xfa_object.XFAObjectArray(); } } class Compress extends _xfa_object.XFAObject { constructor(attributes) { super(CONFIG_NS_ID, &quot;compress&quot;); this.scope = (0, _utils.getStringOption)(attributes.scope, [&quot;imageOnly&quot;, &quot;document&quot;]); } } class CompressLogicalStructure extends _xfa_object.Option01 { constructor(attributes) { super(CONFIG_NS_ID, &quot;compressLogicalStructure&quot;); } } class CompressObjectStream extends _xfa_object.Option10 { constructor(attributes) { super(CONFIG_NS_ID, &quot;compressObjectStream&quot;); } } class Compression extends _xfa_object.XFAObject { constructor(attributes) { super(CONFIG_NS_ID, &quot;compression&quot;, true); this.compressLogicalStructure = null; this.compressObjectStream = null; this.level = null; this.type = null; } } class Config extends _xfa_object.XFAObject { constructor(attributes) { super(CONFIG_NS_ID, &quot;config&quot;, true); this.acrobat = null; this.present = null; this.trace = null; this.agent = new _xfa_object.XFAObjectArray(); } } class Conformance extends _xfa_object.OptionObject { constructor(attributes) { super(CONFIG_NS_ID, &quot;conformance&quot;, [&quot;A&quot;, &quot;B&quot;]); } } class ContentCopy extends _xfa_object.Option01 { constructor(attributes) { super(CONFIG_NS_ID, &quot;contentCopy&quot;); } } class Copies extends _xfa_object.IntegerObject { constructor(attributes) { super(CONFIG_NS_ID, &quot;copies&quot;, 1, n =&gt; n &gt;= 1); } } class Creator extends _xfa_object.StringObject { constructor(attributes) { super(CONFIG_NS_ID, &quot;creator&quot;); } } class CurrentPage extends _xfa_object.IntegerObject { constructor(attributes) { super(CONFIG_NS_ID, &quot;currentPage&quot;, 0, n =&gt; n &gt;= 0); } } class Data extends _xfa_object.XFAObject { constructor(attributes) { super(CONFIG_NS_ID, &quot;data&quot;, true); this.adjustData = null; this.attributes = null; this.incrementalLoad = null; this.outputXSL = null; this.range = null; this.record = null; this.startNode = null; this.uri = null; this.window = null; this.xsl = null; this.excludeNS = new _xfa_object.XFAObjectArray(); this.transform = new _xfa_object.XFAObjectArray(); } } class Debug extends _xfa_object.XFAObject { constructor(attributes) { super(CONFIG_NS_ID, &quot;debug&quot;, true); this.uri = null; } } class DefaultTypeface extends _xfa_object.ContentObject { constructor(attributes) { super(CONFIG_NS_ID, &quot;defaultTypeface&quot;); this.writingScript = (0, _utils.getStringOption)(attributes.writingScript, [&quot;*&quot;, &quot;Arabic&quot;, &quot;Cyrillic&quot;, &quot;EastEuropeanRoman&quot;, &quot;Greek&quot;, &quot;Hebrew&quot;, &quot;Japanese&quot;, &quot;Korean&quot;, &quot;Roman&quot;, &quot;SimplifiedChinese&quot;, &quot;Thai&quot;, &quot;TraditionalChinese&quot;, &quot;Vietnamese&quot;]); } } class Destination extends _xfa_object.OptionObject { constructor(attributes) { super(CONFIG_NS_ID, &quot;destination&quot;, [&quot;pdf&quot;, &quot;pcl&quot;, &quot;ps&quot;, &quot;webClient&quot;, &quot;zpl&quot;]); } } class DocumentAssembly extends _xfa_object.Option01 { constructor(attributes) { super(CONFIG_NS_ID, &quot;documentAssembly&quot;); } } class Driver extends _xfa_object.XFAObject { constructor(attributes) { super(CONFIG_NS_ID, &quot;driver&quot;, true); this.name = attributes.name ? attributes.name.trim() : &quot;&quot;; this.fontInfo = null; this.xdc = null; } } class DuplexOption extends _xfa_object.OptionObject { constructor(attributes) { super(CONFIG_NS_ID, &quot;duplexOption&quot;, [&quot;simplex&quot;, &quot;duplexFlipLongEdge&quot;, &quot;duplexFlipShortEdge&quot;]); } } class DynamicRender extends _xfa_object.OptionObject { constructor(attributes) { super(CONFIG_NS_ID, &quot;dynamicRender&quot;, [&quot;forbidden&quot;, &quot;required&quot;]); } } class Embed extends _xfa_object.Option01 { constructor(attributes) { super(CONFIG_NS_ID, &quot;embed&quot;); } } class Encrypt extends _xfa_object.Option01 { constructor(attributes) { super(CONFIG_NS_ID, &quot;encrypt&quot;); } } class Encryption extends _xfa_object.XFAObject { constructor(attributes) { super(CONFIG_NS_ID, &quot;encryption&quot;, true); this.encrypt = null; this.encryptionLevel = null; this.permissions = null; } } class EncryptionLevel extends _xfa_object.OptionObject { constructor(attributes) { super(CONFIG_NS_ID, &quot;encryptionLevel&quot;, [&quot;40bit&quot;, &quot;128bit&quot;]); } } class Enforce extends _xfa_object.StringObject { constructor(attributes) { super(CONFIG_NS_ID, &quot;enforce&quot;); } } class Equate extends _xfa_object.XFAObject { constructor(attributes) { super(CONFIG_NS_ID, &quot;equate&quot;); this.force = (0, _utils.getInteger)({ data: attributes.force, defaultValue: 1, validate: n =&gt; n === 0 }); this.from = attributes.from || &quot;&quot;; this.to = attributes.to || &quot;&quot;; } } class EquateRange extends _xfa_object.XFAObject { constructor(attributes) { super(CONFIG_NS_ID, &quot;equateRange&quot;); this.from = attributes.from || &quot;&quot;; this.to = attributes.to || &quot;&quot;; this._unicodeRange = attributes.unicodeRange || &quot;&quot;; } get unicodeRange() { const ranges = []; const unicodeRegex = /U\\+([0-9a-fA-F]+)/; const unicodeRange = this._unicodeRange; for (let range of unicodeRange.split(&quot;,&quot;).map(x =&gt; x.trim()).filter(x =&gt; !!x)) { range = range.split(&quot;-&quot;, 2).map(x =&gt; { const found = x.match(unicodeRegex); if (!found) { return 0; } return parseInt(found[1], 16); }); if (range.length === 1) { range.push(range[0]); } ranges.push(range); } return (0, _util.shadow)(this, &quot;unicodeRange&quot;, ranges); } } class Exclude extends _xfa_object.ContentObject { constructor(attributes) { super(CONFIG_NS_ID, &quot;exclude&quot;); } [_xfa_object.$finalize]() { this[_xfa_object.$content] = this[_xfa_object.$content].trim().split(/\\s+/).filter(x =&gt; x &amp;&amp; [&quot;calculate&quot;, &quot;close&quot;, &quot;enter&quot;, &quot;exit&quot;, &quot;initialize&quot;, &quot;ready&quot;, &quot;validate&quot;].includes(x)); } } class ExcludeNS extends _xfa_object.StringObject { constructor(attributes) { super(CONFIG_NS_ID, &quot;excludeNS&quot;); } } class FlipLabel extends _xfa_object.OptionObject { constructor(attributes) { super(CONFIG_NS_ID, &quot;flipLabel&quot;, [&quot;usePrinterSetting&quot;, &quot;on&quot;, &quot;off&quot;]); } } class FontInfo extends _xfa_object.XFAObject { constructor(attributes) { super(CONFIG_NS_ID, &quot;fontInfo&quot;, true); this.embed = null; this.map = null; this.subsetBelow = null; this.alwaysEmbed = new _xfa_object.XFAObjectArray(); this.defaultTypeface = new _xfa_object.XFAObjectArray(); this.neverEmbed = new _xfa_object.XFAObjectArray(); } } class FormFieldFilling extends _xfa_object.Option01 { constructor(attributes) { super(CONFIG_NS_ID, &quot;formFieldFilling&quot;); } } class GroupParent extends _xfa_object.StringObject { constructor(attributes) { super(CONFIG_NS_ID, &quot;groupParent&quot;); } } class IfEmpty extends _xfa_object.OptionObject { constructor(attributes) { super(CONFIG_NS_ID, &quot;ifEmpty&quot;, [&quot;dataValue&quot;, &quot;dataGroup&quot;, &quot;ignore&quot;, &quot;remove&quot;]); } } class IncludeXDPContent extends _xfa_object.StringObject { constructor(attributes) { super(CONFIG_NS_ID, &quot;includeXDPContent&quot;); } } class IncrementalLoad extends _xfa_object.OptionObject { constructor(attributes) { super(CONFIG_NS_ID, &quot;incrementalLoad&quot;, [&quot;none&quot;, &quot;forwardOnly&quot;]); } } class IncrementalMerge extends _xfa_object.Option01 { constructor(attributes) { super(CONFIG_NS_ID, &quot;incrementalMerge&quot;); } } class Interactive extends _xfa_object.Option01 { constructor(attributes) { super(CONFIG_NS_ID, &quot;interactive&quot;); } } class Jog extends _xfa_object.OptionObject { constructor(attributes) { super(CONFIG_NS_ID, &quot;jog&quot;, [&quot;usePrinterSetting&quot;, &quot;none&quot;, &quot;pageSet&quot;]); } } class LabelPrinter extends _xfa_object.XFAObject { constructor(attributes) { super(CONFIG_NS_ID, &quot;labelPrinter&quot;, true); this.name = (0, _utils.getStringOption)(attributes.name, [&quot;zpl&quot;, &quot;dpl&quot;, &quot;ipl&quot;, &quot;tcpl&quot;]); this.batchOutput = null; this.flipLabel = null; this.fontInfo = null; this.xdc = null; } } class Layout extends _xfa_object.OptionObject { constructor(attributes) { super(CONFIG_NS_ID, &quot;layout&quot;, [&quot;paginate&quot;, &quot;panel&quot;]); } } class Level extends _xfa_object.IntegerObject { constructor(attributes) { super(CONFIG_NS_ID, &quot;level&quot;, 0, n =&gt; n &gt; 0); } } class Linearized extends _xfa_object.Option01 { constructor(attributes) { super(CONFIG_NS_ID, &quot;linearized&quot;); } } class Locale extends _xfa_object.StringObject { constructor(attributes) { super(CONFIG_NS_ID, &quot;locale&quot;); } } class LocaleSet extends _xfa_object.StringObject { constructor(attributes) { super(CONFIG_NS_ID, &quot;localeSet&quot;); } } class Log extends _xfa_object.XFAObject { constructor(attributes) { super(CONFIG_NS_ID, &quot;log&quot;, true); this.mode = null; this.threshold = null; this.to = null; this.uri = null; } } class MapElement extends _xfa_object.XFAObject { constructor(attributes) { super(CONFIG_NS_ID, &quot;map&quot;, true); this.equate = new _xfa_object.XFAObjectArray(); this.equateRange = new _xfa_object.XFAObjectArray(); } } class MediumInfo extends _xfa_object.XFAObject { constructor(attributes) { super(CONFIG_NS_ID, &quot;mediumInfo&quot;, true); this.map = null; } } class Message extends _xfa_object.XFAObject { constructor(attributes) { super(CONFIG_NS_ID, &quot;message&quot;, true); this.msgId = null; this.severity = null; } } class Messaging extends _xfa_object.XFAObject { constructor(attributes) { super(CONFIG_NS_ID, &quot;messaging&quot;, true); this.message = new _xfa_object.XFAObjectArray(); } } class Mode extends _xfa_object.OptionObject { constructor(attributes) { super(CONFIG_NS_ID, &quot;mode&quot;, [&quot;append&quot;, &quot;overwrite&quot;]); } } class ModifyAnnots extends _xfa_object.Option01 { constructor(attributes) { super(CONFIG_NS_ID, &quot;modifyAnnots&quot;); } } class MsgId extends _xfa_object.IntegerObject { constructor(attributes) { super(CONFIG_NS_ID, &quot;msgId&quot;, 1, n =&gt; n &gt;= 1); } } class NameAttr extends _xfa_object.StringObject { constructor(attributes) { super(CONFIG_NS_ID, &quot;nameAttr&quot;); } } class NeverEmbed extends _xfa_object.ContentObject { constructor(attributes) { super(CONFIG_NS_ID, &quot;neverEmbed&quot;); } } class NumberOfCopies extends _xfa_object.IntegerObject { constructor(attributes) { super(CONFIG_NS_ID, &quot;numberOfCopies&quot;, null, n =&gt; n &gt;= 2 &amp;&amp; n &lt;= 5); } } class OpenAction extends _xfa_object.XFAObject { constructor(attributes) { super(CONFIG_NS_ID, &quot;openAction&quot;, true); this.destination = null; } } class Output extends _xfa_object.XFAObject { constructor(attributes) { super(CONFIG_NS_ID, &quot;output&quot;, true); this.to = null; this.type = null; this.uri = null; } } class OutputBin extends _xfa_object.StringObject { constructor(attributes) { super(CONFIG_NS_ID, &quot;outputBin&quot;); } } class OutputXSL extends _xfa_object.XFAObject { constructor(attributes) { super(CONFIG_NS_ID, &quot;outputXSL&quot;, true); this.uri = null; } } class Overprint extends _xfa_object.OptionObject { constructor(attributes) { super(CONFIG_NS_ID, &quot;overprint&quot;, [&quot;none&quot;, &quot;both&quot;, &quot;draw&quot;, &quot;field&quot;]); } } class Packets extends _xfa_object.StringObject { constructor(attributes) { super(CONFIG_NS_ID, &quot;packets&quot;); } [_xfa_object.$finalize]() { if (this[_xfa_object.$content] === &quot;*&quot;) { return; } this[_xfa_object.$content] = this[_xfa_object.$content].trim().split(/\\s+/).filter(x =&gt; [&quot;config&quot;, &quot;datasets&quot;, &quot;template&quot;, &quot;xfdf&quot;, &quot;xslt&quot;].includes(x)); } } class PageOffset extends _xfa_object.XFAObject { constructor(attributes) { super(CONFIG_NS_ID, &quot;pageOffset&quot;); this.x = (0, _utils.getInteger)({ data: attributes.x, defaultValue: &quot;useXDCSetting&quot;, validate: n =&gt; true }); this.y = (0, _utils.getInteger)({ data: attributes.y, defaultValue: &quot;useXDCSetting&quot;, validate: n =&gt; true }); } } class PageRange extends _xfa_object.StringObject { constructor(attributes) { super(CONFIG_NS_ID, &quot;pageRange&quot;); } [_xfa_object.$finalize]() { const numbers = this[_xfa_object.$content].trim().split(/\\s+/).map(x =&gt; parseInt(x, 10)); const ranges = []; for (let i = 0, ii = numbers.length; i &lt; ii; i += 2) { ranges.push(numbers.slice(i, i + 2)); } this[_xfa_object.$content] = ranges; } } class Pagination extends _xfa_object.OptionObject { constructor(attributes) { super(CONFIG_NS_ID, &quot;pagination&quot;, [&quot;simplex&quot;, &quot;duplexShortEdge&quot;, &quot;duplexLongEdge&quot;]); } } class PaginationOverride extends _xfa_object.OptionObject { constructor(attributes) { super(CONFIG_NS_ID, &quot;paginationOverride&quot;, [&quot;none&quot;, &quot;forceDuplex&quot;, &quot;forceDuplexLongEdge&quot;, &quot;forceDuplexShortEdge&quot;, &quot;forceSimplex&quot;]); } } class Part extends _xfa_object.IntegerObject { constructor(attributes) { super(CONFIG_NS_ID, &quot;part&quot;, 1, n =&gt; false); } } class Pcl extends _xfa_object.XFAObject { constructor(attributes) { super(CONFIG_NS_ID, &quot;pcl&quot;, true); this.name = attributes.name || &quot;&quot;; this.batchOutput = null; this.fontInfo = null; this.jog = null; this.mediumInfo = null; this.outputBin = null; this.pageOffset = null; this.staple = null; this.xdc = null; } } class Pdf extends _xfa_object.XFAObject { constructor(attributes) { super(CONFIG_NS_ID, &quot;pdf&quot;, true); this.name = attributes.name || &quot;&quot;; this.adobeExtensionLevel = null; this.batchOutput = null; this.compression = null; this.creator = null; this.encryption = null; this.fontInfo = null; this.interactive = null; this.linearized = null; this.openAction = null; this.pdfa = null; this.producer = null; this.renderPolicy = null; this.scriptModel = null; this.silentPrint = null; this.submitFormat = null; this.tagged = null; this.version = null; this.viewerPreferences = null; this.xdc = null; } } class Pdfa extends _xfa_object.XFAObject { constructor(attributes) { super(CONFIG_NS_ID, &quot;pdfa&quot;, true); this.amd = null; this.conformance = null; this.includeXDPContent = null; this.part = null; } } class Permissions extends _xfa_object.XFAObject { constructor(attributes) { super(CONFIG_NS_ID, &quot;permissions&quot;, true); this.accessibleContent = null; this.change = null; this.contentCopy = null; this.documentAssembly = null; this.formFieldFilling = null; this.modifyAnnots = null; this.plaintextMetadata = null; this.print = null; this.printHighQuality = null; } } class PickTrayByPDFSize extends _xfa_object.Option01 { constructor(attributes) { super(CONFIG_NS_ID, &quot;pickTrayByPDFSize&quot;); } } class Picture extends _xfa_object.StringObject { constructor(attributes) { super(CONFIG_NS_ID, &quot;picture&quot;); } } class PlaintextMetadata extends _xfa_object.Option01 { constructor(attributes) { super(CONFIG_NS_ID, &quot;plaintextMetadata&quot;); } } class Presence extends _xfa_object.OptionObject { constructor(attributes) { super(CONFIG_NS_ID, &quot;presence&quot;, [&quot;preserve&quot;, &quot;dissolve&quot;, &quot;dissolveStructure&quot;, &quot;ignore&quot;, &quot;remove&quot;]); } } class Present extends _xfa_object.XFAObject { constructor(attributes) { super(CONFIG_NS_ID, &quot;present&quot;, true); this.behaviorOverride = null; this.cache = null; this.common = null; this.copies = null; this.destination = null; this.incrementalMerge = null; this.layout = null; this.output = null; this.overprint = null; this.pagination = null; this.paginationOverride = null; this.script = null; this.validate = null; this.xdp = null; this.driver = new _xfa_object.XFAObjectArray(); this.labelPrinter = new _xfa_object.XFAObjectArray(); this.pcl = new _xfa_object.XFAObjectArray(); this.pdf = new _xfa_object.XFAObjectArray(); this.ps = new _xfa_object.XFAObjectArray(); this.submitUrl = new _xfa_object.XFAObjectArray(); this.webClient = new _xfa_object.XFAObjectArray(); this.zpl = new _xfa_object.XFAObjectArray(); } } class Print extends _xfa_object.Option01 { constructor(attributes) { super(CONFIG_NS_ID, &quot;print&quot;); } } class PrintHighQuality extends _xfa_object.Option01 { constructor(attributes) { super(CONFIG_NS_ID, &quot;printHighQuality&quot;); } } class PrintScaling extends _xfa_object.OptionObject { constructor(attributes) { super(CONFIG_NS_ID, &quot;printScaling&quot;, [&quot;appdefault&quot;, &quot;noScaling&quot;]); } } class PrinterName extends _xfa_object.StringObject { constructor(attributes) { super(CONFIG_NS_ID, &quot;printerName&quot;); } } class Producer extends _xfa_object.StringObject { constructor(attributes) { super(CONFIG_NS_ID, &quot;producer&quot;); } } class Ps extends _xfa_object.XFAObject { constructor(attributes) { super(CONFIG_NS_ID, &quot;ps&quot;, true); this.name = attributes.name || &quot;&quot;; this.batchOutput = null; this.fontInfo = null; this.jog = null; this.mediumInfo = null; this.outputBin = null; this.staple = null; this.xdc = null; } } class Range extends _xfa_object.ContentObject { constructor(attributes) { super(CONFIG_NS_ID, &quot;range&quot;); } [_xfa_object.$finalize]() { this[_xfa_object.$content] = this[_xfa_object.$content].trim().split(/\\s*,\\s*/, 2).map(range =&gt; range.split(&quot;-&quot;).map(x =&gt; parseInt(x.trim(), 10))).filter(range =&gt; range.every(x =&gt; !isNaN(x))).map(range =&gt; { if (range.length === 1) { range.push(range[0]); } return range; }); } } class Record extends _xfa_object.ContentObject { constructor(attributes) { super(CONFIG_NS_ID, &quot;record&quot;); } [_xfa_object.$finalize]() { this[_xfa_object.$content] = this[_xfa_object.$content].trim(); const n = parseInt(this[_xfa_object.$content], 10); if (!isNaN(n) &amp;&amp; n &gt;= 0) { this[_xfa_object.$content] = n; } } } class Relevant extends _xfa_object.ContentObject { constructor(attributes) { super(CONFIG_NS_ID, &quot;relevant&quot;); } [_xfa_object.$finalize]() { this[_xfa_object.$content] = this[_xfa_object.$content].trim().split(/\\s+/); } } class Rename extends _xfa_object.ContentObject { constructor(attributes) { super(CONFIG_NS_ID, &quot;rename&quot;); } [_xfa_object.$finalize]() { this[_xfa_object.$content] = this[_xfa_object.$content].trim(); if (this[_xfa_object.$content].toLowerCase().startsWith(&quot;xml&quot;) || new RegExp(&quot;[\\\\p{L}_][\\\\p{L}\\\\d._\\\\p{M}-]*&quot;, &quot;u&quot;).test(this[_xfa_object.$content])) { (0, _util.warn)(&quot;XFA - Rename: invalid XFA name&quot;); } } } class RenderPolicy extends _xfa_object.OptionObject { constructor(attributes) { super(CONFIG_NS_ID, &quot;renderPolicy&quot;, [&quot;server&quot;, &quot;client&quot;]); } } class RunScripts extends _xfa_object.OptionObject { constructor(attributes) { super(CONFIG_NS_ID, &quot;runScripts&quot;, [&quot;both&quot;, &quot;client&quot;, &quot;none&quot;, &quot;server&quot;]); } } class Script extends _xfa_object.XFAObject { constructor(attributes) { super(CONFIG_NS_ID, &quot;script&quot;, true); this.currentPage = null; this.exclude = null; this.runScripts = null; } } class ScriptModel extends _xfa_object.OptionObject { constructor(attributes) { super(CONFIG_NS_ID, &quot;scriptModel&quot;, [&quot;XFA&quot;, &quot;none&quot;]); } } class Severity extends _xfa_object.OptionObject { constructor(attributes) { super(CONFIG_NS_ID, &quot;severity&quot;, [&quot;ignore&quot;, &quot;error&quot;, &quot;information&quot;, &quot;trace&quot;, &quot;warning&quot;]); } } class SilentPrint extends _xfa_object.XFAObject { constructor(attributes) { super(CONFIG_NS_ID, &quot;silentPrint&quot;, true); this.addSilentPrint = null; this.printerName = null; } } class Staple extends _xfa_object.XFAObject { constructor(attributes) { super(CONFIG_NS_ID, &quot;staple&quot;); this.mode = (0, _utils.getStringOption)(attributes.mode, [&quot;usePrinterSetting&quot;, &quot;on&quot;, &quot;off&quot;]); } } class StartNode extends _xfa_object.StringObject { constructor(attributes) { super(CONFIG_NS_ID, &quot;startNode&quot;); } } class StartPage extends _xfa_object.IntegerObject { constructor(attributes) { super(CONFIG_NS_ID, &quot;startPage&quot;, 0, n =&gt; true); } } class SubmitFormat extends _xfa_object.OptionObject { constructor(attributes) { super(CONFIG_NS_ID, &quot;submitFormat&quot;, [&quot;html&quot;, &quot;delegate&quot;, &quot;fdf&quot;, &quot;xml&quot;, &quot;pdf&quot;]); } } class SubmitUrl extends _xfa_object.StringObject { constructor(attributes) { super(CONFIG_NS_ID, &quot;submitUrl&quot;); } } class SubsetBelow extends _xfa_object.IntegerObject { constructor(attributes) { super(CONFIG_NS_ID, &quot;subsetBelow&quot;, 100, n =&gt; n &gt;= 0 &amp;&amp; n &lt;= 100); } } class SuppressBanner extends _xfa_object.Option01 { constructor(attributes) { super(CONFIG_NS_ID, &quot;suppressBanner&quot;); } } class Tagged extends _xfa_object.Option01 { constructor(attributes) { super(CONFIG_NS_ID, &quot;tagged&quot;); } } class Template extends _xfa_object.XFAObject { constructor(attributes) { super(CONFIG_NS_ID, &quot;template&quot;, true); this.base = null; this.relevant = null; this.startPage = null; this.uri = null; this.xsl = null; } } class Threshold extends _xfa_object.OptionObject { constructor(attributes) { super(CONFIG_NS_ID, &quot;threshold&quot;, [&quot;trace&quot;, &quot;error&quot;, &quot;information&quot;, &quot;warning&quot;]); } } class To extends _xfa_object.OptionObject { constructor(attributes) { super(CONFIG_NS_ID, &quot;to&quot;, [&quot;null&quot;, &quot;memory&quot;, &quot;stderr&quot;, &quot;stdout&quot;, &quot;system&quot;, &quot;uri&quot;]); } } class TemplateCache extends _xfa_object.XFAObject { constructor(attributes) { super(CONFIG_NS_ID, &quot;templateCache&quot;); this.maxEntries = (0, _utils.getInteger)({ data: attributes.maxEntries, defaultValue: 5, validate: n =&gt; n &gt;= 0 }); } } class Trace extends _xfa_object.XFAObject { constructor(attributes) { super(CONFIG_NS_ID, &quot;trace&quot;, true); this.area = new _xfa_object.XFAObjectArray(); } } class Transform extends _xfa_object.XFAObject { constructor(attributes) { super(CONFIG_NS_ID, &quot;transform&quot;, true); this.groupParent = null; this.ifEmpty = null; this.nameAttr = null; this.picture = null; this.presence = null; this.rename = null; this.whitespace = null; } } class Type extends _xfa_object.OptionObject { constructor(attributes) { super(CONFIG_NS_ID, &quot;type&quot;, [&quot;none&quot;, &quot;ascii85&quot;, &quot;asciiHex&quot;, &quot;ccittfax&quot;, &quot;flate&quot;, &quot;lzw&quot;, &quot;runLength&quot;, &quot;native&quot;, &quot;xdp&quot;, &quot;mergedXDP&quot;]); } } class Uri extends _xfa_object.StringObject { constructor(attributes) { super(CONFIG_NS_ID, &quot;uri&quot;); } } class Validate extends _xfa_object.OptionObject { constructor(attributes) { super(CONFIG_NS_ID, &quot;validate&quot;, [&quot;preSubmit&quot;, &quot;prePrint&quot;, &quot;preExecute&quot;, &quot;preSave&quot;]); } } class ValidateApprovalSignatures extends _xfa_object.ContentObject { constructor(attributes) { super(CONFIG_NS_ID, &quot;validateApprovalSignatures&quot;); } [_xfa_object.$finalize]() { this[_xfa_object.$content] = this[_xfa_object.$content].trim().split(/\\s+/).filter(x =&gt; [&quot;docReady&quot;, &quot;postSign&quot;].includes(x)); } } class ValidationMessaging extends _xfa_object.OptionObject { constructor(attributes) { super(CONFIG_NS_ID, &quot;validationMessaging&quot;, [&quot;allMessagesIndividually&quot;, &quot;allMessagesTogether&quot;, &quot;firstMessageOnly&quot;, &quot;noMessages&quot;]); } } class Version extends _xfa_object.OptionObject { constructor(attributes) { super(CONFIG_NS_ID, &quot;version&quot;, [&quot;1.7&quot;, &quot;1.6&quot;, &quot;1.5&quot;, &quot;1.4&quot;, &quot;1.3&quot;, &quot;1.2&quot;]); } } class VersionControl extends _xfa_object.XFAObject { constructor(attributes) { super(CONFIG_NS_ID, &quot;VersionControl&quot;); this.outputBelow = (0, _utils.getStringOption)(attributes.outputBelow, [&quot;warn&quot;, &quot;error&quot;, &quot;update&quot;]); this.sourceAbove = (0, _utils.getStringOption)(attributes.sourceAbove, [&quot;warn&quot;, &quot;error&quot;]); this.sourceBelow = (0, _utils.getStringOption)(attributes.sourceBelow, [&quot;update&quot;, &quot;maintain&quot;]); } } class ViewerPreferences extends _xfa_object.XFAObject { constructor(attributes) { super(CONFIG_NS_ID, &quot;viewerPreferences&quot;, true); this.ADBE_JSConsole = null; this.ADBE_JSDebugger = null; this.addViewerPreferences = null; this.duplexOption = null; this.enforce = null; this.numberOfCopies = null; this.pageRange = null; this.pickTrayByPDFSize = null; this.printScaling = null; } } class WebClient extends _xfa_object.XFAObject { constructor(attributes) { super(CONFIG_NS_ID, &quot;webClient&quot;, true); this.name = attributes.name ? attributes.name.trim() : &quot;&quot;; this.fontInfo = null; this.xdc = null; } } class Whitespace extends _xfa_object.OptionObject { constructor(attributes) { super(CONFIG_NS_ID, &quot;whitespace&quot;, [&quot;preserve&quot;, &quot;ltrim&quot;, &quot;normalize&quot;, &quot;rtrim&quot;, &quot;trim&quot;]); } } class Window extends _xfa_object.ContentObject { constructor(attributes) { super(CONFIG_NS_ID, &quot;window&quot;); } [_xfa_object.$finalize]() { const pair = this[_xfa_object.$content].trim().split(/\\s*,\\s*/, 2).map(x =&gt; parseInt(x, 10)); if (pair.some(x =&gt; isNaN(x))) { this[_xfa_object.$content] = [0, 0]; return; } if (pair.length === 1) { pair.push(pair[0]); } this[_xfa_object.$content] = pair; } } class Xdc extends _xfa_object.XFAObject { constructor(attributes) { super(CONFIG_NS_ID, &quot;xdc&quot;, true); this.uri = new _xfa_object.XFAObjectArray(); this.xsl = new _xfa_object.XFAObjectArray(); } } class Xdp extends _xfa_object.XFAObject { constructor(attributes) { super(CONFIG_NS_ID, &quot;xdp&quot;, true); this.packets = null; } } class Xsl extends _xfa_object.XFAObject { constructor(attributes) { super(CONFIG_NS_ID, &quot;xsl&quot;, true); this.debug = null; this.uri = null; } } class Zpl extends _xfa_object.XFAObject { constructor(attributes) { super(CONFIG_NS_ID, &quot;zpl&quot;, true); this.name = attributes.name ? attributes.name.trim() : &quot;&quot;; this.batchOutput = null; this.flipLabel = null; this.fontInfo = null; this.xdc = null; } } class ConfigNamespace { static [_namespaces.$buildXFAObject](name, attributes) { if (ConfigNamespace.hasOwnProperty(name)) { return ConfigNamespace[name](attributes); } return undefined; } static acrobat(attrs) { return new Acrobat(attrs); } static acrobat7(attrs) { return new Acrobat7(attrs); } static ADBE_JSConsole(attrs) { return new ADBE_JSConsole(attrs); } static ADBE_JSDebugger(attrs) { return new ADBE_JSDebugger(attrs); } static addSilentPrint(attrs) { return new AddSilentPrint(attrs); } static addViewerPreferences(attrs) { return new AddViewerPreferences(attrs); } static adjustData(attrs) { return new AdjustData(attrs); } static adobeExtensionLevel(attrs) { return new AdobeExtensionLevel(attrs); } static agent(attrs) { return new Agent(attrs); } static alwaysEmbed(attrs) { return new AlwaysEmbed(attrs); } static amd(attrs) { return new Amd(attrs); } static area(attrs) { return new Area(attrs); } static attributes(attrs) { return new Attributes(attrs); } static autoSave(attrs) { return new AutoSave(attrs); } static base(attrs) { return new Base(attrs); } static batchOutput(attrs) { return new BatchOutput(attrs); } static behaviorOverride(attrs) { return new BehaviorOverride(attrs); } static cache(attrs) { return new Cache(attrs); } static change(attrs) { return new Change(attrs); } static common(attrs) { return new Common(attrs); } static compress(attrs) { return new Compress(attrs); } static compressLogicalStructure(attrs) { return new CompressLogicalStructure(attrs); } static compressObjectStream(attrs) { return new CompressObjectStream(attrs); } static compression(attrs) { return new Compression(attrs); } static config(attrs) { return new Config(attrs); } static conformance(attrs) { return new Conformance(attrs); } static contentCopy(attrs) { return new ContentCopy(attrs); } static copies(attrs) { return new Copies(attrs); } static creator(attrs) { return new Creator(attrs); } static currentPage(attrs) { return new CurrentPage(attrs); } static data(attrs) { return new Data(attrs); } static debug(attrs) { return new Debug(attrs); } static defaultTypeface(attrs) { return new DefaultTypeface(attrs); } static destination(attrs) { return new Destination(attrs); } static documentAssembly(attrs) { return new DocumentAssembly(attrs); } static driver(attrs) { return new Driver(attrs); } static duplexOption(attrs) { return new DuplexOption(attrs); } static dynamicRender(attrs) { return new DynamicRender(attrs); } static embed(attrs) { return new Embed(attrs); } static encrypt(attrs) { return new Encrypt(attrs); } static encryption(attrs) { return new Encryption(attrs); } static encryptionLevel(attrs) { return new EncryptionLevel(attrs); } static enforce(attrs) { return new Enforce(attrs); } static equate(attrs) { return new Equate(attrs); } static equateRange(attrs) { return new EquateRange(attrs); } static exclude(attrs) { return new Exclude(attrs); } static excludeNS(attrs) { return new ExcludeNS(attrs); } static flipLabel(attrs) { return new FlipLabel(attrs); } static fontInfo(attrs) { return new FontInfo(attrs); } static formFieldFilling(attrs) { return new FormFieldFilling(attrs); } static groupParent(attrs) { return new GroupParent(attrs); } static ifEmpty(attrs) { return new IfEmpty(attrs); } static includeXDPContent(attrs) { return new IncludeXDPContent(attrs); } static incrementalLoad(attrs) { return new IncrementalLoad(attrs); } static incrementalMerge(attrs) { return new IncrementalMerge(attrs); } static interactive(attrs) { return new Interactive(attrs); } static jog(attrs) { return new Jog(attrs); } static labelPrinter(attrs) { return new LabelPrinter(attrs); } static layout(attrs) { return new Layout(attrs); } static level(attrs) { return new Level(attrs); } static linearized(attrs) { return new Linearized(attrs); } static locale(attrs) { return new Locale(attrs); } static localeSet(attrs) { return new LocaleSet(attrs); } static log(attrs) { return new Log(attrs); } static map(attrs) { return new MapElement(attrs); } static mediumInfo(attrs) { return new MediumInfo(attrs); } static message(attrs) { return new Message(attrs); } static messaging(attrs) { return new Messaging(attrs); } static mode(attrs) { return new Mode(attrs); } static modifyAnnots(attrs) { return new ModifyAnnots(attrs); } static msgId(attrs) { return new MsgId(attrs); } static nameAttr(attrs) { return new NameAttr(attrs); } static neverEmbed(attrs) { return new NeverEmbed(attrs); } static numberOfCopies(attrs) { return new NumberOfCopies(attrs); } static openAction(attrs) { return new OpenAction(attrs); } static output(attrs) { return new Output(attrs); } static outputBin(attrs) { return new OutputBin(attrs); } static outputXSL(attrs) { return new OutputXSL(attrs); } static overprint(attrs) { return new Overprint(attrs); } static packets(attrs) { return new Packets(attrs); } static pageOffset(attrs) { return new PageOffset(attrs); } static pageRange(attrs) { return new PageRange(attrs); } static pagination(attrs) { return new Pagination(attrs); } static paginationOverride(attrs) { return new PaginationOverride(attrs); } static part(attrs) { return new Part(attrs); } static pcl(attrs) { return new Pcl(attrs); } static pdf(attrs) { return new Pdf(attrs); } static pdfa(attrs) { return new Pdfa(attrs); } static permissions(attrs) { return new Permissions(attrs); } static pickTrayByPDFSize(attrs) { return new PickTrayByPDFSize(attrs); } static picture(attrs) { return new Picture(attrs); } static plaintextMetadata(attrs) { return new PlaintextMetadata(attrs); } static presence(attrs) { return new Presence(attrs); } static present(attrs) { return new Present(attrs); } static print(attrs) { return new Print(attrs); } static printHighQuality(attrs) { return new PrintHighQuality(attrs); } static printScaling(attrs) { return new PrintScaling(attrs); } static printerName(attrs) { return new PrinterName(attrs); } static producer(attrs) { return new Producer(attrs); } static ps(attrs) { return new Ps(attrs); } static range(attrs) { return new Range(attrs); } static record(attrs) { return new Record(attrs); } static relevant(attrs) { return new Relevant(attrs); } static rename(attrs) { return new Rename(attrs); } static renderPolicy(attrs) { return new RenderPolicy(attrs); } static runScripts(attrs) { return new RunScripts(attrs); } static script(attrs) { return new Script(attrs); } static scriptModel(attrs) { return new ScriptModel(attrs); } static severity(attrs) { return new Severity(attrs); } static silentPrint(attrs) { return new SilentPrint(attrs); } static staple(attrs) { return new Staple(attrs); } static startNode(attrs) { return new StartNode(attrs); } static startPage(attrs) { return new StartPage(attrs); } static submitFormat(attrs) { return new SubmitFormat(attrs); } static submitUrl(attrs) { return new SubmitUrl(attrs); } static subsetBelow(attrs) { return new SubsetBelow(attrs); } static suppressBanner(attrs) { return new SuppressBanner(attrs); } static tagged(attrs) { return new Tagged(attrs); } static template(attrs) { return new Template(attrs); } static templateCache(attrs) { return new TemplateCache(attrs); } static threshold(attrs) { return new Threshold(attrs); } static to(attrs) { return new To(attrs); } static trace(attrs) { return new Trace(attrs); } static transform(attrs) { return new Transform(attrs); } static type(attrs) { return new Type(attrs); } static uri(attrs) { return new Uri(attrs); } static validate(attrs) { return new Validate(attrs); } static validateApprovalSignatures(attrs) { return new ValidateApprovalSignatures(attrs); } static validationMessaging(attrs) { return new ValidationMessaging(attrs); } static version(attrs) { return new Version(attrs); } static versionControl(attrs) { return new VersionControl(attrs); } static viewerPreferences(attrs) { return new ViewerPreferences(attrs); } static webClient(attrs) { return new WebClient(attrs); } static whitespace(attrs) { return new Whitespace(attrs); } static window(attrs) { return new Window(attrs); } static xdc(attrs) { return new Xdc(attrs); } static xdp(attrs) { return new Xdp(attrs); } static xsl(attrs) { return new Xsl(attrs); } static zpl(attrs) { return new Zpl(attrs); } } exports.ConfigNamespace = ConfigNamespace; /***/ }), /* 90 */ /***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) =&gt; { Object.defineProperty(exports, &quot;__esModule&quot;, ({ value: true })); exports.ConnectionSetNamespace = void 0; var _namespaces = __w_pdfjs_require__(77); var _xfa_object = __w_pdfjs_require__(75); const CONNECTION_SET_NS_ID = _namespaces.NamespaceIds.connectionSet.id; class ConnectionSet extends _xfa_object.XFAObject { constructor(attributes) { super(CONNECTION_SET_NS_ID, &quot;connectionSet&quot;, true); this.wsdlConnection = new _xfa_object.XFAObjectArray(); this.xmlConnection = new _xfa_object.XFAObjectArray(); this.xsdConnection = new _xfa_object.XFAObjectArray(); } } class EffectiveInputPolicy extends _xfa_object.XFAObject { constructor(attributes) { super(CONNECTION_SET_NS_ID, &quot;effectiveInputPolicy&quot;); this.id = attributes.id || &quot;&quot;; this.name = attributes.name || &quot;&quot;; this.use = attributes.use || &quot;&quot;; this.usehref = attributes.usehref || &quot;&quot;; } } class EffectiveOutputPolicy extends _xfa_object.XFAObject { constructor(attributes) { super(CONNECTION_SET_NS_ID, &quot;effectiveOutputPolicy&quot;); this.id = attributes.id || &quot;&quot;; this.name = attributes.name || &quot;&quot;; this.use = attributes.use || &quot;&quot;; this.usehref = attributes.usehref || &quot;&quot;; } } class Operation extends _xfa_object.StringObject { constructor(attributes) { super(CONNECTION_SET_NS_ID, &quot;operation&quot;); this.id = attributes.id || &quot;&quot;; this.input = attributes.input || &quot;&quot;; this.name = attributes.name || &quot;&quot;; this.output = attributes.output || &quot;&quot;; this.use = attributes.use || &quot;&quot;; this.usehref = attributes.usehref || &quot;&quot;; } } class RootElement extends _xfa_object.StringObject { constructor(attributes) { super(CONNECTION_SET_NS_ID, &quot;rootElement&quot;); this.id = attributes.id || &quot;&quot;; this.name = attributes.name || &quot;&quot;; this.use = attributes.use || &quot;&quot;; this.usehref = attributes.usehref || &quot;&quot;; } } class SoapAction extends _xfa_object.StringObject { constructor(attributes) { super(CONNECTION_SET_NS_ID, &quot;soapAction&quot;); this.id = attributes.id || &quot;&quot;; this.name = attributes.name || &quot;&quot;; this.use = attributes.use || &quot;&quot;; this.usehref = attributes.usehref || &quot;&quot;; } } class SoapAddress extends _xfa_object.StringObject { constructor(attributes) { super(CONNECTION_SET_NS_ID, &quot;soapAddress&quot;); this.id = attributes.id || &quot;&quot;; this.name = attributes.name || &quot;&quot;; this.use = attributes.use || &quot;&quot;; this.usehref = attributes.usehref || &quot;&quot;; } } class Uri extends _xfa_object.StringObject { constructor(attributes) { super(CONNECTION_SET_NS_ID, &quot;uri&quot;); this.id = attributes.id || &quot;&quot;; this.name = attributes.name || &quot;&quot;; this.use = attributes.use || &quot;&quot;; this.usehref = attributes.usehref || &quot;&quot;; } } class WsdlAddress extends _xfa_object.StringObject { constructor(attributes) { super(CONNECTION_SET_NS_ID, &quot;wsdlAddress&quot;); this.id = attributes.id || &quot;&quot;; this.name = attributes.name || &quot;&quot;; this.use = attributes.use || &quot;&quot;; this.usehref = attributes.usehref || &quot;&quot;; } } class WsdlConnection extends _xfa_object.XFAObject { constructor(attributes) { super(CONNECTION_SET_NS_ID, &quot;wsdlConnection&quot;, true); this.dataDescription = attributes.dataDescription || &quot;&quot;; this.name = attributes.name || &quot;&quot;; this.effectiveInputPolicy = null; this.effectiveOutputPolicy = null; this.operation = null; this.soapAction = null; this.soapAddress = null; this.wsdlAddress = null; } } class XmlConnection extends _xfa_object.XFAObject { constructor(attributes) { super(CONNECTION_SET_NS_ID, &quot;xmlConnection&quot;, true); this.dataDescription = attributes.dataDescription || &quot;&quot;; this.name = attributes.name || &quot;&quot;; this.uri = null; } } class XsdConnection extends _xfa_object.XFAObject { constructor(attributes) { super(CONNECTION_SET_NS_ID, &quot;xsdConnection&quot;, true); this.dataDescription = attributes.dataDescription || &quot;&quot;; this.name = attributes.name || &quot;&quot;; this.rootElement = null; this.uri = null; } } class ConnectionSetNamespace { static [_namespaces.$buildXFAObject](name, attributes) { if (ConnectionSetNamespace.hasOwnProperty(name)) { return ConnectionSetNamespace[name](attributes); } return undefined; } static connectionSet(attrs) { return new ConnectionSet(attrs); } static effectiveInputPolicy(attrs) { return new EffectiveInputPolicy(attrs); } static effectiveOutputPolicy(attrs) { return new EffectiveOutputPolicy(attrs); } static operation(attrs) { return new Operation(attrs); } static rootElement(attrs) { return new RootElement(attrs); } static soapAction(attrs) { return new SoapAction(attrs); } static soapAddress(attrs) { return new SoapAddress(attrs); } static uri(attrs) { return new Uri(attrs); } static wsdlAddress(attrs) { return new WsdlAddress(attrs); } static wsdlConnection(attrs) { return new WsdlConnection(attrs); } static xmlConnection(attrs) { return new XmlConnection(attrs); } static xsdConnection(attrs) { return new XsdConnection(attrs); } } exports.ConnectionSetNamespace = ConnectionSetNamespace; /***/ }), /* 91 */ /***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) =&gt; { Object.defineProperty(exports, &quot;__esModule&quot;, ({ value: true })); exports.DatasetsNamespace = void 0; var _xfa_object = __w_pdfjs_require__(75); var _namespaces = __w_pdfjs_require__(77); const DATASETS_NS_ID = _namespaces.NamespaceIds.datasets.id; class Data extends _xfa_object.XmlObject { constructor(attributes) { super(DATASETS_NS_ID, &quot;data&quot;, attributes); } [_xfa_object.$isNsAgnostic]() { return true; } } class Datasets extends _xfa_object.XFAObject { constructor(attributes) { super(DATASETS_NS_ID, &quot;datasets&quot;, true); this.data = null; this.Signature = null; } [_xfa_object.$onChild](child) { const name = child[_xfa_object.$nodeName]; if (name === &quot;data&quot; &amp;&amp; child[_xfa_object.$namespaceId] === DATASETS_NS_ID || name === &quot;Signature&quot; &amp;&amp; child[_xfa_object.$namespaceId] === _namespaces.NamespaceIds.signature.id) { this[name] = child; } this[_xfa_object.$appendChild](child); } } class DatasetsNamespace { static [_namespaces.$buildXFAObject](name, attributes) { if (DatasetsNamespace.hasOwnProperty(name)) { return DatasetsNamespace[name](attributes); } return undefined; } static datasets(attributes) { return new Datasets(attributes); } static data(attributes) { return new Data(attributes); } } exports.DatasetsNamespace = DatasetsNamespace; /***/ }), /* 92 */ /***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) =&gt; { Object.defineProperty(exports, &quot;__esModule&quot;, ({ value: true })); exports.LocaleSetNamespace = void 0; var _namespaces = __w_pdfjs_require__(77); var _xfa_object = __w_pdfjs_require__(75); var _utils = __w_pdfjs_require__(76); const LOCALE_SET_NS_ID = _namespaces.NamespaceIds.localeSet.id; class CalendarSymbols extends _xfa_object.XFAObject { constructor(attributes) { super(LOCALE_SET_NS_ID, &quot;calendarSymbols&quot;, true); this.name = &quot;gregorian&quot;; this.dayNames = new _xfa_object.XFAObjectArray(2); this.eraNames = null; this.meridiemNames = null; this.monthNames = new _xfa_object.XFAObjectArray(2); } } class CurrencySymbol extends _xfa_object.StringObject { constructor(attributes) { super(LOCALE_SET_NS_ID, &quot;currencySymbol&quot;); this.name = (0, _utils.getStringOption)(attributes.name, [&quot;symbol&quot;, &quot;isoname&quot;, &quot;decimal&quot;]); } } class CurrencySymbols extends _xfa_object.XFAObject { constructor(attributes) { super(LOCALE_SET_NS_ID, &quot;currencySymbols&quot;, true); this.currencySymbol = new _xfa_object.XFAObjectArray(3); } } class DatePattern extends _xfa_object.StringObject { constructor(attributes) { super(LOCALE_SET_NS_ID, &quot;datePattern&quot;); this.name = (0, _utils.getStringOption)(attributes.name, [&quot;full&quot;, &quot;long&quot;, &quot;med&quot;, &quot;short&quot;]); } } class DatePatterns extends _xfa_object.XFAObject { constructor(attributes) { super(LOCALE_SET_NS_ID, &quot;datePatterns&quot;, true); this.datePattern = new _xfa_object.XFAObjectArray(4); } } class DateTimeSymbols extends _xfa_object.ContentObject { constructor(attributes) { super(LOCALE_SET_NS_ID, &quot;dateTimeSymbols&quot;); } } class Day extends _xfa_object.StringObject { constructor(attributes) { super(LOCALE_SET_NS_ID, &quot;day&quot;); } } class DayNames extends _xfa_object.XFAObject { constructor(attributes) { super(LOCALE_SET_NS_ID, &quot;dayNames&quot;, true); this.abbr = (0, _utils.getInteger)({ data: attributes.abbr, defaultValue: 0, validate: x =&gt; x === 1 }); this.day = new _xfa_object.XFAObjectArray(7); } } class Era extends _xfa_object.StringObject { constructor(attributes) { super(LOCALE_SET_NS_ID, &quot;era&quot;); } } class EraNames extends _xfa_object.XFAObject { constructor(attributes) { super(LOCALE_SET_NS_ID, &quot;eraNames&quot;, true); this.era = new _xfa_object.XFAObjectArray(2); } } class Locale extends _xfa_object.XFAObject { constructor(attributes) { super(LOCALE_SET_NS_ID, &quot;locale&quot;, true); this.desc = attributes.desc || &quot;&quot;; this.name = &quot;isoname&quot;; this.calendarSymbols = null; this.currencySymbols = null; this.datePatterns = null; this.dateTimeSymbols = null; this.numberPatterns = null; this.numberSymbols = null; this.timePatterns = null; this.typeFaces = null; } } class LocaleSet extends _xfa_object.XFAObject { constructor(attributes) { super(LOCALE_SET_NS_ID, &quot;localeSet&quot;, true); this.locale = new _xfa_object.XFAObjectArray(); } } class Meridiem extends _xfa_object.StringObject { constructor(attributes) { super(LOCALE_SET_NS_ID, &quot;meridiem&quot;); } } class MeridiemNames extends _xfa_object.XFAObject { constructor(attributes) { super(LOCALE_SET_NS_ID, &quot;meridiemNames&quot;, true); this.meridiem = new _xfa_object.XFAObjectArray(2); } } class Month extends _xfa_object.StringObject { constructor(attributes) { super(LOCALE_SET_NS_ID, &quot;month&quot;); } } class MonthNames extends _xfa_object.XFAObject { constructor(attributes) { super(LOCALE_SET_NS_ID, &quot;monthNames&quot;, true); this.abbr = (0, _utils.getInteger)({ data: attributes.abbr, defaultValue: 0, validate: x =&gt; x === 1 }); this.month = new _xfa_object.XFAObjectArray(12); } } class NumberPattern extends _xfa_object.StringObject { constructor(attributes) { super(LOCALE_SET_NS_ID, &quot;numberPattern&quot;); this.name = (0, _utils.getStringOption)(attributes.name, [&quot;full&quot;, &quot;long&quot;, &quot;med&quot;, &quot;short&quot;]); } } class NumberPatterns extends _xfa_object.XFAObject { constructor(attributes) { super(LOCALE_SET_NS_ID, &quot;numberPatterns&quot;, true); this.numberPattern = new _xfa_object.XFAObjectArray(4); } } class NumberSymbol extends _xfa_object.StringObject { constructor(attributes) { super(LOCALE_SET_NS_ID, &quot;numberSymbol&quot;); this.name = (0, _utils.getStringOption)(attributes.name, [&quot;decimal&quot;, &quot;grouping&quot;, &quot;percent&quot;, &quot;minus&quot;, &quot;zero&quot;]); } } class NumberSymbols extends _xfa_object.XFAObject { constructor(attributes) { super(LOCALE_SET_NS_ID, &quot;numberSymbols&quot;, true); this.numberSymbol = new _xfa_object.XFAObjectArray(5); } } class TimePattern extends _xfa_object.StringObject { constructor(attributes) { super(LOCALE_SET_NS_ID, &quot;timePattern&quot;); this.name = (0, _utils.getStringOption)(attributes.name, [&quot;full&quot;, &quot;long&quot;, &quot;med&quot;, &quot;short&quot;]); } } class TimePatterns extends _xfa_object.XFAObject { constructor(attributes) { super(LOCALE_SET_NS_ID, &quot;timePatterns&quot;, true); this.timePattern = new _xfa_object.XFAObjectArray(4); } } class TypeFace extends _xfa_object.XFAObject { constructor(attributes) { super(LOCALE_SET_NS_ID, &quot;typeFace&quot;, true); this.name = attributes.name | &quot;&quot;; } } class TypeFaces extends _xfa_object.XFAObject { constructor(attributes) { super(LOCALE_SET_NS_ID, &quot;typeFaces&quot;, true); this.typeFace = new _xfa_object.XFAObjectArray(); } } class LocaleSetNamespace { static [_namespaces.$buildXFAObject](name, attributes) { if (LocaleSetNamespace.hasOwnProperty(name)) { return LocaleSetNamespace[name](attributes); } return undefined; } static calendarSymbols(attrs) { return new CalendarSymbols(attrs); } static currencySymbol(attrs) { return new CurrencySymbol(attrs); } static currencySymbols(attrs) { return new CurrencySymbols(attrs); } static datePattern(attrs) { return new DatePattern(attrs); } static datePatterns(attrs) { return new DatePatterns(attrs); } static dateTimeSymbols(attrs) { return new DateTimeSymbols(attrs); } static day(attrs) { return new Day(attrs); } static dayNames(attrs) { return new DayNames(attrs); } static era(attrs) { return new Era(attrs); } static eraNames(attrs) { return new EraNames(attrs); } static locale(attrs) { return new Locale(attrs); } static localeSet(attrs) { return new LocaleSet(attrs); } static meridiem(attrs) { return new Meridiem(attrs); } static meridiemNames(attrs) { return new MeridiemNames(attrs); } static month(attrs) { return new Month(attrs); } static monthNames(attrs) { return new MonthNames(attrs); } static numberPattern(attrs) { return new NumberPattern(attrs); } static numberPatterns(attrs) { return new NumberPatterns(attrs); } static numberSymbol(attrs) { return new NumberSymbol(attrs); } static numberSymbols(attrs) { return new NumberSymbols(attrs); } static timePattern(attrs) { return new TimePattern(attrs); } static timePatterns(attrs) { return new TimePatterns(attrs); } static typeFace(attrs) { return new TypeFace(attrs); } static typeFaces(attrs) { return new TypeFaces(attrs); } } exports.LocaleSetNamespace = LocaleSetNamespace; /***/ }), /* 93 */ /***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) =&gt; { Object.defineProperty(exports, &quot;__esModule&quot;, ({ value: true })); exports.SignatureNamespace = void 0; var _namespaces = __w_pdfjs_require__(77); var _xfa_object = __w_pdfjs_require__(75); const SIGNATURE_NS_ID = _namespaces.NamespaceIds.signature.id; class Signature extends _xfa_object.XFAObject { constructor(attributes) { super(SIGNATURE_NS_ID, &quot;signature&quot;, true); } } class SignatureNamespace { static [_namespaces.$buildXFAObject](name, attributes) { if (SignatureNamespace.hasOwnProperty(name)) { return SignatureNamespace[name](attributes); } return undefined; } static signature(attributes) { return new Signature(attributes); } } exports.SignatureNamespace = SignatureNamespace; /***/ }), /* 94 */ /***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) =&gt; { Object.defineProperty(exports, &quot;__esModule&quot;, ({ value: true })); exports.StylesheetNamespace = void 0; var _namespaces = __w_pdfjs_require__(77); var _xfa_object = __w_pdfjs_require__(75); const STYLESHEET_NS_ID = _namespaces.NamespaceIds.stylesheet.id; class Stylesheet extends _xfa_object.XFAObject { constructor(attributes) { super(STYLESHEET_NS_ID, &quot;stylesheet&quot;, true); } } class StylesheetNamespace { static [_namespaces.$buildXFAObject](name, attributes) { if (StylesheetNamespace.hasOwnProperty(name)) { return StylesheetNamespace[name](attributes); } return undefined; } static stylesheet(attributes) { return new Stylesheet(attributes); } } exports.StylesheetNamespace = StylesheetNamespace; /***/ }), /* 95 */ /***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) =&gt; { Object.defineProperty(exports, &quot;__esModule&quot;, ({ value: true })); exports.XdpNamespace = void 0; var _namespaces = __w_pdfjs_require__(77); var _xfa_object = __w_pdfjs_require__(75); const XDP_NS_ID = _namespaces.NamespaceIds.xdp.id; class Xdp extends _xfa_object.XFAObject { constructor(attributes) { super(XDP_NS_ID, &quot;xdp&quot;, true); this.uuid = attributes.uuid || &quot;&quot;; this.timeStamp = attributes.timeStamp || &quot;&quot;; this.config = null; this.connectionSet = null; this.datasets = null; this.localeSet = null; this.stylesheet = new _xfa_object.XFAObjectArray(); this.template = null; } [_xfa_object.$onChildCheck](child) { const ns = _namespaces.NamespaceIds[child[_xfa_object.$nodeName]]; return ns &amp;&amp; child[_xfa_object.$namespaceId] === ns.id; } } class XdpNamespace { static [_namespaces.$buildXFAObject](name, attributes) { if (XdpNamespace.hasOwnProperty(name)) { return XdpNamespace[name](attributes); } return undefined; } static xdp(attributes) { return new Xdp(attributes); } } exports.XdpNamespace = XdpNamespace; /***/ }), /* 96 */ /***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) =&gt; { Object.defineProperty(exports, &quot;__esModule&quot;, ({ value: true })); exports.XhtmlNamespace = void 0; var _xfa_object = __w_pdfjs_require__(75); var _namespaces = __w_pdfjs_require__(77); var _html_utils = __w_pdfjs_require__(82); var _utils = __w_pdfjs_require__(76); const XHTML_NS_ID = _namespaces.NamespaceIds.xhtml.id; const $richText = Symbol(); const VALID_STYLES = new Set([&quot;color&quot;, &quot;font&quot;, &quot;font-family&quot;, &quot;font-size&quot;, &quot;font-stretch&quot;, &quot;font-style&quot;, &quot;font-weight&quot;, &quot;margin&quot;, &quot;margin-bottom&quot;, &quot;margin-left&quot;, &quot;margin-right&quot;, &quot;margin-top&quot;, &quot;letter-spacing&quot;, &quot;line-height&quot;, &quot;orphans&quot;, &quot;page-break-after&quot;, &quot;page-break-before&quot;, &quot;page-break-inside&quot;, &quot;tab-interval&quot;, &quot;tab-stop&quot;, &quot;text-align&quot;, &quot;text-decoration&quot;, &quot;text-indent&quot;, &quot;vertical-align&quot;, &quot;widows&quot;, &quot;kerning-mode&quot;, &quot;xfa-font-horizontal-scale&quot;, &quot;xfa-font-vertical-scale&quot;, &quot;xfa-spacerun&quot;, &quot;xfa-tab-stops&quot;]); const StyleMapping = new Map([[&quot;page-break-after&quot;, &quot;breakAfter&quot;], [&quot;page-break-before&quot;, &quot;breakBefore&quot;], [&quot;page-break-inside&quot;, &quot;breakInside&quot;], [&quot;kerning-mode&quot;, value =&gt; value === &quot;none&quot; ? &quot;none&quot; : &quot;normal&quot;], [&quot;xfa-font-horizontal-scale&quot;, value =&gt; `scaleX(${Math.max(0, Math.min(parseInt(value) / 100)).toFixed(2)})`], [&quot;xfa-font-vertical-scale&quot;, value =&gt; `scaleY(${Math.max(0, Math.min(parseInt(value) / 100)).toFixed(2)})`], [&quot;xfa-spacerun&quot;, &quot;&quot;], [&quot;xfa-tab-stops&quot;, &quot;&quot;], [&quot;font-size&quot;, (value, original) =&gt; { value = original.fontSize = (0, _utils.getMeasurement)(value); return (0, _html_utils.measureToString)(0.99 * value); }], [&quot;letter-spacing&quot;, value =&gt; (0, _html_utils.measureToString)((0, _utils.getMeasurement)(value))], [&quot;line-height&quot;, value =&gt; (0, _html_utils.measureToString)((0, _utils.getMeasurement)(value))], [&quot;margin&quot;, value =&gt; (0, _html_utils.measureToString)((0, _utils.getMeasurement)(value))], [&quot;margin-bottom&quot;, value =&gt; (0, _html_utils.measureToString)((0, _utils.getMeasurement)(value))], [&quot;margin-left&quot;, value =&gt; (0, _html_utils.measureToString)((0, _utils.getMeasurement)(value))], [&quot;margin-right&quot;, value =&gt; (0, _html_utils.measureToString)((0, _utils.getMeasurement)(value))], [&quot;margin-top&quot;, value =&gt; (0, _html_utils.measureToString)((0, _utils.getMeasurement)(value))], [&quot;text-indent&quot;, value =&gt; (0, _html_utils.measureToString)((0, _utils.getMeasurement)(value))], [&quot;font-family&quot;, value =&gt; value], [&quot;vertical-align&quot;, value =&gt; (0, _html_utils.measureToString)((0, _utils.getMeasurement)(value))]]); const spacesRegExp = /\\s+/g; const crlfRegExp = /[\\r\\n]+/g; const crlfForRichTextRegExp = /\\r\\n?/g; function mapStyle(styleStr, node, richText) { const style = Object.create(null); if (!styleStr) { return style; } const original = Object.create(null); for (const [key, value] of styleStr.split(&quot;;&quot;).map(s =&gt; s.split(&quot;:&quot;, 2))) { const mapping = StyleMapping.get(key); if (mapping === &quot;&quot;) { continue; } let newValue = value; if (mapping) { if (typeof mapping === &quot;string&quot;) { newValue = mapping; } else { newValue = mapping(value, original); } } if (key.endsWith(&quot;scale&quot;)) { if (style.transform) { style.transform = `${style[key]} ${newValue}`; } else { style.transform = newValue; } } else { style[key.replaceAll(/-([a-zA-Z])/g, (_, x) =&gt; x.toUpperCase())] = newValue; } } if (style.fontFamily) { (0, _html_utils.setFontFamily)({ typeface: style.fontFamily, weight: style.fontWeight || &quot;normal&quot;, posture: style.fontStyle || &quot;normal&quot;, size: original.fontSize || 0 }, node, node[_xfa_object.$globalData].fontFinder, style); } if (richText &amp;&amp; style.verticalAlign &amp;&amp; style.verticalAlign !== &quot;0px&quot; &amp;&amp; style.fontSize) { const SUB_SUPER_SCRIPT_FACTOR = 0.583; const VERTICAL_FACTOR = 0.333; const fontSize = (0, _utils.getMeasurement)(style.fontSize); style.fontSize = (0, _html_utils.measureToString)(fontSize * SUB_SUPER_SCRIPT_FACTOR); style.verticalAlign = (0, _html_utils.measureToString)(Math.sign((0, _utils.getMeasurement)(style.verticalAlign)) * fontSize * VERTICAL_FACTOR); } if (richText &amp;&amp; style.fontSize) { style.fontSize = `calc(${style.fontSize} * var(--scale-factor))`; } (0, _html_utils.fixTextIndent)(style); return style; } function checkStyle(node) { if (!node.style) { return &quot;&quot;; } return node.style.trim().split(/\\s*;\\s*/).filter(s =&gt; !!s).map(s =&gt; s.split(/\\s*:\\s*/, 2)).filter(([key, value]) =&gt; { if (key === &quot;font-family&quot;) { node[_xfa_object.$globalData].usedTypefaces.add(value); } return VALID_STYLES.has(key); }).map(kv =&gt; kv.join(&quot;:&quot;)).join(&quot;;&quot;); } const NoWhites = new Set([&quot;body&quot;, &quot;html&quot;]); class XhtmlObject extends _xfa_object.XmlObject { constructor(attributes, name) { super(XHTML_NS_ID, name); this[$richText] = false; this.style = attributes.style || &quot;&quot;; } [_xfa_object.$clean](builder) { super[_xfa_object.$clean](builder); this.style = checkStyle(this); } [_xfa_object.$acceptWhitespace]() { return !NoWhites.has(this[_xfa_object.$nodeName]); } [_xfa_object.$onText](str, richText = false) { if (!richText) { str = str.replace(crlfRegExp, &quot;&quot;); if (!this.style.includes(&quot;xfa-spacerun:yes&quot;)) { str = str.replace(spacesRegExp, &quot; &quot;); } } else { this[$richText] = true; } if (str) { this[_xfa_object.$content] += str; } } [_xfa_object.$pushGlyphs](measure, mustPop = true) { const xfaFont = Object.create(null); const margin = { top: NaN, bottom: NaN, left: NaN, right: NaN }; let lineHeight = null; for (const [key, value] of this.style.split(&quot;;&quot;).map(s =&gt; s.split(&quot;:&quot;, 2))) { switch (key) { case &quot;font-family&quot;: xfaFont.typeface = (0, _utils.stripQuotes)(value); break; case &quot;font-size&quot;: xfaFont.size = (0, _utils.getMeasurement)(value); break; case &quot;font-weight&quot;: xfaFont.weight = value; break; case &quot;font-style&quot;: xfaFont.posture = value; break; case &quot;letter-spacing&quot;: xfaFont.letterSpacing = (0, _utils.getMeasurement)(value); break; case &quot;margin&quot;: const values = value.split(/ \\t/).map(x =&gt; (0, _utils.getMeasurement)(x)); switch (values.length) { case 1: margin.top = margin.bottom = margin.left = margin.right = values[0]; break; case 2: margin.top = margin.bottom = values[0]; margin.left = margin.right = values[1]; break; case 3: margin.top = values[0]; margin.bottom = values[2]; margin.left = margin.right = values[1]; break; case 4: margin.top = values[0]; margin.left = values[1]; margin.bottom = values[2]; margin.right = values[3]; break; } break; case &quot;margin-top&quot;: margin.top = (0, _utils.getMeasurement)(value); break; case &quot;margin-bottom&quot;: margin.bottom = (0, _utils.getMeasurement)(value); break; case &quot;margin-left&quot;: margin.left = (0, _utils.getMeasurement)(value); break; case &quot;margin-right&quot;: margin.right = (0, _utils.getMeasurement)(value); break; case &quot;line-height&quot;: lineHeight = (0, _utils.getMeasurement)(value); break; } } measure.pushData(xfaFont, margin, lineHeight); if (this[_xfa_object.$content]) { measure.addString(this[_xfa_object.$content]); } else { for (const child of this[_xfa_object.$getChildren]()) { if (child[_xfa_object.$nodeName] === &quot;#text&quot;) { measure.addString(child[_xfa_object.$content]); continue; } child[_xfa_object.$pushGlyphs](measure); } } if (mustPop) { measure.popFont(); } } [_xfa_object.$toHTML](availableSpace) { const children = []; this[_xfa_object.$extra] = { children }; this[_xfa_object.$childrenToHTML]({}); if (children.length === 0 &amp;&amp; !this[_xfa_object.$content]) { return _utils.HTMLResult.EMPTY; } let value; if (this[$richText]) { value = this[_xfa_object.$content] ? this[_xfa_object.$content].replace(crlfForRichTextRegExp, &quot;\\n&quot;) : undefined; } else { value = this[_xfa_object.$content] || undefined; } return _utils.HTMLResult.success({ name: this[_xfa_object.$nodeName], attributes: { href: this.href, style: mapStyle(this.style, this, this[$richText]) }, children, value }); } } class A extends XhtmlObject { constructor(attributes) { super(attributes, &quot;a&quot;); this.href = (0, _html_utils.fixURL)(attributes.href) || &quot;&quot;; } } class B extends XhtmlObject { constructor(attributes) { super(attributes, &quot;b&quot;); } [_xfa_object.$pushGlyphs](measure) { measure.pushFont({ weight: &quot;bold&quot; }); super[_xfa_object.$pushGlyphs](measure); measure.popFont(); } } class Body extends XhtmlObject { constructor(attributes) { super(attributes, &quot;body&quot;); } [_xfa_object.$toHTML](availableSpace) { const res = super[_xfa_object.$toHTML](availableSpace); const { html } = res; if (!html) { return _utils.HTMLResult.EMPTY; } html.name = &quot;div&quot;; html.attributes.class = [&quot;xfaRich&quot;]; return res; } } class Br extends XhtmlObject { constructor(attributes) { super(attributes, &quot;br&quot;); } [_xfa_object.$text]() { return &quot;\\n&quot;; } [_xfa_object.$pushGlyphs](measure) { measure.addString(&quot;\\n&quot;); } [_xfa_object.$toHTML](availableSpace) { return _utils.HTMLResult.success({ name: &quot;br&quot; }); } } class Html extends XhtmlObject { constructor(attributes) { super(attributes, &quot;html&quot;); } [_xfa_object.$toHTML](availableSpace) { const children = []; this[_xfa_object.$extra] = { children }; this[_xfa_object.$childrenToHTML]({}); if (children.length === 0) { return _utils.HTMLResult.success({ name: &quot;div&quot;, attributes: { class: [&quot;xfaRich&quot;], style: {} }, value: this[_xfa_object.$content] || &quot;&quot; }); } if (children.length === 1) { const child = children[0]; if (child.attributes &amp;&amp; child.attributes.class.includes(&quot;xfaRich&quot;)) { return _utils.HTMLResult.success(child); } } return _utils.HTMLResult.success({ name: &quot;div&quot;, attributes: { class: [&quot;xfaRich&quot;], style: {} }, children }); } } class I extends XhtmlObject { constructor(attributes) { super(attributes, &quot;i&quot;); } [_xfa_object.$pushGlyphs](measure) { measure.pushFont({ posture: &quot;italic&quot; }); super[_xfa_object.$pushGlyphs](measure); measure.popFont(); } } class Li extends XhtmlObject { constructor(attributes) { super(attributes, &quot;li&quot;); } } class Ol extends XhtmlObject { constructor(attributes) { super(attributes, &quot;ol&quot;); } } class P extends XhtmlObject { constructor(attributes) { super(attributes, &quot;p&quot;); } [_xfa_object.$pushGlyphs](measure) { super[_xfa_object.$pushGlyphs](measure, false); measure.addString(&quot;\\n&quot;); measure.addPara(); measure.popFont(); } [_xfa_object.$text]() { const siblings = this[_xfa_object.$getParent]()[_xfa_object.$getChildren](); if (siblings.at(-1) === this) { return super[_xfa_object.$text](); } return super[_xfa_object.$text]() + &quot;\\n&quot;; } } class Span extends XhtmlObject { constructor(attributes) { super(attributes, &quot;span&quot;); } } class Sub extends XhtmlObject { constructor(attributes) { super(attributes, &quot;sub&quot;); } } class Sup extends XhtmlObject { constructor(attributes) { super(attributes, &quot;sup&quot;); } } class Ul extends XhtmlObject { constructor(attributes) { super(attributes, &quot;ul&quot;); } } class XhtmlNamespace { static [_namespaces.$buildXFAObject](name, attributes) { if (XhtmlNamespace.hasOwnProperty(name)) { return XhtmlNamespace[name](attributes); } return undefined; } static a(attributes) { return new A(attributes); } static b(attributes) { return new B(attributes); } static body(attributes) { return new Body(attributes); } static br(attributes) { return new Br(attributes); } static html(attributes) { return new Html(attributes); } static i(attributes) { return new I(attributes); } static li(attributes) { return new Li(attributes); } static ol(attributes) { return new Ol(attributes); } static p(attributes) { return new P(attributes); } static span(attributes) { return new Span(attributes); } static sub(attributes) { return new Sub(attributes); } static sup(attributes) { return new Sup(attributes); } static ul(attributes) { return new Ul(attributes); } } exports.XhtmlNamespace = XhtmlNamespace; /***/ }), /* 97 */ /***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) =&gt; { Object.defineProperty(exports, &quot;__esModule&quot;, ({ value: true })); exports.UnknownNamespace = void 0; var _namespaces = __w_pdfjs_require__(77); var _xfa_object = __w_pdfjs_require__(75); class UnknownNamespace { constructor(nsId) { this.namespaceId = nsId; } [_namespaces.$buildXFAObject](name, attributes) { return new _xfa_object.XmlObject(this.namespaceId, name, attributes); } } exports.UnknownNamespace = UnknownNamespace; /***/ }), /* 98 */ /***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) =&gt; { Object.defineProperty(exports, &quot;__esModule&quot;, ({ value: true })); exports.DatasetReader = void 0; var _util = __w_pdfjs_require__(2); var _core_utils = __w_pdfjs_require__(4); var _xml_parser = __w_pdfjs_require__(64); function decodeString(str) { try { return (0, _util.stringToUTF8String)(str); } catch (ex) { (0, _util.warn)(`UTF-8 decoding failed: &quot;${ex}&quot;.`); return str; } } class DatasetXMLParser extends _xml_parser.SimpleXMLParser { constructor(options) { super(options); this.node = null; } onEndElement(name) { const node = super.onEndElement(name); if (node &amp;&amp; name === &quot;xfa:datasets&quot;) { this.node = node; throw new Error(&quot;Aborting DatasetXMLParser.&quot;); } } } class DatasetReader { constructor(data) { if (data.datasets) { this.node = new _xml_parser.SimpleXMLParser({ hasAttributes: true }).parseFromString(data.datasets).documentElement; } else { const parser = new DatasetXMLParser({ hasAttributes: true }); try { parser.parseFromString(data[&quot;xdp:xdp&quot;]); } catch (_) {} this.node = parser.node; } } getValue(path) { if (!this.node || !path) { return &quot;&quot;; } const node = this.node.searchNode((0, _core_utils.parseXFAPath)(path), 0); if (!node) { return &quot;&quot;; } const first = node.firstChild; if (first &amp;&amp; first.nodeName === &quot;value&quot;) { return node.children.map(child =&gt; decodeString(child.textContent)); } return decodeString(node.textContent); } } exports.DatasetReader = DatasetReader; /***/ }), /* 99 */ /***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) =&gt; { Object.defineProperty(exports, &quot;__esModule&quot;, ({ value: true })); exports.XRef = void 0; var _util = __w_pdfjs_require__(2); var _primitives = __w_pdfjs_require__(3); var _core_utils = __w_pdfjs_require__(4); var _parser = __w_pdfjs_require__(15); var _base_stream = __w_pdfjs_require__(5); var _crypto = __w_pdfjs_require__(65); class XRef { constructor(stream, pdfManager) { this.stream = stream; this.pdfManager = pdfManager; this.entries = []; this.xrefstms = Object.create(null); this._cacheMap = new Map(); this._pendingRefs = new _primitives.RefSet(); this.stats = new _core_utils.DocStats(pdfManager.msgHandler); this._newRefNum = null; } getNewRef() { if (this._newRefNum === null) { this._newRefNum = this.entries.length || 1; } return _primitives.Ref.get(this._newRefNum++, 0); } resetNewRef() { this._newRefNum = null; } setStartXRef(startXRef) { this.startXRefQueue = [startXRef]; } parse(recoveryMode = false) { let trailerDict; if (!recoveryMode) { trailerDict = this.readXRef(); } else { (0, _util.warn)(&quot;Indexing all PDF objects&quot;); trailerDict = this.indexObjects(); } trailerDict.assignXref(this); this.trailer = trailerDict; let encrypt; try { encrypt = trailerDict.get(&quot;Encrypt&quot;); } catch (ex) { if (ex instanceof _core_utils.MissingDataException) { throw ex; } (0, _util.warn)(`XRef.parse - Invalid &quot;Encrypt&quot; reference: &quot;${ex}&quot;.`); } if (encrypt instanceof _primitives.Dict) { const ids = trailerDict.get(&quot;ID&quot;); const fileId = ids &amp;&amp; ids.length ? ids[0] : &quot;&quot;; encrypt.suppressEncryption = true; this.encrypt = new _crypto.CipherTransformFactory(encrypt, fileId, this.pdfManager.password); } let root; try { root = trailerDict.get(&quot;Root&quot;); } catch (ex) { if (ex instanceof _core_utils.MissingDataException) { throw ex; } (0, _util.warn)(`XRef.parse - Invalid &quot;Root&quot; reference: &quot;${ex}&quot;.`); } if (root instanceof _primitives.Dict) { try { const pages = root.get(&quot;Pages&quot;); if (pages instanceof _primitives.Dict) { this.root = root; return; } } catch (ex) { if (ex instanceof _core_utils.MissingDataException) { throw ex; } (0, _util.warn)(`XRef.parse - Invalid &quot;Pages&quot; reference: &quot;${ex}&quot;.`); } } if (!recoveryMode) { throw new _core_utils.XRefParseException(); } throw new _util.InvalidPDFException(&quot;Invalid Root reference.&quot;); } processXRefTable(parser) { if (!(&quot;tableState&quot; in this)) { this.tableState = { entryNum: 0, streamPos: parser.lexer.stream.pos, parserBuf1: parser.buf1, parserBuf2: parser.buf2 }; } const obj = this.readXRefTable(parser); if (!(0, _primitives.isCmd)(obj, &quot;trailer&quot;)) { throw new _util.FormatError(&quot;Invalid XRef table: could not find trailer dictionary&quot;); } let dict = parser.getObj(); if (!(dict instanceof _primitives.Dict) &amp;&amp; dict.dict) { dict = dict.dict; } if (!(dict instanceof _primitives.Dict)) { throw new _util.FormatError(&quot;Invalid XRef table: could not parse trailer dictionary&quot;); } delete this.tableState; return dict; } readXRefTable(parser) { const stream = parser.lexer.stream; const tableState = this.tableState; stream.pos = tableState.streamPos; parser.buf1 = tableState.parserBuf1; parser.buf2 = tableState.parserBuf2; let obj; while (true) { if (!(&quot;firstEntryNum&quot; in tableState) || !(&quot;entryCount&quot; in tableState)) { if ((0, _primitives.isCmd)(obj = parser.getObj(), &quot;trailer&quot;)) { break; } tableState.firstEntryNum = obj; tableState.entryCount = parser.getObj(); } let first = tableState.firstEntryNum; const count = tableState.entryCount; if (!Number.isInteger(first) || !Number.isInteger(count)) { throw new _util.FormatError(&quot;Invalid XRef table: wrong types in subsection header&quot;); } for (let i = tableState.entryNum; i &lt; count; i++) { tableState.streamPos = stream.pos; tableState.entryNum = i; tableState.parserBuf1 = parser.buf1; tableState.parserBuf2 = parser.buf2; const entry = {}; entry.offset = parser.getObj(); entry.gen = parser.getObj(); const type = parser.getObj(); if (type instanceof _primitives.Cmd) { switch (type.cmd) { case &quot;f&quot;: entry.free = true; break; case &quot;n&quot;: entry.uncompressed = true; break; } } if (!Number.isInteger(entry.offset) || !Number.isInteger(entry.gen) || !(entry.free || entry.uncompressed)) { throw new _util.FormatError(`Invalid entry in XRef subsection: ${first}, ${count}`); } if (i === 0 &amp;&amp; entry.free &amp;&amp; first === 1) { first = 0; } if (!this.entries[i + first]) { this.entries[i + first] = entry; } } tableState.entryNum = 0; tableState.streamPos = stream.pos; tableState.parserBuf1 = parser.buf1; tableState.parserBuf2 = parser.buf2; delete tableState.firstEntryNum; delete tableState.entryCount; } if (this.entries[0] &amp;&amp; !this.entries[0].free) { throw new _util.FormatError(&quot;Invalid XRef table: unexpected first object&quot;); } return obj; } processXRefStream(stream) { if (!(&quot;streamState&quot; in this)) { const streamParameters = stream.dict; const byteWidths = streamParameters.get(&quot;W&quot;); let range = streamParameters.get(&quot;Index&quot;); if (!range) { range = [0, streamParameters.get(&quot;Size&quot;)]; } this.streamState = { entryRanges: range, byteWidths, entryNum: 0, streamPos: stream.pos }; } this.readXRefStream(stream); delete this.streamState; return stream.dict; } readXRefStream(stream) { const streamState = this.streamState; stream.pos = streamState.streamPos; const [typeFieldWidth, offsetFieldWidth, generationFieldWidth] = streamState.byteWidths; const entryRanges = streamState.entryRanges; while (entryRanges.length &gt; 0) { const [first, n] = entryRanges; if (!Number.isInteger(first) || !Number.isInteger(n)) { throw new _util.FormatError(`Invalid XRef range fields: ${first}, ${n}`); } if (!Number.isInteger(typeFieldWidth) || !Number.isInteger(offsetFieldWidth) || !Number.isInteger(generationFieldWidth)) { throw new _util.FormatError(`Invalid XRef entry fields length: ${first}, ${n}`); } for (let i = streamState.entryNum; i &lt; n; ++i) { streamState.entryNum = i; streamState.streamPos = stream.pos; let type = 0, offset = 0, generation = 0; for (let j = 0; j &lt; typeFieldWidth; ++j) { const typeByte = stream.getByte(); if (typeByte === -1) { throw new _util.FormatError(&quot;Invalid XRef byteWidths &apos;type&apos;.&quot;); } type = type &lt;&lt; 8 | typeByte; } if (typeFieldWidth === 0) { type = 1; } for (let j = 0; j &lt; offsetFieldWidth; ++j) { const offsetByte = stream.getByte(); if (offsetByte === -1) { throw new _util.FormatError(&quot;Invalid XRef byteWidths &apos;offset&apos;.&quot;); } offset = offset &lt;&lt; 8 | offsetByte; } for (let j = 0; j &lt; generationFieldWidth; ++j) { const generationByte = stream.getByte(); if (generationByte === -1) { throw new _util.FormatError(&quot;Invalid XRef byteWidths &apos;generation&apos;.&quot;); } generation = generation &lt;&lt; 8 | generationByte; } const entry = {}; entry.offset = offset; entry.gen = generation; switch (type) { case 0: entry.free = true; break; case 1: entry.uncompressed = true; break; case 2: break; default: throw new _util.FormatError(`Invalid XRef entry type: ${type}`); } if (!this.entries[first + i]) { this.entries[first + i] = entry; } } streamState.entryNum = 0; streamState.streamPos = stream.pos; entryRanges.splice(0, 2); } } indexObjects() { const TAB = 0x9, LF = 0xa, CR = 0xd, SPACE = 0x20; const PERCENT = 0x25, LT = 0x3c; function readToken(data, offset) { let token = &quot;&quot;, ch = data[offset]; while (ch !== LF &amp;&amp; ch !== CR &amp;&amp; ch !== LT) { if (++offset &gt;= data.length) { break; } token += String.fromCharCode(ch); ch = data[offset]; } return token; } function skipUntil(data, offset, what) { const length = what.length, dataLength = data.length; let skipped = 0; while (offset &lt; dataLength) { let i = 0; while (i &lt; length &amp;&amp; data[offset + i] === what[i]) { ++i; } if (i &gt;= length) { break; } offset++; skipped++; } return skipped; } const objRegExp = /^(\\d+)\\s+(\\d+)\\s+obj\\b/; const endobjRegExp = /\\bendobj[\\b\\s]$/; const nestedObjRegExp = /\\s+(\\d+\\s+\\d+\\s+obj[\\b\\s&lt;])$/; const CHECK_CONTENT_LENGTH = 25; const trailerBytes = new Uint8Array([116, 114, 97, 105, 108, 101, 114]); const startxrefBytes = new Uint8Array([115, 116, 97, 114, 116, 120, 114, 101, 102]); const objBytes = new Uint8Array([111, 98, 106]); const xrefBytes = new Uint8Array([47, 88, 82, 101, 102]); this.entries.length = 0; this._cacheMap.clear(); const stream = this.stream; stream.pos = 0; const buffer = stream.getBytes(), length = buffer.length; let position = stream.start; const trailers = [], xrefStms = []; while (position &lt; length) { let ch = buffer[position]; if (ch === TAB || ch === LF || ch === CR || ch === SPACE) { ++position; continue; } if (ch === PERCENT) { do { ++position; if (position &gt;= length) { break; } ch = buffer[position]; } while (ch !== LF &amp;&amp; ch !== CR); continue; } const token = readToken(buffer, position); let m; if (token.startsWith(&quot;xref&quot;) &amp;&amp; (token.length === 4 || /\\s/.test(token[4]))) { position += skipUntil(buffer, position, trailerBytes); trailers.push(position); position += skipUntil(buffer, position, startxrefBytes); } else if (m = objRegExp.exec(token)) { const num = m[1] | 0, gen = m[2] | 0; let contentLength, startPos = position + token.length, updateEntries = false; if (!this.entries[num]) { updateEntries = true; } else if (this.entries[num].gen === gen) { try { const parser = new _parser.Parser({ lexer: new _parser.Lexer(stream.makeSubStream(startPos)) }); parser.getObj(); updateEntries = true; } catch (ex) { if (ex instanceof _core_utils.ParserEOFException) { (0, _util.warn)(`indexObjects -- checking object (${token}): &quot;${ex}&quot;.`); } else { updateEntries = true; } } } if (updateEntries) { this.entries[num] = { offset: position - stream.start, gen, uncompressed: true }; } while (startPos &lt; buffer.length) { const endPos = startPos + skipUntil(buffer, startPos, objBytes) + 4; contentLength = endPos - position; const checkPos = Math.max(endPos - CHECK_CONTENT_LENGTH, startPos); const tokenStr = (0, _util.bytesToString)(buffer.subarray(checkPos, endPos)); if (endobjRegExp.test(tokenStr)) { break; } else { const objToken = nestedObjRegExp.exec(tokenStr); if (objToken &amp;&amp; objToken[1]) { (0, _util.warn)(&apos;indexObjects: Found new &quot;obj&quot; inside of another &quot;obj&quot;, &apos; + &apos;caused by missing &quot;endobj&quot; -- trying to recover.&apos;); contentLength -= objToken[1].length; break; } } startPos = endPos; } const content = buffer.subarray(position, position + contentLength); const xrefTagOffset = skipUntil(content, 0, xrefBytes); if (xrefTagOffset &lt; contentLength &amp;&amp; content[xrefTagOffset + 5] &lt; 64) { xrefStms.push(position - stream.start); this.xrefstms[position - stream.start] = 1; } position += contentLength; } else if (token.startsWith(&quot;trailer&quot;) &amp;&amp; (token.length === 7 || /\\s/.test(token[7]))) { trailers.push(position); position += skipUntil(buffer, position, startxrefBytes); } else { position += token.length + 1; } } for (const xrefStm of xrefStms) { this.startXRefQueue.push(xrefStm); this.readXRef(true); } let trailerDict, trailerError; for (const trailer of [...trailers, &quot;generationFallback&quot;, ...trailers]) { if (trailer === &quot;generationFallback&quot;) { if (!trailerError) { break; } this._generationFallback = true; continue; } stream.pos = trailer; const parser = new _parser.Parser({ lexer: new _parser.Lexer(stream), xref: this, allowStreams: true, recoveryMode: true }); const obj = parser.getObj(); if (!(0, _primitives.isCmd)(obj, &quot;trailer&quot;)) { continue; } const dict = parser.getObj(); if (!(dict instanceof _primitives.Dict)) { continue; } let validPagesDict = false; try { const rootDict = dict.get(&quot;Root&quot;); if (!(rootDict instanceof _primitives.Dict)) { continue; } const pagesDict = rootDict.get(&quot;Pages&quot;); if (!(pagesDict instanceof _primitives.Dict)) { continue; } const pagesCount = pagesDict.get(&quot;Count&quot;); if (Number.isInteger(pagesCount)) { validPagesDict = true; } } catch (ex) { trailerError = ex; continue; } if (validPagesDict &amp;&amp; dict.has(&quot;ID&quot;)) { return dict; } trailerDict = dict; } if (trailerDict) { return trailerDict; } if (this.topDict) { return this.topDict; } throw new _util.InvalidPDFException(&quot;Invalid PDF structure.&quot;); } readXRef(recoveryMode = false) { const stream = this.stream; const startXRefParsedCache = new Set(); try { while (this.startXRefQueue.length) { const startXRef = this.startXRefQueue[0]; if (startXRefParsedCache.has(startXRef)) { (0, _util.warn)(&quot;readXRef - skipping XRef table since it was already parsed.&quot;); this.startXRefQueue.shift(); continue; } startXRefParsedCache.add(startXRef); stream.pos = startXRef + stream.start; const parser = new _parser.Parser({ lexer: new _parser.Lexer(stream), xref: this, allowStreams: true }); let obj = parser.getObj(); let dict; if ((0, _primitives.isCmd)(obj, &quot;xref&quot;)) { dict = this.processXRefTable(parser); if (!this.topDict) { this.topDict = dict; } obj = dict.get(&quot;XRefStm&quot;); if (Number.isInteger(obj)) { const pos = obj; if (!(pos in this.xrefstms)) { this.xrefstms[pos] = 1; this.startXRefQueue.push(pos); } } } else if (Number.isInteger(obj)) { if (!Number.isInteger(parser.getObj()) || !(0, _primitives.isCmd)(parser.getObj(), &quot;obj&quot;) || !((obj = parser.getObj()) instanceof _base_stream.BaseStream)) { throw new _util.FormatError(&quot;Invalid XRef stream&quot;); } dict = this.processXRefStream(obj); if (!this.topDict) { this.topDict = dict; } if (!dict) { throw new _util.FormatError(&quot;Failed to read XRef stream&quot;); } } else { throw new _util.FormatError(&quot;Invalid XRef stream header&quot;); } obj = dict.get(&quot;Prev&quot;); if (Number.isInteger(obj)) { this.startXRefQueue.push(obj); } else if (obj instanceof _primitives.Ref) { this.startXRefQueue.push(obj.num); } this.startXRefQueue.shift(); } return this.topDict; } catch (e) { if (e instanceof _core_utils.MissingDataException) { throw e; } (0, _util.info)(&quot;(while reading XRef): &quot; + e); this.startXRefQueue.shift(); } if (recoveryMode) { return undefined; } throw new _core_utils.XRefParseException(); } getEntry(i) { const xrefEntry = this.entries[i]; if (xrefEntry &amp;&amp; !xrefEntry.free &amp;&amp; xrefEntry.offset) { return xrefEntry; } return null; } fetchIfRef(obj, suppressEncryption = false) { if (obj instanceof _primitives.Ref) { return this.fetch(obj, suppressEncryption); } return obj; } fetch(ref, suppressEncryption = false) { if (!(ref instanceof _primitives.Ref)) { throw new Error(&quot;ref object is not a reference&quot;); } const num = ref.num; const cacheEntry = this._cacheMap.get(num); if (cacheEntry !== undefined) { if (cacheEntry instanceof _primitives.Dict &amp;&amp; !cacheEntry.objId) { cacheEntry.objId = ref.toString(); } return cacheEntry; } let xrefEntry = this.getEntry(num); if (xrefEntry === null) { this._cacheMap.set(num, xrefEntry); return xrefEntry; } if (this._pendingRefs.has(ref)) { this._pendingRefs.remove(ref); (0, _util.warn)(`Ignoring circular reference: ${ref}.`); return _primitives.CIRCULAR_REF; } this._pendingRefs.put(ref); try { if (xrefEntry.uncompressed) { xrefEntry = this.fetchUncompressed(ref, xrefEntry, suppressEncryption); } else { xrefEntry = this.fetchCompressed(ref, xrefEntry, suppressEncryption); } this._pendingRefs.remove(ref); } catch (ex) { this._pendingRefs.remove(ref); throw ex; } if (xrefEntry instanceof _primitives.Dict) { xrefEntry.objId = ref.toString(); } else if (xrefEntry instanceof _base_stream.BaseStream) { xrefEntry.dict.objId = ref.toString(); } return xrefEntry; } fetchUncompressed(ref, xrefEntry, suppressEncryption = false) { const gen = ref.gen; let num = ref.num; if (xrefEntry.gen !== gen) { const msg = `Inconsistent generation in XRef: ${ref}`; if (this._generationFallback &amp;&amp; xrefEntry.gen &lt; gen) { (0, _util.warn)(msg); return this.fetchUncompressed(_primitives.Ref.get(num, xrefEntry.gen), xrefEntry, suppressEncryption); } throw new _core_utils.XRefEntryException(msg); } const stream = this.stream.makeSubStream(xrefEntry.offset + this.stream.start); const parser = new _parser.Parser({ lexer: new _parser.Lexer(stream), xref: this, allowStreams: true }); const obj1 = parser.getObj(); const obj2 = parser.getObj(); const obj3 = parser.getObj(); if (obj1 !== num || obj2 !== gen || !(obj3 instanceof _primitives.Cmd)) { throw new _core_utils.XRefEntryException(`Bad (uncompressed) XRef entry: ${ref}`); } if (obj3.cmd !== &quot;obj&quot;) { if (obj3.cmd.startsWith(&quot;obj&quot;)) { num = parseInt(obj3.cmd.substring(3), 10); if (!Number.isNaN(num)) { return num; } } throw new _core_utils.XRefEntryException(`Bad (uncompressed) XRef entry: ${ref}`); } if (this.encrypt &amp;&amp; !suppressEncryption) { xrefEntry = parser.getObj(this.encrypt.createCipherTransform(num, gen)); } else { xrefEntry = parser.getObj(); } if (!(xrefEntry instanceof _base_stream.BaseStream)) { this._cacheMap.set(num, xrefEntry); } return xrefEntry; } fetchCompressed(ref, xrefEntry, suppressEncryption = false) { const tableOffset = xrefEntry.offset; const stream = this.fetch(_primitives.Ref.get(tableOffset, 0)); if (!(stream instanceof _base_stream.BaseStream)) { throw new _util.FormatError(&quot;bad ObjStm stream&quot;); } const first = stream.dict.get(&quot;First&quot;); const n = stream.dict.get(&quot;N&quot;); if (!Number.isInteger(first) || !Number.isInteger(n)) { throw new _util.FormatError(&quot;invalid first and n parameters for ObjStm stream&quot;); } let parser = new _parser.Parser({ lexer: new _parser.Lexer(stream), xref: this, allowStreams: true }); const nums = new Array(n); const offsets = new Array(n); for (let i = 0; i &lt; n; ++i) { const num = parser.getObj(); if (!Number.isInteger(num)) { throw new _util.FormatError(`invalid object number in the ObjStm stream: ${num}`); } const offset = parser.getObj(); if (!Number.isInteger(offset)) { throw new _util.FormatError(`invalid object offset in the ObjStm stream: ${offset}`); } nums[i] = num; offsets[i] = offset; } const start = (stream.start || 0) + first; const entries = new Array(n); for (let i = 0; i &lt; n; ++i) { const length = i &lt; n - 1 ? offsets[i + 1] - offsets[i] : undefined; if (length &lt; 0) { throw new _util.FormatError(&quot;Invalid offset in the ObjStm stream.&quot;); } parser = new _parser.Parser({ lexer: new _parser.Lexer(stream.makeSubStream(start + offsets[i], length, stream.dict)), xref: this, allowStreams: true }); const obj = parser.getObj(); entries[i] = obj; if (obj instanceof _base_stream.BaseStream) { continue; } const num = nums[i], entry = this.entries[num]; if (entry &amp;&amp; entry.offset === tableOffset &amp;&amp; entry.gen === i) { this._cacheMap.set(num, obj); } } xrefEntry = entries[xrefEntry.gen]; if (xrefEntry === undefined) { throw new _core_utils.XRefEntryException(`Bad (compressed) XRef entry: ${ref}`); } return xrefEntry; } async fetchIfRefAsync(obj, suppressEncryption) { if (obj instanceof _primitives.Ref) { return this.fetchAsync(obj, suppressEncryption); } return obj; } async fetchAsync(ref, suppressEncryption) { try { return this.fetch(ref, suppressEncryption); } catch (ex) { if (!(ex instanceof _core_utils.MissingDataException)) { throw ex; } await this.pdfManager.requestRange(ex.begin, ex.end); return this.fetchAsync(ref, suppressEncryption); } } getCatalogObj() { return this.root; } } exports.XRef = XRef; /***/ }), /* 100 */ /***/ ((__unused_webpack_module, exports) =&gt; { Object.defineProperty(exports, &quot;__esModule&quot;, ({ value: true })); exports.isNodeJS = void 0; const isNodeJS = typeof process === &quot;object&quot; &amp;&amp; process + &quot;&quot; === &quot;[object process]&quot; &amp;&amp; !process.versions.nw &amp;&amp; !(process.versions.electron &amp;&amp; process.type &amp;&amp; process.type !== &quot;browser&quot;); exports.isNodeJS = isNodeJS; /***/ }), /* 101 */ /***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) =&gt; { Object.defineProperty(exports, &quot;__esModule&quot;, ({ value: true })); exports.MessageHandler = void 0; var _util = __w_pdfjs_require__(2); const CallbackKind = { UNKNOWN: 0, DATA: 1, ERROR: 2 }; const StreamKind = { UNKNOWN: 0, CANCEL: 1, CANCEL_COMPLETE: 2, CLOSE: 3, ENQUEUE: 4, ERROR: 5, PULL: 6, PULL_COMPLETE: 7, START_COMPLETE: 8 }; function wrapReason(reason) { if (!(reason instanceof Error || typeof reason === &quot;object&quot; &amp;&amp; reason !== null)) { (0, _util.unreachable)(&apos;wrapReason: Expected &quot;reason&quot; to be a (possibly cloned) Error.&apos;); } switch (reason.name) { case &quot;AbortException&quot;: return new _util.AbortException(reason.message); case &quot;MissingPDFException&quot;: return new _util.MissingPDFException(reason.message); case &quot;PasswordException&quot;: return new _util.PasswordException(reason.message, reason.code); case &quot;UnexpectedResponseException&quot;: return new _util.UnexpectedResponseException(reason.message, reason.status); case &quot;UnknownErrorException&quot;: return new _util.UnknownErrorException(reason.message, reason.details); default: return new _util.UnknownErrorException(reason.message, reason.toString()); } } class MessageHandler { constructor(sourceName, targetName, comObj) { this.sourceName = sourceName; this.targetName = targetName; this.comObj = comObj; this.callbackId = 1; this.streamId = 1; this.streamSinks = Object.create(null); this.streamControllers = Object.create(null); this.callbackCapabilities = Object.create(null); this.actionHandler = Object.create(null); this._onComObjOnMessage = event =&gt; { const data = event.data; if (data.targetName !== this.sourceName) { return; } if (data.stream) { this._processStreamMessage(data); return; } if (data.callback) { const callbackId = data.callbackId; const capability = this.callbackCapabilities[callbackId]; if (!capability) { throw new Error(`Cannot resolve callback ${callbackId}`); } delete this.callbackCapabilities[callbackId]; if (data.callback === CallbackKind.DATA) { capability.resolve(data.data); } else if (data.callback === CallbackKind.ERROR) { capability.reject(wrapReason(data.reason)); } else { throw new Error(&quot;Unexpected callback case&quot;); } return; } const action = this.actionHandler[data.action]; if (!action) { throw new Error(`Unknown action from worker: ${data.action}`); } if (data.callbackId) { const cbSourceName = this.sourceName; const cbTargetName = data.sourceName; new Promise(function (resolve) { resolve(action(data.data)); }).then(function (result) { comObj.postMessage({ sourceName: cbSourceName, targetName: cbTargetName, callback: CallbackKind.DATA, callbackId: data.callbackId, data: result }); }, function (reason) { comObj.postMessage({ sourceName: cbSourceName, targetName: cbTargetName, callback: CallbackKind.ERROR, callbackId: data.callbackId, reason: wrapReason(reason) }); }); return; } if (data.streamId) { this._createStreamSink(data); return; } action(data.data); }; comObj.addEventListener(&quot;message&quot;, this._onComObjOnMessage); } on(actionName, handler) { const ah = this.actionHandler; if (ah[actionName]) { throw new Error(`There is already an actionName called &quot;${actionName}&quot;`); } ah[actionName] = handler; } send(actionName, data, transfers) { this.comObj.postMessage({ sourceName: this.sourceName, targetName: this.targetName, action: actionName, data }, transfers); } sendWithPromise(actionName, data, transfers) { const callbackId = this.callbackId++; const capability = (0, _util.createPromiseCapability)(); this.callbackCapabilities[callbackId] = capability; try { this.comObj.postMessage({ sourceName: this.sourceName, targetName: this.targetName, action: actionName, callbackId, data }, transfers); } catch (ex) { capability.reject(ex); } return capability.promise; } sendWithStream(actionName, data, queueingStrategy, transfers) { const streamId = this.streamId++, sourceName = this.sourceName, targetName = this.targetName, comObj = this.comObj; return new ReadableStream({ start: controller =&gt; { const startCapability = (0, _util.createPromiseCapability)(); this.streamControllers[streamId] = { controller, startCall: startCapability, pullCall: null, cancelCall: null, isClosed: false }; comObj.postMessage({ sourceName, targetName, action: actionName, streamId, data, desiredSize: controller.desiredSize }, transfers); return startCapability.promise; }, pull: controller =&gt; { const pullCapability = (0, _util.createPromiseCapability)(); this.streamControllers[streamId].pullCall = pullCapability; comObj.postMessage({ sourceName, targetName, stream: StreamKind.PULL, streamId, desiredSize: controller.desiredSize }); return pullCapability.promise; }, cancel: reason =&gt; { (0, _util.assert)(reason instanceof Error, &quot;cancel must have a valid reason&quot;); const cancelCapability = (0, _util.createPromiseCapability)(); this.streamControllers[streamId].cancelCall = cancelCapability; this.streamControllers[streamId].isClosed = true; comObj.postMessage({ sourceName, targetName, stream: StreamKind.CANCEL, streamId, reason: wrapReason(reason) }); return cancelCapability.promise; } }, queueingStrategy); } _createStreamSink(data) { const streamId = data.streamId, sourceName = this.sourceName, targetName = data.sourceName, comObj = this.comObj; const self = this, action = this.actionHandler[data.action]; const streamSink = { enqueue(chunk, size = 1, transfers) { if (this.isCancelled) { return; } const lastDesiredSize = this.desiredSize; this.desiredSize -= size; if (lastDesiredSize &gt; 0 &amp;&amp; this.desiredSize &lt;= 0) { this.sinkCapability = (0, _util.createPromiseCapability)(); this.ready = this.sinkCapability.promise; } comObj.postMessage({ sourceName, targetName, stream: StreamKind.ENQUEUE, streamId, chunk }, transfers); }, close() { if (this.isCancelled) { return; } this.isCancelled = true; comObj.postMessage({ sourceName, targetName, stream: StreamKind.CLOSE, streamId }); delete self.streamSinks[streamId]; }, error(reason) { (0, _util.assert)(reason instanceof Error, &quot;error must have a valid reason&quot;); if (this.isCancelled) { return; } this.isCancelled = true; comObj.postMessage({ sourceName, targetName, stream: StreamKind.ERROR, streamId, reason: wrapReason(reason) }); }, sinkCapability: (0, _util.createPromiseCapability)(), onPull: null, onCancel: null, isCancelled: false, desiredSize: data.desiredSize, ready: null }; streamSink.sinkCapability.resolve(); streamSink.ready = streamSink.sinkCapability.promise; this.streamSinks[streamId] = streamSink; new Promise(function (resolve) { resolve(action(data.data, streamSink)); }).then(function () { comObj.postMessage({ sourceName, targetName, stream: StreamKind.START_COMPLETE, streamId, success: true }); }, function (reason) { comObj.postMessage({ sourceName, targetName, stream: StreamKind.START_COMPLETE, streamId, reason: wrapReason(reason) }); }); } _processStreamMessage(data) { const streamId = data.streamId, sourceName = this.sourceName, targetName = data.sourceName, comObj = this.comObj; const streamController = this.streamControllers[streamId], streamSink = this.streamSinks[streamId]; switch (data.stream) { case StreamKind.START_COMPLETE: if (data.success) { streamController.startCall.resolve(); } else { streamController.startCall.reject(wrapReason(data.reason)); } break; case StreamKind.PULL_COMPLETE: if (data.success) { streamController.pullCall.resolve(); } else { streamController.pullCall.reject(wrapReason(data.reason)); } break; case StreamKind.PULL: if (!streamSink) { comObj.postMessage({ sourceName, targetName, stream: StreamKind.PULL_COMPLETE, streamId, success: true }); break; } if (streamSink.desiredSize &lt;= 0 &amp;&amp; data.desiredSize &gt; 0) { streamSink.sinkCapability.resolve(); } streamSink.desiredSize = data.desiredSize; new Promise(function (resolve) { resolve(streamSink.onPull &amp;&amp; streamSink.onPull()); }).then(function () { comObj.postMessage({ sourceName, targetName, stream: StreamKind.PULL_COMPLETE, streamId, success: true }); }, function (reason) { comObj.postMessage({ sourceName, targetName, stream: StreamKind.PULL_COMPLETE, streamId, reason: wrapReason(reason) }); }); break; case StreamKind.ENQUEUE: (0, _util.assert)(streamController, &quot;enqueue should have stream controller&quot;); if (streamController.isClosed) { break; } streamController.controller.enqueue(data.chunk); break; case StreamKind.CLOSE: (0, _util.assert)(streamController, &quot;close should have stream controller&quot;); if (streamController.isClosed) { break; } streamController.isClosed = true; streamController.controller.close(); this._deleteStreamController(streamController, streamId); break; case StreamKind.ERROR: (0, _util.assert)(streamController, &quot;error should have stream controller&quot;); streamController.controller.error(wrapReason(data.reason)); this._deleteStreamController(streamController, streamId); break; case StreamKind.CANCEL_COMPLETE: if (data.success) { streamController.cancelCall.resolve(); } else { streamController.cancelCall.reject(wrapReason(data.reason)); } this._deleteStreamController(streamController, streamId); break; case StreamKind.CANCEL: if (!streamSink) { break; } new Promise(function (resolve) { resolve(streamSink.onCancel &amp;&amp; streamSink.onCancel(wrapReason(data.reason))); }).then(function () { comObj.postMessage({ sourceName, targetName, stream: StreamKind.CANCEL_COMPLETE, streamId, success: true }); }, function (reason) { comObj.postMessage({ sourceName, targetName, stream: StreamKind.CANCEL_COMPLETE, streamId, reason: wrapReason(reason) }); }); streamSink.sinkCapability.reject(wrapReason(data.reason)); streamSink.isCancelled = true; delete this.streamSinks[streamId]; break; default: throw new Error(&quot;Unexpected stream case&quot;); } } async _deleteStreamController(streamController, streamId) { await Promise.allSettled([streamController.startCall &amp;&amp; streamController.startCall.promise, streamController.pullCall &amp;&amp; streamController.pullCall.promise, streamController.cancelCall &amp;&amp; streamController.cancelCall.promise]); delete this.streamControllers[streamId]; } destroy() { this.comObj.removeEventListener(&quot;message&quot;, this._onComObjOnMessage); } } exports.MessageHandler = MessageHandler; /***/ }), /* 102 */ /***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) =&gt; { Object.defineProperty(exports, &quot;__esModule&quot;, ({ value: true })); exports.PDFWorkerStream = void 0; var _util = __w_pdfjs_require__(2); class PDFWorkerStream { constructor(msgHandler) { this._msgHandler = msgHandler; this._contentLength = null; this._fullRequestReader = null; this._rangeRequestReaders = []; } getFullReader() { (0, _util.assert)(!this._fullRequestReader, &quot;PDFWorkerStream.getFullReader can only be called once.&quot;); this._fullRequestReader = new PDFWorkerStreamReader(this._msgHandler); return this._fullRequestReader; } getRangeReader(begin, end) { const reader = new PDFWorkerStreamRangeReader(begin, end, this._msgHandler); this._rangeRequestReaders.push(reader); return reader; } cancelAllRequests(reason) { if (this._fullRequestReader) { this._fullRequestReader.cancel(reason); } for (const reader of this._rangeRequestReaders.slice(0)) { reader.cancel(reason); } } } exports.PDFWorkerStream = PDFWorkerStream; class PDFWorkerStreamReader { constructor(msgHandler) { this._msgHandler = msgHandler; this.onProgress = null; this._contentLength = null; this._isRangeSupported = false; this._isStreamingSupported = false; const readableStream = this._msgHandler.sendWithStream(&quot;GetReader&quot;); this._reader = readableStream.getReader(); this._headersReady = this._msgHandler.sendWithPromise(&quot;ReaderHeadersReady&quot;).then(data =&gt; { this._isStreamingSupported = data.isStreamingSupported; this._isRangeSupported = data.isRangeSupported; this._contentLength = data.contentLength; }); } get headersReady() { return this._headersReady; } get contentLength() { return this._contentLength; } get isStreamingSupported() { return this._isStreamingSupported; } get isRangeSupported() { return this._isRangeSupported; } async read() { const { value, done } = await this._reader.read(); if (done) { return { value: undefined, done: true }; } return { value: value.buffer, done: false }; } cancel(reason) { this._reader.cancel(reason); } } class PDFWorkerStreamRangeReader { constructor(begin, end, msgHandler) { this._msgHandler = msgHandler; this.onProgress = null; const readableStream = this._msgHandler.sendWithStream(&quot;GetRangeReader&quot;, { begin, end }); this._reader = readableStream.getReader(); } get isStreamingSupported() { return false; } async read() { const { value, done } = await this._reader.read(); if (done) { return { value: undefined, done: true }; } return { value: value.buffer, done: false }; } cancel(reason) { this._reader.cancel(reason); } } /***/ }) /******/ ]); /************************************************************************/ /******/ // The module cache /******/ var __webpack_module_cache__ = {}; /******/ /******/ // The require function /******/ function __w_pdfjs_require__(moduleId) { /******/ // Check if module is in cache /******/ var cachedModule = __webpack_module_cache__[moduleId]; /******/ if (cachedModule !== undefined) { /******/ return cachedModule.exports; /******/ } /******/ // Create a new module (and put it into the cache) /******/ var module = __webpack_module_cache__[moduleId] = { /******/ // no module.id needed /******/ // no module.loaded needed /******/ exports: {} /******/ }; /******/ /******/ // Execute the module function /******/ __webpack_modules__[moduleId](module, module.exports, __w_pdfjs_require__); /******/ /******/ // Return the exports of the module /******/ return module.exports; /******/ } /******/ /************************************************************************/ /******/ /* webpack/runtime/define property getters */ /******/ (() =&gt; { /******/ // define getter functions for harmony exports /******/ __w_pdfjs_require__.d = (exports, definition) =&gt; { /******/ for(var key in definition) { /******/ if(__w_pdfjs_require__.o(definition, key) &amp;&amp; !__w_pdfjs_require__.o(exports, key)) { /******/ Object.defineProperty(exports, key, { enumerable: true, get: definition[key] }); /******/ } /******/ } /******/ }; /******/ })(); /******/ /******/ /* webpack/runtime/hasOwnProperty shorthand */ /******/ (() =&gt; { /******/ __w_pdfjs_require__.o = (obj, prop) =&gt; (Object.prototype.hasOwnProperty.call(obj, prop)) /******/ })(); /******/ /******/ /* webpack/runtime/make namespace object */ /******/ (() =&gt; { /******/ // define __esModule on exports /******/ __w_pdfjs_require__.r = (exports) =&gt; { /******/ if(typeof Symbol !== &apos;undefined&apos; &amp;&amp; Symbol.toStringTag) { /******/ Object.defineProperty(exports, Symbol.toStringTag, { value: &apos;Module&apos; }); /******/ } /******/ Object.defineProperty(exports, &apos;__esModule&apos;, { value: true }); /******/ }; /******/ })(); /******/ /************************************************************************/ var __webpack_exports__ = {}; // This entry need to be wrapped in an IIFE because it need to be isolated against other modules in the chunk. (() =&gt; { var exports = __webpack_exports__; Object.defineProperty(exports, &quot;__esModule&quot;, ({ value: true })); Object.defineProperty(exports, &quot;WorkerMessageHandler&quot;, ({ enumerable: true, get: function () { return _worker.WorkerMessageHandler; } })); var _worker = __w_pdfjs_require__(1); const pdfjsVersion = &apos;3.0.0&apos;; const pdfjsBuild = &apos;987062c&apos;; })(); /******/ return __webpack_exports__; /******/ })() ; }); //# sourceMappingURL=pdf.worker.js.map","link":"/lib/pdf/build/pdf.worker.js"}],"posts":[{"title":"2022.12 Summary","text":"This month was supposed to be the month of exams, so I dedicated my time to reviewing the three main lessons in school: Digital Signal Processing, Digital Image Analysis and Combinatorics. I made some notes (all in Chinese). 复习笔记 DSP笔记 on Notion or on GitHub (有一些不太好的MATLAB代码) DIA笔记 on Google Drive (更新中…) 组合数学笔记 on Google Drive (更新中…) Another thing worth mentioning is that this month ChatGPT went viral! I also tried it. It’s amazing I have to say. Here are some interesting or useful links I saw about ChatGPT. Awesome ChatGPT Official Introduction awesome-chatgpt There are many trending repos related to ChatGPT recently. 中国大陆可用的ChatGPT 中国区注册OpenAI账号试用ChatGPT指南 在线接受短信的虚拟号码 ChatGPT初体验：感觉到AI的未来真的已经来了 上线3天，下载4万，ChatGPT中文版VSCode插件来了 这篇罕见的符号编程论文，让你在Jupyter Notebook中手绘草图并变成代码 Other Awesome Links Telegram指南 oi-wiki.org 编程竞赛相关知识wiki。 ctf-wiki.org 网络安全竞赛wiki。 summerschoolsineurope.eu Information about summerschool in Europe. fernwanderweg.blogspot.com He used Google blogger to bulid a blog. Looks good. Digital Logic Online Learning Site: HDLbit, and solutions to learn Verilog. OSS Insight Real-time trends and statistics for github. FreeCodeCamp You can get some certificates after learning? I love it~ Developer Roadmaps Role-based programmer growth guide. Statistics Visualization Learning Site Learn statistics in a visual way. That’s very clear and easy to understand! The above three are several top repositories with the great number of stars on GitHub. I was surprised to find that 996.icu was in top 3 . Languages Unfortunately I didn’t take the IELTS . I wasn’t ready… I’ll do it later! As for learning Japanese, I dont’t use Duolinguo anymore since it’s a bit simple. I found some YouTube videos to watch and learn, like 出口日語. Blog I changed the theme of my blog from Cactus to Ascent. By the way, here’s my stars list about blog themes. I tried to edit a theme to fit my purpose but failed. Frontend is so difficult!","link":"/2023/01/01/2022-12-Summary/"},{"title":"Adaptive Filters","text":"I watched a well-organized and concise youtube video titled Adaptive Filters, which is also a basic course I am taking this semester. I focused on the key points in my course and made a bit of notes. Limitations of fixed-coefficient digital filters Fixed-coefficient digital filters FIR, IIR LP, HP, etc Limitations Time-varying noise-frequency Overlapping bands of signal and noise Adaptive filters 2 main components Digital filter (with adjustable coefficients) Adaptive algorithm 2 input signals: $y_k$ and $x_k$ $y_k = s_k + n_k$ $s_k$ = desired signal $n_k$ = noise $x_k$ = contaminating signal which is correlated with $n_k$, gives an estimate of $n_k$, i.e. $\\hat{n_k}$ Goal: produce optimum $\\hat{n_k}$ $e_k = \\hat{s_k} = y_k - \\hat{n_k} = s_k + n_k - \\hat{n_k}$ Theorem: minimize $e_k$, maximize the signal-to-noise ratio LMS algorithm Wiener filter An input signal w(n) is convolved w ith the Wiener filter g(n) and the result is compared to a reference signal s(n) to obtain the filtering error e(n) Criterion: MMSE (Minimum Mean Square Error) Minimize $J = E[e(n)^2] = E[(x(n) - s(n))^2] = E[(w(n) * g(n) - s(n))^2]$ J can be used to draw the Error-Performance surface The Least mean squares filter converges to the Wiener filter Wiener-Hopf solution Set gradient of J of H to zero, deduced that $H_{opt} = R_{xx}^{-1} R_{xs}$ where $R_{xx} = E(X_k X_k^T)$ $R_{xs} = E(y_k X_k)$ Requires knowledge of $R_{xx}, R_{xs}$ Matrix inversion is expensive For non-stationary, $H_{opt}$ needs to be computed repeatedly LMS adaptive algorithm Version 1: $H(n+1) = H(n) + \\mu (- \\nabla(n))$ Version 2: $H(n+1) = H(n) + \\frac{1}{2}\\delta (- \\nabla(n))$ then $H(n+1) = H(n) + 2\\mu e(n)X(n)$ or $H(n+1) = H(n) + \\delta e(n)X(n)$ where $e(n) = y(n) - H^T(n)X(n)$ $\\mu$ and $\\delta$ are step-sizes Based on the steepest descent algorithm (update H(n) along the opposite direction of the gradient): $H(n+1) = H(n) + \\mu (- \\nabla(n))$ Using instantaneous estimates instead of the means (unbiased): $J = E[e(n)^2] = e(n)^2$ $\\nabla(n) = -2\\mu E[e(n)X(n)] = -2\\mu e(n)X(n)$ Step-size determines stablility and rate of convergence If too large, too much fluctuation If too small, convergences too slow Limitations If the noise is non-stationary, the error-performance surface will change rapidly If $x(n)$ is proportional to $y(n)$, signal will be obliterated H(n) never reached the theoretical optimum (fluctuation) Applications Acoustic echo cancellation Cancelling EOG from contaminated EEG and get correct EEG Cancelling maternal ECG and get foetal ECG during labour","link":"/2022/11/19/Adaptive-Filters/"},{"title":"Basic MATLAB","text":"General concepts Clear commands clc clears the screen clear myVar deletes variable myVar clear all deletes all variables Create variables Creating a scalar: myScalar = 10 Creating a vector: Row vector: myVector = [4 5 6] Column vector: myVectorCol = [7; 8; 9] Creating a matrix: myMatrix = [4 5 6; 7 8 9; 1 2 3] myMatrix(1, 2) gets 5 myMatrix(2, :) gets all columns which are in row 2 myMatrix(3, 2:3) gets row 3, column 2 and 3 Using “;” at the end of command line means it will suppress (i.e. don’t show) the result Variable classes double (default) format long changes double class to long class double, long, short, single, logical (boolean), etc Cell arrays A matrix which has different kinds of elements myCell = {[1 2 3] [4 5 6 7]; &apos;v1&apos; &apos;v2&apos;} myCell{1, 2} gets [4 5 6 7] Core syntax Script “.m” file Comment: % disp(): display something randi(): random integers To tanspose a matrix: matrix&apos; Matrices Create some standard matrices: zeros(m, n) ones(m, n) randi(m, n) Matrix multiplication Standard multiplication: M1 * M2 Element by element multiplication: M1 .* M2 Division is alike Element by element division: M1 ./ M2 If statements 1234567if ... ...elseif ... ...else ...end Switch statements 12345678switch ... case ... ... case ... ... otherwise ...end For loops 1234567891011% step = 1for i = 1: 10 ...end% step = 2% for i = 1: 2: 10% n =25;% step = 5;% for i = 0: step: n While loops 123while ... ...end Programming Set path If MATLAB can’t find your scripts or functions or anything else, make sure you have added the path Function Create a function from “Current Folder”, and it’s a .m file Edit the pattern and wirte your function Import data To import a CSV file: Copy and paste it to “Current Folder” csvread(&apos;sine.csv&apos;) Debugging Set breakpoints at little dashes in the left of Editor Performance Preallocate some memory can speed large calculations Use “tik … tok” to count the time Data representations Plot 123figure% figure(1)plot(x, y) Add a grid: grid on Make the window fits perfectly to the plot: axis tight Set limits to axis: ylim([-1 1]) Change the color: plot(x, y, &apos;m&apos;) % magenta Change the marker: plot(x, y, &apos;o&apos;) % circle, magenta Plot curves multiple times with different lines: hold on. To end it, use hold off Add annotations: xlabel(), title(), legend() Use close all to close all figures Image Use imread() to import the image file Use image() to plot the image (default square) Use imshow() to plot the image in the correct aspect ratio, and there’s no label on the axis 3D plot 12345678x = -2*pi:.5:2*pi;[X, Y] = meshgrid(x);Z = sine(X) + cos(Y);figuresurf(X, Y ,Z)colorbar Simulink A block diagram tool that can be used to build systems and feedback loops, generate code for hardware like FPGAs, etc","link":"/2022/11/20/Basic-MATLAB/"},{"title":"Git学习笔记","text":"看了廖雪峰的Git教程，做了点笔记。 简介 Git是用C语言开发的 集中式&amp;分布式版本控制系统 集中式：版本库集中存放在中央服务器；最大的毛病就是必须联网才能工作 分布式：没有“中央服务器”，每个人的电脑上都是一个完整的版本库，不需要联网；安全性要高很多；通常也有一台充当“中央服务器”的电脑，但这个服务器的作用仅仅是用来方便“交换”大家的修改；极其强大的分支管理 创建版本库 版本库：又名仓库，英文名repository，可以简单理解成一个目录，这个目录里面的所有文件都可以被Git管理起来，每个文件的修改、删除，Git都能跟踪，以便任何时刻都可以追踪历史，或者在将来某个时刻可以“还原” 创建版本库 step1：创建一个空目录 step2：初始化，git init 把一个文件放到Git仓库 git add git commit 时光机穿梭 git status查看工作区状态 git diff查看修改内容 版本回退 git reset --hard commit_id版本回退 git reset --hard HEAD^ 在Git中，用HEAD表示当前版本，上一个版本就是HEAD^，上上一个版本就是HEAD^^，往上100个写成HEAD~100 git reset --hard 1094a 版本号（commit id）没必要写全，前几位就可以了，Git会自动去找 git log查看提交历史 显示从最近到最远的提交日志（如果嫌输出信息太多，加上--pretty=oneline参数） git reflog查看命令历史 可以找到版本号 工作区和暂存区 工作区（Working Directory）：在电脑里能看到的目录 版本库（Repository）：工作区有一个隐藏目录.git，这个不算工作区，而是Git的版本库 版本库里重要的东西有： 暂存区：stage（或者叫index） 分支：Git为我们自动创建的第一个分支master 指针：指向master的一个指针叫HEAD 需要提交的文件修改通通放到暂存区，然后一次性提交暂存区的所有修改 管理修改 Git跟踪并管理的是修改，而非文件 每次修改，如果不用git add到暂存区，那就不会加入到commit中 add只添加进了暂存区，commit才是进版本库，暂存区的相同文件都是覆盖的 撤销修改 git restore -- file丢弃修改，让这个文件回到最近一次git commit或git add时的状态 --很重要，没有--，就变成了“切换到另一个分支”的命令 git restore --staged把暂存区的修改撤销掉（unstage），重新放回工作区 注： 原来的git checkout 可以使用 git restore 代替 原来的git reset HEAD 可以使用 git restore --staged 代替 最新版的git提示都已经更换成了restore 总结： 情况1：在工作区做了修改，并未添加到暂存区，想撤销工作区的修改，用 git restore file 情况2：在工作区做了修改，并用git add 添加到了暂存区，未提交；想撤销，分两步，1.先撤销暂存区的修改，用 git restore --staged file, 2.然后参考情况1撤销工作区的修改 情况3：在工作区做了修改，且git add git commit添加并提交了内容，想撤销本次提交，直接用 git reset --hard HEAD^回退版本，即可保证工作区，暂存区，版本库都是上次的内容 删除文件 git rm 如果一个文件已经被提交到版本库，那么你永远不用担心误删，但是要小心，你只能恢复文件到最新版本，你会丢失最近一次提交后你修改的内容 当你直接在文件管理器中把没用的文件删了，或者用rm命令删了，接下来有两种选择： 确实要从版本库中删除该文件，那就用命令git rm删掉，并且git commit 删错了，用git checkout把误删的文件从版本库里恢复到最新版本 远程仓库 本地Git仓库和GitHub仓库之间的传输通过SSH加密 添加远程库 git remote add origin git@server-name:path/repo-name.git 关联一个远程库时必须给远程库指定一个名字，origin是默认习惯命名 关联后，使用命令git push -u origin master第一次推送master分支的所有内容 此后，每次本地提交后，只要有必要，就可以使用命令git push origin master推送最新修改 删除远程库 git remote rm &lt;name&gt; 使用前，建议先用git remote -v查看远程库信息 只是解除了本地和远程的绑定关系，并不是物理上删除了远程库。远程库本身并没有任何改动。要真正删除远程库，需要登录到GitHub，在后台页面找到删除按钮再删除 从远程库克隆 ssh：git clone git@github.com:your name/repo name.git 更快 https：git clone http://github.com/yourname/reponame.git 分支管理 创建与合并分支 git checkout -b或git switch -c创建并切换 相当于git branch（创建） + git checkout或git switch（切换） git branch查看当前分支 会列出所有分支，当前分支前面会标一个* git merge合并指定分支到当前分支 git branch -d删除分支 创建、合并和删除分支非常快，所以最好使用分支完成某个任务，合并后再删掉分支，这和直接在master分支上工作效果是一样的，但过程更安全 解决冲突 把Git合并失败的文件手动编辑为我们希望的内容，再提交 分支管理策略 分支策略 master分支应该是非常稳定的，也就是仅用来发布新版本，平时不能在上面干活 dev分支是不稳定的，干活都在dev分支上；到某个时候，比如1.0版本发布时，再把dev分支合并到master上，在master分支发布1.0版本 团队成员都在dev分支上干活，每个人都有自己的分支，时不时地往dev分支上合并就可以了 合并分支时的普通模式：加上--no-ff参数 这样合并后的历史有分支，能看出来曾经做过合并，而fast forward合并就看不出来曾经做过合并 Bug分支 修复bug时，通过创建新的bug分支进行修复，然后合并，最后删除 git stash保存工作现场，然后去修复bug，修复后，有两种方式回到工作现场： git stash apply，stash内容并不删除，需要用git stash drop来删除 git stash pop，恢复的同时把stash内容也删了 git stash list查看stash里的内容，然后用git stash apply stash@{0}恢复到指定的stash（这里是stash@{0}） 在master分支上修复的bug，想要合并到当前dev分支，可以用git cherry-pick &lt;commit&gt;，把bug提交的修改“复制”到当前分支，避免重复劳动 Feature分支 开发一个新feature，最好新建一个分支 如果要丢弃一个没有被合并过的分支，可以通过git branch -D &lt;name&gt;强行删除 多人协作 git push origin &lt;branch-name&gt;推送自己的修改 如果推送失败，则因为远程分支比你的本地更新，需要先用git pull试图合并 如果git pull提示no tracking information，则需要用git branch --set-upstream-to &lt;branch-name&gt; origin/&lt;branch-name&gt;建立起本地分支和远程分支的链接关系 如果合并有冲突，则解决冲突，并在本地提交 没有冲突或者解决掉冲突后，再用git push origin &lt;branch-name&gt;推送 Rebase 把本地未push的分叉提交历史整理成直线 目的：使我们在查看历史提交的变化时更容易，因为分叉的提交需要三方对比 标签管理 tag是一个让人容易记住的有意义的名字，它跟某个commit绑在一起 如果这个commit既出现在master分支，又出现在dev分支，那么在这两个分支上都可以看到这个标签 创建标签 git tag &lt;tagname&gt;新建一个标签 默认为HEAD，也可以指定一个commit id 创建的标签都只存储在本地，不会自动推送到远程 git tag -a &lt;tagname&gt; -m &quot;blablabla...&quot;创建带有说明的标签 git tag查看所有标签 不是按时间顺序列出，而是按字母排序 git show &lt;tagname&gt;查看标签信息 操作标签 推送 git push origin &lt;tagname&gt;推送某个本地标签到远程 git push origin --tags一次性推送全部未推送过的本地标签到远程 删除 git tag -d &lt;tagname&gt;删除某个本地标签 删除一个远程标签：先从本地删除（用上面的命令），然后从远程删除，命令是git push origin :refs/tags/&lt;tagname&gt; 使用GitHub 可以任意Fork开源仓库 Fork后的仓库，你拥有读写权限 推送pull request给官方仓库来贡献代码 使用Gitee 国内的Git托管服务 使用方法和GitHub类似 自定义Git git config --global color.ui **true**让Git显示颜色，看起来更醒目 忽略特殊文件 Github官方.gitignore文件合集 忽略文件的原则： 忽略操作系统自动生成的文件 忽略编译生成的中间文件、可执行文件等 忽略带有个人敏感信息的配置文件 git add -f filename虽然被忽略但强制添加 !filename例外文件 .gitignore online generator 配置别名 git config --global **alias**.st status设定用st表示status --global是全局参数，针对当前用户，即让命令在这台电脑的所有Git仓库下都有用；如果不加，那就只针对当前仓库有用 每个仓库的Git配置文件都放在.git/config文件中 当前用户的Git配置文件放在用户主目录下的一个隐藏文件.gitconfig中 要删除别名，直接把[alias]后面的对应别名的行删掉即可 搭建Git服务器 需要一台运行Linux的机器（推荐Ubuntu或Debian）。暂时用不到就没看，详见这里 使用Sourcetree 免费Git图形界面工具 附录 Git Cheat Sheet Git官网","link":"/2022/12/22/Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"title":"Getting Started with Git & Github","text":"This is some simple notes I took when I was learning the LinkedIn course Learning Git and Github. By the way, I found it very convenient to make notes in Notion first and then export Mardown, modify it, copy and paste it into the Blog. Start 12git config --global user.name &quot;name&quot;git config --global user.email &quot;mail&quot; 1git init Staging files 12git add filenamegit add . 1git commit -m &quot;message&quot; 1git log Git environments Working Staging Commit File states 1git status Tracked (after commit) Unmodified Modified Staged Untracked Restoring files 12git restore filenamegit restore . Ignoring files Sensitive info Personal notes System files Use .gitignore file Clearing the cache 1git rm -r --cached . Deleting 1git rm filename Delete, and move to stage and ready to commit. Renaming 1git mv oldname newname Move to stage too. Showing differences 1git diff 1got log --oneline Amending 1git commit --amend 12git resetgit reset --hard Rebasing A time machine. Rewrite the history. 1git rebase Branches 1git branch Copying a branch: 1git switch -c NAME Merging: 1git merge &lt;branch&gt; Deleting a branch: 1git branch --delete NAME Git flow: Fix branch Make changes Merge to master Delete old branch Merge conflicts Choose one. Stashing 1234git stashgit stash listgit stash applygit stash pop Git clean 123git clean -ngit clean -dgit clean -f Github Cloud repository Collaborative dev Projet management Working with github: Set up remote Push Fetch/pull Pushing to github Remotes: 1234git remote add NAME URLgit remote remove NAMEgit rename OLDNAME NEWNAMEgit remote -v Git push: 123git push REMOTE BRANCHgit push -u origin maingit push --all Github options Issues Collaborate with people Write notes, like to-do items, for youself or others Assign to-do to individuals, and they can comment Pull requests Change the repo Approve changes that somebody else has made Compare different branches Actions Manage the repo (advanced) Run tests Host code automatically Download other’s actions to use Projects Manage the repo Kanban board Wiki Create documentation that is easy for people to look at (not really necessary) Security Manage policies for security (advanced) Insights Know contributors, traffic, etc (private) Settings Convert this repo to be a template Github pages Managing projects Contributors Invite a collaborator Issues Labels Miletones Projects Syncing 1git clone 1git fetch 1git pull pull = fetch + merge","link":"/2022/11/17/Getting-Started-with-Git-Github/"},{"title":"My First LinkedIn Certificate!","text":"Yeah I got it ! I have been dreaming of online learning certificates, like coursera and linkedin, for a long time. Coursera’s free plan is a week, while linkedin’s is a month so I chose the latter. (Note that for Chinese mainland users, you must change your location in your account settings to get a monthly free plan. Also you must use a visa credit card.) In a word, I had my first linkedin learning course: Introducation to Web Design and Development Nice course  Short, less than 2 hours, which is very newbie-friendly. Practical! The author introduced many useful websites for learning and developing. What I have learned Types of web development jobs For planning and prototyping: UX (User Experience) UI (User Interface) For coding and developing: Front-end Dev (Javascript, CSS, HTML; frameworks) Back-end Dev Javascript, CSS, HTML HTML identifies structural elements. CSS changes the appearance and style. JS handles the interactivity, like moving and animation. A little knowledge of Github That’s beyond my expectation, and just what I need! Looks like Github Pages Service is a good (means free) start for small and simple web dev. I’ll hands on it lately. No-code It’s a fresh new concept to me. Sounds interesting that you can develop a web without coding. But maybe the price is, the real cost – money? It’s limited anyway, especially when you know more and get greedy . Useful tools Prototying tools: Figma Graphic design tools: Illustrator, Photoshop (professional) Affinity, Figma (lighter) Canva (simplest, free plan, templates) Coding editors: CodePen (online, free plan) VS Code Atom (free, highly customizable) Brackets Web host: Github Pages Service (simplest, free) No-code tools CMSs (Content Management System): Joomla! Drupal Wordpress Website buliders: Squarespace, Wix, Weebly (simple) Webflow, Editor X (complex) Databases: Google Sheets Airtable Apps: Bubble (web) AppGyver (web, ios, android) Adalo, Glide (ios, android) At last, here’s my certificate and I’d like to get more in the future  ~","link":"/2022/11/11/Got-my-first-LinkedIn-certificate/"},{"title":"Hello World","text":"I made it! ","link":"/2022/09/18/Hello_World/"},{"title":"LaTeX CV","text":"From noon yesterday to noon today, I was working on latex to make a resume. That’s very unfriendly for beginners . Luckily I finished it now! Take a look at my CV. Here’s how I did it: -&gt; If you only use latex occasionally or a few times, an onilne editor Overleaf can save you lots of troubles. You can find templates, edit and compile them. -&gt; If you want to do more things, use following steps: Download MiKTeX and VSCode MiKTeX You will get MiKTeX Consle and TeXworks. The latter is an editor but I prefer to use VSCode because it can preview pdf at another window (also because I already have VSCode). Another choose is Tex Live. It comes with a full package pre-installed, but the download is too slow and often fails so I chose MiKTeX. VSCode Remember to download extension latex workshop. Find a template On Overleaf or Github. Here are my favorites: 新卒のためのLaTeX履歴書テンプレート TLC-Resume-2021 And mine: Resume-CV (based on TLC-Resume-2021) Edit the template You may encounter many problems at this step, most of which require you to download Packages in MiKTeX Console, or other stuff like Perl. Just install the missing items as stated in the error message. Share your template Git your template to github (Already bound git and your github accounts and set SSH key) -&gt; Create a new repository -&gt; Git bash the folder which contains full files about your template -&gt; Run the following code in Git: git init git add . git commit -m &apos;Description&apos; git remote add origin https://... (copy from github) git push -u origin master Submit to Overleaf That’s where I found the original template for my CV! I think put templates there may help more people.","link":"/2022/10/29/Latex-CV/"},{"title":"Java入门","text":"廖雪峰的Java教程-Java快速入门一节的笔记。 简介 创始人：James Gosling Java介于编译型语言和解释型语言之间。它是将代码编译成一种“字节码”，类似于抽象的CPU指令，然后针对不同平台编写虚拟机，不同平台的虚拟机负责加载字节码并执行，实现“一次编写，到处运行” Java三个版本 Java SE：Standard Edition，标准版，包含标准的JVM和标准库，是整个Java平台的核心 Java EE：Enterprise Edition，企业版，在Java SE的基础上加上了大量的API和库，以便方便开发Web应用、数据库、消息服务等；Java EE的的虚拟机和Java SE完全相同；是进一步学习Web应用所必须的 Java ME：Micro Edition，针对嵌入式设备的“瘦身版”，Java SE的标准库无法在Java ME上使用；Java ME的虚拟机也是“瘦身版”；不流行，不建议学习 推荐的Java学习路线 首先要学习Java SE，掌握Java语言本身、Java核心开发技术以及Java标准库的使用； 如果继续学习Java EE，那么Spring框架、数据库开发、分布式架构就是需要学习的； 如果要学习大数据开发，那么Hadoop、Spark、Flink这些大数据平台就是需要学习的，他们都基于Java或Scala开发； 如果想要学习移动开发，那么就深入Android平台，掌握Android App开发。 JDK：Java Development Kit，除了包含JRE，还提供了编译器、调试器等开发工具，用来将Java源码编译成Java字节码 JRE：Java Runtime Environment，是运行Java字节码的虚拟机 JSR规范：Java Specification Request JCP组织：Java Community Process RI：Reference Implementation，参考实现 TCK：Technology Compatibility Kit，兼容性测试套件 基础 程序基本结构 123public class Hello { // 类名是Hello // ...} // class定义结束 12345public class Hello { public static void main(String[] args) {// 方法名是main// 方法代码... }// 方法定义结束} 类名必须以英文字母（习惯大写）开头；方法名必须以英文字母（习惯小写）开头 在class内部，可以定义若干方法（method） public是访问修饰符，表示该class是公开的。不写public，也能正确编译，但是这个类将无法从命令行执行 Java入口程序规定的方法必须是静态方法，方法名必须为main ，括号内的参数必须是String数组 Intelli IDEA代码格式化：Ctrl + Alt + L 变量和数据类型 两种变量类型：基本类型和引用类型 基本类型是CPU可以直接进行运算的类型。包括整型，浮点型，布尔型，字符型 剩下的都是引用类型，类似于C语言的指针，它内部存储一个“地址”，指向某个对象在内存的位置。最常用的是String 基本类型的变量是“持有”某个数值，引用类型的变量是“指向”某个对象 常量在初始化后不可重新赋值 简写变量类型，使用var关键字 运算 整数运算永远是精确的，浮点数运算常常无法精确表示 流程控制 输入和输出 输出 System.out.println()，输出并换行 System.out.print()，输出不换行 System.out.printf()，格式化输出 输入（不能在线运行，必须从命令行读取） 1234567import java.util.Scanner;public class Main {publicstaticvoid main(String[] args) { Scanner scanner =new Scanner(System.in);// 创建Scanner对象 String name = scanner.nextLine();// 读取一行输入并获取字符串 int age = scanner.nextInt();// 读取一行输入并获取整数 }} if条件判断 判断浮点数相等用==判断不靠谱，正确的方法是利用差值小于某个临界值来判断 判断引用类型的变量内容是否相等，必须使用equals()方法 case多重选择 总是写上default 从Java12开始，新语法使用-&gt;，如果有多条语句，需要用{}括起来。不要写break语句，因为新语法只会执行匹配的语句，没有穿透效应 在switch表达式内部，用yield返回一个值作为switch语句的返回值 while循环 先判断后循环 可能循环0次 do while循环 先循环后判断 至少循环一次 for循环 可能循环0次 break和continue 在多层嵌套的循环中，都只能跳出自己所在的那一层循环 数组操作 遍历、排序、多维数组、命令行参数（略）","link":"/2022/12/26/Java%E5%85%A5%E9%97%A8/"},{"title":"November Summary","text":"Leetcode Solved 64 problems on Leetcode till now. Finished the Explore Arrays 101 (the remaining one was only available for Premium). It’s very easy even for beginners like me. Got a badge! To be honest, I didn’t quite understand all the data structures in the badge 洛. I’m just familiar with arrays and strings… I plan to find time to digest the other structures, and make a sum-up. Jupyter Notebook Handed on it. I wrote a simple notebook about the process of using Logistic Regression model to classify some datas. Github Workflow Used Metrics in the homepage of my github account. It’s amazing for it can update automatically! LinkedIn Learning Certificates I will give my rating for that course under each certificate. ⭐⭐⭐⭐⭐ ⭐⭐ ⭐⭐ ⭐⭐⭐⭐ ⭐⭐⭐ English Preparing for the IELTS indicator exam. Japanese Kept on learning Japanese on Duolinguo for 42 days. I found out that there were only two Japanese language tests in China, JLPT and JTEST. JLPT is held only two times every year, and it’s often cancelled. JTEST is held more frequently, but it’s not as highly acknowledged as JLPT so I’m hesitant to prepare for it.","link":"/2022/12/02/November-Summary/"},{"title":"October Summary","text":"Programming I finished 27 problems on Leetcode till now, and all used Java. The last explore chapter Array and String was a bit difficult, but the current one Arrays 101 is much easier. Why I’m still doing arrays? I can’t wait to deal with something new. I learnt a little of the famous course, CS61A, including HW 01, HW 02, Lab 00, Lab 01, and I’m in Lab 02 now. I studied more seriously in the first half of the month, and slacked off in the second half. I hope I can persevere and finish this course and CS61B. The OK system is very interesting. I watched some Andrew Ng’s Machine Learning videos, from the beginning to P48 Inference: making predictions. My mentor asked me to learn machine learning so I was trying to get started. I also read some parts of the the classic tutorial book, Hands on Machine Learning. That’s nice, and more codes and more difficult that the videos. However, I still didn’t understand ML well. It seems easy but to do it is really hard勞. The good news was that I made a python program this afternoon finally… Matlab looked convenient, but it required too much computer performance and was a bit unstable. I was thinking of the characteristics of data… Language Insisted on watching one English video a day, especially the Economist. I also read an article named Prince in the section “Briefing”. The gorgeous proses impressed me. And I began to preparing for Duolinguo English Test several days ago. My boyfriend signed up for IELTS(indicator). We all will take exams next week. Hope we all succeed! I also began to lean Japanese from Duolinguo and NHK Easy Japanese. Love this website for its simpleness. I didn’t know Japanese had tenses too. Bye for now! It’s midnight.","link":"/2022/10/31/October-Summary/"},{"title":"Two-pointer","text":"In this October, I was trying to force myself to do one Leetcode problem per day. Although I missed some days, it came to a not bad end: I finished the Explore Array and String1 in Leetcode. The biggest lesson for me is an amazing technique called Two-pointer. At first I thought it’s nested two for-loops, but then I found it’s actually much more flesxible and useful. So I’d like to note it. Meaning Use two pointers at the same time to do the iteration. Application scenarios When you want to iterate the array from two ends to the middle, you can use one pointer starts from the beginning while the other pointer starts from the end. They have same steps. 123456789101112131415// Reverse Stringclass Solution { public void reverseString(char[] s) { int i = 0; int j = s.length - 1; while (i &lt; j) { char temp = s[i]; s[i] = s[j]; s[j] = temp; i++; j--; } }} 12345678910111213141516171819202122// Two Sum II - Input array is sorted// Given a 1-indexed array of integers numbers that is already sorted in non-decreasing order, find two numbers such that they add up to a specific target numberclass Solution { public int[] twoSum(int[] numbers, int target) { int[] res = new int[2]; int start = 0; int end = numbers.length - 1; while (start &lt; end) { if (numbers[start] + numbers[end] == target) { break; } else if (numbers[start] + numbers[end] &lt; target) { start ++; } else { end --; } } res[0] = start + 1; res[1] = end + 1; return res; }} When you want one slow-runner and one fast-runner at the same time, you can use one pointer for the iteration while another one for the special position. They have different steps. 123456789101112131415// Remove Element// &quot;i&quot; for iteration and &quot;k&quot; for the elements to removeclass Solution { public int removeElement(int[] nums, int val) { int k = 0; for (int i = 0; i &lt; nums.length; i++) { if (nums[i] != val) { nums[k] = nums[i]; k++; } } return k; }} Here an important concept is introduced: in-place. An in-place algorithm is an algorithm which transforms input using no auxiliary data structure. However, a small amount of extra storage space is allowed for auxiliary variables. The input is usually overwritten by the output as the algorithm executes. An in-place algorithm updates its input sequence only through replacement or swapping of elements.2 123456789101112131415161718// Max Consecutive Ones// &quot;i&quot; for iteration and &quot;max&quot; for finding the max numberclass Solution { public int findMaxConsecutiveOnes(int[] nums) { int max = 0; int sum = 0; for (int i = 0; i &lt; nums.length; i++) { sum += nums[i]; if (nums[i] == 0) { sum = 0; } else { max = Math.max(sum, max); } } return max; }} 12345678910111213141516// Remove Duplicates from Sorted Array// &quot;i&quot; for iteration and &quot;j&quot; for the unique elementsclass Solution { public int removeDuplicates(int[] nums) { int n = nums.length; int j = 0; for (int i = 1; i &lt; n; i++) { if (nums[j] != nums[i]) { j++; nums[j] = nums[i]; } } return j + 1; }} 1234567891011121314151617181920// Move Zeroes// &quot;i&quot; for iteration and &quot;k&quot; works on the non-zero elementsclass Solution { public void moveZeroes(int[] nums) { int n = nums.length; int k = 0; for (int i = 0; i &lt; n; i++) { k = i; if (nums[i] == 0) { if (k &lt; n-1) { while (nums[k] == 0 &amp;&amp; k &lt; n-1) {k++; } int temp = nums[i]; nums[i] = nums[k]; nums[k] = temp; } } } }} My current progress: Congrats to myself and keep it up!  References [1] Leetcode [2] Wikipedia","link":"/2022/10/26/Two-pointer/"},{"title":"面向对象","text":"class是对象模板，instance是对象实例 定义class（包含多个字段，field） 1234class Person { public String name; public int age;} 创建instance（指向instance的变量都是引用变量） 1Person ming = **new** Person(); 访问实例变量用变量.字段 一个Java源文件可以包含多个类的定义，但只能定义一个public类，且public类名必须与文件名一致。如果要定义多个public类，必须拆到多个Java源文件中 方法 动机：为了避免外部代码直接去访问field，我们可以用private修饰field，拒绝外部访问，然后使用method来让外部代码可以间接修改field 在方法内部，我们有机会检查参数对不对；而外部代码没有任何机会把字段设置成不合理的值 一个类通过定义方法，可以给外部代码暴露一些操作的接口，同时保证内部逻辑一致性 调用方法的语法是实例变量.方法名(参数); 定义方法 123456789// 修饰符 方法返回类型 方法名(方法参数列表) {// 若干方法语句;// return 方法返回值;// }// 如果没有返回值，返回类型设置为void，可以省略returnpublic String getName() { return this.name;} private方法：不允许外部调用，只有类的内部可以调用 this变量：在方法内部，可以使用一个隐含的变量this，它始终指向当前实例。通过this.field就可以访问当前实例的字段 如果没有命名冲突，可以省略this；如果局部变量和字段重名，就必须加上this 方法参数：0或任意个，用于接收传递给方法的变量值 可变参数：类型…，相当于数组类型 可变参数可以保证无法传入null 参数绑定 基本类型参数的传递，是调用方值的复制。双方各自的后续修改，互不影响 引用类型参数的传递，调用方的变量和接收方的参数变量指向的是同一个对象。双方任意一方对这个对象的修改，都会影响对方（因为指向同一个对象） 构造方法 123456789101112131415161718192021222324public class Main { public static void main(String[] args) { Person p = new Person(&quot;Xiao Ming&quot;, 15); }}class Person { private String name; private int age; // 构造方法 public Person(String name, int age) { this.name = name; this.age = age; } public String getName() { return this.name; } public int getAge() { return this.age; }} 实例在创建时通过new操作符会调用其对应的构造方法，构造方法用于初始化实例 创建实例实际上是通过构造方法来初始化实例的 构造方法的名称就是类名 构造方法的参数没有限制，在方法内部，也可以编写任意语句。但是，和普通方法相比，构造方法没有返回值（也没有void），调用构造方法，必须用new 没有定义构造方法时，编译器会自动创建一个默认的无参数构造方法 没有在构造方法中初始化字段时，引用类型的字段默认是null，数值类型的字段用默认值，int类型默认值是0 ，布尔类型默认值是false 多构造方法 可以定义多个构造方法，编译器根据参数自动判断 可以在一个构造方法内部调用另一个构造方法，便于代码复用 方法重载 123456789101112// String类提供了多个重载方法indexof()public class Main { public static void main(String[] args) { String s = &quot;Test string&quot;; int n1 = s.indexOf(&apos;t&apos;); int n2 = s.indexOf(&quot;st&quot;); int n3 = s.indexOf(&quot;st&quot;, 4); System.out.println(n1); System.out.println(n2); System.out.println(n3); }} 含义：方法重载是指多个方法的方法名相同，但各自的参数不同 作用：功能类似的方法使用同一名字，更容易记住，调用起来更简单 方法重载的返回值类型通常是相同的 继承 123456789101112131415161718class Person { private String name; private int age; public String getName() {...} public void setName(String name) {...} public int getAge() {...} public void setAge(int age) {...}}class Student extends Person { // 不要重复name和age字段/方法, // 只需要定义新增score字段/方法: private int score; public int getScore() { … } public void setScore(int score) { … }} 作用：复用代码 使用extends关键字来实现继承 继承树：没有明确写extends的类，编译器会自动加上extends Object 任何类，除了Object，都会继承自某个类 一个类有且仅有一个父类。只有Object特殊，它没有父类 子类无法访问父类的private，可以访问父类的protected 如果父类没有默认的构造方法，子类就必须显式调用super()并给出参数以便让编译器定位到父类的一个合适的构造方法 子类不会继承任何父类的构造方法。子类默认的构造方法是编译器自动生成的，不是继承的 阻止继承 1234public sealed class Shape permits Rect, Circle, Triangle { ...}// 上述Shape类只允许指定的3个类(Rect, Circle, Triangle)继承它 从Java15开始，使用sealed修饰class，并通过permits明确写出能够从该class继承的子类名称 sealed目前是预览状态，要启用它，必须使用参数--enable-preview和--source 15 向上转型（upcasting） 1Person p = new Student(); 把一个子类型安全地变为更加抽象的父类型 例如，继承树是Student &gt; Person &gt; Object，那么可以把Student类型转型为Person，或者更高层次的Object 向下转型（downcasting） 12345Person p = new Student();if (p instanceof Student) { // 只有判断成功才会向下转型: Student s = (Student) p; // 一定会成功} 很可能会失败。为了避免出错，使用instanceof先判断一个实例究竟是不是某种类型 从Java 14开始，判断instanceof后，可以直接转型为指定变量，直接使用，避免再次强制转型 继承&amp;组合 继承是is关系，组合是has关系 多态 12345678910111213class Person { public void run() { … }}class Student extends Person { @Override public void run() { … }}class Teacher extends Person { @Override public void run() { … }} 含义：针对某个类型的方法调用，其真正执行的方法取决于运行时期实际类型的方法 作用：允许添加更多类型的子类实现功能扩展，却不需要修改基于父类的代码 Override 子类可以覆写父类的方法（Override），覆写在子类中改变了父类方法的行为 加上@Override可以让编译器帮助检查是否进行了正确的覆写 在子类的覆写方法中，如果要调用父类的被覆写的方法，可以通过super来调用 final final修饰的方法可以阻止被覆写 final修饰的class可以阻止被继承 final修饰的field必须在创建对象时初始化，随后不可修改 抽象类 123abstract class Person { public abstract void run();} 动机：如果父类的方法本身不需要实现任何功能，仅仅是为了定义方法签名，目的是让子类去覆写它，那么可以把父类的方法声明为抽象方法，本身没有实现任何方法语句 含义：如果一个class定义了方法，但没有具体执行代码，这个方法就是抽象方法，抽象方法用abstract修饰；因为无法执行抽象方法，所以这个类也必须申明为抽象类（abstract class） 抽象类无法实例化 作用：抽象类可以强迫子类实现其定义的抽象方法，否则编译会报错。相当于定义了“规范” 面向抽象编程 上层代码只定义规范 不需要子类就可以实现业务逻辑（正常编译） 具体的业务逻辑由不同的子类实现，调用者并不关心 接口 1234interface Person { void run(); String getName();} 动机：如果一个抽象类没有字段，所有方法全部都是抽象方法，就可以把该抽象类改写为接口 接口是比抽象类还要抽象的纯抽象接口，因为它连字段都不能有 使用interface声明一个接口 当一个具体的class去实现一个interface时，需要使用implements关键字；一个类可以实现多个interface 接口也是数据类型，适用于向上转型和向下转型 接口继承 12345678interface Hello { void hello();}interface Person extends Hello { void run(); String getName();} 使用extends 继承关系 公共逻辑适合放在abstract class中，具体逻辑放到各个子类，而接口层次代表抽象程度 实例化的对象永远只能是某个具体的子类，但总是通过接口去引用它，因为接口比抽象类更抽象 default方法 接口可以定义default方法 动机：当我们需要给接口新增一个方法时，会涉及到修改全部子类。如果新增的是default方法，那么子类就不必全部修改，只需要在需要覆写的地方去覆写新增方法 default方法和抽象类的普通方法的区别：因为interface没有字段，所以default方法无法访问字段，而抽象类的普通方法可以访问实例字段 静态字段&amp;静态方法 静态字段 用static修饰的字段称为静态字段 实例字段&amp;静态字段 实例字段在每个实例中都有自己的一个独立“空间”，各个实例的同名字段互不影响 静态字段只有一个共享“空间”，所有实例都会共享该字段 不推荐用实例变量.静态字段去访问静态字段，推荐用类名来访问静态字段 可以把静态字段理解为描述class本身的字段（非实例字段） 静态方法 用static修饰的方法称为静态方法 实例方法&amp;静态方法 调用实例方法必须通过一个实例变量 调用静态方法则不需要实例变量，通过类名就可以调用。静态方法类似其它编程语言的函数 调用静态方法不需要实例，无法访问this，但可以访问静态字段和其他静态方法 静态方法常用于工具类（如Arrays.sort()，Math.random() ）和辅助方法（如Java程序的入口main() 就是静态方法） 接口的静态字段 interface可以有静态字段，并且静态字段必须为final类型 因为interface的字段只能是public static final类型，所以可以去掉这些修饰符，简写 包 1234package ming; // 申明包名mingpublic class Person {} 在定义class的时候，需要在第一行声明这个class属于哪个包 一个类总是属于某个包（package），类名（比如Person）只是一个简写，真正的完整类名是包名.类名 只要包名不同，类就不同 包可以是多层结构，用.隔开 包没有继承关系 没有定义包名的class使用的是默认包，非常容易引起名字冲突，不推荐不写包名的做法 包作用域 123456789101112131415package hello;public class Person { // 包作用域: void hello() { System.out.println(&quot;Hello!&quot;); }}public class Main { public static void main(String[] args) { Person p = new Person(); p.hello(); // 可以调用，因为Main和Person在同一个包 }} 位于同一个包的类，可以访问包作用域的字段和方法 不用public、protected、private修饰的字段和方法就是包作用域 import 1234567891011// Person.javapackage ming;// 导入完整类名:import mr.jun.Arrays;public class Person { public void run() { Arrays arrays = new Arrays(); }} JDK的核心类使用java.lang包，编译器会自动导入 JDK的其它常用类定义在java.util.*，java.math.*，java.text.*，…… 作用域 public 定义为public的class、interface可以被其他任何类访问 定义为public的field、method可以被其他类访问，前提是首先有访问class的权限 如果不确定是否需要public，就不声明为public，即尽可能少地暴露对外的字段和方法 一个.java文件只能包含一个public类，但可以包含多个非public类。如果有public类，文件名必须和public类的名字相同 private 定义为private的field、method无法被其他类访问 private访问权限被限定在class的内部，而且与方法声明顺序无关。推荐把private方法放到后面 嵌套类（nested class）拥有访问private的权限 protected 作用于继承关系。定义为protected的字段和方法可以被子类访问，以及子类的子类 pakage 包作用域是指一个类允许访问同一个package的没有public、private修饰的class，以及没有public、protected、private修饰的字段和方法 把方法定义为package权限有助于测试 局部变量 在方法内部定义的变量称为局部变量 局部变量作用域从变量声明处开始到对应的块结束 方法参数也是局部变量 应该尽可能把局部变量的作用域缩小，尽可能延后声明局部变量 final 可以阻止被继承、阻止被子类覆写、阻止被重新赋值 内部类（Nested Class） Inner Class 123456789101112131415public class Main { public static void main(String[] args) { Outer outer = new Outer(&quot;Nested&quot;); // 实例化一个Outer Outer.Inner inner = outer.new Inner(); // 实例化一个Inner inner.hello(); }}class Outer { ... class Inner { // 定义了一个Inner Class ... }} Inner Class的实例不能单独存在，必须依附于一个Outer Class的实例 要实例化一个Inner，必须首先创建一个Outer的实例，然后，调用Outer实例的new来创建Inner实例 Inner Class可以修改Outer Class的private字段 Outer类被编译为Outer.class，而Inner类被编译为Outer$Inner.class Anonymous Class 123Runnable r = new Runnable() { // 实现必要的抽象方法...}; 另一种定义Inner Class的方法。它不需要在Outer Class中明确地定义这个Class 动机：因为在这里我们不关心类名，比直接定义Inner Class可以少写很多代码 匿名类也可以访问Outer Class的private字段和方法 匿名类被编译为Outer$1.class、Outer$2.class、Outer$3.class … 除了接口外，匿名类也可以继承自普通类 Inner Class和Anonymous Class本质上是相同的，都必须依附于Outer Class的实例，即隐含地持有Outer.this实例，并拥有Outer Class的private访问权限 Static Nested Class 不再依附于Outer的实例，而是一个完全独立的类，因此无法引用Outer.this，但可以访问Outer的private静态字段和静态方法 Static Nested Class是独立类，但拥有Outer Class的private访问权限 classpath和jar JVM通过环境变量classpath决定搜索class的路径和顺序 不推荐设置系统环境变量classpath，始终建议通过-cp命令传入 jar包相当于目录，可以包含很多.class文件，方便下载和使用 （没懂，以后需要时回顾） class版本 高版本的JDK可编译输出低版本兼容的class文件，反之可能报错 运行时使用哪个JDK版本，编译时就尽量使用同一版本编译源码 （没懂，以后需要时回顾） 模块 .class文件是JVM看到的最小可执行文件，而一个大型程序需要编写很多Class，并生成一堆.class文件。jar文件就是class文件的容器，为了方便管理。它并不关心class之间的依赖 从Java 9开始引入了模块（Module），自带“依赖关系”的class容器就是模块，模块以.jmod扩展名标识 只有java.base模块不依赖任何模块，是“根模块” 把一堆class封装为jar仅仅是一个打包的过程，而把一堆class封装为模块则不但需要打包，还需要写入依赖关系，并且可以包含二进制代码（通常是JNI扩展）、支持多版本 模块的作用：声明并管理依赖关系；进一步隔离代码的访问权限 （没懂，以后需要时回顾）","link":"/2022/12/27/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"}],"tags":[{"name":"Notes","slug":"Notes","link":"/tags/Notes/"},{"name":"Links","slug":"Links","link":"/tags/Links/"},{"name":"Filter","slug":"Filter","link":"/tags/Filter/"},{"name":"MATLAB","slug":"MATLAB","link":"/tags/MATLAB/"},{"name":"Git","slug":"Git","link":"/tags/Git/"},{"name":"Github","slug":"Github","link":"/tags/Github/"},{"name":"Front-end","slug":"Front-end","link":"/tags/Front-end/"},{"name":"Latex","slug":"Latex","link":"/tags/Latex/"},{"name":"Java","slug":"Java","link":"/tags/Java/"}],"categories":[{"name":"Summary","slug":"Summary","link":"/categories/Summary/"},{"name":"Learning","slug":"Learning","link":"/categories/Learning/"},{"name":"Monthly Summary","slug":"Summary/Monthly-Summary","link":"/categories/Summary/Monthly-Summary/"},{"name":"Signal Processing","slug":"Learning/Signal-Processing","link":"/categories/Learning/Signal-Processing/"},{"name":"Software Development","slug":"Learning/Software-Development","link":"/categories/Learning/Software-Development/"},{"name":"Web Development","slug":"Learning/Web-Development","link":"/categories/Learning/Web-Development/"},{"name":"Job","slug":"Job","link":"/categories/Job/"},{"name":"Leetcode","slug":"Leetcode","link":"/categories/Leetcode/"}]}